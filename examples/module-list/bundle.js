(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _parameters = require('@ircam/parameters');

var _parameters2 = _interopRequireDefault(_parameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Abstract class to derive in order to implement a module that decorates the
 * `BasePlayer`.
 * A module must implement the `install` and `uninstall` methods.
 * Other methods may or may not be implemented accroding to the functionnality
 * offered by the module.
 *
 * @param {Object} definitions - Object defining the parameters of the module.
 *  The definitions should follow the convetions defined in
 *  [https://github.com/ircam-jstools/parameters](https://github.com/ircam-jstools/parameters)
 * @param {Object} options - Oveeride parameters default values.
 */
var AbstractModule = function () {
  function AbstractModule(definitions, options) {
    (0, _classCallCheck3.default)(this, AbstractModule);

    this.params = (0, _parameters2.default)(definitions, options);

    this._block = null;
    this._zIndex = null;
  }

  (0, _createClass3.default)(AbstractModule, [{
    key: 'install',


    /**
     * Logic to implement when the module is added to the block.
     */
    value: function install() {}

    /**
     * Logic to implement when the module is removed to the block.
     */

  }, {
    key: 'uninstall',
    value: function uninstall() {}

    /**
     * Abstract methods that can optionnaly be implemented.
     * These commands are executed by the player on each installed module if
     * implemented at the module level.
     */

    /**
     * @abstract
     */
    // setTrack(trackConfig)


    // setWidth(value)
    // setHeight(value)

    /**
     * force rendering
     */
    // render()

    /**
     * event emitted by the main timeline
     * if returns true, propagate event to next module
     * if returns false, stop propagation
     */
    // onEvent(e)

    /**
     * audio player commands
     */
    // start
    // stop
    // pause
    // seek(position, isPlaying)

  }, {
    key: 'block',
    set: function set(block) {
      this._block = block;
    },
    get: function get() {
      return this._block;
    }
  }, {
    key: 'zIndex',
    set: function set(zIndex) {
      this._zIndex = zIndex;
    },
    get: function get() {
      return this._zIndex;
    }
  }]);
  return AbstractModule;
}();

exports.default = AbstractModule;

},{"@ircam/parameters":173,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Abstract interface that should be implemented by any `block` player.
 *
 * @param {Object} block - The block instance that instanciate and consume the player
 */
var AbstractPlayer = function () {
  function AbstractPlayer(block) {
    (0, _classCallCheck3.default)(this, AbstractPlayer);

    this.block = block;
  }

  /**
   * Return the current position of the player.
   * @type Number
   * @readonly
   */


  (0, _createClass3.default)(AbstractPlayer, [{
    key: "setBuffer",


    /**
     * Set the player's audio buffer.
     * @param {AudioBuffer} buffer - audio buffer to read
     */
    value: function setBuffer(buffer) {}

    /**
     * Start the player.
     */

  }, {
    key: "start",
    value: function start() {}

    /**
     * Pause the player.
     */

  }, {
    key: "pause",
    value: function pause() {}

    /**
     * Stop the player.
     */

  }, {
    key: "stop",
    value: function stop() {}

    /**
     * Seek to the given position in the buffer.
     * @param {Number} position - position in second at which the player should jump
     */

  }, {
    key: "seek",
    value: function seek(position) {}

    /**
     * Callback executed in the requestAnimationFrame loop that allow to hook
     * and/or override the generic behavior of the player.
     */

  }, {
    key: "monitorPosition",
    value: function monitorPosition() {}
  }, {
    key: "position",
    get: function get() {}

    /**
     * Return the duration of the audio buffer.
     * @type Number
     * @readonly
     */

  }, {
    key: "duration",
    get: function get() {}

    /**
     * Return the duration of the audio buffer.
     * @type Boolean
     * @readonly
     */

  }, {
    key: "running",
    get: function get() {}

    /**
     * Set the volume of the player
     * @param {Number} gain - volume [0, 1]
     */

  }, {
    key: "gain",
    set: function set(gain) {},
    get: function get() {}
  }]);
  return AbstractPlayer;
}();

exports.default = AbstractPlayer;

},{"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

var _parameters = require('@ircam/parameters');

var _parameters2 = _interopRequireDefault(_parameters);

var _AbstractPlayer = require('./AbstractPlayer');

var _AbstractPlayer2 = _interopRequireDefault(_AbstractPlayer);

var _History = require('../utils/History');

var _History2 = _interopRequireDefault(_History);

var _objectAssignDeep = require('object-assign-deep');

var _objectAssignDeep2 = _interopRequireDefault(_objectAssignDeep);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function decibelToLinear(val) {
  return Math.exp(0.11512925464970229 * val); // pow(10, val / 20)
};

var EVENTS = {
  // @arguments
  // position
  START: 'start',
  // @arguments
  // position
  PAUSE: 'pause',
  // @arguments
  // position
  STOP: 'stop',
  // @arguments
  // targetPosition
  SEEK: 'seek',
  // @arguments
  // endTime
  ENDED: 'ended',
  // @arguments
  // currentPosition
  CURRENT_POSITION: 'position',

  UPDATE: 'update'
};

var UI = function () {
  function UI($container, sizing, width, height) {
    (0, _classCallCheck3.default)(this, UI);

    $container = $container instanceof Element ? $container : document.querySelector($container);

    switch (sizing) {
      case 'auto':
        var boundingClientRect = $container.getBoundingClientRect();
        width = boundingClientRect.width;
        height = boundingClientRect.height;
        break;

      case 'manual':
        $container.style.width = width + 'px';
        $container.style.height = height + 'px';
        break;
    }

    this.$container = $container;
    this._width = width;
    this._height = height;

    // arbitrary `pixelsPerSecond` value to update when a track is set
    this.timeline = new ui.core.Timeline(1, width);
    this.track = new ui.core.Track($container, height);

    this.timeline.add(this.track, 'default');
    this.track.updateContainer(); // init track DOM tree

    // time context that should be shared by all (most) mixins / ui layers
    this.timeContext = new ui.core.LayerTimeContext(this.timeline.timeContext);
  }

  (0, _createClass3.default)(UI, [{
    key: 'height',
    set: function set(value) {
      this._height = value;
      this.$container.style.height = value + 'px';

      this.timeline.tracks.forEach(function (track) {
        track.height = value;
        track.render();
        track.update();
      });
    },
    get: function get() {
      return this._height;
    }
  }, {
    key: 'width',
    set: function set(value) {
      this._width = value;
      this.$container.style.width = value + 'px';

      this.timeline.maintainVisibleDuration = true;
      this.timeline.visibleWidth = value;

      this.timeline.tracks.forEach(function (track) {
        track.render();
        track.update();
      });
    },
    get: function get() {
      return this._width;
    }
  }]);
  return UI;
}();

var definitions = {
  container: {
    type: 'any',
    default: null,
    constant: true,
    metas: {
      desc: 'Css Selector or DOM Element hosting the block'
    }
  },
  player: {
    type: 'any',
    default: _AbstractPlayer2.default, // if we only need the ui part, default to dummy player
    nullable: true,
    constant: true, // sure? why not being able to change dynamically?
    metas: {
      desc: 'Constructor of the player to be used in the block'
    }
  },
  sizing: {
    type: 'enum',
    list: ['auto', 'manual'],
    default: 'auto',
    constant: true
  },
  width: {
    type: 'integer',
    min: 0,
    max: +Infinity,
    default: null,
    nullable: true,
    constant: true
  },
  height: {
    type: 'integer',
    min: 0,
    max: +Infinity,
    default: null,
    nullable: true,
    constant: true
  }

  /**
   * Base audio-visual player to be decorated with additionnal modules.
   *
   * @param {Object} options - Override default configuration (no options for now)
   * @param {String|Element} [options.container] - Css Selector or DOM Element that will
   *  host the player and additionnal modules
   * @param {AbstractPlayer} - The player to be used by the block.
   * @param {'auto'|'manual'} [options.sizing='auto'] - How the size of the block
   *  should be defined. If 'auto', the block adjusts to the size of the container.
   *  If 'manual', use `width` and `height` parameters.
   * @param {Number} [options.width=null] - Width of the block if size is 'manual'.
   * @param {Number} [options.height=null] - Height of the block if size is 'manual'.
   *
   * @example
   * ```
   * const $container = document.querySelector('#container');
   * const defaultWidth = 1000;
   * const defaultHeight = 1000;
   * const block = new blocks.core.Block({
   *   player: abc.player.SeekPlayer,
   *   container: $container,
   *   sizing: 'manual', // if 'auto', adjust to fill $container size
   *   width: defaultWidth,
   *   height: defaultHeight,
   * });
   *
   * const waveformModule = new blocks.module.WaveformModule();
   * const cursorModule = new blocks.module.CursorModule();
   *
   * block.add(simpleWaveformModule);
   * block.add(cursorModule);
   * ```
   */
};
var Block = function () {
  function Block(options) {
    (0, _classCallCheck3.default)(this, Block);

    this.params = (0, _parameters2.default)(definitions, options);

    this.EVENTS = EVENTS;

    this._trackData = null;
    this._trackMetadata = null;

    this._listeners = new _map2.default();
    this._modules = [];
    this._isPlaying = false;

    var $container = this.params.get('container');
    var sizing = this.params.get('sizing');
    var width = this.params.get('width');
    var height = this.params.get('height');
    this.ui = new UI($container, sizing, width, height);

    var playerCtor = this.params.get('player');
    this.player = new playerCtor(this);

    this._history = new _History2.default(this, '_trackMetadata', 20);

    this._monitorPosition = this._monitorPosition.bind(this);
    this._onEvent = this._onEvent.bind(this);

    // listen events from the timeline to propagate to modules
    this.ui.timeline.addListener('event', this._onEvent);
  }

  // ---------------------------------------------------------
  // event system
  // ---------------------------------------------------------

  /**
   * Add a listener to a specific channel of the player.
   * Available events are:
   * - `'start'`: triggered when the player starts
   * - `'pause'`: triggered when the player is paused
   * - `'stop'` : triggered when the player is stopped (pause() + seek(0))
   * - `'seek'` : triggered when the player seek to a new position
   * - `'ended'`: triggered when the player stops at the end of the file (or at
   *              the end of the last segment). The callback is executed with the
   *              stop position.
   * - `'position'`: triggered at each request animation frame with the current
   *              position and duration of the audio file. Trigger only when
   *              the player is playing.
   *
   * @param {String} channel - Name of the channel
   * @param {Function} callback - Function to execute
   */


  (0, _createClass3.default)(Block, [{
    key: 'addListener',
    value: function addListener(channel, callback) {
      if (!this._listeners.has(channel)) this._listeners.set(channel, new _set2.default());

      var listeners = this._listeners.get(channel);
      listeners.add(callback);
    }

    /**
     * Remove a listener from a channel.
     *
     * @param {String} channel - Name of the channel
     * @param {Function} callback - Function to remove
     */

  }, {
    key: 'removeListener',
    value: function removeListener(channel, callback) {
      if (this._listeners.has(channel)) {
        var listeners = this._listeners.get(channel);
        listeners.delete(callback);
      }
    }

    /**
     * Remove all subscibers from a channel.
     *
     * @param {String} channel - Name of the channel.
     */

  }, {
    key: 'removeAllListeners',
    value: function removeAllListeners(channel) {
      if (this._listeners.has(channel)) {
        var listeners = this._listeners.get(channel);
        listeners.clear();

        this._listeners.delete(channel);
      }
    }

    /**
     * Execute all subscribers of a event with given arguments.
     * @private
     */

  }, {
    key: 'emit',
    value: function emit(channel) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var listeners = this._listeners.get(channel);

      if (listeners !== undefined) listeners.forEach(function (listener) {
        return listener.apply(undefined, args);
      });
    }

    /**
     * Main event listener of the waves-ui timeline.
     * @private
     */

  }, {
    key: '_onEvent',
    value: function _onEvent(e, hitLayers) {
      this._executeCommandBackward('onEvent', e, hitLayers);
    }

    // ---------------------------------------------------------
    // module chain
    // ---------------------------------------------------------

    /**
     * Add a module to the player. A module is defined as a specific set
     * of functionnality and visualizations on top of the player.
     * Module can implement features such as waveform, moving cursor, etc.
     *
     * @param {AbstractModule} module - Module to add
     * @param {Number} zIndex - zIndex of the added module
     */

  }, {
    key: 'add',
    value: function add(module) {
      var zIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var index = this._modules.indexOf(module);

      if (index === -1) {
        module.block = this;
        module.zIndex = zIndex;
        module.install(this);

        if (this._trackMetadata && module.setTrack) module.setTrack(this._trackData, this._trackMetadata);

        this._modules.push(module);
        this.render();
      }
    }

    /**
     * Remove a module from the player.
     *
     * @param {AbstractModule} module - Module to remove
     */

  }, {
    key: 'remove',
    value: function remove(module) {
      var index = this._modules.indexOf(module);

      if (index !== -1) {
        module.uninstall(this);
        module.block = null;
        module.zIndex = null;

        this._modules.splice(index, 1);
        this.render();
      }
    }

    /**
     * Execute a command on each module that implements the method. The command
     * are executed in the order in which modules were added to the player.
     * @private
     */

  }, {
    key: '_executeCommandForward',
    value: function _executeCommandForward(command) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      for (var i = 0, l = this._modules.length; i < l; i++) {
        var module = this._modules[i];

        if (module[command]) {
          var next = module[command].apply(module, args);

          if (next === false) return;
        }
      }
    }

    /**
     * Execute a command on each module that implements the method. The command
     * are executed in the reverse order in which modules were added to the player.
     * @private
     */

  }, {
    key: '_executeCommandBackward',
    value: function _executeCommandBackward(command) {
      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      for (var i = this._modules.length - 1; i >= 0; i--) {
        var module = this._modules[i];

        if (module[command]) {
          var next = module[command].apply(module, args);

          if (next === false) return;
        }
      }
    }

    /**
     * Set or change the track of the player. A track is a JSON object that must
     * follow the convention defined ??
     *
     * @param {Object} data - data buffer (i.e. AudioBuffer)
     * @param {Object} metadata - metadata object
     */

  }, {
    key: 'setTrack',
    value: function setTrack(data, metadata) {
      this._setTrack(data, metadata, true);
    }

    /**
     * Set or change the track of the player. A track is a JSON object that must
     * follow the convention defined ??
     * @private
     *
     * @param {Object} data - data buffer (i.e. AudioBuffer)
     * @param {Object} metadata - metadata object
     * @param {Boolean} resetHistory - reset history
     */

  }, {
    key: '_setTrack',
    value: function _setTrack(data, metadata) {
      var resetHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      this._trackMetadata = metadata;
      this._trackData = data;
      this.player.setBuffer(data); // internally stops the play control

      if (resetHistory) {
        this._history.reset();
        this.snap();
      } else {
        // snap already emits the event...
        this.emit(this.EVENTS.UPDATE, this._trackData, this._trackMetadata);
      }

      this.stop();

      this.ui.timeline.pixelsPerSecond = this.width / this.duration;
      this.ui.timeContext.duration = this.duration;

      this._executeCommandForward('setTrack', data, metadata);

      this.render();
    }

    // ---------------------------------------------------------
    // undo / redo
    // ---------------------------------------------------------

    /**
     * @todo - review all history algorithm
     */

    /**
     * Create a snapshot of the data after modifications. Should be used in
     * modules after each significant operation, in order to allow `undo` and
     * `redo` operations.
     */

  }, {
    key: 'snap',
    value: function snap() {
      this._history.snap();
      this.emit(this.EVENTS.UPDATE, this._trackData, this._trackMetadata);
    }

    /**
     * Go to previous snapshot.
     */

  }, {
    key: 'undo',
    value: function undo() {
      if (this._history.undo()) {
        (0, _objectAssignDeep2.default)(this._trackMetadata, this._history.head());
        this._setTrack(this._trackData, this._trackMetadata, false);
      }
    }

    /**
     * Go to next snapshot.
     */

  }, {
    key: 'redo',
    value: function redo() {
      if (this._history.redo()) {
        (0, _objectAssignDeep2.default)(this._trackMetadata, this._history.head());
        this._setTrack(this._trackData, this._trackMetadata, false);
      }
    }

    /**
     * @todo - define if it's really the proper way to go...
     */

  }, {
    key: 'render',


    /**
     * Does this make sens ?
     * @private
     */
    value: function render() {
      // force rendering from outside the module (i.e. if values have changed)
      this.ui.timeline.tracks.forEach(function (track) {
        track.render();
        track.update();
      });

      this._executeCommandBackward('render');
    }
  }, {
    key: 'update',
    value: function update() {
      this.ui.timeline.tracks.forEach(function (track) {
        track.update();
      });

      this._executeCommandBackward('render');
    }

    // ---------------------------------------------------------
    // audio interface
    // ---------------------------------------------------------

    /**
     * Position of the head in the audio file.
     *
     * @name position
     * @type {Number}
     * @instance
     * @readonly
     */

  }, {
    key: 'volume',


    /**
     * Volume of the audio (in dB).
     *
     * @param {Number} db - volume of the player in decibels
     */
    value: function volume(db) {
      var gain = decibelToLinear(db);
      this.player.gain = gain;
    }

    /**
     * Start the player.
     */

  }, {
    key: 'start',
    value: function start() {
      this._isPlaying = true, this.player.start();

      this._executeCommandForward('start');

      this.emit(EVENTS.START);
      this.emitPosition(this.position);

      this._monitorPositionRafId = requestAnimationFrame(this._monitorPosition);
    }

    /**
     * Stop the player (shortcut for `pause` and `seek` to 0).
     */

  }, {
    key: 'stop',
    value: function stop() {
      this._isPlaying = false, this.player.stop();

      this._executeCommandForward('stop');

      this.emit(EVENTS.STOP);
      this.emitPosition(this.position);
    }

    /**
     * Pause the player.
     */

  }, {
    key: 'pause',
    value: function pause() {
      this._isPlaying = false, this.player.pause();

      this._executeCommandForward('pause');

      this.emit(EVENTS.PAUSE);
      this.emitPosition(this.position);
    }

    /**
     * Seek to a new position in the audio file.
     *
     * @param {Number} position - New position.
     */

  }, {
    key: 'seek',
    value: function seek(position) {
      position = Math.max(0, Math.min(position, this.player.duration));
      this.player.seek(position);

      this._executeCommandForward('seek', position, this._isPlaying);
      // as the position can be modified by the SeekControl
      this.emit(EVENTS.SEEK, this.player.position);
      this.emitPosition(this.player.position);
    }

    /**
     * Emit the current position.
     * Shortcut for `this.emit('position', position, duration)`
     */

  }, {
    key: 'emitPosition',
    value: function emitPosition(position) {
      this.emit(EVENTS.CURRENT_POSITION, position, this.player.duration);
    }

    /**
    * Emit the `ended` event.
    */

  }, {
    key: 'ended',
    value: function ended(position) {
      this.emit(EVENTS.ENDED, position);
      this.stop();
    }

    /**
     * Watch the current position of the player in a request animation frame loop.
     * @private
     */

  }, {
    key: '_monitorPosition',
    value: function _monitorPosition() {
      if (this.player.running) this._monitorPositionRafId = requestAnimationFrame(this._monitorPosition);

      var position = this.player.position;
      var duration = this.player.duration;
      this.emitPosition(position);

      if (position > duration) return this.ended(position); // player stops the playControl

      this.player.monitorPosition();
    }
  }, {
    key: 'metadata',
    get: function get() {
      return this._trackMetadata;
    }

    // ---------------------------------------------------------
    // visual interface
    // ---------------------------------------------------------

    /**
     * Width of the player. Defaults to the width of the given container.
     *
     * @name width
     * @type {Number}
     * @instance
     */

  }, {
    key: 'width',
    set: function set(value) {
      this.ui.width = value;
      this._executeCommandForward('setWidth', value);
    },
    get: function get() {
      return this.ui.width;
    }

    /**
     * Height of the player. Defaults to the height of the given container.
     *
     * @name height
     * @type {Number}
     * @instance
     */

  }, {
    key: 'height',
    set: function set(value) {
      this.ui.height = value;
      this._executeCommandForward('setHeight', value);
    },
    get: function get() {
      return this.ui.height;
    }
  }, {
    key: 'position',
    get: function get() {
      return this.player.position;
    }

    /**
     * Duration of the current audio file.
     *
     * @name duration
     * @type {Number}
     * @instance
     * @readonly
     */

  }, {
    key: 'duration',
    get: function get() {
      return this.player.duration;
    }
  }]);
  return Block;
}();

exports.default = Block;

},{"../utils/History":21,"./AbstractPlayer":2,"@ircam/parameters":173,"babel-runtime/core-js/map":177,"babel-runtime/core-js/set":187,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"object-assign-deep":333,"waves-ui":411}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Block = require('./Block');

var _Block2 = _interopRequireDefault(_Block);

var _AbstractPlayer = require('./AbstractPlayer');

var _AbstractPlayer2 = _interopRequireDefault(_AbstractPlayer);

var _AbstractModule = require('./AbstractModule');

var _AbstractModule2 = _interopRequireDefault(_AbstractModule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  Block: _Block2.default,
  AbstractPlayer: _AbstractPlayer2.default,
  AbstractModule: _AbstractModule2.default
};

},{"./AbstractModule":1,"./AbstractPlayer":2,"./Block":3}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core = require('./core');

Object.defineProperty(exports, 'core', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_core).default;
  }
});

var _module = require('./module');

Object.defineProperty(exports, 'module', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_module).default;
  }
});

var _player = require('./player');

Object.defineProperty(exports, 'player', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_player).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./core":4,"./module":17,"./player":20}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _AbstractModule2 = require('../core/AbstractModule');

var _AbstractModule3 = _interopRequireDefault(_AbstractModule2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * State to edit the label
 */
var LabelEditionState = function (_ui$states$BaseState) {
  (0, _inherits3.default)(LabelEditionState, _ui$states$BaseState);

  function LabelEditionState(timeline, layer) {
    (0, _classCallCheck3.default)(this, LabelEditionState);

    var _this = (0, _possibleConstructorReturn3.default)(this, (LabelEditionState.__proto__ || (0, _getPrototypeOf2.default)(LabelEditionState)).call(this, timeline));

    _this.currentTarget = null;
    _this.layer = layer;
    return _this;
  }

  (0, _createClass3.default)(LabelEditionState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'dblclick':
          this.onDblClick(e);
          break;
      }
    }
  }, {
    key: 'onDblClick',
    value: function onDblClick(e) {
      var shape = this.layer.getShapeFromDOMElement(e.target);
      shape.$label.setAttribute('contenteditable', true);
      shape.$label.focus();

      this.currentTarget = e.target;
      this.currentShape = shape;
    }
  }, {
    key: 'updateLabel',
    value: function updateLabel() {
      var value = this.currentShape.$label.innerHTML;
      var shape = this.layer.getShapeFromDOMElement(this.currentTarget);
      var datum = this.layer.getDatumFromDOMElement(this.currentTarget);
      shape.$label.removeAttribute('contenteditable');
      shape.$label.blur();

      if (datum) {
        this.currentShape.label(datum, value);
        this.currentTarget = null;
      }
    }
  }]);
  return LabelEditionState;
}(ui.states.BaseState);

/**
 * State to edit the position
 */


var PositionEditionState = function (_ui$states$BaseState2) {
  (0, _inherits3.default)(PositionEditionState, _ui$states$BaseState2);

  function PositionEditionState(timeline, layer) {
    (0, _classCallCheck3.default)(this, PositionEditionState);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (PositionEditionState.__proto__ || (0, _getPrototypeOf2.default)(PositionEditionState)).call(this, timeline));

    _this2.currentItem = null;
    _this2.currentTarget = null;
    _this2.hasMoved = false;
    _this2.layer = layer;
    return _this2;
  }

  (0, _createClass3.default)(PositionEditionState, [{
    key: 'clear',
    value: function clear() {
      this.currentItem = null;
      this.currentTarget = null;
      this.hasMoved = false;
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.currentTarget = e.target;
      this.currentItem = this.layer.getItemFromDOMElement(e.target);
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      this.layer.edit(this.currentItem, e.dx, e.dy, this.currentTarget);
      this.layer.update(this.currentItem);
    }
  }]);
  return PositionEditionState;
}(ui.states.BaseState);

/**
 * Abstract for fully editable module that display annotations accroding to the
 * given track config.
 * Derived modules should implement the `install` and `createNewAnnotationDatum`
 * methods.
 *
 * The module defines the following interactions:
 * - edit the annotation position (`time`): mouse drag
 * - edit the `label`: double click on the label to edit it
 * - create a new annotation: double click somewhere in the timeline
 * - delete a annotation: keypess suppr
 *
 * @example
 * ```
 * // data format
 * [
 *   { time: 0.230, label: 'label-1' },
 *   { time: 1.480, label: 'label-2' },
 * ]
 * ```
 */


var AbstractAnnotation = function (_AbstractModule) {
  (0, _inherits3.default)(AbstractAnnotation, _AbstractModule);

  function AbstractAnnotation(parameters, options) {
    (0, _classCallCheck3.default)(this, AbstractAnnotation);

    /**
     * The layer containing the annotations created in the install method
     */
    var _this3 = (0, _possibleConstructorReturn3.default)(this, (AbstractAnnotation.__proto__ || (0, _getPrototypeOf2.default)(AbstractAnnotation)).call(this, parameters, options));

    _this3._layer = null;
    return _this3;
  }

  /**
   * derived class shoud set the
   *
   */


  (0, _createClass3.default)(AbstractAnnotation, [{
    key: 'install',
    value: function install() {
      this._timeline = this.block.ui.timeline;
    }
  }, {
    key: 'postInstall',
    value: function postInstall(layer) {
      this._positionEditionState = new PositionEditionState(this._timeline, layer);
      this._labelEditionState = new LabelEditionState(this._timeline, layer);
    }
  }, {
    key: 'uninstall',
    value: function uninstall() {
      this.block.ui.track.remove(this._layer);
    }
  }, {
    key: 'render',
    value: function render() {
      this._layer.render();
      this._layer.update();
    }
  }, {
    key: 'setTrack',
    value: function setTrack(buffer, metadata) {
      this._layer.data = metadata.markers || [];
    }
  }, {
    key: '_createAnnotation',
    value: function _createAnnotation(position) {
      var _timeline$timeContext = this._timeline.timeContext,
          timeToPixel = _timeline$timeContext.timeToPixel,
          offset = _timeline$timeContext.offset;

      var time = timeToPixel.invert(position) - offset;
      var datum = this.createNewAnnotationDatum(time);

      this._layer.data.push(datum);
      this.render();
    }
  }, {
    key: '_deleteAnnotation',
    value: function _deleteAnnotation($item) {
      var datum = this._layer.getDatumFromItem($item);
      var index = this._layer.data.indexOf(datum);

      this._layer.data.splice(index, 1);
      this.render();
    }
  }, {
    key: 'onEvent',
    value: function onEvent(e, hitLayers) {
      var _this4 = this;

      switch (e.type) {
        case 'dblclick':
          if (this._layer.hasElement(e.target) && e.target.tagName === 'DIV') {
            var $target = e.target;

            if (this._timeline.state === this._positionEditionState) this._positionEditionState.clear();

            var prevContent = $target.textContent;
            this._timeline.state = this._labelEditionState;

            var clearLabelEdition = function clearLabelEdition(e) {
              if (_this4._labelEditionState.currentTarget !== e.target) {
                _this4._labelEditionState.updateLabel();
                _this4._timeline.state = null;

                if ($target.textContent !== prevContent) _this4.block.snap();

                document.removeEventListener('mousedown', clearLabelEdition);
              }
            };

            document.addEventListener('mousedown', clearLabelEdition);
            return false;
          } else {
            this._createAnnotation(e.x);
            this.block.snap();
          }

          break;

        case 'mousedown':
          // maybe we wait for a dbl click so stop event propagation
          if (this._layer.hasElement(e.target) && e.target.tagName === 'DIV') return false;

          if (this._layer.hasElement(e.target) && e.target.tagName !== 'DIV') {
            // clear current target and current item only if the user clicks
            // somewhere else => allows for deleting markers
            var clearPositionEdition = function clearPositionEdition(e) {
              if (!_this4._layer.hasElement(e.target)) {
                _this4._positionEditionState.clear();
                _this4._timeline.state = null;

                document.removeEventListener('mousedown', clearPositionEdition);
              }
            };

            this._timeline.state = this._positionEditionState;
            document.addEventListener('mousedown', clearPositionEdition);

            return false;
          }

          break;

        case 'mousemove':
          if (this._timeline.state === this._positionEditionState) this._positionEditionState.hasMoved = true;
          break;

        case 'mouseup':
          if (this._timeline.state === this._positionEditionState && this._positionEditionState.hasMoved === true) {
            this._positionEditionState.hasMoved = false;
            this.block.snap();
          }

          break;

        case 'keydown':
          // delete
          if (e.which === 8 && this._timeline.state == this._positionEditionState) {
            this._deleteAnnotation(this._positionEditionState.currentItem);
            this._positionEditionState.clear();

            this.block.snap();
            return false;
          }

          break;
      }

      if (this._timeline.state === this._labelEditionState) return false;

      return true;
    }
  }]);
  return AbstractAnnotation;
}(_AbstractModule3.default);

exports.default = AbstractAnnotation;

},{"../core/AbstractModule":1,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-ui":411}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

var _AbstractModule2 = require('../core/AbstractModule');

var _AbstractModule3 = _interopRequireDefault(_AbstractModule2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  downbeatColor: {
    type: 'string',
    default: 'red',
    metas: {
      desc: 'Color of a downbeat (`measure === true`)'
    }
  },
  upbeatColor: {
    type: 'string',
    default: 'orange',
    metas: {
      desc: 'Color of an upbeat (`measure === false`)'
    }
  }
};

var BeatGrid = function (_AbstractModule) {
  (0, _inherits3.default)(BeatGrid, _AbstractModule);

  function BeatGrid(options) {
    (0, _classCallCheck3.default)(this, BeatGrid);
    return (0, _possibleConstructorReturn3.default)(this, (BeatGrid.__proto__ || (0, _getPrototypeOf2.default)(BeatGrid)).call(this, definitions, options));
  }

  (0, _createClass3.default)(BeatGrid, [{
    key: 'install',
    value: function install() {
      var _block$ui = this.block.ui,
          track = _block$ui.track,
          timeContext = _block$ui.timeContext;


      this._beats = new ui.core.Layer('collection', [], {
        height: this.block.height,
        zIndex: this.zIndex
      });

      var downbeatColor = this.params.get('downbeatColor');
      var upbeatColor = this.params.get('upbeatColor');

      this._beats.setTimeContext(timeContext);
      this._beats.configureShape(ui.shapes.Marker, {
        x: function x(d) {
          var v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (v !== null) d.time = v;

          return d.time;
        },
        color: function color(d) {
          var v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          return d.measure === true ? downbeatColor : upbeatColor;
        }
      }, {
        displayHandlers: false,
        displayLabels: false
      });

      track.add(this._beats);
    }
  }, {
    key: 'uninstall',
    value: function uninstall() {
      var track = this.block.ui.track;

      track.remove(this._beats);
    }
  }, {
    key: 'setTrack',
    value: function setTrack(data, metadata) {
      if (!metadata.beats) throw new Error('Invalid metadata for module BeatGrid, should contain a `beats` property');

      this._beats.data = metadata.beats;
    }

    /**
     * shift the beats with certain dt
     */

  }, {
    key: 'shift',
    value: function shift(dt) {
      var beats = this.block.metadata.beats;


      for (var i = 0; i < beats.length; i++) {
        beats[i].time += dt;
      }this._beats.update();
      this.block.snap();
    }
  }]);
  return BeatGrid;
}(_AbstractModule3.default);

exports.default = BeatGrid;

},{"../core/AbstractModule":1,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-ui":411}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

var _AbstractModule2 = require('../core/AbstractModule');

var _AbstractModule3 = _interopRequireDefault(_AbstractModule2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// display signal from LFO vector stream like
var Multiline = function (_ui$shapes$BaseShape) {
  (0, _inherits3.default)(Multiline, _ui$shapes$BaseShape);

  function Multiline() {
    (0, _classCallCheck3.default)(this, Multiline);
    return (0, _possibleConstructorReturn3.default)(this, (Multiline.__proto__ || (0, _getPrototypeOf2.default)(Multiline)).apply(this, arguments));
  }

  (0, _createClass3.default)(Multiline, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'multiline';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return {};
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        colors: ['steelblue', 'orange', 'yellow', 'green', 'purple', 'grey'],
        frameSize: 1
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      this.$el = document.createElementNS(this.ns, 'g');

      this.$paths = [];
      var frameSize = this.params.frameSize;

      for (var i = 0; i < frameSize; i++) {
        var $path = document.createElementNS(this.ns, 'path');
        $path.setAttributeNS(null, 'stroke', this.params.colors[i]);
        $path.setAttributeNS(null, 'fill', 'none');

        this.$paths[i] = $path;
        this.$el.appendChild($path);
      }

      return this.$el;
    }

    // recenter on zero

  }, {
    key: 'update',
    value: function update(renderingContext, data) {
      var timeOffset = data[0].time;
      var numFrames = data.length;
      var frameSize = this.params.frameSize;

      for (var i = 0; i < frameSize; i++) {
        var path = 'M';

        for (var j = 0; j < numFrames; j++) {
          var frame = data[j];
          var x = renderingContext.timeToPixel(frame.time - timeOffset);
          var y = renderingContext.valueToPixel(frame.data[i]);
          path += x + ',' + y;

          if (j < numFrames - 1) path += 'L';
        }

        this.$paths[i].setAttributeNS(null, 'd', path);
      }
    }
  }]);
  return Multiline;
}(ui.shapes.BaseShape);

var definitions = {};

var Bpf = function (_AbstractModule) {
  (0, _inherits3.default)(Bpf, _AbstractModule);

  function Bpf(options) {
    (0, _classCallCheck3.default)(this, Bpf);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (Bpf.__proto__ || (0, _getPrototypeOf2.default)(Bpf)).call(this, definitions, options));

    _this2._lines = null;
    return _this2;
  }

  (0, _createClass3.default)(Bpf, [{
    key: 'setTrack',
    value: function setTrack(buffer, metadata) {
      var block = this.block;
      var _block$ui = block.ui,
          track = _block$ui.track,
          timeContext = _block$ui.timeContext;

      var recording = metadata.data;

      if (this._lines) track.remove(this._lines);

      var lines = new ui.core.Layer('entity', recording.frames, {
        height: block.height,
        yDomain: [0, 600]
      });

      lines.setTimeContext(timeContext);
      lines.configureShape(Multiline, {
        frameSize: recording.streamParams.frameSize
      }, {});

      track.add(lines);

      this._lines = lines;
    }
  }]);
  return Bpf;
}(_AbstractModule3.default);

exports.default = Bpf;

},{"../core/AbstractModule":1,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-ui":411}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

var _AbstractModule2 = require('../core/AbstractModule');

var _AbstractModule3 = _interopRequireDefault(_AbstractModule2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  color: {
    type: 'string',
    default: 'red',
    constant: true,
    metas: {
      desc: 'color of the cursor'
    }
  },
  seek: {
    type: 'boolean',
    default: true,
    metas: {
      desc: 'seek interaction of the module'
    }
  },
  startOnDblClick: {
    type: 'boolean',
    default: false,
    metas: {
      desc: 'seek and start the player on double click'
    }
  }
};

/**
 * Seek state, only apply if no state previous decorator took precedence
 */

var SeekState = function (_ui$states$BaseState) {
  (0, _inherits3.default)(SeekState, _ui$states$BaseState);

  function SeekState(block, timeline) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck3.default)(this, SeekState);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SeekState.__proto__ || (0, _getPrototypeOf2.default)(SeekState)).call(this, timeline));

    _this.block = block;
    _this.options = options;
    return _this;
  }

  (0, _createClass3.default)(SeekState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      if (e.type === 'mousedown' || e.type === 'mousemove' || e.type === 'dblclick') {
        var _timeline$timeContext = this.timeline.timeContext,
            timeToPixel = _timeline$timeContext.timeToPixel,
            offset = _timeline$timeContext.offset;

        var time = timeToPixel.invert(e.x) - offset;
        this.block.seek(time);

        if (e.type === 'dblclick' && this.options.startOnDblClick === true) this.block.start();
      }
    }
  }]);
  return SeekState;
}(ui.states.BaseState);

var Cursor = function (_AbstractModule) {
  (0, _inherits3.default)(Cursor, _AbstractModule);

  function Cursor(options) {
    (0, _classCallCheck3.default)(this, Cursor);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (Cursor.__proto__ || (0, _getPrototypeOf2.default)(Cursor)).call(this, definitions, options));

    _this2._data = { currentPosition: 0 };
    _this2._cursor = null;
    _this2._cursorSeekState = null;

    _this2._updateCursorPosition = _this2._updateCursorPosition.bind(_this2);
    return _this2;
  }

  (0, _createClass3.default)(Cursor, [{
    key: 'install',
    value: function install() {
      var block = this.block;
      var _block$ui = block.ui,
          timeline = _block$ui.timeline,
          track = _block$ui.track,
          timeContext = _block$ui.timeContext;


      this._cursor = new ui.core.Layer('entity', this._data, {
        height: block.height,
        zIndex: this.zIndex
      });

      this._cursor.setTimeContext(timeContext);
      this._cursor.configureShape(ui.shapes.Cursor, {
        x: function x(d) {
          return d.currentPosition;
        }
      }, {
        color: this.params.get('color')
      });

      track.add(this._cursor);

      this._cursor.render();
      this._cursorSeekState = new SeekState(block, timeline, {
        startOnDblClick: this.params.get('startOnDblClick')
      });

      block.addListener(block.EVENTS.CURRENT_POSITION, this._updateCursorPosition);

      this._updateCursorPosition(block.position);
    }
  }, {
    key: 'uninstall',
    value: function uninstall() {
      var block = this.block;
      block.removeListener(block.EVENTS.CURRENT_POSITION, this._updateCursorPosition);
      block.ui.track.remove(this._cursor);
    }
  }, {
    key: 'onEvent',
    value: function onEvent(e) {
      if (this.params.get('seek') === false) return true;

      var timeline = this.block.ui.timeline;

      switch (e.type) {
        case 'mousedown':
        case 'dblclick':
          timeline.state = this._cursorSeekState;
          return false; // preventPropagation
          break;
        case 'mouseup':
          if (timeline.state === this._cursorSeekState) timeline.state = null;
          break;
      }

      return true;
    }
  }, {
    key: '_updateCursorPosition',
    value: function _updateCursorPosition(position) {
      this._data.currentPosition = position;
      this._cursor.update();
    }
  }]);
  return Cursor;
}(_AbstractModule3.default);

exports.default = Cursor;

},{"../core/AbstractModule":1,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-ui":411}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _AbstractModule2 = require('../core/AbstractModule');

var _AbstractModule3 = _interopRequireDefault(_AbstractModule2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parameters = {};

/**
 *
 *
 */

var GridAxis = function (_AbstractModule) {
  (0, _inherits3.default)(GridAxis, _AbstractModule);

  function GridAxis() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, GridAxis);
    return (0, _possibleConstructorReturn3.default)(this, (GridAxis.__proto__ || (0, _getPrototypeOf2.default)(GridAxis)).call(this, parameters, options));
  }

  // for use in zoom for example


  (0, _createClass3.default)(GridAxis, [{
    key: 'install',
    value: function install() {
      var _block$ui = this.block.ui,
          timeline = _block$ui.timeline,
          track = _block$ui.track;

      // dummy axis waiting for track config

      this._layer = new ui.axis.AxisLayer(ui.axis.gridAxisGenerator(1, '4/4'), {
        top: 0,
        height: 12,
        zIndex: this.zIndex
      });

      // axis use timeline time context
      this._layer.setTimeContext(timeline.timeContext);
      this._layer.configureShape(ui.shapes.Ticks, {}, { color: '#909090' });

      track.add(this._layer);
    }
  }, {
    key: 'uninstall',
    value: function uninstall() {
      var track = this.block.ui.track;

      track.remove(this._layer);
    }
  }, {
    key: 'setTrack',
    value: function setTrack(buffer, metadata) {
      // as the signature and bpm may change between tracks,
      // we need to recreate generator
      var bpm = metadata.bpm,
          signature = metadata.signature;

      var generator = ui.axis.gridAxisGenerator(bpm, signature);

      this._layer.generator = generator;
      this._layer.render();
      this._layer.update();
    }
  }, {
    key: 'layer',
    get: function get() {
      return this._layer;
    }
  }]);
  return GridAxis;
}(_AbstractModule3.default);

exports.default = GridAxis;

},{"../core/AbstractModule":1,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-ui":411}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _AbstractAnnotation2 = require('./AbstractAnnotation');

var _AbstractAnnotation3 = _interopRequireDefault(_AbstractAnnotation2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parameters = {
  color: {
    type: 'string',
    default: 'green',
    constant: true
  }
};

/**
 * Fully editable module that display markers accroding to the given track config.
 *
 * Markers should be defined in the `markers` entry of the track configuration.
 * A marker is defined by a `time`, `label` and an optionnal `color`.
 *
 * @example
 * ```
 * [
 *   { time: 0.230, label: 'label-1' },
 *   { time: 1.480, label: 'label-2' },
 * ]
 * ```
 *
 * The module defines the following interactions:
 * - edit the marker position (`time`): mouse drag
 * - edit the `label`: double click on the label to edit it
 * - create a new marker: double click somewhere in the timeline
 * - delete a marker: keypess suppr
 *
 * @param {Object} options - Override default parameters
 * @param {String} color - Default color of the markers.
 */

var Marker = function (_AbstractAnnotation) {
  (0, _inherits3.default)(Marker, _AbstractAnnotation);

  function Marker(options) {
    (0, _classCallCheck3.default)(this, Marker);
    return (0, _possibleConstructorReturn3.default)(this, (Marker.__proto__ || (0, _getPrototypeOf2.default)(Marker)).call(this, parameters, options));
  }

  // return a new annotation datum
  // @note - should be modified if the data format changes


  (0, _createClass3.default)(Marker, [{
    key: 'createNewAnnotationDatum',
    value: function createNewAnnotationDatum(time) {
      return {
        time: time,
        label: 'label'
      };
    }
  }, {
    key: 'install',
    value: function install() {
      var _this2 = this;

      (0, _get3.default)(Marker.prototype.__proto__ || (0, _getPrototypeOf2.default)(Marker.prototype), 'install', this).call(this);

      var _block$ui = this.block.ui,
          timeContext = _block$ui.timeContext,
          track = _block$ui.track;


      var markers = new ui.core.Layer('collection', [], {
        height: this.block.height,
        zIndex: this.zIndex
      });

      markers.setTimeContext(timeContext);
      markers.configureShape(ui.shapes.Marker, {
        x: function x(d) {
          var v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (v !== null) d.time = Math.min(v, timeContext.duration);

          return d.time;
        },
        label: function label(d) {
          var v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (v !== null) d.label = v;

          return d.label;
        },
        color: function color(d) {
          return d.color || _this2.params.get('color');
        }
      }, {
        handlerWidth: 7,
        handlerHeight: 10,
        displayHandlers: true,
        displayLabels: true,
        opacity: 1
      });

      markers.setBehavior(new ui.behaviors.MarkerBehavior());

      track.add(markers);

      this._layer = markers;
      this.postInstall(this._layer);
    }
  }]);
  return Marker;
}(_AbstractAnnotation3.default);

exports.default = Marker;

},{"./AbstractAnnotation":6,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-ui":411}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _AbstractAnnotation2 = require('./AbstractAnnotation');

var _AbstractAnnotation3 = _interopRequireDefault(_AbstractAnnotation2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parameters = {};

var Segment = function (_AbstractAnnotation) {
  (0, _inherits3.default)(Segment, _AbstractAnnotation);

  function Segment(options) {
    (0, _classCallCheck3.default)(this, Segment);
    return (0, _possibleConstructorReturn3.default)(this, (Segment.__proto__ || (0, _getPrototypeOf2.default)(Segment)).call(this, parameters, options));
  }

  (0, _createClass3.default)(Segment, [{
    key: 'createNewAnnotationDatum',
    value: function createNewAnnotationDatum(time) {
      return {
        time: time,
        label: 'label',
        duration: 1
      };
    }
  }, {
    key: 'install',
    value: function install() {
      (0, _get3.default)(Segment.prototype.__proto__ || (0, _getPrototypeOf2.default)(Segment.prototype), 'install', this).call(this);

      var _block$ui = this.block.ui,
          timeContext = _block$ui.timeContext,
          track = _block$ui.track;


      var segments = new ui.core.Layer('collection', [], {
        height: this.block.height,
        yDomain: [0, 1],
        zIndex: this.zIndex
      });

      segments.setTimeContext(timeContext);
      segments.configureShape(ui.shapes.Segment, {
        x: function x(d) {
          var v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          // can't go beyond the end of the track
          if (v !== null) d.time = Math.min(v, timeContext.duration - d.duration);

          return d.time;
        },
        width: function width(d) {
          var v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (v !== null) d.duration = Math.min(v, timeContext.duration - d.time);

          return d.duration;
        },
        y: function y(d) {
          return 0;
        },
        height: function height(d) {
          return 1;
        }
      }, {
        opacity: 0.2,
        displayHandlers: true,
        handlerWidth: 1,
        handlerOpacity: 0.4,
        displayLabels: true
      });

      segments.setBehavior(new ui.behaviors.SegmentBehavior());
      track.add(segments);

      this._layer = segments;

      this.postInstall(this._layer);
    }
  }]);
  return Segment;
}(_AbstractAnnotation3.default);

exports.default = Segment;

},{"./AbstractAnnotation":6,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-ui":411}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

var _AbstractModule2 = require('../core/AbstractModule');

var _AbstractModule3 = _interopRequireDefault(_AbstractModule2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SimpleWaveformShape = function (_ui$shapes$BaseShape) {
  (0, _inherits3.default)(SimpleWaveformShape, _ui$shapes$BaseShape);

  function SimpleWaveformShape() {
    (0, _classCallCheck3.default)(this, SimpleWaveformShape);
    return (0, _possibleConstructorReturn3.default)(this, (SimpleWaveformShape.__proto__ || (0, _getPrototypeOf2.default)(SimpleWaveformShape)).apply(this, arguments));
  }

  (0, _createClass3.default)(SimpleWaveformShape, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'simple-waveform';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return {};
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        sampleRate: 44100,
        color: '#000000',
        opacity: 1,
        overlay: false,
        overlayColor: '#000000',
        overlayOpacity: 0.4
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) return this.$el;

      this.$el = document.createElementNS(this.ns, 'g');

      this.$path = document.createElementNS(this.ns, 'path');
      this.$path.setAttributeNS(null, 'fill', 'none');
      this.$path.setAttributeNS(null, 'shape-rendering', 'crispEdges');
      this.$path.setAttributeNS(null, 'stroke', this.params.color);
      this.$path.setAttributeNS(null, 'fill', this.params.color);
      this.$path.style.opacity = this.params.opacity;

      this.$el.appendChild(this.$path);

      if (this.params.overlay === true) {
        this.$overlay = document.createElementNS(this.ns, 'rect');
        this.$overlay.style.fill = this.params.overlayColor;
        this.$overlay.style.fillOpacity = this.params.overlayOpacity;

        this.$el.appendChild(this.$overlay);
      }

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      // define nbr of samples per pixels
      var sliceMethod = datum instanceof Float32Array ? 'subarray' : 'slice';
      var nbrSamples = datum.length;
      var duration = nbrSamples / this.params.sampleRate;
      var width = renderingContext.timeToPixel(duration);
      var samplesPerPixel = nbrSamples / width;

      if (!samplesPerPixel || datum.length < samplesPerPixel) return;

      var minX = renderingContext.minX,
          maxX = renderingContext.maxX;

      var pixelToTime = renderingContext.timeToPixel.invert;
      var sampleRate = this.params.sampleRate;
      var blockSize = 3; // this.params.barWidth;
      var minMax = [];

      // get min/max per bar, clamped to the visible area
      for (var px = minX; px < maxX; px += blockSize) {
        var startTime = pixelToTime(px);
        var startSample = startTime * sampleRate;
        var extract = datum[sliceMethod](startSample, startSample + samplesPerPixel);

        var min = Infinity;
        var max = -Infinity;

        for (var j = 0, l = extract.length; j < l; j++) {
          var sample = extract[j];
          if (sample < min) min = sample;
          if (sample > max) max = sample;
        }
        // disallow Infinity
        min = !isFinite(min) ? 0 : min;
        max = !isFinite(max) ? 0 : max;

        minMax.push([px, min, max]);
      }

      if (minMax.length) {
        var PIXEL = 0;
        var MIN = 1;
        var MAX = 2;

        var d = 'M';

        for (var i = 0, _l = minMax.length; i < _l; i++) {
          var _datum = minMax[i];
          var x = _datum[PIXEL];
          var y1 = Math.round(renderingContext.valueToPixel(_datum[MIN]));
          var y2 = Math.round(renderingContext.valueToPixel(_datum[MAX]));

          d += x + ',' + y1 + 'L' + x + ',' + y2 + 'L' + (x + blockSize - 2) + ',' + y2 + 'L' + (x + blockSize - 2) + ',' + y1 + 'L' + x + ',' + y1;

          if (i < _l - 1) d += 'M';
        }

        this.$path.setAttributeNS(null, 'd', d);
      }

      if (this.params.overlay) {
        this.$overlay.setAttribute('x', 0);
        this.$overlay.setAttribute('y', 0);
        this.$overlay.setAttribute('width', renderingContext.width);
        this.$overlay.setAttribute('height', renderingContext.height / 2);
      }
    }
  }]);
  return SimpleWaveformShape;
}(ui.shapes.BaseShape);

var definitions = {
  color: {
    type: 'string',
    default: 'steelblue',
    constant: true,
    metas: {
      desc: 'color of the waveform'
    }
  },
  overlay: {
    type: 'boolean',
    default: false,
    constant: true,
    metas: {
      desc: 'Define if an overlay should be displayed on the bottom of the waveform'
    }
  },
  overlayColor: {
    type: 'string',
    default: '#000000',
    constant: true,
    metas: {
      desc: 'Color of the overlay'
    }
  },
  overlayOpacity: {
    type: 'float',
    default: 0.4,
    constant: true,
    metas: {
      desc: 'Opacity of the overlay'
    }
  }
};

/**
 * Module that display the waveform of the audio buffer. In case non-mono
 * audio files, only the left channel is rendered. For more accurate
 * representation see WaveformModule.
 *
 * @param {Object} options - Override default parameters
 * @param {String} [options.color='steelblue'] - Color of the waveform
 */

var SimpleWaveform = function (_AbstractModule) {
  (0, _inherits3.default)(SimpleWaveform, _AbstractModule);

  function SimpleWaveform(options) {
    (0, _classCallCheck3.default)(this, SimpleWaveform);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (SimpleWaveform.__proto__ || (0, _getPrototypeOf2.default)(SimpleWaveform)).call(this, definitions, options));

    _this2._waveform = null;
    return _this2;
  }

  (0, _createClass3.default)(SimpleWaveform, [{
    key: 'install',
    value: function install() {
      var _block$ui = this.block.ui,
          track = _block$ui.track,
          timeContext = _block$ui.timeContext;


      this._waveform = new ui.core.Layer('entity', [], {
        height: this.block.height,
        yDomain: [-1, 1],
        zIndex: this.zIndex
      });

      this._waveform.setTimeContext(timeContext);
      this._waveform.configureShape(SimpleWaveformShape, {}, {
        color: this.params.get('color'),
        overlay: this.params.get('overlay'),
        overlayColor: this.params.get('overlayColor'),
        overlayOpacity: this.params.get('overlayOpacity')
      });

      track.add(this._waveform);
    }
  }, {
    key: 'uninstall',
    value: function uninstall() {
      this.block.ui.track.remove(this._waveform);
    }
  }, {
    key: 'setTrack',
    value: function setTrack(buffer, metadata) {
      this._waveform.data = buffer.getChannelData(0);
      this._waveform.render(); // update bindings between data and shapes

      // hack to set the smaple rate properly
      var $item = this._waveform.$el.querySelector('.simple-waveform');
      var shape = this._waveform.getShapeFromItem($item);
      shape.params.sampleRate = buffer.sampleRate;
    }
  }]);
  return SimpleWaveform;
}(_AbstractModule3.default);

exports.default = SimpleWaveform;

},{"../core/AbstractModule":1,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-ui":411}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _AbstractModule2 = require('../core/AbstractModule');

var _AbstractModule3 = _interopRequireDefault(_AbstractModule2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parameters = {};

/**
 *
 *
 */

var TimeAxis = function (_AbstractModule) {
  (0, _inherits3.default)(TimeAxis, _AbstractModule);

  function TimeAxis() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, TimeAxis);
    return (0, _possibleConstructorReturn3.default)(this, (TimeAxis.__proto__ || (0, _getPrototypeOf2.default)(TimeAxis)).call(this, parameters, options));
  }

  // for use in zoom for example


  (0, _createClass3.default)(TimeAxis, [{
    key: 'install',
    value: function install() {
      var _block$ui = this.block.ui,
          timeline = _block$ui.timeline,
          track = _block$ui.track;

      // dummy axis waiting for track config

      this._layer = new ui.axis.AxisLayer(ui.axis.timeAxisGenerator(1, '4/4'), {
        top: 0,
        height: 12,
        zIndex: this.zIndex
      });

      this._layer.setTimeContext(timeline.timeContext);
      this._layer.configureShape(ui.shapes.Ticks, {}, { color: 'steelblue' });

      track.add(this._layer);
    }
  }, {
    key: 'uninstall',
    value: function uninstall() {
      var track = this.block.ui.track;

      track.remove(this._layer);
    }
  }, {
    key: 'setTrack',
    value: function setTrack(data, metadata) {
      this._layer.render();
      this._layer.update();
    }
  }, {
    key: 'layer',
    get: function get() {
      return this._layer;
    }
  }]);
  return TimeAxis;
}(_AbstractModule3.default);

exports.default = TimeAxis;

},{"../core/AbstractModule":1,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-ui":411}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

var _AbstractModule2 = require('../core/AbstractModule');

var _AbstractModule3 = _interopRequireDefault(_AbstractModule2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  color: {
    type: 'string',
    default: 'steelblue',
    constant: true,
    metas: {
      desc: 'color of the waveform'
    }
  },
  channels: {
    type: 'any',
    default: [0],
    constant: true,
    metas: {
      desc: 'array of the channels to display (defaults to [0] - left channel)'
    }
  }
};

/**
 * Module that display the waveform of the audio buffer.
 *
 * @param {Object} options - Override default parameters
 * @param {String} [options.color='steelblue'] - Color of the waveform
 * @param {Array|String} [options.channels=[0]] - Array describing the channels to displays,
 *  'all' to display all the channels. By default display only the left channel.
 */

var Waveform = function (_AbstractModule) {
  (0, _inherits3.default)(Waveform, _AbstractModule);

  function Waveform(options) {
    (0, _classCallCheck3.default)(this, Waveform);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Waveform.__proto__ || (0, _getPrototypeOf2.default)(Waveform)).call(this, definitions, options));

    _this._waveforms = new _set2.default();
    return _this;
  }

  (0, _createClass3.default)(Waveform, [{
    key: 'install',
    value: function install() {}
  }, {
    key: 'uninstall',
    value: function uninstall() {
      this._clear();
    }
  }, {
    key: 'setTrack',
    value: function setTrack(buffer, metadatas) {
      var _this2 = this;

      this._clear();

      var channels = this.params.get('channels');
      var _block$ui = this.block.ui,
          track = _block$ui.track,
          timeContext = _block$ui.timeContext;


      if (channels === 'all') {
        var numChannels = buffer.numberOfChannels;
        channels = [];

        for (var i = 0; i < numChannels; i++) {
          channels.push(i);
        }
      }

      channels.forEach(function (channel, index) {
        var data = null;

        // prevent DOMException, such as:
        // Failed to execute 'getChannelData' on 'AudioBuffer': channel
        // index (1) exceeds number of channels (1)
        try {
          data = buffer.getChannelData(channel);
        } catch (err) {};

        if (data !== null) {
          var layerHeight = _this2.block.height / channels.length;

          var waveform = new ui.core.Layer('entity', data, {
            height: layerHeight,
            top: layerHeight * index,
            yDomain: [-1, 1],
            zIndex: _this2.zIndex
          });

          waveform.setTimeContext(timeContext);
          waveform.configureShape(ui.shapes.Waveform, {}, {
            color: _this2.params.get('color'),
            sampleRate: buffer.sampleRate
          });

          track.add(waveform);

          _this2._waveforms.add(waveform);
        }
      });
    }
  }, {
    key: '_clear',
    value: function _clear() {
      var track = this.block.ui.track;

      this._waveforms.forEach(function (waveform) {
        return track.remove(waveform);
      });
      this._waveforms.clear();
    }
  }]);
  return Waveform;
}(_AbstractModule3.default);

exports.default = Waveform;

},{"../core/AbstractModule":1,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/core-js/set":187,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-ui":411}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _set2 = require('babel-runtime/helpers/set');

var _set3 = _interopRequireDefault(_set2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _AbstractModule2 = require('../core/AbstractModule');

var _AbstractModule3 = _interopRequireDefault(_AbstractModule2);

var _GridAxis = require('./GridAxis');

var _GridAxis2 = _interopRequireDefault(_GridAxis);

var _TimeAxis = require('./TimeAxis');

var _TimeAxis2 = _interopRequireDefault(_TimeAxis);

var _wavesUi = require('waves-ui');

var ui = _interopRequireWildcard(_wavesUi);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var scales = ui.utils.scales;

var ZoomState = function (_ui$states$BaseState) {
  (0, _inherits3.default)(ZoomState, _ui$states$BaseState);

  function ZoomState(block, timeline) {
    var scrollBar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck3.default)(this, ZoomState);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ZoomState.__proto__ || (0, _getPrototypeOf2.default)(ZoomState)).call(this, timeline));

    _this.block = block;
    _this.scrollBar = scrollBar;

    _this._pixelToExponent = scales.linear().domain([0, block.height]).range([0, 1]);
    return _this;
  }

  (0, _createClass3.default)(ZoomState, [{
    key: 'destroy',
    value: function destroy() {
      this.block = null;
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.initialZoom = this.timeline.timeContext.zoom;
      this.initialY = e.y;
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      // prevent annoying text selection when dragging
      e.originalEvent.preventDefault();

      // define max/min zoom
      var maxZoom = 44100 / this.timeline.timeContext.pixelsPerSecond;
      var minZoom = 1;

      var trackDuration = this.block.duration;
      var timeContext = this.timeline.timeContext;
      var lastCenterTime = timeContext.timeToPixel.invert(e.x);
      var exponent = this._pixelToExponent(e.y - this.initialY);
      var targetZoom = this.initialZoom * Math.pow(2, exponent);

      timeContext.zoom = Math.min(Math.max(targetZoom, minZoom), maxZoom);

      var newCenterTime = timeContext.timeToPixel.invert(e.x);
      var delta = newCenterTime - lastCenterTime;

      // clamp zoomed waveform in screen
      var newOffset = timeContext.offset + delta + timeContext.timeToPixel.invert(e.dx);
      var maxOffset = 0;
      var minOffset = timeContext.visibleDuration - trackDuration;

      timeContext.offset = Math.max(minOffset, Math.min(maxOffset, newOffset));

      this.timeline.tracks.update();

      if (this.scrollBar) this.scrollBar.update();
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {}
  }]);
  return ZoomState;
}(ui.states.BaseState);

var ScrollState = function (_ui$states$BaseState2) {
  (0, _inherits3.default)(ScrollState, _ui$states$BaseState2);

  function ScrollState(block, timeline, scrollBar) {
    (0, _classCallCheck3.default)(this, ScrollState);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (ScrollState.__proto__ || (0, _getPrototypeOf2.default)(ScrollState)).call(this, timeline));

    _this2.block = block;
    _this2.scrollBar = scrollBar;
    return _this2;
  }

  (0, _createClass3.default)(ScrollState, [{
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var mainTimeContext = this.timeline.timeContext;
      var trackDuration = this.block.duration;
      var dt = this.scrollBar.timeContext.timeToPixel.invert(e.dx);

      // manipuate and clamp offset of the main timeline
      var newOffset = mainTimeContext.offset - dt;
      var maxOffset = 0;
      var minOffset = mainTimeContext.visibleDuration - trackDuration;

      mainTimeContext.offset = Math.max(minOffset, Math.min(maxOffset, newOffset));

      this.timeline.tracks.update();
      this.scrollBar.update();
    }
  }]);
  return ScrollState;
}(ui.states.BaseState);

var parameters = {
  axisType: {
    type: 'enum',
    list: ['time', 'grid'],
    default: 'time'
  },
  scrollBarContainer: {
    type: 'any',
    default: null,
    required: true,
    metas: {
      desc: 'CSS Selector or DOM element that should contain the scroll bar'
    }
  },
  scrollBarHeight: {
    type: 'float',
    min: 0,
    max: +Infinity,
    step: 1,
    default: 10,
    metas: {
      desc: 'height of the scroll-bar'
    }
  },
  scrollBarColor: {
    type: 'string',
    default: '#000000',
    metas: {
      desc: 'color of the scroll-bar'
    }
  },
  centeredCurrentPosition: {
    type: 'boolean',
    default: false,
    constant: true,
    metas: {
      desc: 'keep waveform center around the block\'s current position'
    }
  }
  // @todo - allow switching between time and grid axis
  // axis: {}


  /**
   *
   */
};
var Zoom = function (_AbstractModule) {
  (0, _inherits3.default)(Zoom, _AbstractModule);

  function Zoom(options) {
    (0, _classCallCheck3.default)(this, Zoom);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (Zoom.__proto__ || (0, _getPrototypeOf2.default)(Zoom)).call(this, parameters, options));

    _this3.axisModule = _this3.params.get('axisType') === 'grid' ? new _GridAxis2.default() : new _TimeAxis2.default();

    _this3.hasScrollBar = false;

    _this3._onScrollBarMouseEvent = _this3._onScrollBarMouseEvent.bind(_this3);
    _this3._updateOffset = _this3._updateOffset.bind(_this3);
    return _this3;
  }

  (0, _createClass3.default)(Zoom, [{
    key: 'install',
    value: function install() {
      var _this4 = this;

      this.axisModule.install();

      var $container = this.params.get('scrollBarContainer');

      if ($container !== null) {
        if (!($container instanceof Element)) $container = document.querySelector($container);

        this.hasScrollBar = true;

        // create a new timeline to host the scroll bar
        var visibleWidth = this.block.width;
        var height = this.params.get('scrollBarHeight');

        $container.style.width = visibleWidth + 'px';
        $container.style.height = height + 'px';

        // init with dummy pixel per second
        var scrollTimeline = new ui.core.Timeline(1, visibleWidth);
        var scrollTrack = new ui.core.Track($container, height);

        scrollTimeline.add(scrollTrack, 'scroll');

        // data of the scroll bar is the timeContext of the main timeline
        var mainTimeContext = this.block.ui.timeline.timeContext;
        var scrollBar = new ui.core.Layer('entity', mainTimeContext, {
          height: height,
          yDomain: [0, 1]
        });

        var timeContext = new ui.core.LayerTimeContext(scrollTimeline.timeContext);
        scrollBar.setTimeContext(timeContext);

        scrollBar.configureShape(ui.shapes.Segment, {
          x: function x(d) {
            return -d.offset;
          },
          y: function y(d) {
            return 0;
          },
          width: function width(d) {
            return d.visibleDuration;
          },
          height: function height(d) {
            return 1;
          },
          color: function color(d) {
            return _this4.params.get('scrollBarColor');
          }
        }, {
          displayHandlers: false
        });

        scrollTrack.add(scrollBar, 'scroll');
        scrollTrack.updateContainer();

        this._scrollTimeline = scrollTimeline;
        this._scrollTrack = scrollTrack;
        this._scrollBar = scrollBar;
        this._scrollTimeline.on('event', this._onScrollBarMouseEvent);

        this._scrollState = new ScrollState(this.block, this.block.ui.timeline, this._scrollBar);
        this._zoomState = new ZoomState(this.block, this.block.ui.timeline, this._scrollBar);
      } else {
        this._zoomState = new ZoomState(this.block, this.block.ui.timeline);
      }

      if (this.params.get('centeredCurrentPosition')) this.block.addListener(this.block.EVENTS.CURRENT_POSITION, this._updateOffset);
    }
  }, {
    key: 'uninstall',
    value: function uninstall() {
      var _block$ui = this.block.ui,
          timeline = _block$ui.timeline,
          track = _block$ui.track;

      // reset zoom value

      timeline.zoom = 1;
      timeline.offset = 0;
      track.update();

      this.axisModule.uninstall(this.block);

      if (this.hasScrollBar) {
        this._scrollTimeline.removeListener('event', this._onScrollBarMouseEvent);
        this._scrollTimeline.remove(this._scrollTrack);
        this._scrollTimeline = null;
        this._scrollTrack = null;
        this._scrollBar = null;
        this._scrollState = null;
      }

      this._zoomState = null;

      if (this.params.get('centeredCurrentPosition')) block.removeListener(block.EVENTS.CURRENT_POSITION, this._updateOffset);
    }
  }, {
    key: 'setWidth',
    value: function setWidth(value) {
      if (this.hasScrollBar) {
        this._scrollTimeline.maintainVisibleDuration = true;
        this._scrollTimeline.visibleWidth = value;

        this._scrollTrack.render();
        this._scrollTrack.update();
      }
    }
  }, {
    key: 'setTrack',
    value: function setTrack(buffer, metadatas) {
      this.axisModule.setTrack(metadatas);
      // reset zoom
      var _block$ui2 = this.block.ui,
          timeline = _block$ui2.timeline,
          track = _block$ui2.track;


      timeline.zoom = 1;
      timeline.offset = 0;
      track.update();

      if (this.hasScrollBar) {
        var duration = this.block.duration;
        var pixelsPerSecond = this.block.width / duration;

        this._scrollTimeline.pixelsPerSecond = pixelsPerSecond;
        this._scrollBar.timeContext.duration = duration;

        this._scrollTrack.render();
        this._scrollTrack.update();
      }
    }

    /**
     * Events are forwarded by the BasePlayer, originate from the main timeline.
     */

  }, {
    key: 'onEvent',
    value: function onEvent(e, hitLayers) {
      var timeline = this.block.ui.timeline;

      switch (e.type) {
        case 'mousedown':
          // @todo - can't zoom if
          // `playControl.running === true` && `centeredCurrentPosition === true`
          if (hitLayers.indexOf(this.axisModule.layer) !== -1) {
            timeline.state = this._zoomState;
            return false;
          }
          break;
        case 'mouseup':
          if (timeline.state === this._zoomState) timeline.state = null;
          break;
      }

      return true;
    }

    /**
     * Events emitted by the scroll timeline.
     */

  }, {
    key: '_onScrollBarMouseEvent',
    value: function _onScrollBarMouseEvent(e) {
      var timeline = this.block.ui.timeline;

      switch (e.type) {
        case 'mousedown':
          if (this._scrollBar.hasElement(e.target)) timeline.state = this._scrollState;
          break;
        case 'mousemove':
          // forward event from scroll timeline to main timeline
          if (timeline.state === this._scrollState) timeline.state.onMouseMove(e);
          break;
        case 'mouseup':
          if (timeline.state === this._scrollState) timeline.state = null;
          break;
      }
    }
  }, {
    key: '_updateOffset',
    value: function _updateOffset(currentPosition) {
      var mainTimeline = this.block.ui.timeline;
      var mainTrack = this.block.ui.track;
      var mainTimeContext = mainTimeline.timeContext;
      var duration = this.block.duration;

      // zoom cannot be < 1 (cf. ZoomState)
      if (mainTimeContext.zoom > 1) {
        var offset = mainTimeContext.offset;
        var visibleDuration = mainTimeContext.visibleDuration;
        var centerScreenPosition = -offset + visibleDuration / 2;
        var lastHalfScreenPosition = duration - visibleDuration / 2;

        if (currentPosition > centerScreenPosition && currentPosition < lastHalfScreenPosition) {
          var dt = currentPosition - centerScreenPosition;
          var dx = mainTimeContext.timeToPixel(dx);
          offset -= dt;

          mainTimeContext.offset = offset;
          mainTrack.update();

          if (this.hasScrollBar) this._scrollBar.update();
        }
      }
    }

    /** @todo - install these directly on the block ? */
    // zoomIn() {}
    // zoomOut() {}

  }, {
    key: 'block',
    set: function set(block) {
      (0, _set3.default)(Zoom.prototype.__proto__ || (0, _getPrototypeOf2.default)(Zoom.prototype), 'block', block, this);
      this.axisModule.block = this.block;
    },
    get: function get() {
      return (0, _get3.default)(Zoom.prototype.__proto__ || (0, _getPrototypeOf2.default)(Zoom.prototype), 'block', this);
    }
  }, {
    key: 'zIndex',
    set: function set(zIndex) {
      (0, _set3.default)(Zoom.prototype.__proto__ || (0, _getPrototypeOf2.default)(Zoom.prototype), 'zIndex', zIndex, this);
      this.axisModule.zIndex = this.zIndex;
    },
    get: function get() {
      return (0, _get3.default)(Zoom.prototype.__proto__ || (0, _getPrototypeOf2.default)(Zoom.prototype), 'zIndex', this);
    }
  }]);
  return Zoom;
}(_AbstractModule3.default);

exports.default = Zoom;

},{"../core/AbstractModule":1,"./GridAxis":10,"./TimeAxis":14,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"babel-runtime/helpers/set":196,"waves-ui":411}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AbstractAnnotation = require('./AbstractAnnotation');

var _AbstractAnnotation2 = _interopRequireDefault(_AbstractAnnotation);

var _BeatGrid = require('./BeatGrid');

var _BeatGrid2 = _interopRequireDefault(_BeatGrid);

var _Bpf = require('./Bpf');

var _Bpf2 = _interopRequireDefault(_Bpf);

var _Cursor = require('./Cursor');

var _Cursor2 = _interopRequireDefault(_Cursor);

var _GridAxis = require('./GridAxis');

var _GridAxis2 = _interopRequireDefault(_GridAxis);

var _Marker = require('./Marker');

var _Marker2 = _interopRequireDefault(_Marker);

var _Segment = require('./Segment');

var _Segment2 = _interopRequireDefault(_Segment);

var _SimpleWaveform = require('./SimpleWaveform');

var _SimpleWaveform2 = _interopRequireDefault(_SimpleWaveform);

var _TimeAxis = require('./TimeAxis');

var _TimeAxis2 = _interopRequireDefault(_TimeAxis);

var _Waveform = require('./Waveform');

var _Waveform2 = _interopRequireDefault(_Waveform);

var _Zoom = require('./Zoom');

var _Zoom2 = _interopRequireDefault(_Zoom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  AbstractAnnotation: _AbstractAnnotation2.default,
  BeatGrid: _BeatGrid2.default,
  Bpf: _Bpf2.default,
  Cursor: _Cursor2.default,
  GridAxis: _GridAxis2.default,
  Marker: _Marker2.default,
  Segment: _Segment2.default,
  SimpleWaveform: _SimpleWaveform2.default,
  TimeAxis: _TimeAxis2.default,
  Waveform: _Waveform2.default,
  Zoom: _Zoom2.default
};

},{"./AbstractAnnotation":6,"./BeatGrid":7,"./Bpf":8,"./Cursor":9,"./GridAxis":10,"./Marker":11,"./Segment":12,"./SimpleWaveform":13,"./TimeAxis":14,"./Waveform":15,"./Zoom":16}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _common = require('waves-lfo/common');

var lfo = _interopRequireWildcard(_common);

var _AbstractPlayer2 = require('../core/AbstractPlayer');

var _AbstractPlayer3 = _interopRequireDefault(_AbstractPlayer2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DataPlayer = function (_AbstractPlayer) {
  (0, _inherits3.default)(DataPlayer, _AbstractPlayer);

  function DataPlayer(block) {
    (0, _classCallCheck3.default)(this, DataPlayer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (DataPlayer.__proto__ || (0, _getPrototypeOf2.default)(DataPlayer)).call(this, block));

    _this._running = false;

    _this._listeners = new _set2.default();

    _this._emit = _this._emit.bind(_this);
    _this._ended = _this._ended.bind(_this);

    _this.dataReader = new lfo.source.DataReader();
    _this.bridge = new lfo.sink.Bridge({
      processFrame: _this._emit,
      finalizeStream: _this._ended
    });
    _this.dataReader.connect(_this.bridge);
    return _this;
  }

  (0, _createClass3.default)(DataPlayer, [{
    key: 'setTrack',
    value: function setTrack(trackConfig) {
      this.dataReader.params.set('source', trackConfig.data);
      this.dataReader.initStream(); // we know everthing is synchronous in the chain
      this.dataReader.initialized = true;
    }
  }, {
    key: 'start',
    value: function start() {
      if (this._running === false) {
        this._running = true;
        this.dataReader.start();
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      this._running = false;
      this.dataReader.stop();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this._running = false;
      this.dataReader.pause();
    }
  }, {
    key: 'seek',
    value: function seek(position) {
      var realPosition = position + this.dataReader.sourceStartTime;
      this.dataReader.seek(position);
    }

    // player specific

  }, {
    key: 'addListener',
    value: function addListener(listener) {
      this._listeners.add(listener);
    }
  }, {
    key: 'removeListener',
    value: function removeListener(listener) {
      this._listeners.remove(listener);
    }
  }, {
    key: '_emit',
    value: function _emit(data) {
      this._listeners.forEach(function (listener) {
        return listener(data);
      });
    }
  }, {
    key: '_ended',
    value: function _ended() {
      this.block.ended(this.position);
    }
  }, {
    key: 'position',
    get: function get() {
      // index / numFrames * duration
      var frameIndex = this.dataReader._frameIndex;
      var numFrames = this.dataReader._numFrames;
      var duration = this.duration;

      var position = frameIndex / numFrames * duration;
      // if for some reason setTrack has not been called yet
      // (aka some module, like cursor, asking for a position too early)
      if (isNaN(position)) position = 0;

      return position;
    }
  }, {
    key: 'duration',
    get: function get() {
      return this.dataReader.sourceEndTime - this.dataReader.sourceStartTime;
    }
  }, {
    key: 'running',
    get: function get() {
      return this._running;
    }
  }]);
  return DataPlayer;
}(_AbstractPlayer3.default);

exports.default = DataPlayer;

},{"../core/AbstractPlayer":2,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/core-js/set":187,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-lfo/common":349}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _wavesAudio = require('waves-audio');

var audio = _interopRequireWildcard(_wavesAudio);

var _AbstractPlayer2 = require('../core/AbstractPlayer');

var _AbstractPlayer3 = _interopRequireDefault(_AbstractPlayer2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audioContext = audio.audioContext;

var SimplePlayer = function (_AbstractPlayer) {
  (0, _inherits3.default)(SimplePlayer, _AbstractPlayer);

  function SimplePlayer(block) {
    (0, _classCallCheck3.default)(this, SimplePlayer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SimplePlayer.__proto__ || (0, _getPrototypeOf2.default)(SimplePlayer)).call(this, block));

    _this.volume = audioContext.createGain();
    _this.volume.connect(audioContext.destination);
    _this.volume.gain.value = 1;
    _this.volume.gain.setValueAtTime(1, audioContext.currentTime);

    _this.engine = new audio.PlayerEngine();
    _this.engine.connect(_this.volume);
    _this.playControl = new audio.PlayControl(_this.engine);
    return _this;
  }

  (0, _createClass3.default)(SimplePlayer, [{
    key: 'setBuffer',
    value: function setBuffer(buffer) {
      this.playControl.stop();
      this.engine.buffer = buffer;
    }
  }, {
    key: 'start',
    value: function start() {
      this.playControl.start();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.playControl.pause();
    }
  }, {
    key: 'stop',
    value: function stop() {
      this.playControl.stop();
    }
  }, {
    key: 'seek',
    value: function seek(position) {
      this.playControl.seek(position);
    }
  }, {
    key: 'monitorPosition',
    value: function monitorPosition() {}
  }, {
    key: 'position',
    get: function get() {
      return this.playControl.currentPosition;
    }
  }, {
    key: 'duration',
    get: function get() {
      return this.engine.buffer ? this.engine.buffer.duration : 0;
    }
  }, {
    key: 'running',
    get: function get() {
      return this.playControl.running;
    }
  }, {
    key: 'gain',
    set: function set(gain) {
      this.volume.gain.setValueAtTime(gain, audioContext.currentTime + 0.005);
    },
    get: function get() {
      return this.volume.gain.value;
    }
  }]);
  return SimplePlayer;
}(_AbstractPlayer3.default);

exports.default = SimplePlayer;

},{"../core/AbstractPlayer":2,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"waves-audio":343}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _DataPlayer = require('./DataPlayer');

var _DataPlayer2 = _interopRequireDefault(_DataPlayer);

var _SimplePlayer = require('./SimplePlayer');

var _SimplePlayer2 = _interopRequireDefault(_SimplePlayer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  DataPlayer: _DataPlayer2.default,
  SimplePlayer: _SimplePlayer2.default
};

},{"./DataPlayer":18,"./SimplePlayer":19}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copy current config to create snapshots
 * @private
 */
function copy(obj) {
  return JSON.parse((0, _stringify2.default)(obj));
}

/**
 *
 *
 */

var History = function () {
  function History(host, attr) {
    var maxSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    (0, _classCallCheck3.default)(this, History);

    // get a reference to host[attr]
    this.host = host;
    this.attr = attr;

    this._stack = [];
    this._pointer = -1;
    this._maxSize = maxSize;
  }

  (0, _createClass3.default)(History, [{
    key: "head",
    value: function head() {
      return this._stack[this._pointer];
    }
  }, {
    key: "snap",
    value: function snap() {
      // eliminate previous future
      this._stack = this._stack.slice(0, this._pointer + 1);

      var maxIndex = this._maxSize - 1;
      this._pointer = Math.min(maxIndex, this._pointer + 1);

      var snapshot = copy(this.host[this.attr]);

      if (this._stack.length === this._maxSize) this._stack.shift();

      this._stack[this._pointer] = snapshot;
      // console.log('snap', this._stack, this._pointer);
    }
  }, {
    key: "reset",
    value: function reset() {
      this._stack.length = 0;
      this._pointer = -1;
    }
  }, {
    key: "undo",
    value: function undo() {
      var pointer = this._pointer - 1;

      if (pointer >= 0) {
        this._pointer = pointer;
        return true;
      }

      return false;
    }
  }, {
    key: "redo",
    value: function redo() {
      var pointer = this._pointer + 1;

      if (this._stack[pointer]) {
        this._pointer = pointer;
        return true;
      }

      return false;
    }
  }]);
  return History;
}();

exports.default = History;

},{"babel-runtime/core-js/json/stringify":176,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192}],22:[function(require,module,exports){
'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var init = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    var loader, buffers, _loop, i, block, waveform, simpleWaveform, cursor, marker, segment, beatGrid, simpleZoom, scrollBarZoom, modules, currentIndex, currentBuffer, $labelControl, $transportControl, names, _loop2, name;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            loader = new loaders.AudioBufferLoader();
            _context.next = 3;
            return loader.load(_metadata2.default.map(function (d) {
              return d.buffer;
            }));

          case 3:
            buffers = _context.sent;

            _loop = function _loop(i) {
              _metadata2.default[i].beats = _metadataBeats2.default.filter(function (b) {
                return b.time < buffers[i].duration;
              });
            };

            for (i = 0; i < _metadata2.default.length; i++) {
              _loop(i);
            }block = new blocks.core.Block({
              player: blocks.player.SimplePlayer,
              container: '#container',
              sizing: 'manual',
              width: 1000,
              height: 100
            });
            waveform = new blocks.module.Waveform({ channels: 'all' });
            simpleWaveform = new blocks.module.SimpleWaveform();
            cursor = new blocks.module.Cursor();
            marker = new blocks.module.Marker();
            segment = new blocks.module.Segment();
            beatGrid = new blocks.module.BeatGrid();
            simpleZoom = new blocks.module.Zoom();
            scrollBarZoom = new blocks.module.Zoom({ scrollBarContainer: '#scroll-bar' });
            modules = {
              waveform: waveform,
              simpleWaveform: simpleWaveform,
              cursor: cursor,
              marker: marker,
              segment: segment,
              beatGrid: beatGrid,
              simpleZoom: simpleZoom,
              scrollBarZoom: scrollBarZoom
            };


            block.add(waveform, 0);
            block.add(simpleZoom, 1);

            currentIndex = 0;
            currentBuffer = buffers[currentIndex];

            // ------------------------------------------------------------
            // CONTROLS
            // ------------------------------------------------------------

            $labelControl = new controllers.Text({
              container: '#controllers',
              label: 'label',
              default: _metadata2.default[currentIndex].title,
              readonly: true
            });
            $transportControl = new controllers.SelectButtons({
              container: '#controllers',
              label: 'transport',
              options: ['start', 'pause', 'stop'],
              default: 'stop',
              callback: function callback(state) {
                return block[state]();
              }
            });


            new controllers.SelectButtons({
              container: '#controllers',
              label: 'change track',
              options: _metadata2.default.map(function (d) {
                return d.title;
              }),
              default: _metadata2.default[currentIndex].title,
              callback: function callback(title) {
                var index = _metadata2.default.findIndex(function (d) {
                  return d.title === title;
                });
                block.setTrack(buffers[index], _metadata2.default[index]);

                $labelControl.value = _metadata2.default[index].title;
                currentBuffer = buffers[index];
                currentIndex = index;
              }
            });

            names = (0, _keys2.default)(modules);

            _loop2 = function _loop2(name) {
              var module = modules[name];

              new controllers.Toggle({
                container: '#controllers',
                label: name,
                default: false,
                callback: function callback(value) {
                  var method = value ? 'add' : 'remove';
                  var zIndex = names.indexOf(name);
                  block[method](module, zIndex);
                }
              });
            };

            for (name in modules) {
              _loop2(name);
            }

            new controllers.TriggerButtons({
              container: '#controllers',
              label: 'log metadata',
              options: ['now'],
              callback: function callback() {
                var $log = document.querySelector('#log-metadata');
                $log.innerHTML = (0, _stringify2.default)(_metadata2.default[currentIndex], null, 2);
              }
            });

            new controllers.TriggerButtons({
              container: '#controllers',
              label: 'beatGrid shift',
              options: [-0.01, 0.01],
              callback: function callback(value) {
                return beatGrid.shift(value);
              }
            });

            // ------------------------------------------------------------
            // ADD LISTENERS AND INITIALIZE
            // ------------------------------------------------------------

            block.addListener(block.EVENTS.STOP, function () {
              return $transportControl.value = 'stop';
            });
            block.setTrack(buffers[currentIndex], _metadata2.default[currentIndex]);

          case 30:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function init() {
    return _ref.apply(this, arguments);
  };
}();

var _wavesBlocks = require('waves-blocks');

var blocks = _interopRequireWildcard(_wavesBlocks);

var _wavesLoaders = require('waves-loaders');

var loaders = _interopRequireWildcard(_wavesLoaders);

var _basicControllers = require('@ircam/basic-controllers');

var controllers = _interopRequireWildcard(_basicControllers);

var _metadata = require('./metadata.js');

var _metadata2 = _interopRequireDefault(_metadata);

var _metadataBeats = require('./metadata-beats.js');

var _metadataBeats2 = _interopRequireDefault(_metadataBeats);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.addEventListener('load', init);

},{"./metadata-beats.js":23,"./metadata.js":24,"@ircam/basic-controllers":37,"babel-runtime/core-js/json/stringify":47,"babel-runtime/core-js/object/keys":52,"babel-runtime/helpers/asyncToGenerator":57,"babel-runtime/regenerator":64,"waves-blocks":5,"waves-loaders":169}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = [{
  "time": 0,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 0.4223682527,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 0.8403274364,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 1.275701586,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 1.6936607697,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 2.1116199534,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 2.5353841257,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 2.959148298,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 3.3829124704,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 3.8066766427,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 4.2246358264,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 4.6542049874,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 5.0721641711,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 5.4959283434,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 5.9196925157,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 6.3434566881,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 6.7672208604,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 7.1851800441,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 7.6089442164,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 8.0327083888,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 8.4564725611,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 8.8744317448,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 9.2923909284,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 9.7103501121,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 10.1341142844,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 10.5578784568,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 10.9874476178,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 11.4170167788,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 11.8407809511,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 12.2645451234,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 12.6825043071,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 13.1062684795,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 13.5300326518,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 13.9537968241,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 14.3775609965,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 14.7955201801,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 15.2134793638,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 15.6314385475,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 16.0552027198,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 16.4789668922,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 16.8969260758,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 17.3206902482,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 17.7444544205,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 18.1682185928,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 18.6035927425,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 19.0273569148,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 19.4453160985,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 19.8748852595,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 20.2928444432,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 20.7108036268,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 21.1345677992,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 21.5583319715,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 21.9704861665,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 22.3942503389,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 22.8180145112,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 23.2417786835,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 23.6655428559,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 24.0835020395,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 24.5072662119,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 24.9310303842,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 25.3489895679,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 25.7727537402,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 26.1965179126,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 26.6202820849,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 27.0382412686,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 27.4620054409,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 27.8799646246,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 28.3037287969,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 28.7274929692,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 29.1512571416,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 29.5750213139,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 29.9987854863,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 30.4225496586,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 30.8463138309,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 31.2700780033,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 31.6938421756,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 32.1176063479,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 32.5413705203,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 32.9593297039,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 33.3772888876,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 33.8068580486,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 34.2364272096,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 34.6601913819,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 35.0839555543,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 35.4961097493,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 35.9198739216,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 36.343638094,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 36.7674022663,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 37.1911664386,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 37.6091256223,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 38.027084806,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 38.456653967,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 38.8804181393,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 39.298377323,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 39.7221414953,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 40.1459056677,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 40.5638648513,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 40.9934340123,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 41.4171981847,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 41.8351573683,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 42.2589215407,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 42.682685713,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 43.1006448967,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 43.524409069,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 43.9481732414,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 44.366132425,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 44.7898965974,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 45.207855781,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 45.6316199534,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 46.0553841257,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 46.479148298,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 46.9029124704,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 47.3266766427,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 47.7504408151,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 48.1742049874,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 48.5979691597,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 49.0217333321,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 49.4454975044,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 49.8692616767,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 50.2930258491,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 50.7167900214,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 51.1405541937,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 51.5585133774,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 51.9764725611,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 52.4002367334,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 52.8240009058,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 53.2419600894,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 53.6657242618,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 54.0836834454,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 54.5132526064,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 54.9312117901,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 55.3549759624,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 55.7729351461,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 56.1966993185,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 56.6204634908,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 57.0442276631,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 57.4679918355,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 57.8917560078,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 58.3097151915,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 58.7334793638,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 59.1572435361,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 59.5810077085,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 59.9989668922,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 60.4227310645,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 60.8406902482,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 61.2586494318,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 61.6882185928,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 62.1119827652,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 62.5357469375,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 62.9537061212,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 63.3774702935,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 63.8012344658,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 64.2249986382,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 64.6429578219,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 65.0609170055,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 65.4846811779,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 65.9026403615,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 66.3264045339,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 66.7501687062,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 67.1739328785,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 67.5976970509,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 68.0330712005,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 68.4626403615,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 68.8864045339,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 69.3101687062,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 69.7281278899,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 70.1460870736,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 70.5698512459,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 70.9878104296,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 71.4057696132,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 71.8295337856,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 72.2474929692,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 72.6770621302,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 73.0950213139,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 73.5187854863,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 73.9367446699,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 74.3605088423,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 74.7842730146,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 75.2080371869,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 75.6318013593,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 76.0555655316,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 76.4793297039,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 76.9030938763,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 77.3268580486,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 77.7506222209,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 78.1743863933,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 78.6039555543,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 79.021914738,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 79.4456789103,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 79.8694430826,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 80.293207255,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 80.7111664386,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 81.134930611,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 81.5586947833,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 81.976653967,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 82.4004181393,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 82.8241823117,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 83.247946484,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 83.6659056677,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 84.08966984,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 84.5134340123,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 84.931393196,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 85.3493523797,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 85.773116552,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 86.1910757357,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 86.614839908,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 87.0327990917,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 87.456563264,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 87.8803274364,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 88.3040916087,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 88.7336607697,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 89.157424942,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 89.5811891144,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 89.999148298,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 90.4229124704,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 90.8466766427,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 91.2704408151,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 91.6883999987,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 92.1121641711,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 92.5301233547,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 92.9538875271,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 93.3834566881,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 93.8014158717,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 94.2251800441,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 94.6431392278,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 95.0669034001,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 95.4906675724,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 95.9144317448,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 96.3323909284,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 96.7561551008,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 97.1799192731,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 97.6036834454,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 98.0216426291,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 98.4454068014,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 98.8633659851,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 99.2871301575,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 99.7108943298,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 100.1404634908,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 100.5642276631,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 100.9821868468,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 101.4059510191,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 101.8297151915,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 102.2534793638,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 102.6772435361,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 103.1010077085,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 103.5247718808,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 103.9427310645,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 104.3664952368,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 104.7902594092,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 105.2082185928,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 105.6319827652,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 106.0557469375,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 106.4737061212,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 106.9032752822,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 107.3270394545,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 107.7449986382,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 108.1687628105,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 108.5925269829,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 109.0104861665,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 109.4342503389,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 109.8522095225,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 110.2759736949,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 110.6997378672,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 111.1235020395,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 111.5472662119,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 111.9826403615,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 112.4005995452,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 112.8185587289,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 113.2423229012,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 113.6660870736,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 114.0898512459,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 114.5136154182,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 114.9315746019,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 115.3553387742,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 115.7791029466,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 116.2028671189,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 116.6266312912,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 117.0445904749,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 117.4683546473,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 117.8921188196,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 118.3158829919,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 118.7338421756,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 119.1576063479,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 119.5813705203,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 119.9993297039,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 120.4288988649,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 120.8468580486,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 121.2706222209,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 121.6943863933,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 122.1181505656,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 122.541914738,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 122.9598739216,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 123.383638094,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 123.8074022663,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 124.22536145,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 124.6491256223,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 125.0728897946,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 125.4908489783,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 125.9146131507,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 126.338377323,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 126.7563365067,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 127.180100679,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 127.6038648513,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 128.021824035,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 128.4455882073,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 128.8693523797,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 129.2873115634,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 129.7110757357,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 130.1406448967,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 130.564409069,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 130.9823682527,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 131.406132425,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 131.8240916087,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 132.247855781,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 132.6716199534,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 133.1011891144,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 133.5133433094,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 133.9429124704,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 134.3666766427,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 134.7846358264,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 135.2083999987,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 135.6379691597,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 136.0501233547,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 136.4738875271,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 136.8918467107,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 137.3156108831,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 137.7393750554,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 138.1573342391,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 138.5810984114,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 139.0048625838,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 139.4286267561,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 139.8523909284,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 140.2703501121,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 140.6941142844,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 141.1178784568,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 141.5416426291,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 141.9654068014,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 142.3891709738,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 142.8129351461,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 143.2366993185,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 143.6546585021,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 144.0784226745,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 144.4963818581,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 144.9259510191,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 145.3497151915,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 145.7734793638,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 146.2030485248,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 146.6210077085,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 147.0447718808,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 147.4743410418,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 147.8981052141,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 148.3160643978,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 148.7340235815,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 149.1519827652,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 149.5757469375,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 149.9995111098,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 150.4232752822,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 150.8412344658,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 151.2649986382,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 151.6887628105,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 152.1125269829,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 152.5304861665,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 152.9542503389,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 153.3722095225,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 153.7959736949,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 154.2197378672,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 154.6435020395,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 155.0672662119,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 155.4852253956,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 155.9147945566,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 156.3385587289,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 156.7681278899,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 157.1860870736,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 157.6098512459,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 158.0336154182,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 158.4515746019,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 158.8753387742,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 159.2932979579,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 159.7170621302,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 160.1408263026,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 160.5587854863,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 160.9825496586,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 161.4063138309,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 161.8300780033,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 162.2538421756,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 162.6776063479,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 163.1013705203,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 163.5251346926,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 163.9488988649,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 164.3726630373,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 164.7906222209,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 165.2085814046,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 165.632345577,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 166.0503047606,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 166.4682639443,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 166.8920281166,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 167.315792289,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 167.7337514727,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 168.157515645,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 168.5812798173,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 169.0050439897,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 169.4346131507,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 169.858377323,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 170.2821414953,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 170.7059056677,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 171.12966984,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 171.5534340123,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 171.9771981847,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 172.3951573683,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 172.8189215407,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 173.2368807244,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 173.654839908,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 174.0786040804,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 174.5023682527,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 174.9319374137,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 175.355701586,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 175.7794657584,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 176.2032299307,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 176.6211891144,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 177.0449532867,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 177.4629124704,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 177.8866766427,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 178.3046358264,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 178.7283999987,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 179.1463591824,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 179.5701233547,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 179.9938875271,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 180.4176516994,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 180.8356108831,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 181.2593750554,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 181.6831392278,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 182.1069034001,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 182.5248625838,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 182.9544317448,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 183.3723909284,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 183.8019600894,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 184.2257242618,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 184.6436834454,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 185.0674476178,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 185.4912117901,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 185.9091709738,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 186.3329351461,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 186.7508943298,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 187.1804634908,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 187.6042276631,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 188.0337968241,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 188.4575609965,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 188.8813251688,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 189.2992843525,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 189.7288535135,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 190.1526176858,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 190.5763818581,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 190.9943410418,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 191.4239102028,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 191.8418693865,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 192.2656335588,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 192.6777877538,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 193.1073569148,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 193.5253160985,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 193.9490802708,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 194.3728444432,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 194.7966086155,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 195.2145677992,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 195.6383319715,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 196.0562911552,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 196.4858603162,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 196.9038194999,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 197.3333886609,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 197.7513478445,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 198.1751120169,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 198.5988761892,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 199.0168353729,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 199.4347945566,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 199.8643637175,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 200.2823229012,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 200.7002820849,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 201.1240462572,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 201.5478104296,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 201.9715746019,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 202.3953387742,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 202.8191029466,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 203.2428671189,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 203.6666312912,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 204.0903954636,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 204.5083546473,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 204.9321188196,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 205.3558829919,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 205.7796471643,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 206.1976063479,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 206.6213705203,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 207.0451346926,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 207.4630938763,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 207.8868580486,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 208.3164272096,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 208.7343863933,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 209.1581505656,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 209.581914738,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 210.0056789103,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 210.4294430826,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 210.8474022663,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 211.2711664386,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 211.694930611,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 212.1186947833,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 212.536653967,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 212.9604181393,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 213.3841823117,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 213.807946484,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 214.2317106563,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 214.6438648513,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 215.0676290237,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 215.491393196,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 215.9093523797,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 216.333116552,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 216.7568807244,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 217.1806448967,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 217.5986040804,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 218.0223682527,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 218.446132425,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 218.8698965974,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 219.2936607697,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 219.717424942,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 220.1411891144,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 220.5649532867,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 220.9829124704,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 221.4066766427,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 221.8304408151,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 222.2542049874,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 222.6779691597,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 223.1017333321,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 223.5254975044,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 223.9550666654,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 224.3730258491,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 224.7967900214,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 225.2205541937,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 225.6385133774,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 226.0622775497,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 226.4802367334,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 226.9040009058,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 227.3277650781,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 227.7457242618,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 228.1694884341,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 228.5932526064,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 229.0170167788,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 229.4407809511,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 229.8645451234,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 230.2825043071,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 230.7062684795,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 231.1300326518,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 231.5479918355,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 231.9717560078,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 232.3955201801,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 232.8192843525,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 233.2430485248,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 233.6726176858,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 234.0963818581,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 234.5201460305,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 234.9381052141,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 235.3618693865,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 235.7798285702,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 236.1977877538,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 236.6215519262,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 237.0395111098,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 237.4632752822,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 237.8870394545,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 238.3108036268,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 238.7345677992,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 239.1583319715,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 239.5820961439,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 240.0058603162,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 240.4296244885,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 240.8533886609,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 241.2771528332,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 241.6951120169,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 242.1188761892,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 242.5368353729,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 242.9605995452,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 243.3785587289,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 243.8023229012,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 244.2202820849,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 244.6440462572,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 245.0678104296,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 245.4915746019,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 245.9153387742,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 246.3391029466,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 246.7570621302,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 247.1808263026,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 247.6045904749,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 248.0283546473,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 248.4463138309,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 248.8642730146,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 249.2880371869,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 249.7118013593,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 250.1355655316,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 250.5593297039,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 250.9830938763,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 251.4068580486,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 251.8248172323,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 252.2543863933,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 252.672345577,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 253.0961097493,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 253.5256789103,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 253.9494430826,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 254.373207255,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 254.7911664386,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 255.2207355996,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 255.644499772,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 256.0624589556,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 256.4804181393,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 256.9041823117,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 257.3221414953,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 257.7459056677,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 258.16966984,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 258.5876290237,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 259.011393196,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 259.4351573683,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 259.8589215407,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 260.2768807244,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 260.7006448967,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 261.124409069,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 261.5481732414,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 261.966132425,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 262.3898965974,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 262.8136607697,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 263.2316199534,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 263.6553841257,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 264.079148298,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 264.5029124704,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 264.9266766427,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 265.3504408151,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 265.7742049874,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 266.1979691597,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 266.6217333321,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 267.0454975044,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 267.4750666654,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 267.8930258491,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 268.3109850327,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 268.7289442164,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 269.1527083888,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 269.5764725611,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 270.0002367334,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 270.4240009058,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 270.8419600894,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 271.2657242618,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 271.6894884341,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 272.1132526064,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 272.5370167788,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 272.9665859398,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 273.3787401348,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 273.8025043071,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 274.2262684795,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 274.6442276631,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 275.0679918355,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 275.4917560078,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 275.9155201801,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 276.3392843525,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 276.7630485248,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 277.1810077085,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 277.6047718808,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 278.0285360531,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 278.4464952368,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 278.8702594092,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 279.2882185928,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 279.7177877538,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 280.1415519262,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 280.5653160985,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 280.9890802708,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 281.4128444432,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 281.8366086155,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 282.2545677992,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 282.6783319715,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 283.0962911552,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 283.5258603162,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 283.9438194999,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 284.3617786835,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 284.7855428559,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 285.2151120169,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 285.6388761892,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 286.0626403615,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 286.4864045339,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 286.9043637175,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 287.3281278899,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 287.7518920622,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 288.1756562346,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 288.5936154182,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 289.0115746019,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 289.4353387742,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 289.8591029466,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 290.2770621302,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 290.7008263026,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 291.1245904749,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 291.5483546473,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 291.9721188196,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 292.3958829919,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 292.8138421756,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 293.2376063479,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 293.6613705203,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 294.0793297039,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 294.5030938763,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 294.9268580486,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 295.3448172323,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 295.7511664386,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 296.1633206336,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 296.5812798173,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 297.0050439897,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 297.428808162,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 297.858377323,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 298.2937514727,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 298.7233206336,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 299.1412798173,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 299.541824035,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 299.9597832187,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 300.3777424024,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 300.8073115634,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 301.2368807244,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 301.654839908,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 302.049579137,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 302.4907582754,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 302.9145224477,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 303.3092616767,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 303.7446358264,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 304.1800099761,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 304.6153841257,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 305.056563264,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 305.486132425,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 305.933116552,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 306.380100679,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 306.7980598627,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 307.2102140577,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 307.6223682527,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 308.028717459,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 308.4350666654,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 308.8414158717,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 309.2709850327,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 309.6831392278,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 310.1069034001,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 310.5190575951,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 310.9660417221,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 311.3723909284,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 311.7148852595,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 312.1038194999,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 312.5217786835,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 312.9397378672,
  "length": 0,
  "measure": true,
  "pattern": false,
  "beat": 1
}, {
  "time": 313.4099419488,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}, {
  "time": 313.8279011325,
  "length": 0,
  "measure": false,
  "pattern": false,
  "beat": 1
}];

},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = [{
  "buffer": "./assets/audio/cherokee.wav",
  "title": "Who knows?",
  "bpm": 60,
  "signature": "4/4",
  "markers": [{
    "time": 0.10424190476190476,
    "label": "label 0",
    "duration": 0.5
  }, {
    "time": 1.1280142857142856,
    "duration": 1,
    "label": "label 1"
  }, {
    "time": 1.7054447619047617,
    "duration": 0.1,
    "label": "label 2"
  }]
}, {
  "buffer": "./assets/audio/hendrix.wav",
  "title": "Hymnen",
  "bpm": 120,
  "signature": "3/4",
  "markers": [{
    "time": 3.787285442176871,
    "duration": 2.186198911564627,
    "label": "label 0"
  }, {
    "time": 8.197190476190475,
    "duration": 1,
    "label": "label 1"
  }, {
    "time": 12.293813061224492,
    "duration": 3.554651428571429,
    "label": "label 2"
  }, {
    "time": 17.828468979591833,
    "label": "label",
    "duration": 2
  }]
}, {
  "buffer": "./assets/audio/human-voice.wav",
  "title": "Speech",
  "bpm": 140,
  "signature": "4/4",
  "markers": [{
    "time": 8.583150204081635,
    "duration": 3.4361632653061225,
    "label": "label 0"
  }, {
    "time": 26.3684506122449,
    "duration": 1,
    "label": "label 1"
  }, {
    "time": 44.34585795918368,
    "duration": 2.801270204081632,
    "label": "label 2"
  }, {
    "time": 15.914004897959185,
    "label": "label 0.1",
    "duration": 2.1761697959183675
  }, {
    "time": 37.17182693877552,
    "label": "label 1.1",
    "duration": 2
  }]
}];

},{}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @module basic-controller */

var typeCounters = {};

/**
 * Base class to create new controllers.
 *
 * @param {String} type - String describing the type of the controller.
 * @param {Object} defaults - Default parameters of the controller.
 * @param {Object} config - User defined configuration options.
 */

var BaseComponent = function () {
  function BaseComponent(type, defaults) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, BaseComponent);

    this.type = type;
    this.params = Object.assign({}, defaults, config);

    // handle id
    if (!typeCounters[type]) typeCounters[type] = 0;

    if (!this.params.id) {
      this.id = type + "-" + typeCounters[type];
      typeCounters[type] += 1;
    } else {
      this.id = this.params.id;
    }

    this._listeners = new Set();
    this._groupListeners = new Set();

    // register callback if given
    if (this.params.callback) this.addListener(this.params.callback);
  }

  /**
   * Add a listener to the controller.
   *
   * @param {Function} callback - Function to be applied when the controller
   *  state change.
   */


  _createClass(BaseComponent, [{
    key: "addListener",
    value: function addListener(callback) {
      this._listeners.add(callback);
    }

    /**
     * Called when a listener is added from a containing group.
     * @private
     */

  }, {
    key: "_addGroupListener",
    value: function _addGroupListener(id, callId, callback) {
      if (!callId) this.addListener(callback);else {
        this._groupListeners.add({ callId: callId, callback: callback });
      }
    }

    /**
     * Remove a listener from the controller.
     *
     * @param {Function} callback - Function to remove from the listeners.
     * @private
     * @todo - reexpose when `container` can override this method...
     */
    // removeListener(callback) {
    //   this._listeners.remove(callback);
    // }

    /** @private */

  }, {
    key: "executeListeners",
    value: function executeListeners() {
      for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      this._listeners.forEach(function (callback) {
        return callback.apply(undefined, values);
      });

      this._groupListeners.forEach(function (payload) {
        var callback = payload.callback,
            callId = payload.callId;

        callback.apply(undefined, [callId].concat(values));
      });
    }
  }]);

  return BaseComponent;
}();

exports.default = BaseComponent;

},{}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AudioContext = window.AudioContext || window.webkitAudioContext;

/** @module basic-controllers */

var defaults = {
  label: 'Drag and drop audio files',
  labelProcess: 'process...',
  audioContext: null,
  container: null,
  callback: null
};

/**
 * Drag and drop zone for audio files returning `AudioBuffer`s and/or JSON
 * descriptor data.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} [config.label='Drag and drop audio files'] - Label of the
 *  controller.
 * @param {String} [config.labelProcess='process...'] - Label of the controller
 *  while audio files are decoded.
 * @param {AudioContext} [config.audioContext=null] - Optionnal audio context
 *  to use in order to decode audio files.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const dragAndDrop = new controllers.DragAndDrop({
 *   container: '#container',
 *   callback: (results) => console.log(results),
 * });
 */

var DragAndDrop = function (_display) {
  _inherits(DragAndDrop, _display);

  function DragAndDrop(options) {
    _classCallCheck(this, DragAndDrop);

    var _this = _possibleConstructorReturn(this, (DragAndDrop.__proto__ || Object.getPrototypeOf(DragAndDrop)).call(this, 'drag-and-drop', defaults, options));

    _this._value = null;

    if (!_this.params.audioContext) _this.params.audioContext = new AudioContext();

    _get(DragAndDrop.prototype.__proto__ || Object.getPrototypeOf(DragAndDrop.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Get the last results
   * @type {Object<String, AudioBuffer|JSON>}
   * @readonly
   */


  _createClass(DragAndDrop, [{
    key: 'render',
    value: function render() {
      var label = this.params.label;

      var content = '\n      <div class="drop-zone">\n        <p class="label">' + label + '</p>\n      </div>\n    ';

      this.$el = _get(DragAndDrop.prototype.__proto__ || Object.getPrototypeOf(DragAndDrop.prototype), 'render', this).call(this);
      this.$el.innerHTML = content;
      this.$dropZone = this.$el.querySelector('.drop-zone');
      this.$label = this.$el.querySelector('.label');

      this._bindEvents();

      return this.$el;
    }
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$dropZone.addEventListener('dragover', function (e) {
        e.preventDefault();
        e.stopPropagation();

        _this2.$dropZone.classList.add('drag');
        e.dataTransfer.dropEffect = 'copy';
      }, false);

      this.$dropZone.addEventListener('dragleave', function (e) {
        e.preventDefault();
        e.stopPropagation();

        _this2.$dropZone.classList.remove('drag');
      }, false);

      this.$dropZone.addEventListener('drop', function (e) {
        e.preventDefault();
        e.stopPropagation();

        var files = Array.from(e.dataTransfer.files);
        var audioFiles = files.filter(function (file) {
          if (/^audio/.test(file.type)) {
            file.shortType = 'audio';
            return true;
          } else if (/json$/.test(file.type)) {
            file.shortType = 'json';
            return true;
          }

          return false;
        });

        var results = {};
        var counter = 0;

        _this2.$label.textContent = _this2.params.labelProcess;

        var testEnd = function testEnd() {
          counter += 1;

          if (counter === audioFiles.length) {
            _this2._value = results;
            _this2.executeListeners(results);

            _this2.$dropZone.classList.remove('drag');
            _this2.$label.textContent = _this2.params.label;
          }
        };

        files.forEach(function (file, index) {
          var reader = new FileReader();

          reader.onload = function (e) {
            if (file.shortType === 'json') {
              results[file.name] = JSON.parse(e.target.result);
              testEnd();
            } else if (file.shortType === 'audio') {
              _this2.params.audioContext.decodeAudioData(e.target.result).then(function (audioBuffer) {
                results[file.name] = audioBuffer;
                testEnd();
              }).catch(function (err) {
                results[file.name] = null;
                testEnd();
              });
            }
          };

          if (file.shortType === 'json') reader.readAsText(file);else if (file.shortType === 'audio') reader.readAsArrayBuffer(file);
        });
      }, false);
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    }
  }]);

  return DragAndDrop;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = DragAndDrop;

},{"../mixins/display":39,"./BaseComponent":25}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display = require('../mixins/display');

var _display2 = _interopRequireDefault(_display);

var _container2 = require('../mixins/container');

var _container3 = _interopRequireDefault(_container2);

var _elements = require('../utils/elements');

var elements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  legend: '&nbsp;',
  default: 'opened',
  container: null
};

/**
 * Group of controllers.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the group.
 * @param {'opened'|'closed'} [config.default='opened'] - Default state of the
 *  group.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * // create a group
 * const group = new controllers.Group({
 *   label: 'Group',
 *   default: 'opened',
 *   container: '#container'
 * });
 *
 * // insert controllers in the group
 * const groupSlider = new controllers.Slider({
 *   label: 'Group Slider',
 *   min: 20,
 *   max: 1000,
 *   step: 1,
 *   default: 200,
 *   unit: 'Hz',
 *   size: 'large',
 *   container: group,
 *   callback: (value) => console.log(value),
 * });
 *
 * const groupText = new controllers.Text({
 *   label: 'Group Text',
 *   default: 'text input',
 *   readonly: false,
 *   container: group,
 *   callback: (value) => console.log(value),
 * });
 */

var Group = function (_container) {
  _inherits(Group, _container);

  function Group(config) {
    _classCallCheck(this, Group);

    var _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, 'group', defaults, config));

    _this._states = ['opened', 'closed'];

    if (_this._states.indexOf(_this.params.default) === -1) throw new Error('Invalid state "' + value + '"');

    _this._state = _this.params.default;

    _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * State of the group (`'opened'` or `'closed'`).
   * @type {String}
   */


  _createClass(Group, [{
    key: 'render',


    /** @private */
    value: function render() {
      var content = '\n      <div class="group-header">\n        ' + elements.smallArrowRight + '\n        ' + elements.smallArrowBottom + '\n        <span class="label">' + this.params.label + '</span>\n      </div>\n      <div class="group-content"></div>\n    ';

      this.$el = _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'render', this).call(this);
      this.$el.innerHTML = content;
      this.$el.classList.add(this._state);

      this.$header = this.$el.querySelector('.group-header');
      this.$container = this.$el.querySelector('.group-content');

      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$header.addEventListener('click', function () {
        var state = _this2._state === 'closed' ? 'opened' : 'closed';
        _this2.state = state;
      });
    }
  }, {
    key: 'value',
    get: function get() {
      return this.state;
    },
    set: function set(state) {
      this.state = state;
    }

    /**
     * Alias for `value`.
     * @type {String}
     */

  }, {
    key: 'state',
    get: function get() {
      return this._state;
    },
    set: function set(value) {
      if (this._states.indexOf(value) === -1) throw new Error('Invalid state "' + value + '"');

      this.$el.classList.remove(this._state);
      this.$el.classList.add(value);

      this._state = value;
    }
  }]);

  return Group;
}((0, _container3.default)((0, _display2.default)(_BaseComponent2.default)));

exports.default = Group;

},{"../mixins/container":38,"../mixins/display":39,"../utils/elements":40,"./BaseComponent":25}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

var _elements = require('../utils/elements');

var elements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  min: 0,
  max: 1,
  step: 0.01,
  default: 0,
  container: null,
  callback: null
};

/**
 * Number Box controller
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Number} [config.min=0] - Minimum value.
 * @param {Number} [config.max=1] - Maximum value.
 * @param {Number} [config.step=0.01] - Step between consecutive values.
 * @param {Number} [config.default=0] - Default value.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const numberBox = new controllers.NumberBox({
 *   label: 'My Number Box',
 *   min: 0,
 *   max: 10,
 *   step: 0.1,
 *   default: 5,
 *   container: '#container',
 *   callback: (value) => console.log(value),
 * });
 */

var NumberBox = function (_display) {
  _inherits(NumberBox, _display);

  // legend, min = 0, max = 1, step = 0.01, defaultValue = 0, $container = null, callback = null
  function NumberBox(config) {
    _classCallCheck(this, NumberBox);

    var _this = _possibleConstructorReturn(this, (NumberBox.__proto__ || Object.getPrototypeOf(NumberBox)).call(this, 'number-box', defaults, config));

    _this._value = _this.params.default;
    _this._isIntStep = _this.params.step % 1 === 0;

    _get(NumberBox.prototype.__proto__ || Object.getPrototypeOf(NumberBox.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Current value of the controller.
   *
   * @type {Number}
   */


  _createClass(NumberBox, [{
    key: 'render',


    /** @private */
    value: function render() {
      var _params = this.params,
          label = _params.label,
          min = _params.min,
          max = _params.max,
          step = _params.step;

      var content = '\n      <span class="label">' + label + '</span>\n      <div class="inner-wrapper">\n        ' + elements.arrowLeft + '\n        <input class="number" type="number" min="' + min + '" max="' + max + '" step="' + step + '" value="' + this._value + '" />\n        ' + elements.arrowRight + '\n      </div>\n    ';

      this.$el = _get(NumberBox.prototype.__proto__ || Object.getPrototypeOf(NumberBox.prototype), 'render', this).call(this);
      this.$el.classList.add('align-small');
      this.$el.innerHTML = content;

      this.$prev = this.$el.querySelector('.arrow-left');
      this.$next = this.$el.querySelector('.arrow-right');
      this.$number = this.$el.querySelector('input[type="number"]');

      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$prev.addEventListener('click', function (e) {
        var step = _this2.params.step;
        var decimals = step.toString().split('.')[1];
        var exp = decimals ? decimals.length : 0;
        var mult = Math.pow(10, exp);

        var intValue = Math.floor(_this2._value * mult + 0.5);
        var intStep = Math.floor(step * mult + 0.5);
        var value = (intValue - intStep) / mult;

        _this2._propagate(value);
      }, false);

      this.$next.addEventListener('click', function (e) {
        var step = _this2.params.step;
        var decimals = step.toString().split('.')[1];
        var exp = decimals ? decimals.length : 0;
        var mult = Math.pow(10, exp);

        var intValue = Math.floor(_this2._value * mult + 0.5);
        var intStep = Math.floor(step * mult + 0.5);
        var value = (intValue + intStep) / mult;

        _this2._propagate(value);
      }, false);

      this.$number.addEventListener('change', function (e) {
        var value = _this2.$number.value;
        value = _this2._isIntStep ? parseInt(value, 10) : parseFloat(value);
        value = Math.min(_this2.params.max, Math.max(_this2.params.min, value));

        _this2._propagate(value);
      }, false);
    }

    /** @private */

  }, {
    key: '_propagate',
    value: function _propagate(value) {
      if (value === this._value) {
        return;
      }

      this._value = value;
      this.$number.value = value;

      this.executeListeners(this._value);
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(value) {
      // use $number element min, max and step system
      this.$number.value = value;
      value = this.$number.value;
      value = this._isIntStep ? parseInt(value, 10) : parseFloat(value);
      this._value = value;
    }
  }]);

  return NumberBox;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = NumberBox;

},{"../mixins/display":39,"../utils/elements":40,"./BaseComponent":25}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

var _elements = require('../utils/elements');

var elements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  options: null,
  default: null,
  container: null,
  callback: null
};

/**
 * List of buttons with state.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Array} [config.options=null] - Values of the drop down list.
 * @param {Number} [config.default=null] - Default value.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const selectButtons = new controllers.SelectButtons({
 *   label: 'SelectButtons',
 *   options: ['standby', 'run', 'end'],
 *   default: 'run',
 *   container: '#container',
 *   callback: (value, index) => console.log(value, index),
 * });
 */

var SelectButtons = function (_display) {
  _inherits(SelectButtons, _display);

  function SelectButtons(config) {
    _classCallCheck(this, SelectButtons);

    var _this = _possibleConstructorReturn(this, (SelectButtons.__proto__ || Object.getPrototypeOf(SelectButtons)).call(this, 'select-buttons', defaults, config));

    if (!Array.isArray(_this.params.options)) throw new Error('TriggerButton: Invalid option "options"');

    _this._value = _this.params.default;

    var options = _this.params.options;
    var index = options.indexOf(_this._value);
    _this._index = index === -1 ? 0 : index;
    _this._maxIndex = options.length - 1;

    _get(SelectButtons.prototype.__proto__ || Object.getPrototypeOf(SelectButtons.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Current value.
   * @type {String}
   */


  _createClass(SelectButtons, [{
    key: 'render',


    /** @private */
    value: function render() {
      var _params = this.params,
          options = _params.options,
          label = _params.label;

      var content = '\n      <span class="label">' + label + '</span>\n      <div class="inner-wrapper">\n        ' + elements.arrowLeft + '\n        ' + options.map(function (option, index) {
        return '\n            <button class="btn" data-index="' + index + '" data-value="' + option + '">\n              ' + option + '\n            </button>';
      }).join('') + '\n        ' + elements.arrowRight + '\n      </div>\n    ';

      this.$el = _get(SelectButtons.prototype.__proto__ || Object.getPrototypeOf(SelectButtons.prototype), 'render', this).call(this, this.type);
      this.$el.innerHTML = content;

      this.$prev = this.$el.querySelector('.arrow-left');
      this.$next = this.$el.querySelector('.arrow-right');
      this.$btns = Array.from(this.$el.querySelectorAll('.btn'));

      this._highlightBtn(this._index);
      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$prev.addEventListener('click', function () {
        var index = _this2._index - 1;
        _this2._propagate(index);
      });

      this.$next.addEventListener('click', function () {
        var index = _this2._index + 1;
        _this2._propagate(index);
      });

      this.$btns.forEach(function ($btn, index) {
        $btn.addEventListener('click', function (e) {
          e.preventDefault();
          _this2._propagate(index);
        });
      });
    }

    /** @private */

  }, {
    key: '_propagate',
    value: function _propagate(index) {
      if (index < 0 || index > this._maxIndex) return;

      this._index = index;
      this._value = this.params.options[index];
      this._highlightBtn(this._index);

      this.executeListeners(this._value, this._index);
    }

    /** @private */

  }, {
    key: '_highlightBtn',
    value: function _highlightBtn(activeIndex) {
      this.$btns.forEach(function ($btn, index) {
        $btn.classList.remove('active');

        if (activeIndex === index) {
          $btn.classList.add('active');
        }
      });
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(value) {
      var index = this.params.options.indexOf(value);

      if (index !== -1) this.index = index;
    }

    /**
     * Current option index.
     * @type {Number}
     */

  }, {
    key: 'index',
    get: function get() {
      this._index;
    },
    set: function set(index) {
      if (index < 0 || index > this._maxIndex) return;

      this._value = this.params.options[index];
      this._index = index;
      this._highlightBtn(this._index);
    }
  }]);

  return SelectButtons;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = SelectButtons;

},{"../mixins/display":39,"../utils/elements":40,"./BaseComponent":25}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

var _elements = require('../utils/elements');

var elements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  options: null,
  default: null,
  container: null,
  callback: null

  /**
   * Drop-down list controller.
   *
   * @param {Object} config - Override default parameters.
   * @param {String} config.label - Label of the controller.
   * @param {Array} [config.options=null] - Values of the drop down list.
   * @param {Number} [config.default=null] - Default value.
   * @param {String|Element|basic-controller~Group} [config.container=null] -
   *  Container of the controller.
   * @param {Function} [config.callback=null] - Callback to be executed when the
   *  value changes.
   *
   * @example
   * import * as controllers from 'basic-controllers';
   *
   * const selectList = new controllers.SelectList({
   *   label: 'SelectList',
   *   options: ['standby', 'run', 'end'],
   *   default: 'run',
   *   container: '#container',
   *   callback: (value, index) => console.log(value, index),
   * });
   */
};
var SelectList = function (_display) {
  _inherits(SelectList, _display);

  function SelectList(config) {
    _classCallCheck(this, SelectList);

    var _this = _possibleConstructorReturn(this, (SelectList.__proto__ || Object.getPrototypeOf(SelectList)).call(this, 'select-list', defaults, config));

    if (!Array.isArray(_this.params.options)) throw new Error('TriggerButton: Invalid option "options"');

    _this._value = _this.params.default;

    var options = _this.params.options;
    var index = options.indexOf(_this._value);
    _this._index = index === -1 ? 0 : index;
    _this._maxIndex = options.length - 1;

    _get(SelectList.prototype.__proto__ || Object.getPrototypeOf(SelectList.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Current value.
   * @type {String}
   */


  _createClass(SelectList, [{
    key: 'render',


    /** @private */
    value: function render() {
      var _params = this.params,
          label = _params.label,
          options = _params.options;

      var content = '\n      <span class="label">' + label + '</span>\n      <div class="inner-wrapper">\n        ' + elements.arrowLeft + '\n        <select>\n        ' + options.map(function (option, index) {
        return '<option value="' + option + '">' + option + '</option>';
      }).join('') + '\n        <select>\n        ' + elements.arrowRight + '\n      </div>\n    ';

      this.$el = _get(SelectList.prototype.__proto__ || Object.getPrototypeOf(SelectList.prototype), 'render', this).call(this, this.type);
      this.$el.classList.add('align-small');
      this.$el.innerHTML = content;

      this.$prev = this.$el.querySelector('.arrow-left');
      this.$next = this.$el.querySelector('.arrow-right');
      this.$select = this.$el.querySelector('select');
      // set to default value
      this.$select.value = options[this._index];
      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$prev.addEventListener('click', function () {
        var index = _this2._index - 1;
        _this2._propagate(index);
      }, false);

      this.$next.addEventListener('click', function () {
        var index = _this2._index + 1;
        _this2._propagate(index);
      }, false);

      this.$select.addEventListener('change', function () {
        var value = _this2.$select.value;
        var index = _this2.params.options.indexOf(value);
        _this2._propagate(index);
      });
    }

    /** @private */

  }, {
    key: '_propagate',
    value: function _propagate(index) {
      if (index < 0 || index > this._maxIndex) return;

      var value = this.params.options[index];
      this._index = index;
      this._value = value;
      this.$select.value = value;

      this.executeListeners(this._value, this._index);
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(value) {
      this.$select.value = value;
      this._value = value;
      this._index = this.params.options.indexOf(value);
    }

    /**
     * Current option index.
     * @type {Number}
     */

  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      if (index < 0 || index > this._maxIndex) return;
      this.value = this.params.options[index];
    }
  }]);

  return SelectList;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = SelectList;

},{"../mixins/display":39,"../utils/elements":40,"./BaseComponent":25}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

var _guiComponents = require('@ircam/gui-components');

var guiComponents = _interopRequireWildcard(_guiComponents);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  min: 0,
  max: 1,
  step: 0.01,
  default: 0,
  unit: '',
  size: 'medium',
  container: null,
  callback: null

  /**
   * Slider controller.
   *
   * @param {Object} config - Override default parameters.
   * @param {String} config.label - Label of the controller.
   * @param {Number} [config.min=0] - Minimum value.
   * @param {Number} [config.max=1] - Maximum value.
   * @param {Number} [config.step=0.01] - Step between consecutive values.
   * @param {Number} [config.default=0] - Default value.
   * @param {String} [config.unit=''] - Unit of the value.
   * @param {'small'|'medium'|'large'} [config.size='medium'] - Size of the
   *  slider.
   * @param {String|Element|basic-controller~Group} [config.container=null] -
   *  Container of the controller.
   * @param {Function} [config.callback=null] - Callback to be executed when the
   *  value changes.
   *
   * @example
   * import * as controllers from 'basic-controllers';
   *
   * const slider = new controllers.Slider({
   *   label: 'My Slider',
   *   min: 20,
   *   max: 1000,
   *   step: 1,
   *   default: 537,
   *   unit: 'Hz',
   *   size: 'large',
   *   container: '#container',
   *   callback: (value) => console.log(value),
   * });
   */
};
var Slider = function (_display) {
  _inherits(Slider, _display);

  function Slider(config) {
    _classCallCheck(this, Slider);

    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, 'slider', defaults, config));

    _this._value = _this.params.default;
    _this._onSliderChange = _this._onSliderChange.bind(_this);

    _get(Slider.prototype.__proto__ || Object.getPrototypeOf(Slider.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Current value.
   * @type {Number}
   */


  _createClass(Slider, [{
    key: 'render',


    /** @private */
    value: function render() {
      var _params = this.params,
          label = _params.label,
          min = _params.min,
          max = _params.max,
          step = _params.step,
          unit = _params.unit,
          size = _params.size;

      var content = '\n      <span class="label">' + label + '</span>\n      <div class="inner-wrapper">\n        <div class="range"></div>\n        <div class="number-wrapper">\n          <input type="number" class="number" min="' + min + '" max="' + max + '" step="' + step + '" value="' + this._value + '" />\n          <span class="unit">' + unit + '</span>\n        </div>\n      </div>';

      this.$el = _get(Slider.prototype.__proto__ || Object.getPrototypeOf(Slider.prototype), 'render', this).call(this, this.type);
      this.$el.innerHTML = content;
      this.$el.classList.add('slider-' + size);

      this.$range = this.$el.querySelector('.range');
      this.$number = this.$el.querySelector('input[type="number"]');

      this.slider = new guiComponents.Slider({
        container: this.$range,
        callback: this._onSliderChange,
        min: min,
        max: max,
        step: step,
        default: this._value,
        foregroundColor: '#ababab'
      });

      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: 'resize',
    value: function resize() {
      _get(Slider.prototype.__proto__ || Object.getPrototypeOf(Slider.prototype), 'resize', this).call(this);

      var _$range$getBoundingCl = this.$range.getBoundingClientRect(),
          width = _$range$getBoundingCl.width,
          height = _$range$getBoundingCl.height;

      this.slider.resize(width, height);
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$number.addEventListener('change', function () {
        var value = parseFloat(_this2.$number.value);
        // the slider propagates the value
        _this2.slider.value = value;
        _this2._value = value;

        _this2.executeListeners(_this2._value);
      }, false);
    }

    /** @private */

  }, {
    key: '_onSliderChange',
    value: function _onSliderChange(value) {
      this.$number.value = value;
      this._value = value;

      this.executeListeners(this._value);
    }
  }, {
    key: 'value',
    set: function set(value) {
      this._value = value;

      if (this.$number && this.$range) {
        this.$number.value = this.value;
        this.slider.value = this.value;
      }
    },
    get: function get() {
      return this._value;
    }
  }]);

  return Slider;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = Slider;

},{"../mixins/display":39,"./BaseComponent":25,"@ircam/gui-components":46}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  default: '',
  readonly: false,
  container: null,
  callback: null

  /**
   * Text controller.
   *
   * @param {Object} config - Override default parameters.
   * @param {String} config.label - Label of the controller.
   * @param {Array} [config.default=''] - Default value of the controller.
   * @param {Array} [config.readonly=false] - Define if the controller is readonly.
   * @param {String|Element|basic-controller~Group} [config.container=null] -
   *  Container of the controller.
   * @param {Function} [config.callback=null] - Callback to be executed when the
   *  value changes.
   *
   * @example
   * import * as controllers from 'basic-contollers';
   *
   * const text = new controllers.Text({
   *   label: 'My Text',
   *   default: 'default value',
   *   readonly: false,
   *   container: '#container',
   *   callback: (value) => console.log(value),
   * });
   */
};
var Text = function (_display) {
  _inherits(Text, _display);

  function Text(config) {
    _classCallCheck(this, Text);

    var _this = _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, 'text', defaults, config));

    _this._value = _this.params.default;
    _this.initialize();
    return _this;
  }

  /**
   * Current value.
   * @type {String}
   */


  _createClass(Text, [{
    key: 'render',


    /** @private */
    value: function render() {
      var readonly = this.params.readonly ? 'readonly' : '';
      var content = '\n      <span class="label">' + this.params.label + '</span>\n      <div class="inner-wrapper">\n        <input class="text" type="text" value="' + this._value + '" ' + readonly + ' />\n      </div>\n    ';

      this.$el = _get(Text.prototype.__proto__ || Object.getPrototypeOf(Text.prototype), 'render', this).call(this);
      this.$el.innerHTML = content;
      this.$input = this.$el.querySelector('.text');

      this.bindEvents();
      return this.$el;
    }

    /** @private */

  }, {
    key: 'bindEvents',
    value: function bindEvents() {
      var _this2 = this;

      this.$input.addEventListener('keyup', function () {
        _this2._value = _this2.$input.value;
        _this2.executeListeners(_this2._value);
      }, false);
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(value) {
      this.$input.value = value;
      this._value = value;
    }
  }]);

  return Text;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = Text;

},{"../mixins/display":39,"./BaseComponent":25}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  container: null
};

/**
 * Title.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 *
 * @example
 * import * as controller from 'basic-controllers';
 *
 * const title = new controllers.Title({
 *   label: 'My Title',
 *   container: '#container'
 * });
 */

var Title = function (_display) {
  _inherits(Title, _display);

  function Title(config) {
    _classCallCheck(this, Title);

    var _this = _possibleConstructorReturn(this, (Title.__proto__ || Object.getPrototypeOf(Title)).call(this, 'title', defaults, config));

    _get(Title.prototype.__proto__ || Object.getPrototypeOf(Title.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /** @private */


  _createClass(Title, [{
    key: 'render',
    value: function render() {
      var content = '<span class="label">' + this.params.label + '</span>';

      this.$el = _get(Title.prototype.__proto__ || Object.getPrototypeOf(Title.prototype), 'render', this).call(this);
      this.$el.innerHTML = content;

      return this.$el;
    }
  }]);

  return Title;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = Title;

},{"../mixins/display":39,"./BaseComponent":25}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

var _elements = require('../utils/elements');

var elements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&bnsp;',
  active: false,
  container: null,
  callback: null
};

/**
 * On/Off controller.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Array} [config.active=false] - Default state of the toggle.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const toggle = new controllers.Toggle({
 *   label: 'My Toggle',
 *   active: false,
 *   container: '#container',
 *   callback: (active) => console.log(active),
 * });
 */

var Toggle = function (_display) {
  _inherits(Toggle, _display);

  function Toggle(config) {
    _classCallCheck(this, Toggle);

    var _this = _possibleConstructorReturn(this, (Toggle.__proto__ || Object.getPrototypeOf(Toggle)).call(this, 'toggle', defaults, config));

    _this._active = _this.params.active;

    _get(Toggle.prototype.__proto__ || Object.getPrototypeOf(Toggle.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Value of the toggle
   * @type {Boolean}
   */


  _createClass(Toggle, [{
    key: '_updateBtn',


    /** @private */
    value: function _updateBtn() {
      var method = this.active ? 'add' : 'remove';
      this.$toggle.classList[method]('active');
    }

    /** @private */

  }, {
    key: 'render',
    value: function render() {
      var content = '\n      <span class="label">' + this.params.label + '</span>\n      <div class="inner-wrapper">\n        ' + elements.toggle + '\n      </div>';

      this.$el = _get(Toggle.prototype.__proto__ || Object.getPrototypeOf(Toggle.prototype), 'render', this).call(this);
      this.$el.classList.add('align-small');
      this.$el.innerHTML = content;

      this.$toggle = this.$el.querySelector('.toggle-element');
      // initialize state
      this.active = this._active;
      this.bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: 'bindEvents',
    value: function bindEvents() {
      var _this2 = this;

      this.$toggle.addEventListener('click', function (e) {
        e.preventDefault();

        _this2.active = !_this2.active;
        _this2.executeListeners(_this2._active);
      });
    }
  }, {
    key: 'value',
    set: function set(bool) {
      this.active = bool;
    },
    get: function get() {
      return this._active;
    }

    /**
     * Alias for `value`.
     * @type {Boolean}
     */

  }, {
    key: 'active',
    set: function set(bool) {
      this._active = bool;
      this._updateBtn();
    },
    get: function get() {
      return this._active;
    }
  }]);

  return Toggle;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = Toggle;

},{"../mixins/display":39,"../utils/elements":40,"./BaseComponent":25}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BaseComponent = require('./BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _display2 = require('../mixins/display');

var _display3 = _interopRequireDefault(_display2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

var defaults = {
  label: '&nbsp;',
  options: null,
  container: null,
  callback: null
};

/**
 * List of buttons without state.
 *
 * @param {Object} config - Override default parameters.
 * @param {String} config.label - Label of the controller.
 * @param {Array} [config.options=null] - Options for each button.
 * @param {String|Element|basic-controller~Group} [config.container=null] -
 *  Container of the controller.
 * @param {Function} [config.callback=null] - Callback to be executed when the
 *  value changes.
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const triggerButtons = new controllers.TriggerButtons({
 *   label: 'My Trigger Buttons',
 *   options: ['value 1', 'value 2', 'value 3'],
 *   container: '#container',
 *   callback: (value, index) => console.log(value, index),
 * });
 */

var TriggerButtons = function (_display) {
  _inherits(TriggerButtons, _display);

  function TriggerButtons(config) {
    _classCallCheck(this, TriggerButtons);

    var _this = _possibleConstructorReturn(this, (TriggerButtons.__proto__ || Object.getPrototypeOf(TriggerButtons)).call(this, 'trigger-buttons', defaults, config));

    if (!Array.isArray(_this.params.options)) throw new Error('TriggerButton: Invalid option "options"');

    _this._index = null;
    _this._value = null;

    _get(TriggerButtons.prototype.__proto__ || Object.getPrototypeOf(TriggerButtons.prototype), 'initialize', _this).call(_this);
    return _this;
  }

  /**
   * Last triggered button value.
   *
   * @readonly
   * @type {String}
   */


  _createClass(TriggerButtons, [{
    key: 'render',


    /** @private */
    value: function render() {
      var _params = this.params,
          label = _params.label,
          options = _params.options;


      var content = '\n      <span class="label">' + label + '</span>\n      <div class="inner-wrapper">\n        ' + options.map(function (option, index) {
        return '<a href="#" class="btn">' + option + '</a>';
      }).join('') + '\n      </div>';

      this.$el = _get(TriggerButtons.prototype.__proto__ || Object.getPrototypeOf(TriggerButtons.prototype), 'render', this).call(this);
      this.$el.innerHTML = content;

      this.$buttons = Array.from(this.$el.querySelectorAll('.btn'));
      this._bindEvents();

      return this.$el;
    }

    /** @private */

  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this2 = this;

      this.$buttons.forEach(function ($btn, index) {
        var value = _this2.params.options[index];

        $btn.addEventListener('click', function (e) {
          e.preventDefault();

          _this2._value = value;
          _this2._index = index;

          _this2.executeListeners(value, index);
        });
      });
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    }

    /**
     * Last triggered button index.
     *
     * @readonly
     * @type {String}
     */

  }, {
    key: 'index',
    get: function get() {
      return this._index;
    }
  }]);

  return TriggerButtons;
}((0, _display3.default)(_BaseComponent2.default));

exports.default = TriggerButtons;

},{"../mixins/display":39,"./BaseComponent":25}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _BaseComponent = require('./components/BaseComponent');

var _BaseComponent2 = _interopRequireDefault(_BaseComponent);

var _Group = require('./components/Group');

var _Group2 = _interopRequireDefault(_Group);

var _NumberBox = require('./components/NumberBox');

var _NumberBox2 = _interopRequireDefault(_NumberBox);

var _SelectButtons = require('./components/SelectButtons');

var _SelectButtons2 = _interopRequireDefault(_SelectButtons);

var _SelectList = require('./components/SelectList');

var _SelectList2 = _interopRequireDefault(_SelectList);

var _Slider = require('./components/Slider');

var _Slider2 = _interopRequireDefault(_Slider);

var _Text = require('./components/Text');

var _Text2 = _interopRequireDefault(_Text);

var _Title = require('./components/Title');

var _Title2 = _interopRequireDefault(_Title);

var _Toggle = require('./components/Toggle');

var _Toggle2 = _interopRequireDefault(_Toggle);

var _TriggerButtons = require('./components/TriggerButtons');

var _TriggerButtons2 = _interopRequireDefault(_TriggerButtons);

var _container2 = require('./mixins/container');

var _container3 = _interopRequireDefault(_container2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// map type names to constructors
var typeCtorMap = {
  'group': _Group2.default,
  'number-box': _NumberBox2.default,
  'select-buttons': _SelectButtons2.default,
  'select-list': _SelectList2.default,
  'slider': _Slider2.default,
  'text': _Text2.default,
  'title': _Title2.default,
  'toggle': _Toggle2.default,
  'trigger-buttons': _TriggerButtons2.default
};

var defaults = {
  container: 'body'
};

var Control = function (_container) {
  _inherits(Control, _container);

  function Control(config) {
    _classCallCheck(this, Control);

    var _this = _possibleConstructorReturn(this, (Control.__proto__ || Object.getPrototypeOf(Control)).call(this, 'control', defaults, config));

    var $container = _this.params.container;

    if (typeof $container === 'string') $container = document.querySelector($container);

    _this.$container = $container;
    return _this;
  }

  return Control;
}((0, _container3.default)(_BaseComponent2.default));

/** @module basic-controllers */

/**
 * Create a whole control surface from a json definition.
 *
 * @param {String|Element} container - Container of the controls.
 * @param {Object} - Definitions for the controls.
 * @return {Object} - A `Control` instance that behaves like a group without graphic.
 * @static
 *
 * @example
 * import * as controllers from 'basic-controllers';
 *
 * const definitions = [
 *   {
 *     id: 'my-slider',
 *     type: 'slider',
 *     label: 'My Slider',
 *     size: 'large',
 *     min: 0,
 *     max: 1000,
 *     step: 1,
 *     default: 253,
 *   }, {
 *     id: 'my-group',
 *     type: 'group',
 *     label: 'Group',
 *     default: 'opened',
 *     elements: [
 *       {
 *         id: 'my-number',
 *         type: 'number-box',
 *         default: 0.4,
 *         min: -1,
 *         max: 1,
 *         step: 0.01,
 *       }
 *     ],
 *   }
 * ];
 *
 * const controls = controllers.create('#container', definitions);
 *
 * // add a listener on all the component inside `my-group`
 * controls.addListener('my-group', (id, value) => console.log(id, value));
 *
 * // retrieve the instance of `my-number`
 * const myNumber = controls.getComponent('my-group/my-number');
 */


function create(container, definitions) {

  function _parse(container, definitions) {
    definitions.forEach(function (def, index) {
      var type = def.type;
      var ctor = typeCtorMap[type];
      var config = Object.assign({}, def);

      //
      config.container = container;
      delete config.type;

      var component = new ctor(config);

      if (type === 'group') _parse(component, config.elements);
    });
  };

  var _root = new Control({ container: container });
  _parse(_root, definitions);

  return _root;
}

exports.default = create;

},{"./components/BaseComponent":25,"./components/Group":27,"./components/NumberBox":28,"./components/SelectButtons":29,"./components/SelectList":30,"./components/Slider":31,"./components/Text":32,"./components/Title":33,"./components/Toggle":34,"./components/TriggerButtons":35,"./mixins/container":38}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setTheme = exports.create = exports.TriggerButtons = exports.Toggle = exports.Title = exports.Text = exports.Slider = exports.SelectList = exports.SelectButtons = exports.NumberBox = exports.DragAndDrop = exports.Group = exports.BaseComponent = exports.styles = undefined;

var _Group = require('./components/Group');

Object.defineProperty(exports, 'Group', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Group).default;
  }
});

var _DragAndDrop = require('./components/DragAndDrop');

Object.defineProperty(exports, 'DragAndDrop', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DragAndDrop).default;
  }
});

var _NumberBox = require('./components/NumberBox');

Object.defineProperty(exports, 'NumberBox', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_NumberBox).default;
  }
});

var _SelectButtons = require('./components/SelectButtons');

Object.defineProperty(exports, 'SelectButtons', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SelectButtons).default;
  }
});

var _SelectList = require('./components/SelectList');

Object.defineProperty(exports, 'SelectList', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SelectList).default;
  }
});

var _Slider = require('./components/Slider');

Object.defineProperty(exports, 'Slider', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Slider).default;
  }
});

var _Text = require('./components/Text');

Object.defineProperty(exports, 'Text', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Text).default;
  }
});

var _Title = require('./components/Title');

Object.defineProperty(exports, 'Title', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Title).default;
  }
});

var _Toggle = require('./components/Toggle');

Object.defineProperty(exports, 'Toggle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Toggle).default;
  }
});

var _TriggerButtons = require('./components/TriggerButtons');

Object.defineProperty(exports, 'TriggerButtons', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_TriggerButtons).default;
  }
});

var _factory = require('./factory');

Object.defineProperty(exports, 'create', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_factory).default;
  }
});

var _display = require('./mixins/display');

Object.defineProperty(exports, 'setTheme', {
  enumerable: true,
  get: function get() {
    return _display.setTheme;
  }
});
exports.disableStyles = disableStyles;

var _styles2 = require('./utils/styles');

var _styles = _interopRequireWildcard(_styles2);

var _BaseComponent2 = require('./components/BaseComponent');

var _BaseComponent3 = _interopRequireDefault(_BaseComponent2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var styles = exports.styles = _styles;

/** @module basic-controllers */

// expose for plugins
var BaseComponent = exports.BaseComponent = _BaseComponent3.default;

// components


/**
 * Disable default styling (expect a broken ui)
 */
function disableStyles() {
  _styles.disable();
};

},{"./components/BaseComponent":25,"./components/DragAndDrop":26,"./components/Group":27,"./components/NumberBox":28,"./components/SelectButtons":29,"./components/SelectList":30,"./components/Slider":31,"./components/Text":32,"./components/Title":33,"./components/Toggle":34,"./components/TriggerButtons":35,"./factory":36,"./mixins/display":39,"./utils/styles":42}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var separator = '/';

function getHead(path) {
  return path.split(separator)[0];
}

function getTail(path) {
  var parts = path.split(separator);
  parts.shift();
  return parts.join(separator);
}

var container = function container(superclass) {
  return function (_superclass) {
    _inherits(_class, _superclass);

    function _class() {
      var _ref;

      _classCallCheck(this, _class);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _this = _possibleConstructorReturn(this, (_ref = _class.__proto__ || Object.getPrototypeOf(_class)).call.apply(_ref, [this].concat(args)));

      _this.elements = new Set();

      // sure of that ?
      delete _this._listeners;
      delete _this._groupListeners;
      return _this;
    }

    /**
     * Return one of the group children according to its `id`, `null` otherwise.
     * @private
     */


    _createClass(_class, [{
      key: '_getHead',
      value: function _getHead(id) {}
    }, {
      key: '_getTail',
      value: function _getTail(id) {}

      /**
       * Return a child of the group recursively according to the given `id`,
       * `null` otherwise.
       * @private
       */

    }, {
      key: 'getComponent',
      value: function getComponent(id) {
        var head = getHead(id);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var component = _step.value;

            if (head === component.id) {
              if (head === id) return component;else if (component.type = 'group') return component.getComponent(getTail(id));else throw new Error('Undefined component ' + id);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        throw new Error('Undefined component ' + id);
      }

      /**
       * Add Listener on each components of the group.
       *
       * @param {String} id - Path to component id.
       * @param {Function} callback - Function to execute.
       */

    }, {
      key: 'addListener',
      value: function addListener(id, callback) {
        if (arguments.length === 1) {
          callback = id;
          this._addGroupListener('', '', callback);
        } else {
          this._addGroupListener(id, '', callback);
        }
      }

      /** @private */

    }, {
      key: '_addGroupListener',
      value: function _addGroupListener(id, callId, callback) {
        if (id) {
          var componentId = getHead(id);
          var component = this.getComponent(componentId);

          if (component) {
            id = getTail(id);
            component._addGroupListener(id, callId, callback);
          } else {
            throw new Error('Undefined component ' + this.rootId + '/' + componentId);
          }
        } else {
          this.elements.forEach(function (component) {
            var _callId = callId; // create a new branche
            _callId += callId === '' ? component.id : separator + component.id;
            component._addGroupListener(id, _callId, callback);
          });
        }
      }
    }]);

    return _class;
  }(superclass);
};

exports.default = container;

},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.setTheme = setTheme;

var _styles = require('../utils/styles');

var styles = _interopRequireWildcard(_styles);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @module basic-controllers */

// default theme
var theme = 'light';
// set of the instanciated controllers
var controllers = new Set();

/**
 * Change the theme of the controllers, currently 3 themes are available:
 *  - `'light'` (default)
 *  - `'grey'`
 *  - `'dark'`
 *
 * @param {String} theme - Name of the theme.
 */
function setTheme(value) {
  controllers.forEach(function (controller) {
    return controller.$el.classList.remove(theme);
  });
  theme = value;
  controllers.forEach(function (controller) {
    return controller.$el.classList.add(theme);
  });
}

/**
 * display mixin - components with DOM
 * @private
 */
var display = function display(superclass) {
  return function (_superclass) {
    _inherits(_class, _superclass);

    function _class() {
      var _ref;

      _classCallCheck(this, _class);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // insert styles when the first controller is created
      var _this = _possibleConstructorReturn(this, (_ref = _class.__proto__ || Object.getPrototypeOf(_class)).call.apply(_ref, [this].concat(args)));

      if (controllers.size === 0) styles.insertStyleSheet();

      _this.resize = _this.resize.bind(_this);

      controllers.add(_this);
      return _this;
    }

    _createClass(_class, [{
      key: 'initialize',
      value: function initialize() {
        var _this2 = this;

        var $container = this.params.container;

        if ($container) {
          // css selector
          if (typeof $container === 'string') {
            $container = document.querySelector($container);
            // group
          } else if ($container.$container) {
            // this.group = $container;
            $container.elements.add(this);
            $container = $container.$container;
          }

          $container.appendChild(this.render());
          setTimeout(function () {
            return _this2.resize();
          }, 0);
        }
      }

      /** @private */

    }, {
      key: 'render',
      value: function render() {
        this.$el = document.createElement('div');
        this.$el.classList.add(styles.ns, theme, this.type);

        window.removeEventListener('resize', this.resize);
        window.addEventListener('resize', this.resize);

        return this.$el;
      }

      /** @private */

    }, {
      key: 'resize',
      value: function resize() {
        if (this.$el) {
          var boundingRect = this.$el.getBoundingClientRect();
          var width = boundingRect.width;
          var method = width > 600 ? 'remove' : 'add';

          this.$el.classList[method]('small');
        }
      }
    }]);

    return _class;
  }(superclass);
};

exports.default = display;

},{"../utils/styles":42}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var toggle = exports.toggle = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"toggle-element\" version=\"1.1\" viewBox=\"0 0 50 50\" preserveAspectRatio=\"none\">\n      <g class=\"x\">\n        <line x1=\"8\" y1=\"8\" x2=\"42\" y2=\"42\" stroke=\"white\" />\n        <line x1=\"8\" y1=\"42\" x2=\"42\" y2=\"8\" stroke=\"white\" />\n      </g>\n  </svg>\n";

var arrowRight = exports.arrowRight = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"arrow-right\" version=\"1.1\" viewBox=\"0 0 50 50\" preserveAspectRatio=\"none\">\n    <line x1=\"10\" y1=\"10\" x2=\"40\" y2=\"25\" />\n    <line x1=\"10\" y1=\"40\" x2=\"40\" y2=\"25\" />\n  </svg>\n";

var arrowLeft = exports.arrowLeft = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"arrow-left\" version=\"1.1\" viewBox=\"0 0 50 50\" preserveAspectRatio=\"none\">\n    <line x1=\"40\" y1=\"10\" x2=\"10\" y2=\"25\" />\n    <line x1=\"40\" y1=\"40\" x2=\"10\" y2=\"25\" />\n  </svg>\n";

var smallArrowRight = exports.smallArrowRight = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"small-arrow-right\" viewBox=\"0 0 50 50\">\n    <path d=\"M 20 15 L 35 25 L 20 35 Z\" />\n  </svg>\n";

var smallArrowBottom = exports.smallArrowBottom = "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"small-arrow-bottom\" viewBox=\"0 0 50 50\">\n    <path d=\"M 15 17 L 35 17 L 25 32 Z\" />\n  </svg>\n";

},{}],41:[function(require,module,exports){
module.exports = " .basic-controllers { } .basic-controllers { width: 100%; max-width: 800px; height: 34px; padding: 3px; margin: 4px 0; background-color: #efefef; border: 1px solid #aaaaaa; box-sizing: border-box; border-radius: 2px; display: block; color: #464646; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .basic-controllers .label { font: italic normal 1.2em Quicksand, arial, sans-serif; line-height: 26px; overflow: hidden; text-align: right; padding: 0 8px 0 0; display: block; box-sizing: border-box; width: 24%; float: left; white-space: nowrap; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; user-select: none; } .basic-controllers .inner-wrapper { display: -webkit-inline-flex; display: inline-flex; -webkit-flex-wrap: no-wrap; flex-wrap: no-wrap; width: 76%; float: left; } .basic-controllers.small { height: 48px; } .basic-controllers.small:not(.align-small) { height: auto; } .basic-controllers.small:not(.align-small) .label { width: 100%; float: none; text-align: left; line-height: 40px; } .basic-controllers.small:not(.align-small) .inner-wrapper { width: 100%; float: none; } .basic-controllers.small.align-small .label { display: block; margin-right: 20px; text-align: left; line-height: 40px; } .basic-controllers.small.align-small .inner-wrapper { display: inline-block; width: auto; } .basic-controllers .arrow-right, .basic-controllers .arrow-left { border-radius: 2px; width: 14px; height: 26px; cursor: pointer; background-color: #464646; } .basic-controllers .arrow-right line, .basic-controllers .arrow-left line { stroke-width: 3px; stroke: #ffffff; } .basic-controllers .arrow-right:hover, .basic-controllers .arrow-left:hover { background-color: #686868; } .basic-controllers .arrow-right:active, .basic-controllers .arrow-left:active { background-color: #909090; } .basic-controllers .small-arrow-right, .basic-controllers .small-arrow-bottom { width: 26px; height: 26px; cursor: pointer; } .basic-controllers .small-arrow-right path, .basic-controllers .small-arrow-bottom path { fill: #909090; } .basic-controllers .small-arrow-right:hover path, .basic-controllers .small-arrow-bottom:hover path { fill: #686868; } .basic-controllers .toggle-element { width: 26px; height: 26px; border-radius: 2px; background-color: #464646; cursor: pointer; } .basic-controllers .toggle-element:hover { background-color: #686868; } .basic-controllers .toggle-element line { stroke-width: 3px; } .basic-controllers .toggle-element .x { display: none; } .basic-controllers .toggle-element.active .x { display: block; } .basic-controllers .btn { display: block; text-align: center; font: normal normal 12px arial; text-decoration: none; height: 26px; line-height: 26px; background-color: #464646; border: none; color: #ffffff; margin: 0 4px 0 0; padding: 0; box-sizing: border-box; border-radius: 2px; cursor: pointer; -webkit-flex-grow: 1; flex-grow: 1; } .basic-controllers .btn:last-child { margin: 0; } .basic-controllers .btn:hover { background-color: #686868; } .basic-controllers .btn:active, .basic-controllers .btn.active { background-color: #909090; } .basic-controllers .btn:focus { outline: none; } .basic-controllers .number { height: 26px; display: inline-block; position: relative; font: normal normal 1.2em Quicksand, arial, sans-serif; vertical-align: top; border: none; background: none; color: #464646; padding: 0 4px; margin: 0; background-color: #f9f9f9; border-radius: 2px; box-sizing: border-box; } .basic-controllers .number:focus { outline: none; } .basic-controllers select { height: 26px; line-height: 26px; background-color: #f9f9f9; border-radius: 2px; border: none; vertical-align: top; padding: 0; margin: 0; } .basic-controllers select:focus { outline: none; } .basic-controllers input[type=text] { width: 100%; height: 26px; line-height: 26px; border: 0; padding: 0 4px; background-color: #f9f9f9; border-radius: 2px; color: #565656; } .basic-controllers.small .arrow-right, .basic-controllers.small .arrow-left { width: 24px; height: 40px; } .basic-controllers.small .toggle-element { width: 40px; height: 40px; } .basic-controllers.small .btn { height: 40px; line-height: 40px; } .basic-controllers.small .number { height: 40px; } .basic-controllers.small select { height: 40px; line-height: 40px; } .basic-controllers.small input[type=text] { height: 40px; line-height: 40px; } .basic-controllers.title { border: none !important; margin-bottom: 0; margin-top: 8px; padding-top: 8px; padding-bottom: 0; background-color: transparent !important; height: 25px; } .basic-controllers.title .label { font: normal bold 1.3em Quicksand, arial, sans-serif; height: 100%; overflow: hidden; text-align: left; padding: 0; width: 100%; box-sizing: border-box; -webkit-flex-grow: 1; flex-grow: 1; } .basic-controllers.group { height: auto; background-color: white; } .basic-controllers.group .group-header .label { font: normal bold 1.3em Quicksand, arial, sans-serif; height: 26px; line-height: 26px; overflow: hidden; text-align: left; padding: 0 0 0 36px; width: 100%; box-sizing: border-box; -webkit-flex-grow: 1; flex-grow: 1; float: none; cursor: pointer; } .basic-controllers.group .group-header .small-arrow-right { width: 26px; height: 26px; position: absolute; } .basic-controllers.group .group-header .small-arrow-bottom { width: 26px; height: 26px; position: absolute; } .basic-controllers.group .group-content { overflow: hidden; } .basic-controllers.group .group-content > div { margin: 4px auto; } .basic-controllers.group .group-content > div:last-child { margin-bottom: 0; } .basic-controllers.group.opened .group-header .small-arrow-right { display: none; } .basic-controllers.group.opened .group-header .small-arrow-bottom { display: block; } .basic-controllers.group.opened .group-content { display: block; } .basic-controllers.group.closed .group-header .small-arrow-right { display: block; } .basic-controllers.group.closed .group-header .small-arrow-bottom { display: none; } .basic-controllers.group.closed .group-content { display: none; } .basic-controllers.slider .range { height: 26px; display: inline-block; margin: 0; -webkit-flex-grow: 4; flex-grow: 4; position: relative; } .basic-controllers.slider .range canvas { position: absolute; top: 0; left: 0; } .basic-controllers.slider .number-wrapper { display: inline; height: 26px; text-align: right; -webkit-flex-grow: 3; flex-grow: 3; } .basic-controllers.slider .number-wrapper .number { left: 5px; width: 54px; text-align: right; } .basic-controllers.slider .number-wrapper .unit { font: italic normal 1em Quicksand, arial, sans-serif; line-height: 26px; height: 26px; width: 30px; display: inline-block; position: relative; padding-left: 5px; padding-right: 5px; color: #565656; } .basic-controllers.slider .number-wrapper .unit sup { line-height: 7px; } .basic-controllers.slider.slider-large .range { -webkit-flex-grow: 50; flex-grow: 50; } .basic-controllers.slider.slider-large .number-wrapper { -webkit-flex-grow: 1; flex-grow: 1; } .basic-controllers.slider.slider-small .range { -webkit-flex-grow: 2; flex-grow: 2; } .basic-controllers.slider.slider-small .number-wrapper { -webkit-flex-grow: 4; flex-grow: 4; } .basic-controllers.small.slider .range { height: 40px; } .basic-controllers.small.slider .number-wrapper { height: 40px; } .basic-controllers.small.slider .number-wrapper .unit { line-height: 40px; height: 40px; } .basic-controllers.number-box .number { width: 120px; margin: 0 10px; vertical-align: top; } .basic-controllers.select-list select { margin: 0 10px; width: 120px; font: normal normal 1.2em Quicksand, arial, sans-serif; color: #464646; } .basic-controllers.select-buttons .btn:first-of-type { margin-left: 4px; } .basic-controllers.text input[type=text] { font: normal normal 1.2em Quicksand, arial, sans-serif; color: #464646; } .basic-controllers.drag-and-drop { width: 100%; text-align: center; font-weight: bold; height: 100px; } .basic-controllers.drag-and-drop .drop-zone { border: 1px dotted #c4c4c4; border-radius: 2px; transition: background 200ms; height: 90px; } .basic-controllers.drag-and-drop .drop-zone.drag { background-color: #c4c4c4; } .basic-controllers.drag-and-drop .label { display: block; width: 100%; height: 90px; line-height: 90px; margin: 0; padding: 0; text-align: center; } .basic-controllers.drag-and-drop.process .label { display: none; } .basic-controllers.small.drag-and-drop { height: 120px; } .basic-controllers.small.drag-and-drop .drop-zone { height: 110px; } .basic-controllers.small.drag-and-drop .label { display: block; width: 100%; height: 110px; line-height: 110px; margin: 0; padding: 0; text-align: center; } .basic-controllers.grey { background-color: #363636; border: 1px solid #585858; color: rgba(255, 255, 255, 0.95); } .basic-controllers.grey .toggle-element { background-color: #efefef; } .basic-controllers.grey .toggle-element line { stroke: #363636; } .basic-controllers.grey .toggle-element:hover { background-color: #cdcdcd; } .basic-controllers.grey .arrow-right, .basic-controllers.grey .arrow-left { background-color: #efefef; } .basic-controllers.grey .arrow-right line, .basic-controllers.grey .arrow-left line { stroke: #363636; } .basic-controllers.grey .arrow-right:hover, .basic-controllers.grey .arrow-left:hover { background-color: #cdcdcd; } .basic-controllers.grey .arrow-right:active, .basic-controllers.grey .arrow-left:active { background-color: #ababab; } .basic-controllers.grey .small-arrow-right path, .basic-controllers.grey .small-arrow-bottom path { fill: #ababab; } .basic-controllers.grey .small-arrow-right:hover path, .basic-controllers.grey .small-arrow-bottom:hover path { fill: #cdcdcd; } .basic-controllers.grey .number, .basic-controllers.grey select, .basic-controllers.grey input[type=text] { color: rgba(255, 255, 255, 0.95); background-color: #454545; } .basic-controllers.grey .btn { background-color: #efefef; color: #363636; } .basic-controllers.grey .btn:hover { background-color: #cdcdcd; } .basic-controllers.grey .btn:active, .basic-controllers.grey .btn.active { background-color: #ababab; } .basic-controllers.grey.slider .inner-wrapper .number-wrapper .unit { color: #bcbcbc; } .basic-controllers.grey.group { background-color: #505050; } .basic-controllers.grey.drag-and-drop .drop-zone { border: 1px dotted #727272; } .basic-controllers.grey.drag-and-drop .drop-zone.drag { background-color: #727272; } .basic-controllers.dark { background-color: #242424; border: 1px solid #282828; color: #ffffff; } .basic-controllers.dark .toggle-element { background-color: #464646; } .basic-controllers.dark .toggle-element line { stroke: #ffffff; } .basic-controllers.dark .toggle-element:hover { background-color: #686868; } .basic-controllers.dark .arrow-right, .basic-controllers.dark .arrow-left { background-color: #464646; } .basic-controllers.dark .arrow-right line, .basic-controllers.dark .arrow-left line { stroke: #ffffff; } .basic-controllers.dark .arrow-right:hover, .basic-controllers.dark .arrow-left:hover { background-color: #686868; } .basic-controllers.dark .arrow-right:active, .basic-controllers.dark .arrow-left:active { background-color: #909090; } .basic-controllers.dark .small-arrow-right path, .basic-controllers.dark .small-arrow-bottom path { fill: #909090; } .basic-controllers.dark .small-arrow-right:hover path, .basic-controllers.dark .small-arrow-bottom:hover path { fill: #686868; } .basic-controllers.dark .number, .basic-controllers.dark select, .basic-controllers.dark input[type=text] { color: #ffffff; background-color: #333333; } .basic-controllers.dark .btn { background-color: #464646; color: #ffffff; } .basic-controllers.dark .btn:hover { background-color: #686868; } .basic-controllers.dark .btn:active, .basic-controllers.dark .btn.active { background-color: #909090; } .basic-controllers.dark.slider .inner-wrapper .number-wrapper .unit { color: #cdcdcd; } .basic-controllers.dark.group { background-color: #3e3e3e; } .basic-controllers.dark.drag-and-drop .drop-zone { border: 1px dotted #424242; } .basic-controllers.dark.drag-and-drop .drop-zone.drag { background-color: #424242; } ";
},{}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ns = undefined;
exports.disable = disable;
exports.insertStyleSheet = insertStyleSheet;

var _package = require('../../package.json');

var _stylesDeclarations = require('./styles-declarations.js');

var _stylesDeclarations2 = _interopRequireDefault(_stylesDeclarations);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ns = exports.ns = _package.name.replace('@ircam/', '');

var nsClass = '.' + ns;
var _disabled = false;

function disable() {
  _disabled = true;
}

function insertStyleSheet() {
  if (_disabled) return;

  var $css = document.createElement('style');
  $css.setAttribute('data-namespace', ns);
  $css.type = 'text/css';

  if ($css.styleSheet) $css.styleSheet.cssText = _stylesDeclarations2.default;else $css.appendChild(document.createTextNode(_stylesDeclarations2.default));

  // insert before link or styles if exists
  var $link = document.head.querySelector('link');
  var $style = document.head.querySelector('style');

  if ($link) document.head.insertBefore($css, $link);else if ($style) document.head.insertBefore($css, $style);else document.head.appendChild($css);
}

},{"../../package.json":43,"./styles-declarations.js":41}],43:[function(require,module,exports){
module.exports={
  "_from": "@ircam/basic-controllers",
  "_id": "@ircam/basic-controllers@1.0.4",
  "_inBundle": false,
  "_integrity": "sha512-3cSAtxfpXtg1a3hvyVJN5gNmfqwf5mSbxuxq2g9I6/roUswtxOgGwYwWV18UJFWR75Mqot5SSVvbLdPPgv1noA==",
  "_location": "/@ircam/basic-controllers",
  "_phantomChildren": {},
  "_requested": {
    "type": "tag",
    "registry": true,
    "raw": "@ircam/basic-controllers",
    "name": "@ircam/basic-controllers",
    "escapedName": "@ircam%2fbasic-controllers",
    "scope": "@ircam",
    "rawSpec": "",
    "saveSpec": null,
    "fetchSpec": "latest"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/@ircam/basic-controllers/-/basic-controllers-1.0.4.tgz",
  "_shasum": "2e2152c618bae946126b8ebf41baeb95cb3c40f8",
  "_spec": "@ircam/basic-controllers",
  "_where": "/Users/matuszewski/dev/js/wavesjs/lib/waves-blocks/examples/module-list",
  "bugs": {
    "url": "https://github.com/ircam-jstools/basic-controllers/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "@ircam/gui-components": "^1.0.3"
  },
  "deprecated": false,
  "description": "Set of simple controllers for rapid prototyping",
  "devDependencies": {
    "babel-core": "^6.26.0",
    "babel-plugin-transform-es2015-modules-commonjs": "^6.26.0",
    "babel-preset-env": "^1.6.1",
    "browserify": "^14.5.0",
    "chalk": "^2.3.0",
    "fs-extra": "^4.0.3",
    "jsdoc-to-markdown": "^3.0.0",
    "klaw": "^2.1.1",
    "node-sass": "^4.7.2",
    "np": "^2.18.2",
    "tape": "^4.8.0",
    "uglify-js": "^3.2.2",
    "watch": "^1.0.2"
  },
  "homepage": "https://github.com/ircam-jstools/basic-controllers#readme",
  "license": "BSD-3-Clause",
  "main": "dist/index.js",
  "name": "@ircam/basic-controllers",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ircam-jstools/basic-controllers.git"
  },
  "scripts": {
    "bundle": "node ./bin/runner --bundle",
    "deploy": "np --yolo",
    "doc": "jsdoc2md -t tmpl/README.hbs src/**/*.js > README.md",
    "prewatch": "npm run transpile",
    "transpile": "node ./bin/runner --transpile",
    "version": "npm run transpile && npm run doc && git add README.md",
    "watch": "node ./bin/runner --watch"
  },
  "standalone": "basicControllers",
  "version": "1.0.4"
}

},{}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Breakpoint = function () {
  function Breakpoint(options) {
    _classCallCheck(this, Breakpoint);

    var defaults = {
      callback: function callback(value) {},
      width: 300,
      height: 150,
      container: 'body',
      default: [],
      radius: 4
    };

    this.params = Object.assign({}, defaults, options);

    this._values = {
      norm: [],
      logical: [],
      displayed: []
    };

    this._createElement();

    // initialize
    this._resizeElement();

    this._onMouseDown = this._onMouseDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    this._onMouseUp = this._onMouseUp.bind(this);

    this._onResize = this._onResize.bind(this);

    this._onResize();
    this._bindEvents();

    window.addEventListener('resize', this._onResize);
  }

  _createClass(Breakpoint, [{
    key: '_createElement',


    /** @note - same as Slider */
    value: function _createElement() {
      var container = this.params.container;

      this.$canvas = document.createElement('canvas');
      this.ctx = this.$canvas.getContext('2d');

      if (container instanceof Element) this.$container = container;else this.$container = document.querySelector(container);

      this.$container.appendChild(this.$canvas);
    }

    /** @note - same as Slider */

  }, {
    key: '_resizeElement',
    value: function _resizeElement() {
      var _params = this.params,
          width = _params.width,
          height = _params.height;

      // logical and pixel size of the canvas

      this._pixelRatio = function (ctx) {
        var dPR = window.devicePixelRatio || 1;
        var bPR = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;

        return dPR / bPR;
      }(this.ctx);

      this._canvasWidth = width * this._pixelRatio;
      this._canvasHeight = height * this._pixelRatio;

      this.ctx.canvas.width = this._canvasWidth;
      this.ctx.canvas.height = this._canvasHeight;
      this.ctx.canvas.style.width = width + 'px';
      this.ctx.canvas.style.height = height + 'px';
    }
  }, {
    key: 'resize',
    value: function resize(width, height) {}

    // update this.dots.displayed according to new width and height


    /** @note - same as Slider */

  }, {
    key: '_onResize',
    value: function _onResize() {
      this._boundingClientRect = this.$canvas.getBoundingClientRect();
    }
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      this.$canvas.addEventListener('mousedown', this._onMouseDown);
    }
  }, {
    key: '_onMouseDown',
    value: function _onMouseDown(e) {
      var pageX = e.pageX;
      var pageY = e.pageY;
      var x = pageX - this._boundingClientRect.left;
      var y = pageY - this._boundingClientRect.top;

      if (this._testHit(x, y)) {
        // bind mousemove and mouseup
        console.log('hit');
      } else {
        // create a new point
        console.log('create dot');
        this._createDot(x, y);
      }
    }
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove() {}
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp() {}

    // test if given x, y (in pixels) match some already displayed values

  }, {
    key: '_testHit',
    value: function _testHit(x, y) {
      var displayedValues = this._values.displayed;
      var radius = this.params.radius;

      for (var i = 0; i < displayedValues.length; i++) {
        var dot = displayedValues[i];
        var dx = dot[0] - x;
        var dy = dot[1] - y;
        var mag = Math.sqrt(dx * dx + dy * dy);

        if (mag <= radius) return true;
      }

      return false;
    }
  }, {
    key: '_createDot',
    value: function _createDot(x, y) {
      var normX = x / this.params.width;
      var normY = y / this.p$arams.height;
    }
  }, {
    key: 'values',
    get: function get() {},
    set: function set(values) {}
  }]);

  return Breakpoint;
}();

exports.default = Breakpoint;

},{}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getScale(domain, range) {
  var slope = (range[1] - range[0]) / (domain[1] - domain[0]);
  var intercept = range[0] - slope * domain[0];

  function scale(val) {
    return slope * val + intercept;
  }

  scale.invert = function (val) {
    return (val - intercept) / slope;
  };

  return scale;
}

function getClipper(min, max, step) {
  return function (val) {
    var clippedValue = Math.round(val / step) * step;
    var fixed = Math.max(Math.log10(1 / step), 0);
    var fixedValue = clippedValue.toFixed(fixed); // fix floating point errors
    return Math.min(max, Math.max(min, parseFloat(fixedValue)));
  };
}

/**
 * @module gui-components
 */

/**
 * Versatile canvas based slider.
 *
 * @param {Object} options - Override default parameters.
 * @param {'jump'|'proportionnal'|'handle'} [options.mode='jump'] - Mode of the slider:
 *  - in 'jump' mode, the value is changed on 'touchstart' or 'mousedown', and
 *    on move.
 *  - in 'proportionnal' mode, the value is updated relatively to move.
 *  - in 'handle' mode, the slider can be grabbed only around its value.
 * @param {Function} [options.callback] - Callback to be executed when the value
 *  of the slider changes.
 * @param {Number} [options.width=200] - Width of the slider.
 * @param {Number} [options.height=30] - Height of the slider.
 * @param {Number} [options.min=0] - Minimum value.
 * @param {Number} [options.max=1] - Maximum value.
 * @param {Number} [options.step=0.01] - Step between each consecutive values.
 * @param {Number} [options.default=0] - Default value.
 * @param {String|Element} [options.container='body'] - CSS Selector or DOM
 *  element in which inserting the slider.
 * @param {String} [options.backgroundColor='#464646'] - Background color of the
 *  slider.
 * @param {String} [options.foregroundColor='steelblue'] - Foreground color of
 *  the slider.
 * @param {'horizontal'|'vertical'} [options.orientation='horizontal'] -
 *  Orientation of the slider.
 * @param {Array} [options.markers=[]] - List of values where markers should
 *  be displayed on the slider.
 * @param {Boolean} [options.showHandle=true] - In 'handle' mode, define if the
 *  draggable should be show or not.
 * @param {Number} [options.handleSize=20] - Size of the draggable zone.
 * @param {String} [options.handleColor='rgba(255, 255, 255, 0.7)'] - Color of the
 *  draggable zone (when `showHandle` is `true`).
 *
 * @example
 * import { Slider} from 'gui-components';
 *
 * const slider = new Slider({
 *   mode: 'jump',
 *   container: '#container',
 *   default: 0.6,
 *   markers: [0.5],
 *   callback: (value) => console.log(value),
 * });
 */

var Slider = function () {
  function Slider(options) {
    _classCallCheck(this, Slider);

    var defaults = {
      mode: 'jump',
      callback: function callback(value) {},
      width: 200,
      height: 30,
      min: 0,
      max: 1,
      step: 0.01,
      default: 0,
      container: 'body',
      backgroundColor: '#464646',
      foregroundColor: 'steelblue',
      orientation: 'horizontal',
      markers: [],

      // handle specific options
      showHandle: true,
      handleSize: 20,
      handleColor: 'rgba(255, 255, 255, 0.7)'
    };

    this.params = Object.assign({}, defaults, options);
    this._listeners = [];
    this._boundingClientRect = null;
    this._touchId = null;
    this._value = null;
    this._canvasWidth = null;
    this._canvasHeight = null;
    // for proportionnal mode
    this._currentMousePosition = { x: null, y: null };
    this._currentSliderPosition = null;

    this._onMouseDown = this._onMouseDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    this._onMouseUp = this._onMouseUp.bind(this);

    this._onTouchStart = this._onTouchStart.bind(this);
    this._onTouchMove = this._onTouchMove.bind(this);
    this._onTouchEnd = this._onTouchEnd.bind(this);

    this._onResize = this._onResize.bind(this);

    this._createElement();

    // initialize
    this._resizeElement();
    this._setScales();
    this._bindEvents();
    this._onResize();
    this._updateValue(this.params.default, true, true);

    window.addEventListener('resize', this._onResize);
  }

  /**
   * Current value of the slider.
   *
   * @type {Number}
   */


  _createClass(Slider, [{
    key: 'reset',


    /**
     * Reset the slider to its default value.
     */
    value: function reset() {
      this._updateValue(this.params.default);
    }

    /**
     * Resize the slider.
     *
     * @param {Number} width - New width of the slider.
     * @param {Number} height - New height of the slider.
     */

  }, {
    key: 'resize',
    value: function resize(width, height) {
      this.params.width = width;
      this.params.height = height;

      this._resizeElement();
      this._setScales();
      this._onResize();
      this._updateValue(this._value, true, true);
    }
  }, {
    key: '_updateValue',
    value: function _updateValue(value) {
      var _this = this;

      var silent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var forceRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var callback = this.params.callback;

      var clippedValue = this.clipper(value);

      // resize render but don't trigger callback
      if (clippedValue === this._value && forceRender === true) requestAnimationFrame(function () {
        return _this._render(clippedValue);
      });

      // trigger callback
      if (clippedValue !== this._value) {
        this._value = clippedValue;

        if (!silent) callback(clippedValue);

        requestAnimationFrame(function () {
          return _this._render(clippedValue);
        });
      }
    }
  }, {
    key: '_createElement',
    value: function _createElement() {
      var container = this.params.container;

      this.$canvas = document.createElement('canvas');
      this.ctx = this.$canvas.getContext('2d');

      if (container instanceof Element) this.$container = container;else this.$container = document.querySelector(container);

      this.$container.appendChild(this.$canvas);
    }
  }, {
    key: '_resizeElement',
    value: function _resizeElement() {
      var _params = this.params,
          width = _params.width,
          height = _params.height;

      // logical and pixel size of the canvas

      this._pixelRatio = function (ctx) {
        var dPR = window.devicePixelRatio || 1;
        var bPR = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;

        return dPR / bPR;
      }(this.ctx);

      this._canvasWidth = width * this._pixelRatio;
      this._canvasHeight = height * this._pixelRatio;

      this.ctx.canvas.width = this._canvasWidth;
      this.ctx.canvas.height = this._canvasHeight;
      this.ctx.canvas.style.width = width + 'px';
      this.ctx.canvas.style.height = height + 'px';
    }
  }, {
    key: '_onResize',
    value: function _onResize() {
      this._boundingClientRect = this.$canvas.getBoundingClientRect();
    }
  }, {
    key: '_setScales',
    value: function _setScales() {
      var _params2 = this.params,
          orientation = _params2.orientation,
          width = _params2.width,
          height = _params2.height,
          min = _params2.min,
          max = _params2.max,
          step = _params2.step;
      // define transfert functions

      var screenSize = orientation === 'horizontal' ? width : height;

      var canvasSize = orientation === 'horizontal' ? this._canvasWidth : this._canvasHeight;

      var domain = orientation === 'horizontal' ? [min, max] : [max, min];
      var screenRange = [0, screenSize];
      var canvasRange = [0, canvasSize];

      this.screenScale = getScale(domain, screenRange);
      this.canvasScale = getScale(domain, canvasRange);
      this.clipper = getClipper(min, max, step);
    }
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      this.$canvas.addEventListener('mousedown', this._onMouseDown);
      this.$canvas.addEventListener('touchstart', this._onTouchStart);
    }
  }, {
    key: '_onStart',
    value: function _onStart(x, y) {
      var started = null;

      switch (this.params.mode) {
        case 'jump':
          this._updatePosition(x, y);
          started = true;
          break;
        case 'proportionnal':
          this._currentMousePosition.x = x;
          this._currentMousePosition.y = y;
          started = true;
          break;
        case 'handle':
          var orientation = this.params.orientation;
          var position = this.screenScale(this._value);
          var compare = orientation === 'horizontal' ? x : y;
          var delta = this.params.handleSize / 2;

          if (compare < position + delta && compare > position - delta) {
            this._currentMousePosition.x = x;
            this._currentMousePosition.y = y;
            started = true;
          } else {
            started = false;
          }
          break;
      }

      return started;
    }
  }, {
    key: '_onMove',
    value: function _onMove(x, y) {
      switch (this.params.mode) {
        case 'jump':
          break;
        case 'proportionnal':
        case 'handle':
          var deltaX = x - this._currentMousePosition.x;
          var deltaY = y - this._currentMousePosition.y;
          this._currentMousePosition.x = x;
          this._currentMousePosition.y = y;

          x = this.screenScale(this._value) + deltaX;
          y = this.screenScale(this._value) + deltaY;
          break;
      }

      this._updatePosition(x, y);
    }
  }, {
    key: '_onEnd',
    value: function _onEnd() {
      switch (this.params.mode) {
        case 'jump':
          break;
        case 'proportionnal':
        case 'handle':
          this._currentMousePosition.x = null;
          this._currentMousePosition.y = null;
          break;
      }
    }

    // mouse events

  }, {
    key: '_onMouseDown',
    value: function _onMouseDown(e) {
      var pageX = e.pageX;
      var pageY = e.pageY;
      var x = pageX - this._boundingClientRect.left;
      var y = pageY - this._boundingClientRect.top;

      if (this._onStart(x, y) === true) {
        window.addEventListener('mousemove', this._onMouseMove);
        window.addEventListener('mouseup', this._onMouseUp);
      }
    }
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(e) {
      e.preventDefault(); // prevent text selection

      var pageX = e.pageX;
      var pageY = e.pageY;
      var x = pageX - this._boundingClientRect.left;;
      var y = pageY - this._boundingClientRect.top;;

      this._onMove(x, y);
    }
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp(e) {
      this._onEnd();

      window.removeEventListener('mousemove', this._onMouseMove);
      window.removeEventListener('mouseup', this._onMouseUp);
    }

    // touch events

  }, {
    key: '_onTouchStart',
    value: function _onTouchStart(e) {
      if (this._touchId !== null) return;

      var touch = e.touches[0];
      this._touchId = touch.identifier;

      var pageX = touch.pageX;
      var pageY = touch.pageY;
      var x = pageX - this._boundingClientRect.left;
      var y = pageY - this._boundingClientRect.top;

      if (this._onStart(x, y) === true) {
        window.addEventListener('touchmove', this._onTouchMove);
        window.addEventListener('touchend', this._onTouchEnd);
        window.addEventListener('touchcancel', this._onTouchEnd);
      }
    }
  }, {
    key: '_onTouchMove',
    value: function _onTouchMove(e) {
      var _this2 = this;

      e.preventDefault(); // prevent text selection

      var touches = Array.from(e.touches);
      var touch = touches.filter(function (t) {
        return t.identifier === _this2._touchId;
      })[0];

      if (touch) {
        var pageX = touch.pageX;
        var pageY = touch.pageY;
        var x = pageX - this._boundingClientRect.left;
        var y = pageY - this._boundingClientRect.top;

        this._onMove(x, y);
      }
    }
  }, {
    key: '_onTouchEnd',
    value: function _onTouchEnd(e) {
      var _this3 = this;

      var touches = Array.from(e.touches);
      var touch = touches.filter(function (t) {
        return t.identifier === _this3._touchId;
      })[0];

      if (touch === undefined) {
        this._onEnd();
        this._touchId = null;

        window.removeEventListener('touchmove', this._onTouchMove);
        window.removeEventListener('touchend', this._onTouchEnd);
        window.removeEventListener('touchcancel', this._onTouchEnd);
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition(x, y) {
      var _params3 = this.params,
          orientation = _params3.orientation,
          height = _params3.height;

      var position = orientation === 'horizontal' ? x : y;
      var value = this.screenScale.invert(position);

      this._updateValue(value, false, true);
    }
  }, {
    key: '_render',
    value: function _render(clippedValue) {
      var _params4 = this.params,
          backgroundColor = _params4.backgroundColor,
          foregroundColor = _params4.foregroundColor,
          orientation = _params4.orientation;

      var canvasPosition = Math.round(this.canvasScale(clippedValue));
      var width = this._canvasWidth;
      var height = this._canvasHeight;
      var ctx = this.ctx;

      ctx.save();
      ctx.clearRect(0, 0, width, height);

      // background
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, width, height);

      // foreground
      ctx.fillStyle = foregroundColor;

      if (orientation === 'horizontal') ctx.fillRect(0, 0, canvasPosition, height);else ctx.fillRect(0, canvasPosition, width, height);

      // markers
      var markers = this.params.markers;

      for (var i = 0; i < markers.length; i++) {
        var marker = markers[i];
        var position = this.canvasScale(marker);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();

        if (orientation === 'horizontal') {
          ctx.moveTo(position - 0.5, 1);
          ctx.lineTo(position - 0.5, height - 1);
        } else {
          ctx.moveTo(1, height - position + 0.5);
          ctx.lineTo(width - 1, height - position + 0.5);
        }

        ctx.closePath();
        ctx.stroke();
      }

      // handle mode
      if (this.params.mode === 'handle' && this.params.showHandle) {
        var delta = this.params.handleSize * this._pixelRatio / 2;
        var start = canvasPosition - delta;
        var end = canvasPosition + delta;

        ctx.globalAlpha = 1;
        ctx.fillStyle = this.params.handleColor;

        if (orientation === 'horizontal') {
          ctx.fillRect(start, 0, end - start, height);
        } else {
          ctx.fillRect(0, start, width, end - start);
        }
      }

      ctx.restore();
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(val) {
      // don't trigger the callback when value is set from outside
      this._updateValue(val, true, false);
    }
  }]);

  return Slider;
}();

exports.default = Slider;

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Slider = require('./Slider');

Object.defineProperty(exports, 'Slider', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Slider).default;
  }
});

var _Breakpoint = require('./Breakpoint');

Object.defineProperty(exports, 'Breakpoint', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Breakpoint).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./Breakpoint":44,"./Slider":45}],47:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/json/stringify"), __esModule: true };
},{"core-js/library/fn/json/stringify":65}],48:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":66}],49:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":67}],50:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":68}],51:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":69}],52:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":70}],53:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":71}],54:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":72}],55:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":73}],56:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":74}],57:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _promise = require("../core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};
},{"../core-js/promise":54}],58:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],59:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":49}],60:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getPrototypeOf = require("../core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyDescriptor = require("../core-js/object/get-own-property-descriptor");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

  if (desc === undefined) {
    var parent = (0, _getPrototypeOf2.default)(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};
},{"../core-js/object/get-own-property-descriptor":50,"../core-js/object/get-prototype-of":51}],61:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":48,"../core-js/object/set-prototype-of":53,"../helpers/typeof":63}],62:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":63}],63:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":55,"../core-js/symbol/iterator":56}],64:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":166}],65:[function(require,module,exports){
var core = require('../../modules/_core');
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};

},{"../../modules/_core":82}],66:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

},{"../../modules/_core":82,"../../modules/es6.object.create":149}],67:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":82,"../../modules/es6.object.define-property":150}],68:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-descriptor');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};

},{"../../modules/_core":82,"../../modules/es6.object.get-own-property-descriptor":151}],69:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/_core').Object.getPrototypeOf;

},{"../../modules/_core":82,"../../modules/es6.object.get-prototype-of":152}],70:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;

},{"../../modules/_core":82,"../../modules/es6.object.keys":153}],71:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;

},{"../../modules/_core":82,"../../modules/es6.object.set-prototype-of":154}],72:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
require('../modules/es7.promise.finally');
require('../modules/es7.promise.try');
module.exports = require('../modules/_core').Promise;

},{"../modules/_core":82,"../modules/es6.object.to-string":155,"../modules/es6.promise":156,"../modules/es6.string.iterator":157,"../modules/es7.promise.finally":159,"../modules/es7.promise.try":160,"../modules/web.dom.iterable":163}],73:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":82,"../../modules/es6.object.to-string":155,"../../modules/es6.symbol":158,"../../modules/es7.symbol.async-iterator":161,"../../modules/es7.symbol.observable":162}],74:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":145,"../../modules/es6.string.iterator":157,"../../modules/web.dom.iterable":163}],75:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],76:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],77:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],78:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":101}],79:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":137,"./_to-iobject":139,"./_to-length":140}],80:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":81,"./_wks":146}],81:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],82:[function(require,module,exports){
var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],83:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":75}],84:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],85:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":90}],86:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":92,"./_is-object":101}],87:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],88:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":118,"./_object-keys":121,"./_object-pie":122}],89:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":82,"./_ctx":83,"./_global":92,"./_hide":94}],90:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],91:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":78,"./_ctx":83,"./_is-array-iter":99,"./_iter-call":102,"./_to-length":140,"./core.get-iterator-method":147}],92:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],93:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],94:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":85,"./_object-dp":113,"./_property-desc":126}],95:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":92}],96:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":85,"./_dom-create":86,"./_fails":90}],97:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],98:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":81}],99:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":107,"./_wks":146}],100:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":81}],101:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],102:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":78}],103:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":94,"./_object-create":112,"./_property-desc":126,"./_set-to-string-tag":131,"./_wks":146}],104:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var has = require('./_has');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":89,"./_has":93,"./_hide":94,"./_iter-create":103,"./_iterators":107,"./_library":108,"./_object-gpo":119,"./_redefine":128,"./_set-to-string-tag":131,"./_wks":146}],105:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":146}],106:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],107:[function(require,module,exports){
module.exports = {};

},{}],108:[function(require,module,exports){
module.exports = true;

},{}],109:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":90,"./_has":93,"./_is-object":101,"./_object-dp":113,"./_uid":143}],110:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":81,"./_global":92,"./_task":136}],111:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":75}],112:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":78,"./_dom-create":86,"./_enum-bug-keys":87,"./_html":95,"./_object-dps":114,"./_shared-key":132}],113:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":78,"./_descriptors":85,"./_ie8-dom-define":96,"./_to-primitive":142}],114:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":78,"./_descriptors":85,"./_object-dp":113,"./_object-keys":121}],115:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":85,"./_has":93,"./_ie8-dom-define":96,"./_object-pie":122,"./_property-desc":126,"./_to-iobject":139,"./_to-primitive":142}],116:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":117,"./_to-iobject":139}],117:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":87,"./_object-keys-internal":120}],118:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],119:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":93,"./_shared-key":132,"./_to-object":141}],120:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":79,"./_has":93,"./_shared-key":132,"./_to-iobject":139}],121:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":87,"./_object-keys-internal":120}],122:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],123:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":82,"./_export":89,"./_fails":90}],124:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],125:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":78,"./_is-object":101,"./_new-promise-capability":111}],126:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],127:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

},{"./_hide":94}],128:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":94}],129:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":78,"./_ctx":83,"./_is-object":101,"./_object-gopd":115}],130:[function(require,module,exports){
'use strict';
var global = require('./_global');
var core = require('./_core');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_core":82,"./_descriptors":85,"./_global":92,"./_object-dp":113,"./_wks":146}],131:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":93,"./_object-dp":113,"./_wks":146}],132:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":133,"./_uid":143}],133:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":92}],134:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":75,"./_an-object":78,"./_wks":146}],135:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":84,"./_to-integer":138}],136:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":81,"./_ctx":83,"./_dom-create":86,"./_global":92,"./_html":95,"./_invoke":97}],137:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":138}],138:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],139:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":84,"./_iobject":98}],140:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":138}],141:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":84}],142:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":101}],143:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],144:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":82,"./_global":92,"./_library":108,"./_object-dp":113,"./_wks-ext":145}],145:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":146}],146:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":92,"./_shared":133,"./_uid":143}],147:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":80,"./_core":82,"./_iterators":107,"./_wks":146}],148:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":76,"./_iter-define":104,"./_iter-step":106,"./_iterators":107,"./_to-iobject":139}],149:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":89,"./_object-create":112}],150:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":85,"./_export":89,"./_object-dp":113}],151:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":115,"./_object-sap":123,"./_to-iobject":139}],152:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":119,"./_object-sap":123,"./_to-object":141}],153:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":121,"./_object-sap":123,"./_to-object":141}],154:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":89,"./_set-proto":129}],155:[function(require,module,exports){

},{}],156:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":75,"./_an-instance":77,"./_classof":80,"./_core":82,"./_ctx":83,"./_export":89,"./_for-of":91,"./_global":92,"./_is-object":101,"./_iter-detect":105,"./_library":108,"./_microtask":110,"./_new-promise-capability":111,"./_perform":124,"./_promise-resolve":125,"./_redefine-all":127,"./_set-species":130,"./_set-to-string-tag":131,"./_species-constructor":134,"./_task":136,"./_wks":146}],157:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":104,"./_string-at":135}],158:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":78,"./_descriptors":85,"./_enum-keys":88,"./_export":89,"./_fails":90,"./_global":92,"./_has":93,"./_hide":94,"./_is-array":100,"./_is-object":101,"./_library":108,"./_meta":109,"./_object-create":112,"./_object-dp":113,"./_object-gopd":115,"./_object-gopn":117,"./_object-gopn-ext":116,"./_object-gops":118,"./_object-keys":121,"./_object-pie":122,"./_property-desc":126,"./_redefine":128,"./_set-to-string-tag":131,"./_shared":133,"./_to-iobject":139,"./_to-primitive":142,"./_uid":143,"./_wks":146,"./_wks-define":144,"./_wks-ext":145}],159:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":82,"./_export":89,"./_global":92,"./_promise-resolve":125,"./_species-constructor":134}],160:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":89,"./_new-promise-capability":111,"./_perform":124}],161:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":144}],162:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":144}],163:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":92,"./_hide":94,"./_iterators":107,"./_wks":146,"./es6.array.iterator":148}],164:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],165:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],166:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

},{"./runtime":167}],167:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);

},{}],168:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _loader = require('./loader');

var _loader2 = _interopRequireDefault(_loader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets called if a parameter is missing and the expression
 * specifying the default value is evaluated.
 * @function
 */
function throwIfMissing() {
  throw new Error('Missing parameter');
}

var audioContext = void 0;

window.AudioContext = window.AudioContext || window.webkitAudioContext;

try {
  audioContext = new window.AudioContext();
} catch (e) {}

/**
 * AudioBufferLoader
 * Promise based implementation of XMLHttpRequest Level 2 for GET method and decode audio data for arraybuffer.
 */

var AudioBufferLoader = function (_Loader) {
  (0, _inherits3.default)(AudioBufferLoader, _Loader);

  /**
   * Set the responseType to 'arraybuffer' and initialize options.
   * @param {string} [responseType="arraybuffer"]
   */

  function AudioBufferLoader() {
    var responseType = arguments.length <= 0 || arguments[0] === undefined ? 'arraybuffer' : arguments[0];
    (0, _classCallCheck3.default)(this, AudioBufferLoader);

    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(AudioBufferLoader).call(this, responseType));

    _this.options = {
      "wrapAroundExtension": 0
    };
    _this.responseType = responseType;
    _this.audioContext = audioContext;
    return _this;
  }

  /**
   * Allow to set the audio context that should be used in order to decode
   * the file and create the AudioBuffer.
   * @param {AudioContext} audioContext
   */


  (0, _createClass3.default)(AudioBufferLoader, [{
    key: 'setAudioContext',
    value: function setAudioContext(audioContext) {
      this.audioContext = audioContext;
    }

    /**
     * Method for promise audio file loading and decoding.
     * @param {(string|string[])} fileURLs - The URL(s) of the audio files to load. Accepts a URL pointing to the file location or an array of URLs.
     * @param {{wrapAroundExtension: number}} [options] - Object with a wrapAroundExtension key which set the length, in seconds to be copied from the begining at the end of the returned AudioBuffer
     * @returns {Promise}
     */

  }, {
    key: 'load',
    value: function load() {
      var fileURLs = arguments.length <= 0 || arguments[0] === undefined ? throwIfMissing() : arguments[0];
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      this.options = options;
      this.options.wrapAroundExtension = this.options.wrapAroundExtension || 0;
      return (0, _get3.default)((0, _getPrototypeOf2.default)(AudioBufferLoader.prototype), 'load', this).call(this, fileURLs);
    }

    /**
     * Load a single audio file, decode it in an AudioBuffer, return a Promise
     * @private
     * @param {string} fileURL - The URL of the audio file location to load.
     * @returns {Promise}
     */

  }, {
    key: 'loadOne',
    value: function loadOne(fileURL) {
      return (0, _get3.default)((0, _getPrototypeOf2.default)(AudioBufferLoader.prototype), 'loadOne', this).call(this, fileURL).then(this.decodeAudioData.bind(this), function (error) {
        throw error;
      });
    }

    /**
     * Load all audio files at once in a single array, decode them in an array of AudioBuffers, and return a Promise.
     * @private
     * @param {string[]} fileURLs - The URLs array of the audio files to load.
     * @returns {Promise}
     */

  }, {
    key: 'loadAll',
    value: function loadAll(fileURLs) {
      var _this2 = this;

      return (0, _get3.default)((0, _getPrototypeOf2.default)(AudioBufferLoader.prototype), 'loadAll', this).call(this, fileURLs).then(function (arraybuffers) {
        return _promise2.default.all(arraybuffers.map(function (arraybuffer) {
          return _this2.decodeAudioData.bind(_this2)(arraybuffer);
        }));
      }, function (error) {
        throw error; // TODO: better error handler
      });
    }

    /**
     * Decode Audio Data, return a Promise
     * @private
     * @param {arraybuffer} - The arraybuffer of the loaded audio file to be decoded.
     * @returns {Promise}
     */

  }, {
    key: 'decodeAudioData',
    value: function decodeAudioData(arraybuffer) {
      var _this3 = this;

      if (arraybuffer instanceof ArrayBuffer) {
        return new _promise2.default(function (resolve, reject) {
          _this3.audioContext.decodeAudioData(arraybuffer, // returned audio data array
          function (buffer) {
            if (_this3.options.wrapAroundExtension === 0) resolve(buffer);else resolve(_this3.__wrapAround(buffer));
          }, function (error) {
            reject(new Error("DecodeAudioData error"));
          });
        });
      } else {
        return new _promise2.default(function (resolve, reject) {
          resolve(arraybuffer);
        });
      }
    }

    /**
     * WrapAround, copy the begining input buffer to the end of an output buffer
     * @private
     * @param {arraybuffer} inBuffer {arraybuffer} - The input buffer
     * @returns {arraybuffer} - The processed buffer (with frame copied from the begining to the end)
     */

  }, {
    key: '__wrapAround',
    value: function __wrapAround(inBuffer) {
      var length = inBuffer.length + this.options.wrapAroundExtension * inBuffer.sampleRate;

      var outBuffer = this.audioContext.createBuffer(inBuffer.numberOfChannels, length, inBuffer.sampleRate);
      var arrayChData, arrayOutChData;

      for (var channel = 0; channel < inBuffer.numberOfChannels; channel++) {
        arrayChData = inBuffer.getChannelData(channel);
        arrayOutChData = outBuffer.getChannelData(channel);

        arrayOutChData.forEach(function (sample, index) {
          if (index < inBuffer.length) arrayOutChData[index] = arrayChData[index];else arrayOutChData[index] = arrayChData[index - inBuffer.length];
        });
      }

      return outBuffer;
    }
  }]);
  return AudioBufferLoader;
}(_loader2.default);

exports.default = AudioBufferLoader;

},{"./loader":170,"babel-runtime/core-js/object/get-prototype-of":51,"babel-runtime/core-js/promise":54,"babel-runtime/helpers/classCallCheck":58,"babel-runtime/helpers/createClass":59,"babel-runtime/helpers/get":60,"babel-runtime/helpers/inherits":61,"babel-runtime/helpers/possibleConstructorReturn":62}],169:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loader = require('./loader');

Object.defineProperty(exports, 'Loader', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_loader).default;
  }
});

var _audioBufferLoader = require('./audio-buffer-loader');

Object.defineProperty(exports, 'AudioBufferLoader', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioBufferLoader).default;
  }
});

var _superLoader = require('./super-loader');

Object.defineProperty(exports, 'SuperLoader', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_superLoader).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./audio-buffer-loader":168,"./loader":170,"./super-loader":171}],170:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets called if a parameter is missing and the expression
 * specifying the default value is evaluated.
 * @function
 */
function throwIfMissing() {
  throw new Error('Missing parameter');
}

/**
 * Promise based implementation of XMLHttpRequest Level 2 for GET method.
 */

var Loader = function () {
  /**
   * @constructs
   * @param {string} [responseType=""] - responseType's value, "text" (equal to ""), "arraybuffer", "blob", "document" or "json"
   */

  function Loader() {
    var responseType = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];
    (0, _classCallCheck3.default)(this, Loader);

    /**
     * @type {string}
     */
    this.responseType = responseType;
    // rename to `onProgress` ?
    /**
     * @type {function}
     */
    this.progressCb = undefined;
  }

  /**
   * Method for a promise based file loading.
   * Internally switch between loadOne and loadAll.
   * @public
   * @param {(string|string[])} fileURLs - The URL(s) of the files to load. Accepts a URL pointing to the file location or an array of URLs.
   * @returns {Promise}
   */


  (0, _createClass3.default)(Loader, [{
    key: 'load',
    value: function load() {
      var fileURLs = arguments.length <= 0 || arguments[0] === undefined ? throwIfMissing() : arguments[0];

      if (fileURLs === undefined) throw new Error('load needs at least a url to load');
      if (Array.isArray(fileURLs)) {
        return this.loadAll(fileURLs);
      } else {
        return this.loadOne(fileURLs);
      }
    }

    /**
     * Load a single file
     * @private
     * @param {string} fileURL - The URL of the file to load.
     * @returns {Promise}
     */

  }, {
    key: 'loadOne',
    value: function loadOne(fileURL) {
      return this.fileLoadingRequest(fileURL);
    }

    /**
     * Load all files at once in a single array and return a Promise
     * @private
     * @param {string[]} fileURLs - The URLs array of the files to load.
     * @returns {Promise}
     */

  }, {
    key: 'loadAll',
    value: function loadAll(fileURLs) {
      var urlsCount = fileURLs.length,
          promises = [];

      for (var i = 0; i < urlsCount; ++i) {
        promises.push(this.fileLoadingRequest(fileURLs[i], i));
      }

      return _promise2.default.all(promises);
    }

    /**
     * Load a file asynchronously, return a Promise.
     * @private
     * @param {string} url - The URL of the file to load
     * @param {string} [index] - The index of the file in the array of files to load
     * @returns {Promise}
     */

  }, {
    key: 'fileLoadingRequest',
    value: function fileLoadingRequest(url, index) {
      var _this = this;

      var promise = new _promise2.default(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.index = index;
        if (_this.responseType) {
          request.responseType = _this.responseType;
        } else {
          var suffix = '.json';
          if (url.indexOf(suffix, _this.length - suffix.length) !== -1) {
            request.responseType = 'json';
          } else {
            request.responseType = 'arraybuffer';
          }
        }
        request.addEventListener('load', function () {
          // Test request.status value, as 404 will also get there
          // Test request.status === 0 for cordova internal ajax calls
          if (request.status === 200 || request.status === 304 || request.status === 0) {
            // Hack for iOS 7, to remove as soon as possible
            if (this.responseType === 'json' && typeof request.response === 'string') {
              request.response = JSON.parse(request.response);
            }
            resolve(request.response);
          } else {
            reject(new Error(request.statusText));
          }
        });
        request.addEventListener('progress', function (evt) {
          if (_this.progressCallback) {
            if (index !== undefined) {
              _this.progressCallback({
                index: index,
                value: evt.loaded / evt.total,
                loaded: evt.loaded,
                total: evt.total
              });
            } else {
              _this.progressCallback({
                value: evt.loaded / evt.total,
                loaded: evt.loaded,
                total: evt.total
              });
            }
          }
        });
        // Manage network errors
        request.addEventListener('error', function () {
          reject(new Error('Network Error'));
        });

        request.send();
      });
      return promise;
    }

    /**
     * Get the callback function to get the progress of file loading process.
     * This is only for the file loading progress as decodeAudioData doesn't
     * expose a decode progress value.
     * @type {function}
     */

  }, {
    key: 'progressCallback',
    get: function get() {
      return this.progressCb;
    }

    /**
     * Set the callback function to get the progress of file loading process.
     * This is only for the file loading progress as decodeAudioData doesn't
     * expose a decode progress value.
     * @type {function} callback - The callback that handles the response.
     */
    ,
    set: function set(callback) {
      this.progressCb = callback;
    }
  }]);
  return Loader;
}();

exports.default = Loader;

},{"babel-runtime/core-js/promise":54,"babel-runtime/helpers/classCallCheck":58,"babel-runtime/helpers/createClass":59}],171:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioBufferLoader = require('./audio-buffer-loader');

var _audioBufferLoader2 = _interopRequireDefault(_audioBufferLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SuperLoader
 * Helper to load multiple type of files, and get them in their useful type, json for json files, AudioBuffer for audio files.
 */

var SuperLoader = function (_AudioBufferLoader) {
  (0, _inherits3.default)(SuperLoader, _AudioBufferLoader);

  /**
   * Use composition to setup appropriate file loaders
   */

  function SuperLoader() {
    (0, _classCallCheck3.default)(this, SuperLoader);
    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(SuperLoader).call(this, null));
    // bypass AudioBufferLoader constructor. This is bad but it works.
  }

  return SuperLoader;
}(_audioBufferLoader2.default);

exports.default = SuperLoader;

},{"./audio-buffer-loader":168,"babel-runtime/core-js/object/get-prototype-of":51,"babel-runtime/helpers/classCallCheck":58,"babel-runtime/helpers/inherits":61,"babel-runtime/helpers/possibleConstructorReturn":62}],172:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var min = Math.min;
var max = Math.max;

function clip(value) {
  var lower = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;
  var upper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : +Infinity;

  return max(lower, min(upper, value));
}

/**
 * Dictionnary of the available types. Each key correspond to the type of the
 * implemented param while the corresponding object value should the
 * {@link `paramDefinition`} of the defined type.
 *
 * typedef {Object} paramTemplates
 * @type {Object<String, paramTemplate>}
 */

/**
 * Definition of a parameter. The definition should at least contain the entries
 * `type` and `default`. Every parameter can also accept optionnal configuration
 * entries `constant` and `metas`.
 * Available definitions are:
 * - {@link booleanDefinition}
 * - {@link integerDefinition}
 * - {@link floatDefinition}
 * - {@link stringDefinition}
 * - {@link enumDefinition}
 *
 * typedef {Object} paramDefinition
 * @property {String} type - Type of the parameter.
 * @property {Mixed} default - Default value of the parameter if no
 *  initialization value is provided.
 * @property {Boolean} [constant=false] - Define if the parameter can be change
 *  after its initialization.
 * @property {Object} [metas=null] - Any user defined data associated to the
 *  parameter that couls be usefull in the application.
 */

exports.default = {
  /**
   * @typedef {Object} booleanDefinition
   * @property {String} [type='boolean'] - Define a boolean parameter.
   * @property {Boolean} default - Default value of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  boolean: {
    definitionTemplate: ['default'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      if (typeof value !== 'boolean') throw new Error('Invalid value for boolean param "' + name + '": ' + value);

      return value;
    }
  },

  /**
   * @typedef {Object} integerDefinition
   * @property {String} [type='integer'] - Define a boolean parameter.
   * @property {Mixed} default - Default value of the parameter.
   * @property {Number} [min=-Infinity] - Minimum value of the parameter.
   * @property {Number} [max=+Infinity] - Maximum value of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  integer: {
    definitionTemplate: ['default'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      if (!(typeof value === 'number' && Math.floor(value) === value)) throw new Error('Invalid value for integer param "' + name + '": ' + value);

      return clip(value, definition.min, definition.max);
    }
  },

  /**
   * @typedef {Object} floatDefinition
   * @property {String} [type='float'] - Define a boolean parameter.
   * @property {Mixed} default - Default value of the parameter.
   * @property {Number} [min=-Infinity] - Minimum value of the parameter.
   * @property {Number} [max=+Infinity] - Maximum value of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  float: {
    definitionTemplate: ['default'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      if (typeof value !== 'number' || value !== value) // reject NaN
        throw new Error('Invalid value for float param "' + name + '": ' + value);

      return clip(value, definition.min, definition.max);
    }
  },

  /**
   * @typedef {Object} stringDefinition
   * @property {String} [type='string'] - Define a boolean parameter.
   * @property {Mixed} default - Default value of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  string: {
    definitionTemplate: ['default'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      if (typeof value !== 'string') throw new Error('Invalid value for string param "' + name + '": ' + value);

      return value;
    }
  },

  /**
   * @typedef {Object} enumDefinition
   * @property {String} [type='enum'] - Define a boolean parameter.
   * @property {Mixed} default - Default value of the parameter.
   * @property {Array} list - Possible values of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  enum: {
    definitionTemplate: ['default', 'list'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      if (definition.list.indexOf(value) === -1) throw new Error('Invalid value for enum param "' + name + '": ' + value);

      return value;
    }
  },

  /**
   * @typedef {Object} anyDefinition
   * @property {String} [type='enum'] - Define a parameter of any type.
   * @property {Mixed} default - Default value of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  any: {
    definitionTemplate: ['default'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      // no check as it can have any type...
      return value;
    }
  }
};

},{}],173:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paramTemplates = require('./paramTemplates');

var _paramTemplates2 = _interopRequireDefault(_paramTemplates);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generic class for typed parameters.
 *
 * @param {String} name - Name of the parameter.
 * @param {Array} definitionTemplate - List of mandatory keys in the param
 *  definition.
 * @param {Function} typeCheckFunction - Function to be used in order to check
 *  the value against the param definition.
 * @param {Object} definition - Definition of the parameter.
 * @param {Mixed} value - Value of the parameter.
 * @private
 */
var Param = function () {
  function Param(name, definitionTemplate, typeCheckFunction, definition, value) {
    _classCallCheck(this, Param);

    definitionTemplate.forEach(function (key) {
      if (definition.hasOwnProperty(key) === false) throw new Error('Invalid definition for param "' + name + '", ' + key + ' is not defined');
    });

    this.name = name;
    this.type = definition.type;
    this.definition = definition;

    if (this.definition.nullable === true && value === null) this.value = null;else this.value = typeCheckFunction(value, definition, name);
    this._typeCheckFunction = typeCheckFunction;
  }

  /**
   * Returns the current value.
   * @return {Mixed}
   */


  _createClass(Param, [{
    key: 'getValue',
    value: function getValue() {
      return this.value;
    }

    /**
     * Update the current value.
     * @param {Mixed} value - New value of the parameter.
     * @return {Boolean} - `true` if the param has been updated, false otherwise
     *  (e.g. if the parameter already had this value).
     */

  }, {
    key: 'setValue',
    value: function setValue(value) {
      if (this.definition.constant === true) throw new Error('Invalid assignement to constant param "' + this.name + '"');

      if (!(this.definition.nullable === true && value === null)) value = this._typeCheckFunction(value, this.definition, this.name);

      if (this.value !== value) {
        this.value = value;
        return true;
      }

      return false;
    }
  }]);

  return Param;
}();

/**
 * Bag of parameters. Main interface of the library
 */


var ParameterBag = function () {
  function ParameterBag(params, definitions) {
    _classCallCheck(this, ParameterBag);

    /**
     * List of parameters.
     *
     * @type {Object<String, Param>}
     * @name _params
     * @memberof ParameterBag
     * @instance
     * @private
     */
    this._params = params;

    /**
     * List of definitions with init values.
     *
     * @type {Object<String, paramDefinition>}
     * @name _definitions
     * @memberof ParameterBag
     * @instance
     * @private
     */
    this._definitions = definitions;

    /**
     * List of global listeners.
     *
     * @type {Set}
     * @name _globalListeners
     * @memberof ParameterBag
     * @instance
     * @private
     */
    this._globalListeners = new Set();

    /**
     * List of params listeners.
     *
     * @type {Object<String, Set>}
     * @name _paramsListeners
     * @memberof ParameterBag
     * @instance
     * @private
     */
    this._paramsListeners = {};

    // initialize empty Set for each param
    for (var name in params) {
      this._paramsListeners[name] = new Set();
    }
  }

  /**
   * Return the given definitions along with the initialization values.
   *
   * @return {Object}
   */


  _createClass(ParameterBag, [{
    key: 'getDefinitions',
    value: function getDefinitions() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (name !== null) return this._definitions[name];else return this._definitions;
    }

    /**
     * Return the value of the given parameter.
     *
     * @param {String} name - Name of the parameter.
     * @return {Mixed} - Value of the parameter.
     */

  }, {
    key: 'get',
    value: function get(name) {
      if (!this._params[name]) throw new Error('Cannot read property value of undefined parameter "' + name + '"');

      return this._params[name].value;
    }

    /**
     * Set the value of a parameter. If the value of the parameter is updated
     * (aka if previous value is different from new value) all registered
     * callbacks are registered.
     *
     * @param {String} name - Name of the parameter.
     * @param {Mixed} value - Value of the parameter.
     * @return {Mixed} - New value of the parameter.
     */

  }, {
    key: 'set',
    value: function set(name, value) {
      var param = this._params[name];
      var updated = param.setValue(value);
      value = param.getValue();

      if (updated) {
        var metas = param.definition.metas;
        // trigger global listeners
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._globalListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var listener = _step.value;

            listener(name, value, metas);
          } // trigger param listeners
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._paramsListeners[name][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _listener = _step2.value;

            _listener(value, metas);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return value;
    }

    /**
     * Define if the `name` parameter exists or not.
     *
     * @param {String} name - Name of the parameter.
     * @return {Boolean}
     */

  }, {
    key: 'has',
    value: function has(name) {
      return this._params[name] ? true : false;
    }

    /**
     * Reset a parameter to its init value. Reset all parameters if no argument.
     *
     * @param {String} [name=null] - Name of the parameter to reset.
     */

  }, {
    key: 'reset',
    value: function reset() {
      var _this = this;

      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (name !== null) this.set(name, param.definition.initValue);else Object.keys(this._params).forEach(function (name) {
        return _this.reset(name);
      });
    }

    /**
     * @callback ParameterBag~listenerCallback
     * @param {String} name - Parameter name.
     * @param {Mixed} value - Updated value of the parameter.
     * @param {Object} [meta=] - Given meta data of the parameter.
     */

    /**
     * Add listener to all param updates.
     *
     * @param {ParameterBag~listenerCallack} callback - Listener to register.
     */

  }, {
    key: 'addListener',
    value: function addListener(callback) {
      this._globalListeners.add(callback);
    }

    /**
     * Remove listener from all param changes.
     *
     * @param {ParameterBag~listenerCallack} callback - Listener to remove. If
     *  `null` remove all listeners.
     */

  }, {
    key: 'removeListener',
    value: function removeListener() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (callback === null) this._globalListeners.clear();else this._globalListeners.delete(callback);
    }

    /**
     * @callback ParameterBag~paramListenerCallack
     * @param {Mixed} value - Updated value of the parameter.
     * @param {Object} [meta=] - Given meta data of the parameter.
     */

    /**
     * Add listener to a given param updates.
     *
     * @param {String} name - Parameter name.
     * @param {ParameterBag~paramListenerCallack} callback - Function to apply
     *  when the value of the parameter changes.
     * @param {Boolean} [trigger=false] - Execute the callback immediately with
     *  current parameter value.
     */

  }, {
    key: 'addParamListener',
    value: function addParamListener(name, callback) {
      var trigger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      this._paramsListeners[name].add(callback);

      if (trigger) {
        var _param = this._params[name];
        var value = _param.getValue();
        var metas = _param.definition.metas;
        callback(value, metas);
      }
    }

    /**
     * Remove listener from a given param updates.
     *
     * @param {String} name - Parameter name.
     * @param {ParameterBag~paramListenerCallack} callback - Listener to remove.
     *  If `null` remove all listeners.
     */

  }, {
    key: 'removeParamListener',
    value: function removeParamListener(name) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (callback === null) this._paramsListeners[name].clear();else this._paramsListeners[name].delete(callback);
    }
  }]);

  return ParameterBag;
}();

/**
 * Factory for the `ParameterBag` class.
 *
 * @param {Object<String, paramDefinition>} definitions - Object describing the
 *  parameters.
 * @param {Object<String, Mixed>} values - Initialization values for the
 *  parameters.
 * @return {ParameterBag}
 */


function parameters(definitions) {
  var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var params = {};

  for (var name in values) {
    if (definitions.hasOwnProperty(name) === false) throw new Error('Unknown param "' + name + '"');
  }

  for (var _name in definitions) {
    if (params.hasOwnProperty(_name) === true) throw new Error('Parameter "' + _name + '" already defined');

    var definition = definitions[_name];

    if (!_paramTemplates2.default[definition.type]) throw new Error('Unknown param type "' + definition.type + '"');

    var _paramTemplates$defin = _paramTemplates2.default[definition.type],
        definitionTemplate = _paramTemplates$defin.definitionTemplate,
        typeCheckFunction = _paramTemplates$defin.typeCheckFunction;


    var value = void 0;

    if (values.hasOwnProperty(_name) === true) value = values[_name];else value = definition.default;

    // store init value in definition
    definition.initValue = value;

    if (!typeCheckFunction || !definitionTemplate) throw new Error('Invalid param type definition "' + definition.type + '"');

    params[_name] = new Param(_name, definitionTemplate, typeCheckFunction, definition, value);
  }

  return new ParameterBag(params, definitions);
}

/**
 * Register a new type for the `parameters` factory.
 * @param {String} typeName - Value that will be available as the `type` of a
 *  param definition.
 * @param {parameterDefinition} parameterDefinition - Object describing the
 *  parameter.
 */
parameters.defineType = function (typeName, parameterDefinition) {
  _paramTemplates2.default[typeName] = parameterDefinition;
};

exports.default = parameters;

},{"./paramTemplates":172}],174:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// http://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser
var isNode = new Function('try { return this === global; } catch(e) { return false }');

/**
 * Create a function that returns time in milliseconds according to the current
 * environnement (node or browser).
 * If running in node the time rely on `process.hrtime`, while if in the browser
 * it is provided by the `currentTime` of an `AudioContext`, this context can
 * optionnaly be provided to keep time consistency between several `EventIn`
 * nodes.
 *
 * @param {AudioContext} [audioContext=null] - Optionnal audio context.
 * @return {Function}
 * @private
 */
function getTimeFunction() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  if (isNode()) {
    return function () {
      var t = process.hrtime();
      return (t[0] + t[1] * 1e-9) * 1e3;
    };
  } else {
    return function () {
      return performance.now();
    };
  }
}

/**
 * @callback TickerCallback
 * @param {Number} logicalTime - logical time since `start` in ms
 * @param {Number} currentTime - current time as returned by `performance.now`
 * @param {Number} error - current error
 */

/**
 * Precise periodic timer (based on `setTimeout`) that monitor and adapt itself
 * to stay close to the given therical period. In particular, try to minimize
 * the drift caused by the use of a raw `setTimeout`.
 * Observed average jitter is around +/- 2ms.
 *
 * @param {Number} period - period of the timer interval in milliseconds
 *  (floored if float is given)
 * @param {TickerCallback} callback - callback to execute on each tick
 * @param {Object} options - additionnal options
 * @param {Number} [options.errorThreshold] - Threshold error where the timer
 *  considers itself as out of bounds. Increasing this value tends to increase
 *  the overall jitter.
 */

var Ticker = function () {
  function Ticker(period, callback) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$errorThreshold = _ref.errorThreshold,
        errorThreshold = _ref$errorThreshold === undefined ? 0.4 : _ref$errorThreshold;

    _classCallCheck(this, Ticker);

    period = Math.floor(period);

    this.logicalPeriod = period;
    this.computedPeriod = period;
    this.callback = callback;
    this.errorThreshold = errorThreshold;
    this.isRunning = false;
    this.getTime = getTimeFunction();

    this._tick = this._tick.bind(this);
  }

  /**
   * Period of the timer. Must be an integer, the given value is floored.
   * When updated the new value is applied at the next tick.
   *
   * @name period
   * @type {Number}
   * @instance
   * @memberof Ticker
   */


  _createClass(Ticker, [{
    key: 'start',


    /**
     * Start the ticker instance.
     */
    value: function start() {
      if (!this.isRunning) {
        this.startTime = this.getTime();
        this.logicalTime = 0;

        this._tick(); // run now

        this.isRunning = true;
      }
    }

    /**
     * Stop the ticker instance.
     */

  }, {
    key: 'stop',
    value: function stop() {
      clearTimeout(this.timeoutId);
      this.isRunning = false;
    }

    /** @private */

  }, {
    key: '_tick',
    value: function _tick() {
      var now = this.getTime();
      var time = now - this.startTime;
      var error = time - this.logicalTime;

      if (error >= this.errorThreshold) this.computedPeriod = this.computedPeriod - 1;

      if (error < -this.errorThreshold) this.computedPeriod = this.logicalPeriod;

      this.timeoutId = setTimeout(this._tick, this.computedPeriod);

      this.callback(this.logicalTime, now, error);
      // next call time
      this.logicalTime += this.logicalPeriod;
    }
  }, {
    key: 'period',
    set: function set(value) {
      value = Math.floor(value);
      this.logicalPeriod = value;
      this.computedPeriod = value;
    },
    get: function get() {
      return this.logicalPeriod;
    }
  }]);

  return Ticker;
}();

exports.default = Ticker;

}).call(this,require('_process'))

},{"_process":165}],175:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":198}],176:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"core-js/library/fn/json/stringify":199,"dup":47}],177:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":200}],178:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/log10"), __esModule: true };
},{"core-js/library/fn/math/log10":201}],179:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/is-finite"), __esModule: true };
},{"core-js/library/fn/number/is-finite":202}],180:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":203}],181:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"core-js/library/fn/object/create":204,"dup":48}],182:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"core-js/library/fn/object/define-property":205,"dup":49}],183:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"core-js/library/fn/object/get-own-property-descriptor":206,"dup":50}],184:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"core-js/library/fn/object/get-prototype-of":207,"dup":51}],185:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"core-js/library/fn/object/set-prototype-of":208,"dup":53}],186:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"core-js/library/fn/promise":209,"dup":54}],187:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":210}],188:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"core-js/library/fn/symbol":211,"dup":55}],189:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"core-js/library/fn/symbol/iterator":212,"dup":56}],190:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/weak-map"), __esModule: true };
},{"core-js/library/fn/weak-map":213}],191:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"dup":58}],192:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"../core-js/object/define-property":182,"dup":59}],193:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"../core-js/object/get-own-property-descriptor":183,"../core-js/object/get-prototype-of":184,"dup":60}],194:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"../core-js/object/create":181,"../core-js/object/set-prototype-of":185,"../helpers/typeof":197,"dup":61}],195:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"../helpers/typeof":197,"dup":62}],196:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getPrototypeOf = require("../core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyDescriptor = require("../core-js/object/get-own-property-descriptor");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function set(object, property, value, receiver) {
  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

  if (desc === undefined) {
    var parent = (0, _getPrototypeOf2.default)(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};
},{"../core-js/object/get-own-property-descriptor":183,"../core-js/object/get-prototype-of":184}],197:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"../core-js/symbol":188,"../core-js/symbol/iterator":189,"dup":63}],198:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');

},{"../modules/core.get-iterator":300,"../modules/es6.string.iterator":314,"../modules/web.dom.iterable":329}],199:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"../../modules/_core":229,"dup":65}],200:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
require('../modules/es7.map.of');
require('../modules/es7.map.from');
module.exports = require('../modules/_core').Map;

},{"../modules/_core":229,"../modules/es6.map":302,"../modules/es6.object.to-string":311,"../modules/es6.string.iterator":314,"../modules/es7.map.from":317,"../modules/es7.map.of":318,"../modules/es7.map.to-json":319,"../modules/web.dom.iterable":329}],201:[function(require,module,exports){
require('../../modules/es6.math.log10');
module.exports = require('../../modules/_core').Math.log10;

},{"../../modules/_core":229,"../../modules/es6.math.log10":303}],202:[function(require,module,exports){
require('../../modules/es6.number.is-finite');
module.exports = require('../../modules/_core').Number.isFinite;

},{"../../modules/_core":229,"../../modules/es6.number.is-finite":304}],203:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":229,"../../modules/es6.object.assign":305}],204:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"../../modules/_core":229,"../../modules/es6.object.create":306,"dup":66}],205:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"../../modules/_core":229,"../../modules/es6.object.define-property":307,"dup":67}],206:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"../../modules/_core":229,"../../modules/es6.object.get-own-property-descriptor":308,"dup":68}],207:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"../../modules/_core":229,"../../modules/es6.object.get-prototype-of":309,"dup":69}],208:[function(require,module,exports){
arguments[4][71][0].apply(exports,arguments)
},{"../../modules/_core":229,"../../modules/es6.object.set-prototype-of":310,"dup":71}],209:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"../modules/_core":229,"../modules/es6.object.to-string":311,"../modules/es6.promise":312,"../modules/es6.string.iterator":314,"../modules/es7.promise.finally":320,"../modules/es7.promise.try":321,"../modules/web.dom.iterable":329,"dup":72}],210:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
require('../modules/es7.set.of');
require('../modules/es7.set.from');
module.exports = require('../modules/_core').Set;

},{"../modules/_core":229,"../modules/es6.object.to-string":311,"../modules/es6.set":313,"../modules/es6.string.iterator":314,"../modules/es7.set.from":322,"../modules/es7.set.of":323,"../modules/es7.set.to-json":324,"../modules/web.dom.iterable":329}],211:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"../../modules/_core":229,"../../modules/es6.object.to-string":311,"../../modules/es6.symbol":315,"../../modules/es7.symbol.async-iterator":325,"../../modules/es7.symbol.observable":326,"dup":73}],212:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"../../modules/_wks-ext":297,"../../modules/es6.string.iterator":314,"../../modules/web.dom.iterable":329,"dup":74}],213:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/web.dom.iterable');
require('../modules/es6.weak-map');
require('../modules/es7.weak-map.of');
require('../modules/es7.weak-map.from');
module.exports = require('../modules/_core').WeakMap;

},{"../modules/_core":229,"../modules/es6.object.to-string":311,"../modules/es6.weak-map":316,"../modules/es7.weak-map.from":327,"../modules/es7.weak-map.of":328,"../modules/web.dom.iterable":329}],214:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"dup":75}],215:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],216:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"dup":77}],217:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"./_is-object":248,"dup":78}],218:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":238}],219:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"./_to-absolute-index":288,"./_to-iobject":290,"./_to-length":291,"dup":79}],220:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":222,"./_ctx":230,"./_iobject":245,"./_to-length":291,"./_to-object":292}],221:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":247,"./_is-object":248,"./_wks":298}],222:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":221}],223:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"./_cof":224,"./_wks":298,"dup":80}],224:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"dup":81}],225:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":216,"./_ctx":230,"./_descriptors":232,"./_for-of":238,"./_iter-define":251,"./_iter-step":253,"./_meta":257,"./_object-create":261,"./_object-dp":262,"./_redefine-all":276,"./_set-species":281,"./_validate-collection":295}],226:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":218,"./_classof":223}],227:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":216,"./_an-object":217,"./_array-methods":220,"./_for-of":238,"./_has":240,"./_is-object":248,"./_meta":257,"./_redefine-all":276,"./_validate-collection":295}],228:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var meta = require('./_meta');
var fails = require('./_fails');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var setToStringTag = require('./_set-to-string-tag');
var dP = require('./_object-dp').f;
var each = require('./_array-methods')(0);
var DESCRIPTORS = require('./_descriptors');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":216,"./_array-methods":220,"./_descriptors":232,"./_export":236,"./_fails":237,"./_for-of":238,"./_global":239,"./_hide":241,"./_is-object":248,"./_meta":257,"./_object-dp":262,"./_redefine-all":276,"./_set-to-string-tag":282}],229:[function(require,module,exports){
var core = module.exports = { version: '2.5.0' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],230:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"./_a-function":214,"dup":83}],231:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"dup":84}],232:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"./_fails":237,"dup":85}],233:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"./_global":239,"./_is-object":248,"dup":86}],234:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"dup":87}],235:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"./_object-gops":267,"./_object-keys":270,"./_object-pie":271,"dup":88}],236:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"./_core":229,"./_ctx":230,"./_global":239,"./_hide":241,"dup":89}],237:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"dup":90}],238:[function(require,module,exports){
arguments[4][91][0].apply(exports,arguments)
},{"./_an-object":217,"./_ctx":230,"./_is-array-iter":246,"./_iter-call":249,"./_to-length":291,"./core.get-iterator-method":299,"dup":91}],239:[function(require,module,exports){
arguments[4][92][0].apply(exports,arguments)
},{"dup":92}],240:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"dup":93}],241:[function(require,module,exports){
arguments[4][94][0].apply(exports,arguments)
},{"./_descriptors":232,"./_object-dp":262,"./_property-desc":275,"dup":94}],242:[function(require,module,exports){
arguments[4][95][0].apply(exports,arguments)
},{"./_global":239,"dup":95}],243:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"./_descriptors":232,"./_dom-create":233,"./_fails":237,"dup":96}],244:[function(require,module,exports){
arguments[4][97][0].apply(exports,arguments)
},{"dup":97}],245:[function(require,module,exports){
arguments[4][98][0].apply(exports,arguments)
},{"./_cof":224,"dup":98}],246:[function(require,module,exports){
arguments[4][99][0].apply(exports,arguments)
},{"./_iterators":254,"./_wks":298,"dup":99}],247:[function(require,module,exports){
arguments[4][100][0].apply(exports,arguments)
},{"./_cof":224,"dup":100}],248:[function(require,module,exports){
arguments[4][101][0].apply(exports,arguments)
},{"dup":101}],249:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"./_an-object":217,"dup":102}],250:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"./_hide":241,"./_object-create":261,"./_property-desc":275,"./_set-to-string-tag":282,"./_wks":298,"dup":103}],251:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var has = require('./_has');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":236,"./_has":240,"./_hide":241,"./_iter-create":250,"./_iterators":254,"./_library":256,"./_object-gpo":268,"./_redefine":277,"./_set-to-string-tag":282,"./_wks":298}],252:[function(require,module,exports){
arguments[4][105][0].apply(exports,arguments)
},{"./_wks":298,"dup":105}],253:[function(require,module,exports){
arguments[4][106][0].apply(exports,arguments)
},{"dup":106}],254:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"dup":107}],255:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
module.exports = function (object, el) {
  var O = toIObject(object);
  var keys = getKeys(O);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) if (O[key = keys[index++]] === el) return key;
};

},{"./_object-keys":270,"./_to-iobject":290}],256:[function(require,module,exports){
arguments[4][108][0].apply(exports,arguments)
},{"dup":108}],257:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"./_fails":237,"./_has":240,"./_is-object":248,"./_object-dp":262,"./_uid":294,"dup":109}],258:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":224,"./_global":239,"./_task":287}],259:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./_a-function":214,"dup":111}],260:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":237,"./_iobject":245,"./_object-gops":267,"./_object-keys":270,"./_object-pie":271,"./_to-object":292}],261:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"./_an-object":217,"./_dom-create":233,"./_enum-bug-keys":234,"./_html":242,"./_object-dps":263,"./_shared-key":283,"dup":112}],262:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"./_an-object":217,"./_descriptors":232,"./_ie8-dom-define":243,"./_to-primitive":293,"dup":113}],263:[function(require,module,exports){
arguments[4][114][0].apply(exports,arguments)
},{"./_an-object":217,"./_descriptors":232,"./_object-dp":262,"./_object-keys":270,"dup":114}],264:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"./_descriptors":232,"./_has":240,"./_ie8-dom-define":243,"./_object-pie":271,"./_property-desc":275,"./_to-iobject":290,"./_to-primitive":293,"dup":115}],265:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"./_object-gopn":266,"./_to-iobject":290,"dup":116}],266:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./_enum-bug-keys":234,"./_object-keys-internal":269,"dup":117}],267:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],268:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"./_has":240,"./_shared-key":283,"./_to-object":292,"dup":119}],269:[function(require,module,exports){
arguments[4][120][0].apply(exports,arguments)
},{"./_array-includes":219,"./_has":240,"./_shared-key":283,"./_to-iobject":290,"dup":120}],270:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"./_enum-bug-keys":234,"./_object-keys-internal":269,"dup":121}],271:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"dup":122}],272:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./_core":229,"./_export":236,"./_fails":237,"dup":123}],273:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],274:[function(require,module,exports){
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_new-promise-capability":259}],275:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],276:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"./_hide":241,"dup":127}],277:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"./_hide":241,"dup":128}],278:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":214,"./_ctx":230,"./_export":236,"./_for-of":238}],279:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":236}],280:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"./_an-object":217,"./_ctx":230,"./_is-object":248,"./_object-gopd":264,"dup":129}],281:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"./_core":229,"./_descriptors":232,"./_global":239,"./_object-dp":262,"./_wks":298,"dup":130}],282:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./_has":240,"./_object-dp":262,"./_wks":298,"dup":131}],283:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./_shared":284,"./_uid":294,"dup":132}],284:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"./_global":239,"dup":133}],285:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"./_a-function":214,"./_an-object":217,"./_wks":298,"dup":134}],286:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"./_defined":231,"./_to-integer":289,"dup":135}],287:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"./_cof":224,"./_ctx":230,"./_dom-create":233,"./_global":239,"./_html":242,"./_invoke":244,"dup":136}],288:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"./_to-integer":289,"dup":137}],289:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"dup":138}],290:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"./_defined":231,"./_iobject":245,"dup":139}],291:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"./_to-integer":289,"dup":140}],292:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"./_defined":231,"dup":141}],293:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"./_is-object":248,"dup":142}],294:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"dup":143}],295:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":248}],296:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"./_core":229,"./_global":239,"./_library":256,"./_object-dp":262,"./_wks-ext":297,"dup":144}],297:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"./_wks":298,"dup":145}],298:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"./_global":239,"./_shared":284,"./_uid":294,"dup":146}],299:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"./_classof":223,"./_core":229,"./_iterators":254,"./_wks":298,"dup":147}],300:[function(require,module,exports){
var anObject = require('./_an-object');
var get = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

},{"./_an-object":217,"./_core":229,"./core.get-iterator-method":299}],301:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"./_add-to-unscopables":215,"./_iter-define":251,"./_iter-step":253,"./_iterators":254,"./_to-iobject":290,"dup":148}],302:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":228,"./_collection-strong":225,"./_validate-collection":295}],303:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":236}],304:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":236,"./_global":239}],305:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":236,"./_object-assign":260}],306:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"./_export":236,"./_object-create":261,"dup":149}],307:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"./_descriptors":232,"./_export":236,"./_object-dp":262,"dup":150}],308:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"./_object-gopd":264,"./_object-sap":272,"./_to-iobject":290,"dup":151}],309:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"./_object-gpo":268,"./_object-sap":272,"./_to-object":292,"dup":152}],310:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"./_export":236,"./_set-proto":280,"dup":154}],311:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"dup":155}],312:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var sameConstructor = LIBRARY ? function (a, b) {
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
} : function (a, b) {
  return a === b;
};
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return sameConstructor($Promise, C)
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;
    return promiseResolve(this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":214,"./_an-instance":216,"./_classof":223,"./_core":229,"./_ctx":230,"./_export":236,"./_for-of":238,"./_global":239,"./_is-object":248,"./_iter-detect":252,"./_library":256,"./_microtask":258,"./_new-promise-capability":259,"./_perform":273,"./_promise-resolve":274,"./_redefine-all":276,"./_set-species":281,"./_set-to-string-tag":282,"./_species-constructor":285,"./_task":287,"./_wks":298}],313:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":228,"./_collection-strong":225,"./_validate-collection":295}],314:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"./_iter-define":251,"./_string-at":286,"dup":157}],315:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var keyOf = require('./_keyof');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key) {
    if (isSymbol(key)) return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":217,"./_descriptors":232,"./_enum-keys":235,"./_export":236,"./_fails":237,"./_global":239,"./_has":240,"./_hide":241,"./_is-array":247,"./_keyof":255,"./_library":256,"./_meta":257,"./_object-create":261,"./_object-dp":262,"./_object-gopd":264,"./_object-gopn":266,"./_object-gopn-ext":265,"./_object-gops":267,"./_object-keys":270,"./_object-pie":271,"./_property-desc":275,"./_redefine":277,"./_set-to-string-tag":282,"./_shared":284,"./_to-iobject":290,"./_to-primitive":293,"./_uid":294,"./_wks":298,"./_wks-define":296,"./_wks-ext":297}],316:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":220,"./_collection":228,"./_collection-weak":227,"./_fails":237,"./_is-object":248,"./_meta":257,"./_object-assign":260,"./_redefine":277,"./_validate-collection":295}],317:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":278}],318:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":279}],319:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":226,"./_export":236}],320:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"./_core":229,"./_export":236,"./_global":239,"./_promise-resolve":274,"./_species-constructor":285,"dup":159}],321:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"./_export":236,"./_new-promise-capability":259,"./_perform":273,"dup":160}],322:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":278}],323:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":279}],324:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":226,"./_export":236}],325:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"./_wks-define":296,"dup":161}],326:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"./_wks-define":296,"dup":162}],327:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":278}],328:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":279}],329:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./_global":239,"./_hide":241,"./_iterators":254,"./_wks":298,"./es6.array.iterator":301,"dup":163}],330:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":331,"_process":165}],331:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":332}],332:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],333:[function(require,module,exports){
'use strict';

/*
 * OBJECT ASSIGN DEEP
 * Allows deep cloning of plain objects that contain primitives, nested plain objects, or nested plain arrays.
 */

/*
 * A unified way of returning a string that describes the type of the given variable.
 */
function getTypeOf (input) {

	if (input === null) {
		return `null`;
	}

	else if (typeof input === `undefined`) {
		return `undefined`;
	}

	else if (typeof input === `object`) {
		return (Array.isArray(input) ? `array` : `object`);
	}

	return typeof input;

}

/*
 * Branching logic which calls the correct function to clone the given value base on its type.
 */
function cloneValue (value) {

	// The value is an object so lets clone it.
	if (getTypeOf(value) === `object`) {
		return quickCloneObject(value);
	}

	// The value is an array so lets clone it.
	else if (getTypeOf(value) === `array`) {
		return quickCloneArray(value);
	}

	// Any other value can just be copied.
	return value;

}

/*
 * Enumerates the given array and returns a new array, with each of its values cloned (i.e. references broken).
 */
function quickCloneArray (input) {
	return input.map(cloneValue);
}

/*
 * Enumerates the properties of the given object (ignoring the prototype chain) and returns a new object, with each of
 * its values cloned (i.e. references broken).
 */
function quickCloneObject (input) {

	const output = {};

	for (const key in input) {
		if (!input.hasOwnProperty(key)) { continue; }

		output[key] = cloneValue(input[key]);
	}

	return output;

}

/*
 * Does the actual deep merging.
 */
function executeDeepMerge (target, _objects = [], _options = {}) {

	const options = {
		arrayBehaviour: _options.arrayBehaviour || `replace`,  // Can be "merge" or "replace".
	};

	// Ensure we have actual objects for each.
	const objects = _objects.map(object => object || {});

	const output = target || {};

	// Enumerate the objects and their keys.
	for (let oindex = 0; oindex < objects.length; oindex++) {
		const object = objects[oindex];
		const keys = Object.keys(object);

		for (let kindex = 0; kindex < keys.length; kindex++) {
			const key = keys[kindex];
			const value = object[key];
			const type = getTypeOf(value);
			const existingValueType = getTypeOf(output[key]);

			if (type === `object`) {
				if (existingValueType !== `undefined`) {
					const existingValue = (existingValueType === `object` ? output[key] : {});
					output[key] = executeDeepMerge({}, [existingValue, quickCloneObject(value)], options);
				}
				else {
					output[key] = quickCloneObject(value);
				}
			}

			else if (type === `array`) {
				if (existingValueType === `array`) {
					const newValue = quickCloneArray(value);
					output[key] = (options.arrayBehaviour === `merge` ? output[key].concat(newValue) : newValue);
				}
				else {
					output[key] = quickCloneArray(value);
				}
			}

			else {
				output[key] = value;
			}


		}
	}

	return output;

}

/*
 * Merge all the supplied objects into the target object, breaking all references, including those of nested objects
 * and arrays, and even objects nested inside arrays. The first parameter is not mutated unlike Object.assign().
 * Properties in later objects will always overwrite.
 */
module.exports = function objectAssignDeep (target, ...objects) {
	return executeDeepMerge(target, objects);
};

/*
 * Same as objectAssignDeep() except it doesn't mutate the target object and returns an entirely new object.
 */
module.exports.noMutate = function objectAssignDeepInto (...objects) {
	return executeDeepMerge({}, objects);
};

/*
 * Allows an options object to be passed in to customise the behaviour of the function.
 */
module.exports.withOptions = function objectAssignDeepInto (target, objects, options) {
	return executeDeepMerge(target, objects, options);
};

},{}],334:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var AudioContext = window.AudioContext || window.webkitAudioContext;

/**
 * Expose a unique audio context singleton as the default audio
 * context used by the components of the Waves Audio library and
 * applications using the library.
 *
 * @type AudioContext
 * @name audioContext
 * @constant
 * @global
 * @instance
 *
 * @example
 * import * as audio from 'waves-audio';
 * const audioContext = audio.audioContext;
 */
var audioContext = null;

if (AudioContext) {
  audioContext = new AudioContext();

  if (/(iPhone|iPad)/i.test(navigator.userAgent) && audioContext.sampleRate < 44100) {
    var buffer = audioContext.createBuffer(1, 1, 44100);
    var dummy = audioContext.createBufferSource();
    dummy.buffer = buffer;
    dummy.connect(audioContext.destination);
    dummy.start(0);
    dummy.disconnect();
  }
}

exports.default = audioContext;

},{}],335:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _timeEngine = require('./time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _audioContext = require('./audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This is the base class for all audio related time engine components. It is
 * used to handle audio related events such as the playback of a media stream.
 * It extends the TimeEngine class by the standard web audio node methods
 * connect and disconnect.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/audio-time-engine.html}
 *
 * @extends TimeEngine
 * @example
 * import audio from 'waves-audio';
 *
 * class MyEngine extends audio.AudioTimeEngine {
 *   constructor() {
 *     super();
 *     // ...
 *   }
 * }
 */
var AudioTimeEngine = function (_TimeEngine) {
  (0, _inherits3.default)(AudioTimeEngine, _TimeEngine);

  function AudioTimeEngine() {
    var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;
    (0, _classCallCheck3.default)(this, AudioTimeEngine);

    /**
     * Audio context used by the TimeEngine, default to the global audioContext
     *
     * @name audioContext
     * @type AudioContext
     * @memberof AudioTimeEngine
     * @see audioContext
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (AudioTimeEngine.__proto__ || (0, _getPrototypeOf2.default)(AudioTimeEngine)).call(this));

    _this.audioContext = audioContext;

    /**
     * Output audio node. By default the connect method connects a given node
     * to this output node.
     *
     * @name outputNode
     * @type AudioNode
     * @memberof AudioTimeEngine
     * @default null
     */
    _this.outputNode = null;
    return _this;
  }

  /**
   * Connect to an audio node (e.g. audioContext.destination)
   *
   * @param {AudioNode} target - Target audio node
   */


  (0, _createClass3.default)(AudioTimeEngine, [{
    key: 'connect',
    value: function connect(target) {
      this.outputNode.connect(target);
      return this;
    }

    /**
     * Disconnect from an audio node (e.g. audioContext.destination). If undefined
     * disconnect from all target nodes.
     *
     * @param {AudioNode} target - Target audio node.
     */

  }, {
    key: 'disconnect',
    value: function disconnect(connection) {
      this.outputNode.disconnect(connection);
      return this;
    }
  }]);
  return AudioTimeEngine;
}(_timeEngine2.default);

exports.default = AudioTimeEngine;

},{"./audio-context":334,"./time-engine":338,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],336:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// works by reference
function swap(arr, i1, i2) {
  var tmp = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = tmp;
}

// https://jsperf.com/js-for-loop-vs-array-indexof/346
function indexOf(arr, el) {
  var l = arr.length;
  // ignore first element as it can't be a entry
  for (var i = 1; i < l; i++) {
    if (arr[i] === el) {
      return i;
    }
  }

  return -1;
}

/**
 * Define if `time1` should be lower in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isLowerMaxHeap = function _isLowerMaxHeap(time1, time2) {
  return time1 < time2;
};

var _isLowerMinHeap = function _isLowerMinHeap(time1, time2) {
  return time1 > time2;
};

/**
 * Define if `time1` should be higher in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isHigherMaxHeap = function _isHigherMaxHeap(time1, time2) {
  return time1 > time2;
};

var _isHigherMinHeap = function _isHigherMinHeap(time1, time2) {
  return time1 < time2;
};

var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

/**
 * Priority queue implementing a binary heap.
 * Acts as a min heap by default, can be dynamically changed to a max heap
 * by setting `reverse` to true.
 *
 * _note_: the queue creates and maintains a new property (i.e. `queueTime`)
 * to each object added.
 *
 * @param {Number} [heapLength=100] - Default size of the array used to create the heap.
 */

var PriorityQueue = function () {
  function PriorityQueue() {
    var heapLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
    (0, _classCallCheck3.default)(this, PriorityQueue);

    /**
     * Pointer to the first empty index of the heap.
     * @type {Number}
     * @memberof PriorityQueue
     * @name _currentLength
     * @private
     */
    this._currentLength = 1;

    /**
     * Array of the sorted indexes of the entries, the actual heap. Ignore the index 0.
     * @type {Array}
     * @memberof PriorityQueue
     * @name _heap
     * @private
     */
    this._heap = new Array(heapLength + 1);

    /**
     * Type of the queue: `min` heap if `false`, `max` heap if `true`
     * @type {Boolean}
     * @memberof PriorityQueue
     * @name _reverse
     * @private
     */
    this._reverse = null;

    // initialize compare functions
    this.reverse = false;
  }

  /**
   * Time of the first element in the binary heap.
   * @returns {Number}
   */


  (0, _createClass3.default)(PriorityQueue, [{
    key: "_bubbleUp",


    /**
     * Fix the heap by moving an entry to a new upper position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */
    value: function _bubbleUp(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var parentIndex = Math.floor(index / 2);
      var parent = this._heap[parentIndex];

      while (parent && this._isHigher(entry.queueTime, parent.queueTime)) {
        swap(this._heap, index, parentIndex);

        index = parentIndex;
        parentIndex = Math.floor(index / 2);
        parent = this._heap[parentIndex];
      }
    }

    /**
     * Fix the heap by moving an entry to a new lower position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */

  }, {
    key: "_bubbleDown",
    value: function _bubbleDown(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var c1index = index * 2;
      var c2index = c1index + 1;
      var child1 = this._heap[c1index];
      var child2 = this._heap[c2index];

      while (child1 && this._isLower(entry.queueTime, child1.queueTime) || child2 && this._isLower(entry.queueTime, child2.queueTime)) {
        // swap with the minimum child
        var targetIndex = void 0;

        if (child2) targetIndex = this._isHigher(child1.queueTime, child2.queueTime) ? c1index : c2index;else targetIndex = c1index;

        swap(this._heap, index, targetIndex);

        // update to find next children
        index = targetIndex;
        c1index = index * 2;
        c2index = c1index + 1;
        child1 = this._heap[c1index];
        child2 = this._heap[c2index];
      }
    }

    /**
     * Build the heap (from bottom up).
     */

  }, {
    key: "buildHeap",
    value: function buildHeap() {
      // find the index of the last internal node
      // @todo - make sure that's the right way to do.
      var maxIndex = Math.floor((this._currentLength - 1) / 2);

      for (var i = maxIndex; i > 0; i--) {
        this._bubbleDown(i);
      }
    }

    /**
     * Insert a new object in the binary heap and sort it.
     *
     * @param {Object} entry - Entry to insert.
     * @param {Number} time - Time at which the entry should be orderer.
     * @returns {Number} - Time of the first entry in the heap.
     */

  }, {
    key: "insert",
    value: function insert(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        entry.queueTime = time;
        // add the new entry at the end of the heap
        this._heap[this._currentLength] = entry;
        // bubble it up
        this._bubbleUp(this._currentLength);
        this._currentLength += 1;

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Move a given entry to a new position.
     *
     * @param {Object} entry - Entry to move.
     * @param {Number} time - Time at which the entry should be orderer.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "move",
    value: function move(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        var index = indexOf(this._heap, entry);

        if (index !== -1) {
          entry.queueTime = time;
          // define if the entry should be bubbled up or down
          var parent = this._heap[Math.floor(index / 2)];

          if (parent && this._isHigher(time, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
        }

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Remove an entry from the heap and fix the heap.
     *
     * @param {Object} entry - Entry to remove.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "remove",
    value: function remove(entry) {
      // find the index of the entry
      var index = indexOf(this._heap, entry);

      if (index !== -1) {
        var lastIndex = this._currentLength - 1;

        // if the entry is the last one
        if (index === lastIndex) {
          // remove the element from heap
          this._heap[lastIndex] = undefined;
          // update current length
          this._currentLength = lastIndex;

          return this.time;
        } else {
          // swap with the last element of the heap
          swap(this._heap, index, lastIndex);
          // remove the element from heap
          this._heap[lastIndex] = undefined;

          if (index === 1) {
            this._bubbleDown(1);
          } else {
            // bubble the (ex last) element up or down according to its new context
            var _entry = this._heap[index];
            var parent = this._heap[Math.floor(index / 2)];

            if (parent && this._isHigher(_entry.queueTime, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
          }
        }

        // update current length
        this._currentLength = lastIndex;
      }

      return this.time;
    }

    /**
     * Clear the queue.
     */

  }, {
    key: "clear",
    value: function clear() {
      this._currentLength = 1;
      this._heap = new Array(this._heap.length);
    }

    /**
     * Defines if the queue contains the given `entry`.
     *
     * @param {Object} entry - Entry to be checked
     * @return {Boolean}
     */

  }, {
    key: "has",
    value: function has(entry) {
      return this._heap.indexOf(entry) !== -1;
    }
  }, {
    key: "time",
    get: function get() {
      if (this._currentLength > 1) return this._heap[1].queueTime;

      return Infinity;
    }

    /**
     * First element in the binary heap.
     * @returns {Number}
     * @readonly
     */

  }, {
    key: "head",
    get: function get() {
      return this._heap[1];
    }

    /**
     * Change the order of the queue (max heap if true, min heap if false),
     * rebuild the heap with the existing entries.
     *
     * @type {Boolean}
     */

  }, {
    key: "reverse",
    set: function set(value) {
      if (value !== this._reverse) {
        this._reverse = value;

        if (this._reverse === true) {
          this._isLower = _isLowerMaxHeap;
          this._isHigher = _isHigherMaxHeap;
        } else {
          this._isLower = _isLowerMinHeap;
          this._isHigher = _isHigherMinHeap;
        }

        this.buildHeap();
      }
    },
    get: function get() {
      return this._reverse;
    }
  }]);
  return PriorityQueue;
}();

exports.default = PriorityQueue;

},{"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192}],337:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _priorityQueue = require('./priority-queue');

var _priorityQueue2 = _interopRequireDefault(_priorityQueue);

var _timeEngine = require('./time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class SchedulingQueue
 * @extends TimeEngine
 */
/**
 * SchedulingQueue base class
 * http://wavesjs.github.io/audio/#audio-scheduling-queue
 *
 * Norbert.Schnell@ircam.fr
 * Copyright 2014, 2015 IRCAM – Centre Pompidou
 */

var SchedulingQueue = function (_TimeEngine) {
  (0, _inherits3.default)(SchedulingQueue, _TimeEngine);

  function SchedulingQueue() {
    (0, _classCallCheck3.default)(this, SchedulingQueue);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(SchedulingQueue)).call(this));

    _this.__queue = new _priorityQueue2.default();
    _this.__engines = new _set2.default();
    return _this;
  }

  // TimeEngine 'scheduled' interface


  (0, _createClass3.default)(SchedulingQueue, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var engine = this.__queue.head;
      var nextEngineTime = engine.advanceTime(time);

      if (!nextEngineTime) {
        engine.master = null;
        this.__engines.delete(engine);
        this.__queue.remove(engine);
      } else {
        this.__queue.move(engine, nextEngineTime);
      }

      return this.__queue.time;
    }

    // TimeEngine master method to be implemented by derived class

  }, {
    key: 'defer',


    // call a function at a given time
    value: function defer(fun) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!(fun instanceof Function)) throw new Error("object cannot be defered by scheduler");

      this.add({
        advanceTime: function advanceTime(time) {
          fun(time);
        } // make sur that the advanceTime method does not returm anything
      }, time);
    }

    // add a time engine to the scheduler

  }, {
    key: 'add',
    value: function add(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!_timeEngine2.default.implementsScheduled(engine)) throw new Error("object cannot be added to scheduler");

      if (engine.master) throw new Error("object has already been added to a master");

      engine.master = this;

      // add to engines and queue
      this.__engines.add(engine);
      var nextTime = this.__queue.insert(engine, time);

      // reschedule queue
      this.resetTime(nextTime);
    }

    // remove a time engine from the queue

  }, {
    key: 'remove',
    value: function remove(engine) {
      if (engine.master !== this) throw new Error("object has not been added to this scheduler");

      engine.master = null;

      // remove from array and queue
      this.__engines.delete(engine);
      var nextTime = this.__queue.remove(engine);

      // reschedule queue
      this.resetTime(nextTime);
    }

    // reset next engine time

  }, {
    key: 'resetEngineTime',
    value: function resetEngineTime(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (engine.master !== this) throw new Error("object has not been added to this scheduler");

      var nextTime = void 0;

      if (this.__queue.has(engine)) nextTime = this.__queue.move(engine, time);else nextTime = this.__queue.insert(engine, time);

      this.resetTime(nextTime);
    }

    // check whether a given engine is scheduled

  }, {
    key: 'has',
    value: function has(engine) {
      return this.__engines.has(engine);
    }

    // clear queue

  }, {
    key: 'clear',
    value: function clear() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__engines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var engine = _step.value;

          engine.master = null;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.__queue.clear();
      this.__engines.clear();
      this.resetTime(Infinity);
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return 0;
    }
  }]);
  return SchedulingQueue;
}(_timeEngine2.default);

exports.default = SchedulingQueue;

},{"./priority-queue":336,"./time-engine":338,"babel-runtime/core-js/get-iterator":175,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/core-js/set":187,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],338:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base class for time engines
 *
 * A time engine generates more or less regular events and/or plays back a
 * media stream. It implements one or multiple interfaces to be driven by a
 * master (i.e. a Scheduler, a Transport or a PlayControl) in synchronization
 * with other engines. The provided interfaces are scheduled, transported,
 * and play-controlled.
 *
 *
 * #### The `scheduled` interface
 *
 * The scheduled interface allows for synchronizing an engine to a monotonous time
 * as it is provided by the Scheduler master.
 *
 * ###### `advanceTime(time :Number) -> {Number}`
 *
 * The `advanceTime` method has to be implemented by an `TimeEngine` as part of the
 * scheduled interface. The method is called by the master (e.g. the scheduler).
 * It generates an event and to returns the time of the next event (i.e. the next
 * call of advanceTime). The returned time has to be greater than the time
 * received as argument of the method. In case that a TimeEngine has to generate
 * multiple events at the same time, the engine has to implement its own loop
 * while(event.time <= time) and return the time of the next event (if any).
 *
 * ###### `resetTime(time=undefined :Number)`
 *
 * The `resetTime` method is provided by the `TimeEngine` base class. An engine may
 * call this method to reset its next event time (e.g. when a parameter is
 * changed that influences the engine's temporal behavior). When no argument
 * is given, the time is reset to the current master time. When calling the
 * method with Infinity the engine is suspended without being removed from the
 * master.
 *
 *
 * #### The `transported` interface
 *
 * The transported interface allows for synchronizing an engine to a position
 * (i.e. media playback time) that can run forward and backward and jump as it
 * is provided by the Transport master.
 *
 * ###### `syncPosition(time :Number, position :Number, speed :Number) -> {Number}`
 *
 * The `syncPositon` method has to be implemented by a `TimeEngine` as part of the
 * transported interface. The method syncPositon is called whenever the master
 * of a transported engine has to (re-)synchronize the engine's position. This
 * is for example required when the master (re-)starts playback, jumps to an
 * arbitrary position, and when reversing playback direction. The method returns
 * the next position of the engine in the given playback direction
 * (i.e. `speed < 0` or `speed > 0`).
 *
 * ###### `advancePosition(time :Number, position :Number, speed :Number) -> {Number}`
 *
 * The `advancePosition` method has to be implemented by a `TimeEngine` as part
 * of the transported interface. The master calls the advancePositon method when
 * the engine's event position is reached. The method generates an event and
 * returns the next position in the given playback direction (i.e. speed < 0 or
 * speed > 0). The returned position has to be greater (i.e. when speed > 0)
 * or less (i.e. when speed < 0) than the position received as argument of the
 * method.
 *
 * ###### `resetPosition(position=undefined :Number)`
 *
 * The resetPosition method is provided by the TimeEngine base class. An engine
 * may call this method to reset its next event position. When no argument
 * is given, the time is reset to the current master time. When calling the
 * method with Infinity the engine is suspended without being removed from
 * the master.
 *
 *
 * #### The speed-controlled interface
 *
 * The "speed-controlled" interface allows for syncronizing an engine that is
 * neither driven through the scheduled nor the transported interface. The
 * interface allows in particular to synchronize engines that assure their own
 * scheduling (i.e. audio player or an oscillator) to the event-based scheduled
 * and transported engines.
 *
 * ###### `syncSpeed(time :Number, position :Number, speed :Number, seek=false :Boolean)`
 *
 * The syncSpeed method has to be implemented by a TimeEngine as part of the
 * speed-controlled interface. The method is called by the master whenever the
 * playback speed changes or the position jumps arbitarily (i.e. on a seek).
 *
 *
 * <hr />
 *
 * Example that shows a `TimeEngine` running in a `Scheduler` that counts up
 * at a given frequency:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/time-engine.html}
 *
 * @example
 * import * as audio from 'waves-audio';
 *
 * class MyEngine extends audio.TimeEngine {
 *   constructor() {
 *     super();
 *     // ...
 *   }
 * }
 *
 */
var TimeEngine = function () {
  function TimeEngine() {
    (0, _classCallCheck3.default)(this, TimeEngine);

    /**
     * The engine's master.
     *
     * @type {Mixed}
     * @name master
     * @memberof TimeEngine
     */
    this.master = null;
  }

  /**
   * The time engine's current (master) time.
   *
   * @type {Number}
   * @memberof TimeEngine
   * @readonly
   */


  (0, _createClass3.default)(TimeEngine, [{
    key: "resetTime",
    value: function resetTime() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (this.master) this.master.resetEngineTime(this, time);
    }

    /**
     * Transported interface
     *   - syncPosition(time, position, speed), called to reposition TimeEngine, returns next position
     *   - advancePosition(time, position, speed), called to generate next event at given time and position, returns next position
     *
     * @static
     * @memberof TimeEngine
     */

  }, {
    key: "resetPosition",
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (this.master) this.master.resetEnginePosition(this, position);
    }

    /**
     * Speed-controlled interface
     *   - syncSpeed(time, position, speed, ), called to
     *
     * @static
     * @memberof TimeEngine
     */

  }, {
    key: "currentTime",
    get: function get() {
      if (this.master) return this.master.currentTime;

      return undefined;
    }

    /**
     * The time engine's current (master) position.
     *
     * @type {Number}
     * @memberof TimeEngine
     * @readonly
     */

  }, {
    key: "currentPosition",
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return undefined;
    }

    /**
     * Scheduled interface
     *   - advanceTime(time), called to generate next event at given time, returns next time
     *
     * @static
     * @memberof TimeEngine
     */

  }], [{
    key: "implementsScheduled",
    value: function implementsScheduled(engine) {
      return engine.advanceTime && engine.advanceTime instanceof Function;
    }
  }, {
    key: "implementsTransported",
    value: function implementsTransported(engine) {
      return engine.syncPosition && engine.syncPosition instanceof Function && engine.advancePosition && engine.advancePosition instanceof Function;
    }
  }, {
    key: "implementsSpeedControlled",
    value: function implementsSpeedControlled(engine) {
      return engine.syncSpeed && engine.syncSpeed instanceof Function;
    }
  }]);
  return TimeEngine;
}();

exports.default = TimeEngine;

},{"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192}],339:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Granular synthesis TimeEngine implementing the scheduled interface.
 * The grain position (grain onset or center time in the audio buffer) is
 * optionally determined by the engine's currentPosition attribute.
 *
 * Example that shows a `GranularEngine` (with a few parameter controls) driven
 * by a `Scheduler` and a `PlayControl`:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/granular-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const granularEngine = new audio.GranularEngine();
 *
 * scheduler.add(granularEngine);
 *
 *
 * @param {Object} options={} - Parameters
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0.01] - Absolute grain period in sec
 * @param {Number} [options.periodRel=0] - Grain period relative to absolute
 *  duration
 * @param {Number} [options.periodVar=0] - Amout of random grain period
 *  variation relative to grain period
 * @param {Number} [options.periodMin=0.001] - Minimum grain period
 * @param {Number} [options.position=0] - Grain position (onset time in audio
 *  buffer) in sec
 * @param {Number} [options.positionVar=0.003] - Amout of random grain position
 *  variation in sec
 * @param {Number} [options.durationAbs=0.1] - Absolute grain duration in sec
 * @param {Number} [options.durationRel=0] - Grain duration relative to grain
 *  period (overlap)
 * @param {Number} [options.attackAbs=0] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0.5] - Attack time relative to grain duration
 * @param {String} [options.attackShape='lin'] - Shape of attack
 * @param {Number} [options.releaseAbs=0] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0.5] - Release time relative to grain duration
 * @param {Number} [options.releaseShape='lin'] - Shape of release
 * @param {String} [options.expRampOffset=0.0001] - Offset (start/end value)
 *  for exponential attack/release
 * @param {Number} [options.resampling=0] - Grain resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Boolean} [options.centered=true] - Whether the grain position refers
 *  to the center of the grain (or the beginning)
 * @param {Boolean} [options.cyclic=false] - Whether the audio buffer and grain
 *  position are considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the
 *  audio buffer that has been copied from the beginning to assure cyclic behavior
 */

var GranularEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(GranularEngine, _AudioTimeEngine);

  function GranularEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, GranularEngine);

    /**
     * Audio buffer
     *
     * @type {AudioBuffer}
     * @name buffer
     * @default null
     * @memberof GranularEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (GranularEngine.__proto__ || (0, _getPrototypeOf2.default)(GranularEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute grain period in sec
     *
     * @type {Number}
     * @name periodAbs
     * @default 0.01
     * @memberof GranularEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0.01);

    /**
     * Grain period relative to absolute duration
     *
     * @type {Number}
     * @name periodRel
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 0);

    /**
     * Amout of random grain period variation relative to grain period
     *
     * @type {Number}
     * @name periodVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum grain period
     *
     * @type {Number}
     * @name periodMin
     * @default 0.001
     * @memberof GranularEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Grain position (onset time in audio buffer) in sec
     *
     * @type {Number}
     * @name position
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.position = optOrDef(options.position, 0);

    /**
     * Amout of random grain position variation in sec
     *
     * @type {Number}
     * @name positionVar
     * @default 0.003
     * @memberof GranularEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0.003);

    /**
     * Absolute grain duration in sec
     *
     * @type {Number}
     * @name durationAbs
     * @default 0.1
     * @memberof GranularEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0.1); // absolute grain duration

    /**
     * Grain duration relative to grain period (overlap)
     *
     * @type {Number}
     * @name durationRel
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 0);

    /**
     * Absolute attack time in sec
     *
     * @type {Number}
     * @name attackAbs
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0);

    /**
     * Attack time relative to grain duration
     *
     * @type {Number}
     * @name attackRel
     * @default 0.5
     * @memberof GranularEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0.5);

    /**
     * Shape of attack ('lin' for linear ramp, 'exp' for exponential ramp)
     *
     * @type {String}
     * @name attackShape
     * @default 'lin'
     * @memberof GranularEngine
     * @instance
     */
    _this.attackShape = optOrDef(options.attackShape, 'lin');

    /**
     * Absolute release time in sec
     *
     * @type {Number}
     * @name releaseAbs
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0);

    /**
     * Release time relative to grain duration
     *
     * @type {Number}
     * @name releaseRel
     * @default 0.5
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0.5);

    /**
     * Shape of release ('lin' for linear ramp, 'exp' for exponential ramp)
     *
     * @type {String}
     * @name releaseShape
     * @default 'lin'
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseShape = optOrDef(options.releaseShape, 'lin');

    /**
     * Offset (start/end value) for exponential attack/release
     *
     * @type {Number}
     * @name expRampOffset
     * @default 0.0001
     * @memberof GranularEngine
     * @instance
     */
    _this.expRampOffset = optOrDef(options.expRampOffset, 0.0001);

    /**
     * Grain resampling in cent
     *
     * @type {Number}
     * @name resampling
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     *
     * @type {Number}
     * @name resamplingVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     *
     * @type {Number}
     * @name gain
     * @default 1
     * @memberof GranularEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Whether the grain position refers to the center of the grain (or the beginning)
     *
     * @type {Boolean}
     * @name centered
     * @default true
     * @memberof GranularEngine
     * @instance
     */
    _this.centered = optOrDef(options.centered, true);

    /**
     * Whether the audio buffer and grain position are considered as cyclic
     *
     * @type {Boolean}
     * @name cyclic
     * @default false
     * @memberof GranularEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);

    /**
     * Portion at the end of the audio buffer that has been copied from the
     * beginning to assure cyclic behavior
     *
     * @type {Number}
     * @name wrapAroundExtension
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @name bufferDuration
   * @memberof GranularEngine
   * @instance
   * @readonly
   */


  (0, _createClass3.default)(GranularEngine, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    /**
     * Trigger a grain. This function can be called at any time (whether the
     * engine is scheduled or not) to generate a single grain according to the
     * current grain parameters.
     *
     * @param {Number} time - grain synthesis audio time
     * @return {Number} - period to next grain
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var grainTime = time || audioContext.currentTime;
      var grainPeriod = this.periodAbs;
      var grainPosition = this.currentPosition;
      var grainDuration = this.durationAbs;

      if (this.buffer) {
        var resamplingRate = 1.0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        grainPeriod += this.periodRel * grainDuration;
        grainDuration += this.durationRel * grainPeriod;

        // grain period randon variation
        if (this.periodVar > 0.0) grainPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

        // center grain
        if (this.centered) grainPosition -= 0.5 * grainDuration;

        // randomize grain position
        if (this.positionVar > 0) grainPosition += (2.0 * Math.random() - 1) * this.positionVar;

        var bufferDuration = this.bufferDuration;

        // wrap or clip grain position and duration into buffer duration
        if (grainPosition < 0 || grainPosition >= bufferDuration) {
          if (this.cyclic) {
            var cycles = grainPosition / bufferDuration;
            grainPosition = (cycles - Math.floor(cycles)) * bufferDuration;

            if (grainPosition + grainDuration > this.buffer.duration) grainDuration = this.buffer.duration - grainPosition;
          } else {
            if (grainPosition < 0) {
              grainTime -= grainPosition;
              grainDuration += grainPosition;
              grainPosition = 0;
            }

            if (grainPosition + grainDuration > bufferDuration) grainDuration = bufferDuration - grainPosition;
          }
        }

        // make grain
        if (this.gain > 0 && grainDuration >= 0.001) {
          // make grain envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * grainDuration;
          var release = this.releaseAbs + this.releaseRel * grainDuration;

          if (attack + release > grainDuration) {
            var factor = grainDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = grainTime + attack;
          var grainEndTime = grainTime + grainDuration / resamplingRate;
          var releaseStartTime = grainEndTime - release;

          envelope.gain.value = 0;

          if (this.attackShape === 'lin') {
            envelope.gain.setValueAtTime(0.0, grainTime);
            envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);
          } else {
            envelope.gain.setValueAtTime(this.expRampOffset, grainTime);
            envelope.gain.exponentialRampToValueAtTime(this.gain, attackEndTime);
          }

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          if (this.releaseShape === 'lin') {
            envelope.gain.linearRampToValueAtTime(0.0, grainEndTime);
          } else {
            envelope.gain.exponentialRampToValueAtTime(this.expRampOffset, grainEndTime);
          }

          envelope.connect(this.outputNode);

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(grainTime, grainPosition);
          source.stop(grainEndTime);
        }
      }

      return Math.max(this.periodMin, grainPeriod);
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }

    /**
     * Current position
     *
     * @type {Number}
     * @name currentPosition
     * @memberof GranularEngine
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.position;
    }
  }]);
  return GranularEngine;
}(_audioTimeEngine2.default);

exports.default = GranularEngine;

},{"../core/audio-time-engine":335,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],340:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Metronome audio engine. It extends Time Engine as a transported interface.
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/metronome.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const metronome = new audio.Metronome({period: 0.333});
 *
 * scheduler.add(metronome);
 *
 * @param {Object} [options={}] - Default options
 * @param {Number} [options.period=1] - Metronome period
 * @param {Number} [options.clickFreq=600] - Metronome click frequency
 * @param {Number} [options.clickAttack=0.002] - Metronome click attack time
 * @param {Number} [options.clickRelease=0.098] - Metronome click release time
 * @param {Number} [options.gain=1] - Gain
 */

var Metronome = function (_AudioTimeEngine) {
  (0, _inherits3.default)(Metronome, _AudioTimeEngine);

  function Metronome() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Metronome);

    /**
     * Metronome period
     * @type {Number}
     * @private
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (Metronome.__proto__ || (0, _getPrototypeOf2.default)(Metronome)).call(this, options.audioContext));

    _this.__period = optOrDef(options.period, 1);

    /**
     * Metronome click frequency
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickFreq
     * @instance
     */
    _this.clickFreq = optOrDef(options.clickFreq, 600);

    /**
     * Metronome click attack time
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickAttack
     * @instance
     */
    _this.clickAttack = optOrDef(options.clickAttack, 0.002);

    /**
     * Metronome click release time
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickRelease
     * @instance
     */
    _this.clickRelease = optOrDef(options.clickRelease, 0.098);

    _this.__lastTime = 0;
    _this.__phase = 0;

    _this.__gainNode = _this.audioContext.createGain();
    _this.__gainNode.gain.value = optOrDef(options.gain, 1);

    _this.outputNode = _this.__gainNode;
    return _this;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(Metronome, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      this.trigger(time);
      this.__lastTime = time;
      return time + this.__period;
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (this.__period > 0) {
        var nextPosition = (Math.floor(position / this.__period) + this.__phase) * this.__period;

        if (speed > 0 && nextPosition < position) nextPosition += this.__period;else if (speed < 0 && nextPosition > position) nextPosition -= this.__period;

        return nextPosition;
      }

      return Infinity * speed;
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      this.trigger(time);

      if (speed < 0) return position - this.__period;

      return position + this.__period;
    }

    /**
     * Trigger metronome click
     * @param {Number} time metronome click synthesis audio time
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var clickAttack = this.clickAttack;
      var clickRelease = this.clickRelease;

      var env = audioContext.createGain();
      env.gain.value = 0.0;
      env.gain.setValueAtTime(0, time);
      env.gain.linearRampToValueAtTime(1.0, time + clickAttack);
      env.gain.exponentialRampToValueAtTime(0.0000001, time + clickAttack + clickRelease);
      env.gain.setValueAtTime(0, time);
      env.connect(this.outputNode);

      var osc = audioContext.createOscillator();
      osc.frequency.value = this.clickFreq;
      osc.start(time);
      osc.stop(time + clickAttack + clickRelease);
      osc.connect(env);
    }

    /**
     * linear gain factor
     *
     * @type {Number}
     * @name gain
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'gain',
    set: function set(value) {
      this.__gainNode.gain.value = value;
    },
    get: function get() {
      return this.__gainNode.gain.value;
    }

    /**
     * metronome period
     *
     * @type {Number}
     * @name period
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'period',
    set: function set(period) {
      this.__period = period;

      var master = this.master;

      if (master) {
        if (master.resetEngineTime) master.resetEngineTime(this, this.__lastTime + period);else if (master.resetEnginePosition) master.resetEnginePosition(this);
      }
    },
    get: function get() {
      return this.__period;
    }

    /**
     * Set phase parameter (available only when 'transported'), should be
     * between [0, 1[
     *
     * @type {Number}
     * @name phase
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'phase',
    set: function set(phase) {
      this.__phase = phase - Math.floor(phase);

      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this);
    },
    get: function get() {
      return this.__phase;
    }
  }]);
  return Metronome;
}(_audioTimeEngine2.default);

exports.default = Metronome;

},{"../core/audio-time-engine":335,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],341:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Used with a buffer to serve audio files.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/player-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const playerEngine = audio.PlayerEngine();
 * const playControl = new audio.PlayControl(playerEngine);
 *
 * playControl.start();
 *
 * @param {Object} [options={}] - Default options
 * @param {Number} [options.buffer=1] - Audio buffer
 * @param {Number} [options.fadeTime=600] - Fade time for chaining segments
 * @param {Number} [options.cyclic=false] - Loop mode
 * @param {Number} [options.gain=1] - Gain
 */

var PlayerEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(PlayerEngine, _AudioTimeEngine);

  function PlayerEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, PlayerEngine);

    var _this = (0, _possibleConstructorReturn3.default)(this, (PlayerEngine.__proto__ || (0, _getPrototypeOf2.default)(PlayerEngine)).call(this, options.audioContext));

    _this.transport = null; // set when added to transporter

    /**
     * Audio buffer
     *
     * @type {AudioBuffer}
     * @name buffer
     * @memberof PlayerEngine
     * @instance
     * @default null
     */
    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Fade time for chaining segments (e.g. in start, stop, and seek)
     *
     * @type {Number}
     * @name fadeTime
     * @memberof PlayerEngine
     * @instance
     * @default 0.005
     */
    _this.fadeTime = optOrDef(options.fadeTime, 0.005);

    _this.__time = 0;
    _this.__position = 0;
    _this.__speed = 0;

    _this.__bufferSource = null;
    _this.__envNode = null;

    _this.__gainNode = _this.audioContext.createGain();
    _this.__gainNode.gain.value = optOrDef(options.gain, 1);

    _this.__cyclic = optOrDef(options.cyclic, false);

    _this.outputNode = _this.__gainNode;
    return _this;
  }

  (0, _createClass3.default)(PlayerEngine, [{
    key: '__start',
    value: function __start(time, position, speed) {
      var audioContext = this.audioContext;

      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.__cyclic && (position < 0 || position >= bufferDuration)) {
          var phase = position / bufferDuration;
          position = (phase - Math.floor(phase)) * bufferDuration;
        }

        if (position >= 0 && position < bufferDuration && speed > 0) {
          this.__envNode = audioContext.createGain();
          this.__envNode.gain.setValueAtTime(0, time);
          this.__envNode.gain.linearRampToValueAtTime(1, time + this.fadeTime);
          this.__envNode.connect(this.__gainNode);

          this.__bufferSource = audioContext.createBufferSource();
          this.__bufferSource.buffer = this.buffer;
          this.__bufferSource.playbackRate.value = speed;
          this.__bufferSource.loop = this.__cyclic;
          this.__bufferSource.loopStart = 0;
          this.__bufferSource.loopEnd = bufferDuration;
          this.__bufferSource.start(time, position);
          this.__bufferSource.connect(this.__envNode);
        }
      }
    }
  }, {
    key: '__halt',
    value: function __halt(time) {
      if (this.__bufferSource) {
        this.__envNode.gain.cancelScheduledValues(time);
        this.__envNode.gain.setValueAtTime(this.__envNode.gain.value, time);
        this.__envNode.gain.linearRampToValueAtTime(0, time + this.fadeTime);
        this.__bufferSource.stop(time + this.fadeTime);

        this.__bufferSource = null;
        this.__envNode = null;
      }
    }

    // TimeEngine method (speed-controlled interface)

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      if (speed !== lastSpeed || seek) {
        if (seek || lastSpeed * speed < 0) {
          this.__halt(time);
          this.__start(time, position, speed);
        } else if (lastSpeed === 0 || seek) {
          this.__start(time, position, speed);
        } else if (speed === 0) {
          this.__halt(time);
        } else if (this.__bufferSource) {
          this.__bufferSource.playbackRate.setValueAtTime(speed, time);
        }

        this.__speed = speed;
      }
    }

    /**
     * Set whether the audio buffer is considered as cyclic
     * @type {Bool}
     * @name cyclic
     * @memberof PlayerEngine
     * @instance
     */

  }, {
    key: 'cyclic',
    set: function set(cyclic) {
      if (cyclic !== this.__cyclic) {
        var time = this.currentTime;
        var position = this.currentosition;

        this.__halt(time);
        this.__cyclic = cyclic;

        if (this.__speed !== 0) this.__start(time, position, this.__speed);
      }
    },
    get: function get() {
      return this.__cyclic;
    }

    /**
     * Linear gain factor
     * @type {Number}
     * @name gain
     * @memberof PlayerEngine
     * @instance
     */

  }, {
    key: 'gain',
    set: function set(value) {
      var time = this.currentTime;
      this.__gainNode.cancelScheduledValues(time);
      this.__gainNode.setValueAtTime(this.__gainNode.gain.value, time);
      this.__gainNode.linearRampToValueAtTime(0, time + this.fadeTime);
    },
    get: function get() {
      return this.__gainNode.gain.value;
    }

    /**
     * Get buffer duration
     * @type {Number}
     * @name bufferDuration
     * @memberof PlayerEngine
     * @instance
     * @readonly
     */

  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) return this.buffer.duration;

      return 0;
    }
  }]);
  return PlayerEngine;
}(_audioTimeEngine2.default);

exports.default = PlayerEngine;

},{"../core/audio-time-engine":335,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],342:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] > value) {
        index--;
      }while (sortedArray[index + 1] <= value) {
        index++;
      }
    }
  }

  return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] < value) {
        index++;
      }while (sortedArray[index - 1] >= value) {
        index--;
      }
    }
  }

  return index;
}

/**
 * Used with a buffer to serve audio files via granular synthesis.
 *
 * The engine implements the "scheduled" and "transported" interfaces.
 * When "scheduled", the engine  generates segments more or less periodically
 * (controlled by the periodAbs, periodRel, and perioVar attributes).
 * When "transported", the engine generates segments at the position of their onset time.
 *
 * Example that shows a `SegmentEngine` with a few parameter controls running in a `Scheduler`.
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/segment-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const segmentEngine = new audio.SegmentEngine();
 *
 * scheduler.add(segmentEngine);
 *
 * @param {Object} [options={}] - Default options
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0] - Absolute segment period in sec
 * @param {Number} [options.periodRel=1] - Segment period relative to inter-segment distance
 * @param {Number} [options.periodVar=0] - Amout of random segment period variation relative
 *  to segment period
 * @param {Number} [options.periodMin=0.001] - Minimum segment period
 * @param {Number} [options.positionArray=[0.0]] - Array of segment positions (onset times
 *  in audio buffer) in sec
 * @param {Number} [options.positionVar=0] - Amout of random segment position variation in sec
 * @param {Number} [options.durationArray=[0.0]] - Array of segment durations in sec
 * @param {Number} [options.durationAbs=0] - Absolute segment duration in sec
 * @param {Number} [options.durationRel=1] - Segment duration relative to given segment
 *  duration or inter-segment distance
 * @param {Array} [options.offsetArray=[0.0]] - Array of segment offsets in sec
 * @param {Number} [options.offsetAbs=-0.005] - Absolute segment offset in sec
 * @param {Number} [options.offsetRel=0] - Segment offset relative to segment duration
 * @param {Number} [options.delay=0.005] - Time by which all segments are delayed (especially
 *  to realize segment offsets)
 * @param {Number} [options.attackAbs=0.005] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0] - Attack time relative to segment duration
 * @param {Number} [options.releaseAbs=0.005] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0] - Release time relative to segment duration
 * @param {Number} [options.resampling=0] - Segment resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Number} [options.abortTime=0.005] - fade-out time when aborted
 * @param {Number} [options.segmentIndex=0] - Index of the segment to synthesize (i.e. of
 *  this.positionArray/durationArray/offsetArray)
 * @param {Bool} [options.cyclic=false] - Whether the audio buffer and segment indices are
 *  considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the audio buffer
 *  that has been copied from the beginning to assure cyclic behavior
 */

var SegmentEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(SegmentEngine, _AudioTimeEngine);

  function SegmentEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SegmentEngine);

    /**
     * Audio buffer
     * @name buffer
     * @type {AudioBuffer}
     * @default null
     * @memberof SegmentEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (SegmentEngine.__proto__ || (0, _getPrototypeOf2.default)(SegmentEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute segment period in sec
     * @name periodAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0);

    /**
     * Segment period relative to inter-segment distance
     * @name periodRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 1);

    /**
     * Amout of random segment period variation relative to segment period
     * @name periodVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum segment period
     * @name periodMin
     * @type {Number}
     * @default 0.001
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Array of segment positions (onset times in audio buffer) in sec
     * @name positionArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionArray = optOrDef(options.positionArray, [0.0]);

    /**
     * Amout of random segment position variation in sec
     * @name positionVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0);

    /**
     * Array of segment durations in sec
     * @name durationArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationArray = optOrDef(options.durationArray, [0.0]);

    /**
     * Absolute segment duration in sec
     * @name durationAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0);

    /**
     * Segment duration relative to given segment duration or inter-segment distance
     * @name durationRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 1);

    /**
     * Array of segment offsets in sec
     *
     * offset > 0: the segment's reference position is after the given segment position
     * offset < 0: the given segment position is the segment's reference position
     * and the duration has to be corrected by the offset
     *
     * @name offsetArray
     * @type {Array}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetArray = optOrDef(options.offsetArray, [0.0]);

    /**
     * Absolute segment offset in sec
     * @name offsetAbs
     * @type {Number}
     * @default -0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetAbs = optOrDef(options.offsetAbs, -0.005);

    /**
     * Segment offset relative to segment duration
     * @name offsetRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetRel = optOrDef(options.offsetRel, 0);

    /**
     * Time by which all segments are delayed (especially to realize segment offsets)
     * @name delay
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.delay = optOrDef(options.delay, 0.005);

    /**
     * Absolute attack time in sec
     * @name attackAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0.005);

    /**
     * Attack time relative to segment duration
     * @name attackRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0);

    /**
     * Absolute release time in sec
     * @name releaseAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0.005);

    /**
     * Release time relative to segment duration
     * @name releaseRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0);

    /**
     * Segment resampling in cent
     * @name resampling
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     * @name resamplingVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     * @name gain
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Index of the segment to synthesize (i.e. of this.positionArray/durationArray/offsetArray)
     * @name segmentIndex
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.segmentIndex = optOrDef(options.segmentIndex, 0);

    /**
     * Whether the audio buffer and segment indices are considered as cyclic
     * @name cyclic
     * @type {Bool}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);
    _this.__cyclicOffset = 0;

    /**
     * Whether the last segment is aborted when triggering the next
     * @name monophonic
     * @type {Number}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.monophonic = optOrDef(options.monophonic, false);
    _this.__currentSrc = null;
    _this.__currentEnv = null;
    _this.__releaseStartTime = 0;
    _this.__currentGain = 0;
    _this.__currentEndTime = 0;

    /**
     * Fade-out time (when aborted)
     * @name abortTime
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.abortTime = optOrDef(options.abortTime, 0.005);

    /**
     * Portion at the end of the audio buffer that has been copied from the beginning to assure cyclic behavior
     * @name wrapAroundExtension
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @default 0
   * @memberof SegmentEngine
   * @instance
   */


  (0, _createClass3.default)(SegmentEngine, [{
    key: 'advanceTime',


    // TimeEngine method (transported interface)
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = 0;
      var bufferDuration = this.bufferDuration;

      if (this.cyclic) {
        var cycles = position / bufferDuration;

        cyclicOffset = Math.floor(cycles) * bufferDuration;
        position -= cyclicOffset;
      }

      if (speed > 0) {
        index = getCurrentOrNextIndex(this.positionArray, position);

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else if (speed < 0) {
        index = getCurrentOrPreviousIndex(this.positionArray, position);

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      } else {
        return Infinity;
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = this.__cyclicOffset;

      this.trigger(time);

      if (speed > 0) {
        index++;

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += this.bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else {
        index--;

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= this.bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    /**
     * Trigger a segment.
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     *
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var segmentTime = (time || audioContext.currentTime) + this.delay;
      var segmentPeriod = this.periodAbs;
      var segmentIndex = this.segmentIndex;

      if (this.buffer) {
        var segmentPosition = 0.0;
        var segmentDuration = 0.0;
        var segmentOffset = 0.0;
        var resamplingRate = 1.0;
        var bufferDuration = this.bufferDuration;

        if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

        if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

        if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

        if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // calculate inter-segment distance
        if (segmentDuration === 0 || this.periodRel > 0) {
          var nextSegmentIndex = segmentIndex + 1;
          var nextPosition, nextOffset;

          if (nextSegmentIndex === this.positionArray.length) {
            if (this.cyclic) {
              nextPosition = this.positionArray[0] + bufferDuration;
              nextOffset = this.offsetArray[0];
            } else {
              nextPosition = bufferDuration;
              nextOffset = 0;
            }
          } else {
            nextPosition = this.positionArray[nextSegmentIndex];
            nextOffset = this.offsetArray[nextSegmentIndex];
          }

          var interSegmentDistance = nextPosition - segmentPosition;

          // correct inter-segment distance by offsets
          //   offset > 0: the segment's reference position is after the given segment position
          if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

          if (nextOffset > 0) interSegmentDistance += nextOffset;

          if (interSegmentDistance < 0) interSegmentDistance = 0;

          // use inter-segment distance instead of segment duration
          if (segmentDuration === 0) segmentDuration = interSegmentDistance;

          // calculate period relative to inter marker distance
          segmentPeriod += this.periodRel * interSegmentDistance;
        }

        // add relative and absolute segment duration
        segmentDuration *= this.durationRel;
        segmentDuration += this.durationAbs;

        // add relative and absolute segment offset
        segmentOffset *= this.offsetRel;
        segmentOffset += this.offsetAbs;

        // apply segment offset
        //   offset > 0: the segment's reference position is after the given segment position
        //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
        if (segmentOffset < 0) {
          segmentDuration -= segmentOffset;
          segmentPosition += segmentOffset;
          segmentTime += segmentOffset / resamplingRate;
        } else {
          segmentTime -= segmentOffset / resamplingRate;
        }

        // randomize segment position
        if (this.positionVar > 0) segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;

        // shorten duration of segments over the edges of the buffer
        if (segmentPosition < 0) {
          //segmentTime -= grainPosition; hm, not sure if we want to do this
          segmentDuration += segmentPosition;
          segmentPosition = 0;
        }

        if (segmentPosition + segmentDuration > this.buffer.duration) segmentDuration = this.buffer.duration - segmentPosition;

        segmentDuration /= resamplingRate;

        if (this.monophonic) this.abort(segmentTime);

        // make segment
        if (this.gain > 0 && segmentDuration > 0) {
          // make segment envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * segmentDuration;
          var release = this.releaseAbs + this.releaseRel * segmentDuration;

          if (attack + release > segmentDuration) {
            var factor = segmentDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = segmentTime + attack;
          var segmentEndTime = segmentTime + segmentDuration;
          var releaseStartTime = segmentEndTime - release;

          envelope.gain.value = 0;
          envelope.gain.setValueAtTime(0.0, segmentTime);
          envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
          envelope.connect(this.outputNode);

          this.__currentEnv = envelope;

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(segmentTime, segmentPosition);
          source.stop(segmentTime + segmentDuration);

          this.__currentSrc = source;
          this.__releaseStartTime = releaseStartTime;
          this.__currentGain = this.gain;
          this.__currentEndTime = segmentEndTime;
        }
      }

      // grain period randon variation
      if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

      return Math.max(this.periodMin, segmentPeriod);
    }
  }, {
    key: 'abort',
    value: function abort(time) {
      var audioContext = this.audioContext;
      var endTime = this.__currentEndTime;
      var abortTime = time || audioContext.currentTime;

      if (abortTime < endTime) {
        var segmentEndTime = Math.min(abortTime + this.abortTime, endTime);
        var envelope = this.__currentEnv;
        var currentGainValue = this.__currentGain;

        if (abortTime > this.__releaseStartTime) {
          var releaseStart = this.__releaseStartTime;
          currentGainValue *= (abortTime - releaseStart) / (endTime - releaseStart);
        }

        envelope.gain.cancelScheduledValues(abortTime);
        envelope.gain.setValueAtTime(currentGainValue, abortTime);
        envelope.gain.linearRampToValueAtTime(0, segmentEndTime);

        this.__currentSrc = null;
        this.__currentEnv = null;
        this.__releaseStartTime = 0;
        this.__currentGain = 0;
        this.__currentEndTime = 0;
      }
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }
  }]);
  return SegmentEngine;
}(_audioTimeEngine2.default);

exports.default = SegmentEngine;

},{"../core/audio-time-engine":335,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],343:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _audioContext = require('./core/audio-context');

Object.defineProperty(exports, 'audioContext', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioContext).default;
  }
});

var _timeEngine = require('./core/time-engine');

Object.defineProperty(exports, 'TimeEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_timeEngine).default;
  }
});

var _audioTimeEngine = require('./core/audio-time-engine');

Object.defineProperty(exports, 'AudioTimeEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioTimeEngine).default;
  }
});

var _priorityQueue = require('./core/priority-queue');

Object.defineProperty(exports, 'PriorityQueue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_priorityQueue).default;
  }
});

var _schedulingQueue = require('./core/scheduling-queue');

Object.defineProperty(exports, 'SchedulingQueue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_schedulingQueue).default;
  }
});

var _granularEngine = require('./engines/granular-engine');

Object.defineProperty(exports, 'GranularEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_granularEngine).default;
  }
});

var _metronome = require('./engines/metronome');

Object.defineProperty(exports, 'Metronome', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_metronome).default;
  }
});

var _playerEngine = require('./engines/player-engine');

Object.defineProperty(exports, 'PlayerEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_playerEngine).default;
  }
});

var _segmentEngine = require('./engines/segment-engine');

Object.defineProperty(exports, 'SegmentEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_segmentEngine).default;
  }
});

var _playControl = require('./masters/play-control');

Object.defineProperty(exports, 'PlayControl', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_playControl).default;
  }
});

var _transport = require('./masters/transport');

Object.defineProperty(exports, 'Transport', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_transport).default;
  }
});

var _scheduler = require('./masters/scheduler');

Object.defineProperty(exports, 'Scheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scheduler).default;
  }
});

var _simpleScheduler = require('./masters/simple-scheduler');

Object.defineProperty(exports, 'SimpleScheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_simpleScheduler).default;
  }
});

var _factories = require('./masters/factories');

Object.defineProperty(exports, 'getScheduler', {
  enumerable: true,
  get: function get() {
    return _factories.getScheduler;
  }
});
Object.defineProperty(exports, 'getSimpleScheduler', {
  enumerable: true,
  get: function get() {
    return _factories.getSimpleScheduler;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./core/audio-context":334,"./core/audio-time-engine":335,"./core/priority-queue":336,"./core/scheduling-queue":337,"./core/time-engine":338,"./engines/granular-engine":339,"./engines/metronome":340,"./engines/player-engine":341,"./engines/segment-engine":342,"./masters/factories":344,"./masters/play-control":345,"./masters/scheduler":346,"./masters/simple-scheduler":347,"./masters/transport":348}],344:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSimpleScheduler = exports.getScheduler = undefined;

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _scheduler = require('./scheduler');

var _scheduler2 = _interopRequireDefault(_scheduler);

var _simpleScheduler = require('./simple-scheduler');

var _simpleScheduler2 = _interopRequireDefault(_simpleScheduler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var schedulerMap = new _weakMap2.default(); // schedulers should be singletons

var simpleSchedulerMap = new _weakMap2.default();

/**
 * Returns a unique instance of `Scheduler`
 *
 * @global
 * @function
 * @returns {Scheduler}
 * @see Scheduler
 */
var getScheduler = exports.getScheduler = function getScheduler() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;

  var scheduler = schedulerMap.get(audioContext);

  if (!scheduler) {
    scheduler = new _scheduler2.default({ audioContext: audioContext });
    schedulerMap.set(audioContext, scheduler);
  }

  return scheduler;
};

/**
 * Returns a unique instance of `SimpleScheduler`
 *
 * @global
 * @function
 * @returns {SimpleScheduler}
 * @see SimpleScheduler
 */
var getSimpleScheduler = exports.getSimpleScheduler = function getSimpleScheduler() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;

  var simpleScheduler = simpleSchedulerMap.get(audioContext);

  if (!simpleScheduler) {
    simpleScheduler = new _simpleScheduler2.default({ audioContext: audioContext });
    simpleSchedulerMap.set(audioContext, simpleScheduler);
  }

  return simpleScheduler;
};

},{"../core/audio-context":334,"./scheduler":346,"./simple-scheduler":347,"babel-runtime/core-js/weak-map":190}],345:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _factories = require('./factories');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EPSILON = 1e-8;

var LoopControl = function (_TimeEngine) {
  (0, _inherits3.default)(LoopControl, _TimeEngine);

  function LoopControl(playControl) {
    (0, _classCallCheck3.default)(this, LoopControl);

    var _this = (0, _possibleConstructorReturn3.default)(this, (LoopControl.__proto__ || (0, _getPrototypeOf2.default)(LoopControl)).call(this));

    _this.__playControl = playControl;
    _this.speed = 1;
    _this.lower = -Infinity;
    _this.upper = Infinity;
    return _this;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(LoopControl, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var playControl = this.__playControl;
      var speed = this.speed;
      var lower = this.lower;
      var upper = this.upper;

      if (speed > 0) time += EPSILON;else time -= EPSILON;

      if (speed > 0) {
        playControl.syncSpeed(time, lower, speed, true);
        return playControl.__getTimeAtPosition(upper) - EPSILON;
      } else if (speed < 0) {
        playControl.syncSpeed(time, upper, speed, true);
        return playControl.__getTimeAtPosition(lower) + EPSILON;
      }

      return Infinity;
    }
  }, {
    key: 'reschedule',
    value: function reschedule(speed) {
      var playControl = this.__playControl;
      var lower = Math.min(playControl.__loopStart, playControl.__loopEnd);
      var upper = Math.max(playControl.__loopStart, playControl.__loopEnd);

      this.speed = speed;
      this.lower = lower;
      this.upper = upper;

      if (lower === upper) speed = 0;

      if (speed > 0) this.resetTime(playControl.__getTimeAtPosition(upper) - EPSILON);else if (speed < 0) this.resetTime(playControl.__getTimeAtPosition(lower) + EPSILON);else this.resetTime(Infinity);
    }
  }, {
    key: 'applyLoopBoundaries',
    value: function applyLoopBoundaries(position, speed) {
      var lower = this.lower;
      var upper = this.upper;

      if (speed > 0 && position >= upper) return lower + (position - lower) % (upper - lower);else if (speed < 0 && position < lower) return upper - (upper - position) % (upper - lower);

      return position;
    }
  }]);
  return LoopControl;
}(_timeEngine2.default);

// play controlled base class


var PlayControlled = function () {
  function PlayControlled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlled);

    this.__playControl = playControl;

    engine.master = this;
    this.__engine = engine;
  }

  (0, _createClass3.default)(PlayControlled, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      this.__engine.syncSpeed(time, position, speed, seek);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__playControl = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlled;
}();

// play control for engines implementing the *speed-controlled* interface


var PlayControlledSpeedControlled = function (_PlayControlled) {
  (0, _inherits3.default)(PlayControlledSpeedControlled, _PlayControlled);

  function PlayControlledSpeedControlled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (PlayControlledSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSpeedControlled)).call(this, playControl, engine));
  }

  return PlayControlledSpeedControlled;
}(PlayControlled);

// play control for engines implmenting the *transported* interface


var PlayControlledTransported = function (_PlayControlled2) {
  (0, _inherits3.default)(PlayControlledTransported, _PlayControlled2);

  function PlayControlledTransported(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledTransported);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledTransported.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledTransported)).call(this, playControl, engine));

    _this3.__schedulerHook = new PlayControlledSchedulerHook(playControl, engine);
    return _this3;
  }

  (0, _createClass3.default)(PlayControlledTransported, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      if (speed !== lastSpeed || seek && speed !== 0) {
        var nextPosition;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__engine.syncPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__engine.syncPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;

          if (this.__engine.syncSpeed) this.__engine.syncSpeed(time, position, 0);
        } else if (this.__engine.syncSpeed) {
          // change speed without reversing direction
          this.__engine.syncSpeed(time, position, speed);
        }

        this.__schedulerHook.resetPosition(nextPosition);
      }
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position === undefined) {
        var playControl = this.__playControl;
        var time = playControl.__sync();

        position = this.__engine.syncPosition(time, playControl.__position, playControl.__speed);
      }

      this.__schedulerHook.resetPosition(position);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__schedulerHook.destroy();
      this.__schedulerHook = null;

      (0, _get3.default)(PlayControlledTransported.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledTransported.prototype), 'destroy', this).call(this);
    }
  }]);
  return PlayControlledTransported;
}(PlayControlled);

// play control for time engines implementing the *scheduled* interface


var PlayControlledScheduled = function (_PlayControlled3) {
  (0, _inherits3.default)(PlayControlledScheduled, _PlayControlled3);

  function PlayControlledScheduled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledScheduled.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledScheduled)).call(this, playControl, engine));

    engine.master = null;
    _this4.__schedulingQueue = new PlayControlledSchedulingQueue(playControl, engine);
    return _this4;
  }

  (0, _createClass3.default)(PlayControlledScheduled, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      if (lastSpeed === 0 && speed !== 0) // start or seek
        this.__engine.resetTime();else if (lastSpeed !== 0 && speed === 0) // stop
        this.__engine.resetTime(Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__schedulingQueue.destroy();
      (0, _get3.default)(PlayControlledScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return PlayControlledScheduled;
}(PlayControlled);

// translates transported engine advancePosition into global scheduler times


var PlayControlledSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(PlayControlledSchedulerHook, _TimeEngine2);

  function PlayControlledSchedulerHook(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSchedulerHook)).call(this));

    _this5.__playControl = playControl;
    _this5.__engine = engine;

    _this5.__nextPosition = Infinity;
    playControl.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  (0, _createClass3.default)(PlayControlledSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var playControl = this.__playControl;
      var engine = this.__engine;
      var position = this.__nextPosition;
      var nextPosition = engine.advancePosition(time, position, playControl.__speed);
      var nextTime = playControl.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var time = this.__playControl.__getTimeAtPosition(position);
      this.__nextPosition = position;
      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__playControl.__scheduler.remove(this);
      this.__playControl = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlledSchedulerHook;
}(_timeEngine2.default);

// internal scheduling queue that returns the current position (and time) of the play control


var PlayControlledSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(PlayControlledSchedulingQueue, _SchedulingQueue);

  function PlayControlledSchedulingQueue(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSchedulingQueue)).call(this));

    _this6.__playControl = playControl;
    _this6.__engine = engine;

    _this6.add(engine, Infinity);
    playControl.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(PlayControlledSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__playControl.__scheduler.remove(this);
      this.remove(this.__engine);

      this.__playControl = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlledSchedulingQueue;
}(_schedulingQueue2.default);

/**
 * Extends Time Engine to provide playback control of a Time Engine instance.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/play-control.html}
 *
 * @extends TimeEngine
 * @param {TimeEngine} engine - engine to control
 *
 * @example
 * import * as audio from 'waves-audio';
 * const playerEngine = audio.PlayerEngine();
 * const playControl = new audio.PlayControl(playerEngine);
 *
 * playControl.start();
 */


var PlayControl = function (_TimeEngine3) {
  (0, _inherits3.default)(PlayControl, _TimeEngine3);

  function PlayControl(engine) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, PlayControl);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (PlayControl.__proto__ || (0, _getPrototypeOf2.default)(PlayControl)).call(this));

    _this7.audioContext = options.audioContext || _audioContext2.default;
    _this7.__scheduler = (0, _factories.getScheduler)(_this7.audioContext);

    _this7.__playControlled = null;

    _this7.__loopControl = null;
    _this7.__loopStart = 0;
    _this7.__loopEnd = 1;

    // synchronized tie, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;

    // non-zero "user" speed
    _this7.__playingSpeed = 1;

    if (engine) _this7.__setEngine(engine);
    return _this7;
  }

  (0, _createClass3.default)(PlayControl, [{
    key: '__setEngine',
    value: function __setEngine(engine) {
      if (engine.master) throw new Error("object has already been added to a master");

      if (_timeEngine2.default.implementsSpeedControlled(engine)) this.__playControlled = new PlayControlledSpeedControlled(this, engine);else if (_timeEngine2.default.implementsTransported(engine)) this.__playControlled = new PlayControlledTransported(this, engine);else if (_timeEngine2.default.implementsScheduled(engine)) this.__playControlled = new PlayControlledScheduled(this, engine);else throw new Error("object cannot be added to play control");
    }
  }, {
    key: '__resetEngine',
    value: function __resetEngine() {
      this.__playControlled.destroy();
      this.__playControlled = null;
    }

    /**
     * Calculate/extrapolate playing time for given position
     *
     * @param {Number} position position
     * @return {Number} extrapolated time
     * @private
     */

  }, {
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      return this.__time + (position - this.__position) / this.__speed;
    }

    /**
     * Calculate/extrapolate playing position for given time
     *
     * @param {Number} time time
     * @return {Number} extrapolated position
     * @private
     */

  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__sync',
    value: function __sync() {
      var now = this.currentTime;
      this.__position += (now - this.__time) * this.__speed;
      this.__time = now;
      return now;
    }

    /**
     * Get current master time.
     * This function will be replaced when the play-control is added to a master.
     *
     * @name currentTime
     * @type {Number}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'set',
    value: function set() {
      var engine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var time = this.__sync();
      var speed = this.__speed;

      if (this.__playControlled !== null && this.__playControlled.__engine !== engine) {

        this.syncSpeed(time, this.__position, 0);

        if (this.__playControlled) this.__resetEngine();

        if (this.__playControlled === null && engine !== null) {
          this.__setEngine(engine);

          if (speed !== 0) this.syncSpeed(time, this.__position, speed);
        }
      }
    }

    /**
     * Sets the play control loop behavior.
     *
     * @type {Boolean}
     * @name loop
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'setLoopBoundaries',


    /**
     * Sets loop start and end time.
     *
     * @param {Number} loopStart - loop start value.
     * @param {Number} loopEnd - loop end value.
     */
    value: function setLoopBoundaries(loopStart, loopEnd) {
      this.__loopStart = loopStart;
      this.__loopEnd = loopEnd;

      this.loop = this.loop;
    }

    /**
     * Sets loop start value
     *
     * @type {Number}
     * @name loopStart
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'syncSpeed',


    // TimeEngine method (speed-controlled interface)
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      if (speed !== lastSpeed || seek) {
        if ((seek || lastSpeed === 0) && this.__loopControl) position = this.__loopControl.applyLoopBoundaries(position, speed);

        this.__time = time;
        this.__position = position;
        this.__speed = speed;

        if (this.__playControlled) this.__playControlled.syncSpeed(time, position, speed, seek, lastSpeed);

        if (this.__loopControl) this.__loopControl.reschedule(speed);
      }
    }

    /**
     * Starts playback
     */

  }, {
    key: 'start',
    value: function start() {
      var time = this.__sync();
      this.syncSpeed(time, this.__position, this.__playingSpeed);
    }

    /**
     * Pauses playback and stays at the same position.
     */

  }, {
    key: 'pause',
    value: function pause() {
      var time = this.__sync();
      this.syncSpeed(time, this.__position, 0);
    }

    /**
     * Stops playback and seeks to initial (0) position.
     */

  }, {
    key: 'stop',
    value: function stop() {
      var time = this.__sync();
      this.syncSpeed(time, 0, 0, true);
    }

    /**
     * If speed if provided, sets the playback speed. The speed value should
     * be non-zero between -16 and -1/16 or between 1/16 and 16.
     *
     * @type {Number}
     * @name speed
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'seek',


    /**
     * Set (jump to) playing position.
     *
     * @param {Number} position target position
     */
    value: function seek(position) {
      var time = this.__sync();
      this.__position = position;
      this.syncSpeed(time, position, this.__speed, true);
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get current master position.
     * This function will be replaced when the play-control is added to a master.
     *
     * @name currentPosition
     * @type {Number}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }

    /**
     * Returns if the play control is runnin g.
     *
     * @name running
     * @type {Boolean}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'running',
    get: function get() {
      return !(this.__speed === 0);
    }
  }, {
    key: 'loop',
    set: function set(enable) {
      if (enable && this.__loopStart > -Infinity && this.__loopEnd < Infinity) {
        if (!this.__loopControl) {
          this.__loopControl = new LoopControl(this);
          this.__scheduler.add(this.__loopControl, Infinity);
        }

        if (this.__speed !== 0) {
          var position = this.currentPosition;
          var lower = Math.min(this.__loopStart, this.__loopEnd);
          var upper = Math.max(this.__loopStart, this.__loopEnd);

          if (this.__speed > 0 && position > upper) this.seek(upper);else if (this.__speed < 0 && position < lower) this.seek(lower);else this.__loopControl.reschedule(this.__speed);
        }
      } else if (this.__loopControl) {
        this.__scheduler.remove(this.__loopControl);
        this.__loopControl = null;
      }
    },
    get: function get() {
      return !!this.__loopControl;
    }
  }, {
    key: 'loopStart',
    set: function set(loopStart) {
      this.setLoopBoundaries(loopStart, this.__loopEnd);
    },
    get: function get() {
      return this.__loopStart;
    }

    /**
     * Sets loop end value
     *
     * @type {Number}
     * @name loopEnd
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'loopEnd',
    set: function set(loopEnd) {
      this.setLoopBoundaries(this.__loopStart, loopEnd);
    },
    get: function get() {
      return this.__loopEnd;
    }
  }, {
    key: 'speed',
    set: function set(speed) {
      var time = this.__sync();

      if (speed >= 0) {
        if (speed < 0.01) speed = 0.01;else if (speed > 100) speed = 100;
      } else {
        if (speed < -100) speed = -100;else if (speed > -0.01) speed = -0.01;
      }

      this.__playingSpeed = speed;

      if (!this.master && this.__speed !== 0) this.syncSpeed(time, this.__position, speed);
    },
    get: function get() {
      return this.__playingSpeed;
    }
  }]);
  return PlayControl;
}(_timeEngine2.default);

exports.default = PlayControl;

},{"../core/audio-context":334,"../core/scheduling-queue":337,"../core/time-engine":338,"./factories":344,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],346:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('wavesjs:audio');

/**
 * The `Scheduler` class implements a master for `TimeEngine` or `AudioTimeEngine`
 * instances that implement the *scheduled* interface such as the `Metronome`
 * `GranularEngine`.
 *
 * A `Scheduler` can also schedule simple callback functions.
 * The class is based on recursive calls to `setTimeOut` and uses the
 * `audioContext.currentTime` as logical passed to the `advanceTime` methods
 * of the scheduled engines or to the scheduled callback functions.
 * It extends the `SchedulingQueue` class that itself includes a `PriorityQueue`
 * to assure the order of the scheduled engines (see `SimpleScheduler` for a
 * simplified scheduler implementation without `PriorityQueue`).
 *
 * To get a unique instance of `Scheduler` as the global scheduler of an
 * application, the `getScheduler` factory function should be used. The
 * function accepts an audio context as optional argument and uses the Waves
 * default audio context (see `audioContext`) as
 * default. The factory creates a single scheduler for each audio context.
 *
 * Example that shows three Metronome engines running in a Scheduler:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/scheduler.html}
 *
 * @param {Object} [options={}] - default options
 * @param {Number} [options.period=0.025] - period of the scheduler.
 * @param {Number} [options.lookahead=0.1] - lookahead of the scheduler.
 *
 * @see TimeEngine
 * @see AudioTimeEngine
 * @see getScheduler
 * @see SimpleScheduler
 *
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 *
 * scheduler.add(myEngine);
 */

var Scheduler = function (_SchedulingQueue) {
  (0, _inherits3.default)(Scheduler, _SchedulingQueue);

  function Scheduler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Scheduler);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Scheduler.__proto__ || (0, _getPrototypeOf2.default)(Scheduler)).call(this));

    _this.audioContext = options.audioContext || _audioContext2.default;

    _this.__currentTime = null;
    _this.__nextTime = Infinity;
    _this.__timeout = null;

    /**
     * scheduler (setTimeout) period
     * @type {Number}
     * @name period
     * @memberof Scheduler
     * @instance
     */
    _this.period = options.period || 0.025;

    /**
     * scheduler lookahead time (> period)
     * @type {Number}
     * @name lookahead
     * @memberof Scheduler
     * @instance
     */
    _this.lookahead = options.lookahead || 0.1;
    return _this;
  }

  // setTimeout scheduling loop


  (0, _createClass3.default)(Scheduler, [{
    key: '__tick',
    value: function __tick() {
      var audioContext = this.audioContext;
      var currentTime = audioContext.currentTime;
      var time = this.__nextTime;

      this.__timeout = null;

      while (time <= currentTime + this.lookahead) {
        this.__currentTime = time;
        time = this.advanceTime(time);
      }

      this.__currentTime = null;
      this.resetTime(time);
    }
  }, {
    key: 'resetTime',
    value: function resetTime() {
      var _this2 = this;

      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentTime;

      if (this.master) {
        this.master.reset(this, time);
      } else {
        if (this.__timeout) {
          clearTimeout(this.__timeout);
          this.__timeout = null;
        }

        if (time !== Infinity) {
          if (this.__nextTime === Infinity) log('Scheduler Start');

          var timeOutDelay = Math.max(time - this.lookahead - this.audioContext.currentTime, this.period);

          this.__timeout = setTimeout(function () {
            _this2.__tick();
          }, Math.ceil(timeOutDelay * 1000));
        } else if (this.__nextTime !== Infinity) {
          log('Scheduler Stop');
        }

        this.__nextTime = time;
      }
    }

    /**
     * Scheduler current logical time.
     *
     * @name currentTime
     * @type {Number}
     * @memberof Scheduler
     * @instance
     */

  }, {
    key: 'currentTime',
    get: function get() {
      if (this.master) return this.master.currentTime;

      return this.__currentTime || this.audioContext.currentTime + this.lookahead;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return undefined;
    }

    // inherited from scheduling queue
    /**
     * Add a TimeEngine or a simple callback function to the scheduler at an
     * optionally given time. Whether the add method is called with a TimeEngine
     * or a callback function it returns a TimeEngine that can be used as argument
     * of the methods remove and resetEngineTime. A TimeEngine added to a scheduler
     * has to implement the scheduled interface. The callback function added to a
     * scheduler will be called at the given time and with the given time as
     * argument. The callback can return a new scheduling time (i.e. the next
     * time when it will be called) or it can return Infinity to suspend scheduling
     * without removing the function from the scheduler. A function that does
     * not return a value (or returns null or 0) is removed from the scheduler
     * and cannot be used as argument of the methods remove and resetEngineTime
     * anymore.
     *
     * @name add
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine|Function} engine - Engine to add to the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    /**
     * Remove a TimeEngine from the scheduler that has been added to the
     * scheduler using the add method.
     *
     * @name add
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine} engine - Engine to remove from the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    /**
     * Reschedule a scheduled time engine at a given time.
     *
     * @name resetEngineTime
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine} engine - Engine to reschedule
     * @param {Number} time - Schedule time
     */
    /**
     * Remove all scheduled callbacks and engines from the scheduler.
     *
     * @name clear
     * @function
     * @memberof Scheduler
     * @instance
     */

  }]);
  return Scheduler;
}(_schedulingQueue2.default);

exports.default = Scheduler;

},{"../core/audio-context":334,"../core/scheduling-queue":337,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195,"debug":330}],347:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('wavesjs:audio');

/**
 *
 *
 *
 * The SimpleScheduler class implements a simplified master for time engines
 * (see TimeEngine or AudioTimeEngine) that implement the scheduled interface
 * such as the Metronome and the GranularEngine. The API and funtionalities of
 * the SimpleScheduler class are identical to the Scheduler class. But, other
 * than the Scheduler, the SimpleScheduler class does not guarantee the order
 * of events (i.e. calls to the advanceTime method of scheduled time engines
 * and to scheduled callback functions) within a scheduling period (see period
 * attribute).
 *
 * To get a unique instance of SimpleScheduler as the global scheduler of an
 * application, the getSimpleScheduler factory function should be used. The
 * function accepts an audio context as optional argument and uses the Waves
 * default audio context (see Audio Context) as default. The factory creates
 * a single (simple) scheduler for each audio context.
 *
 * Example that shows three Metronome engines running in a SimpleScheduler:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/simple-scheduler.html}
 *
 * @param {Object} [options={}] - default options
 * @param {Number} [options.period=0.025] - period of the scheduler.
 * @param {Number} [options.lookahead=0.1] - lookahead of the scheduler.
 *
 * @see TimeEngine
 * @see AudioTimeEngine
 * @see getSimpleScheduler
 * @see Scheduler
 *
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getSimpleScheduler();
 *
 * scheduler.add(myEngine);
 */

var SimpleScheduler = function () {
  function SimpleScheduler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SimpleScheduler);

    this.audioContext = options.audioContext || _audioContext2.default;

    this.__engines = new _set2.default();

    this.__schedEngines = [];
    this.__schedTimes = [];

    this.__currentTime = null;
    this.__timeout = null;

    /**
     * scheduler (setTimeout) period
     * @type {Number}
     * @name period
     * @memberof Scheduler
     * @instance
     */
    this.period = options.period || 0.025;

    /**
     * scheduler lookahead time (> period)
     * @type {Number}
     * @name lookahead
     * @memberof Scheduler
     * @instance
     */
    this.lookahead = options.lookahead || 0.1;
  }

  (0, _createClass3.default)(SimpleScheduler, [{
    key: '__scheduleEngine',
    value: function __scheduleEngine(engine, time) {
      this.__schedEngines.push(engine);
      this.__schedTimes.push(time);
    }
  }, {
    key: '__rescheduleEngine',
    value: function __rescheduleEngine(engine, time) {
      var index = this.__schedEngines.indexOf(engine);

      if (index >= 0) {
        if (time !== Infinity) {
          this.__schedTimes[index] = time;
        } else {
          this.__schedEngines.splice(index, 1);
          this.__schedTimes.splice(index, 1);
        }
      } else if (time < Infinity) {
        this.__schedEngines.push(engine);
        this.__schedTimes.push(time);
      }
    }
  }, {
    key: '__unscheduleEngine',
    value: function __unscheduleEngine(engine) {
      var index = this.__schedEngines.indexOf(engine);

      if (index >= 0) {
        this.__schedEngines.splice(index, 1);
        this.__schedTimes.splice(index, 1);
      }
    }
  }, {
    key: '__resetTick',
    value: function __resetTick() {
      if (this.__schedEngines.length > 0) {
        if (!this.__timeout) {
          log('SimpleScheduler Start');
          this.__tick();
        }
      } else if (this.__timeout) {
        log('SimpleScheduler Stop');
        clearTimeout(this.__timeout);
        this.__timeout = null;
      }
    }
  }, {
    key: '__tick',
    value: function __tick() {
      var _this = this;

      var audioContext = this.audioContext;
      var currentTime = audioContext.currentTime;
      var i = 0;

      while (i < this.__schedEngines.length) {
        var engine = this.__schedEngines[i];
        var time = this.__schedTimes[i];

        while (time && time <= currentTime + this.lookahead) {
          time = Math.max(time, currentTime);
          this.__currentTime = time;
          time = engine.advanceTime(time);
        }

        if (time && time < Infinity) {
          this.__schedTimes[i++] = time;
        } else {
          this.__unscheduleEngine(engine);

          // remove engine from scheduler
          if (!time) {
            engine.master = null;
            this.__engines.delete(engine);
          }
        }
      }

      this.__currentTime = null;
      this.__timeout = null;

      if (this.__schedEngines.length > 0) {
        this.__timeout = setTimeout(function () {
          _this.__tick();
        }, this.period * 1000);
      }
    }

    /**
     * Scheduler current logical time.
     *
     * @name currentTime
     * @type {Number}
     * @memberof Scheduler
     * @instance
     */

  }, {
    key: 'defer',


    // call a function at a given time
    /**
     * Defer the execution of a function at a given time.
     *
     * @param {Function} fun - Function to defer
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    value: function defer(fun) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!(fun instanceof Function)) throw new Error("object cannot be defered by scheduler");

      this.add({
        advanceTime: function advanceTime(time) {
          fun(time);
        } // make sur that the advanceTime method does not returm anything
      }, time);
    }

    /**
     * Add a TimeEngine function to the scheduler at an optionally given time.
     *
     * @param {TimeEngine} engine - Engine to add to the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!_timeEngine2.default.implementsScheduled(engine)) throw new Error("object cannot be added to scheduler");

      if (engine.master) throw new Error("object has already been added to a master");

      // set master and add to array
      engine.master = this;
      this.__engines.add(engine);

      // schedule engine
      this.__scheduleEngine(engine, time);
      this.__resetTick();
    }

    /**
     * Remove a TimeEngine from the scheduler that has been added to the
     * scheduler using the add method.
     *
     * @param {TimeEngine} engine - Engine to remove from the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */

  }, {
    key: 'remove',
    value: function remove(engine) {
      if (!engine.master || engine.master !== this) throw new Error("engine has not been added to this scheduler");

      // reset master and remove from array
      engine.master = null;
      this.__engines.delete(engine);

      // unschedule engine
      this.__unscheduleEngine(engine);
      this.__resetTick();
    }

    /**
     * Reschedule a scheduled time engine at a given time.
     *
     * @param {TimeEngine} engine - Engine to reschedule
     * @param {Number} time - Schedule time
     */

  }, {
    key: 'resetEngineTime',
    value: function resetEngineTime(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      this.__rescheduleEngine(engine, time);
      this.__resetTick();
    }

    /**
     * Check whether a given engine is scheduled.
     *
     * @param {TimeEngine} engine - Engine to check
     */

  }, {
    key: 'has',
    value: function has(engine) {
      return this.__engines.has(engine);
    }

    /**
     * Remove all engines from the scheduler.
     */

  }, {
    key: 'clear',
    value: function clear() {
      if (this.__timeout) {
        clearTimeout(this.__timeout);
        this.__timeout = null;
      }

      this.__schedEngines.length = 0;
      this.__schedTimes.length = 0;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__currentTime || this.audioContext.currentTime + this.lookahead;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return undefined;
    }
  }]);
  return SimpleScheduler;
}();

exports.default = SimpleScheduler;

},{"../core/audio-context":334,"../core/time-engine":338,"babel-runtime/core-js/set":187,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"debug":330}],348:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _priorityQueue = require('../core/priority-queue');

var _priorityQueue2 = _interopRequireDefault(_priorityQueue);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _factories = require('./factories');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addDuplet(firstArray, secondArray, firstElement, secondElement) {
  firstArray.push(firstElement);
  secondArray.push(secondElement);
}

function removeDuplet(firstArray, secondArray, firstElement) {
  var index = firstArray.indexOf(firstElement);

  if (index >= 0) {
    var secondElement = secondArray[index];

    firstArray.splice(index, 1);
    secondArray.splice(index, 1);

    return secondElement;
  }

  return null;
}

// The Transported call is the base class of the adapters between
// different types of engines (i.e. transported, scheduled, play-controlled)
// The adapters are at the same time masters for the engines added to the transport
// and transported TimeEngines inserted into the transport's position-based pritority queue.

var Transported = function (_TimeEngine) {
  (0, _inherits3.default)(Transported, _TimeEngine);

  function Transported(transport, engine, start, duration, offset) {
    var stretch = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    (0, _classCallCheck3.default)(this, Transported);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Transported.__proto__ || (0, _getPrototypeOf2.default)(Transported)).call(this));

    _this.master = transport;

    _this.__engine = engine;
    engine.master = _this;

    _this.__startPosition = start;
    _this.__endPosition = !isFinite(duration) ? Infinity : start + duration;
    _this.__offsetPosition = start + offset;
    _this.__stretchPosition = stretch;
    _this.__isRunning = false;
    return _this;
  }

  (0, _createClass3.default)(Transported, [{
    key: 'setBoundaries',
    value: function setBoundaries(start, duration) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var stretch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      this.__startPosition = start;
      this.__endPosition = start + duration;
      this.__offsetPosition = start + offset;
      this.__stretchPosition = stretch;
      this.resetPosition();
    }
  }, {
    key: 'start',
    value: function start(time, position, speed) {}
  }, {
    key: 'stop',
    value: function stop(time, position) {}
  }, {
    key: 'resetPosition',
    value: function resetPosition(position) {
      if (position !== undefined) position += this.__offsetPosition;

      this.master.resetEnginePosition(this, position);
    }
  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0) {
        if (position < this.__startPosition) {

          if (this.__isRunning) this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__startPosition;
        } else if (position < this.__endPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__endPosition;
        }
      } else {
        if (position > this.__endPosition) {
          if (this.__isRunning) // if engine is running
            this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__endPosition;
        } else if (position > this.__startPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__startPosition;
        }
      }

      if (this.__isRunning) // if engine is running
        this.stop(time, position);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      if (!this.__isRunning) {
        this.start(time, position - this.__offsetPosition, speed);
        this.__isRunning = true;

        if (speed > 0) return this.__endPosition;

        return this.__startPosition;
      }

      // stop engine
      this.stop(time, position - this.__offsetPosition);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (speed === 0) // stop
        this.stop(time, position - this.__offsetPosition);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.master.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.master.currentPosition - this.__offsetPosition;
    }
  }]);
  return Transported;
}(_timeEngine2.default);

// TransportedTransported
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedTransported = function (_Transported) {
  (0, _inherits3.default)(TransportedTransported, _Transported);

  function TransportedTransported(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedTransported);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedTransported.__proto__ || (0, _getPrototypeOf2.default)(TransportedTransported)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedTransported, [{
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0 && position < this.__endPosition) position = Math.max(position, this.__startPosition);else if (speed < 0 && position >= this.__startPosition) position = Math.min(position, this.__endPosition);

      return this.__offsetPosition + this.__engine.syncPosition(time, position - this.__offsetPosition, speed);
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      position = this.__offsetPosition + this.__engine.advancePosition(time, position - this.__offsetPosition, speed);

      if (speed > 0 && position < this.__endPosition || speed < 0 && position >= this.__startPosition) return position;

      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__engine.syncSpeed) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position !== undefined) position += this.__offsetPosition;

      this.resetPosition(position);
    }
  }]);
  return TransportedTransported;
}(Transported);

// TransportedSpeedControlled
// has to start and stop the speed-controlled engines when the transport hits the engine's start and end position


var TransportedSpeedControlled = function (_Transported2) {
  (0, _inherits3.default)(TransportedSpeedControlled, _Transported2);

  function TransportedSpeedControlled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedSpeedControlled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.__engine.syncSpeed(time, position, speed, true);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.__engine.syncSpeed(time, position, 0);
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__isRunning) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__engine.syncSpeed(this.master.currentTime, this.master.currentPosition - this.__offsetPosition, 0);
      (0, _get3.default)(TransportedSpeedControlled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedSpeedControlled;
}(Transported);

// TransportedScheduled
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedScheduled = function (_Transported3) {
  (0, _inherits3.default)(TransportedScheduled, _Transported3);

  function TransportedScheduled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (TransportedScheduled.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));

    engine.master = null;
    transport.__schedulingQueue.add(engine, Infinity);
    return _this4;
  }

  (0, _createClass3.default)(TransportedScheduled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, time);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master.__schedulingQueue.remove(this.__engine);
      (0, _get3.default)(TransportedScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedScheduled;
}(Transported);

// translates advancePosition of *transported* engines into global scheduler times


var TransportSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(TransportSchedulerHook, _TimeEngine2);

  function TransportSchedulerHook(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulerHook)).call(this));

    _this5.__transport = transport;

    _this5.__nextPosition = Infinity;
    _this5.__nextTime = Infinity;
    transport.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(TransportSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var transport = this.__transport;
      var position = this.__nextPosition;
      var speed = transport.__speed;
      var nextPosition = transport.advancePosition(time, position, speed);
      var nextTime = transport.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      this.__nextTime = nextTime;

      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var transport = this.__transport;
      var time = transport.__getTimeAtPosition(position);

      this.__nextPosition = position;
      this.__nextTime = time;

      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }]);
  return TransportSchedulerHook;
}(_timeEngine2.default);

// internal scheduling queue that returns the current position (and time) of the play control


var TransportSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(TransportSchedulingQueue, _SchedulingQueue);

  function TransportSchedulingQueue(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulingQueue)).call(this));

    _this6.__transport = transport;
    transport.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(TransportSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__transport.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__transport.currentPosition;
    }
  }]);
  return TransportSchedulingQueue;
}(_schedulingQueue2.default);

/**
 * Provides synchronized scheduling of Time Engine instances.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/transport.html}
 *
 * @example
 * import * as audio from 'waves-audio';
 * const transport = audio.Transport();
 * const playControl = new audio.PlayControl(transport);
 * const myEngine = new MyEngine();
 * const yourEngine = new yourEngine();
 *
 * transport.add(myEngine);
 * transport.add(yourEngine);
 *
 * playControl.start();
 */


var Transport = function (_TimeEngine3) {
  (0, _inherits3.default)(Transport, _TimeEngine3);

  function Transport() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Transport);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (Transport.__proto__ || (0, _getPrototypeOf2.default)(Transport)).call(this));

    _this7.audioContext = options.audioContext || _audioContext2.default;

    _this7.__engines = [];
    _this7.__transported = [];

    _this7.__scheduler = (0, _factories.getScheduler)(_this7.audioContext);
    _this7.__schedulerHook = new TransportSchedulerHook(_this7);
    _this7.__transportedQueue = new _priorityQueue2.default();
    _this7.__schedulingQueue = new TransportSchedulingQueue(_this7);

    // syncronized time, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;
    return _this7;
  }

  (0, _createClass3.default)(Transport, [{
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      return this.__time + (position - this.__position) / this.__speed;
    }
  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__syncTransportedPosition',
    value: function __syncTransportedPosition(time, position, speed) {
      var numTransportedEngines = this.__transported.length;
      var nextPosition = Infinity * speed;

      if (numTransportedEngines > 0) {
        this.__transportedQueue.clear();
        this.__transportedQueue.reverse = speed < 0;

        for (var i = 0; i < numTransportedEngines; i++) {
          var engine = this.__transported[i];
          var nextEnginePosition = engine.syncPosition(time, position, speed);
          this.__transportedQueue.insert(engine, nextEnginePosition);
        }

        nextPosition = this.__transportedQueue.time;
      }

      return nextPosition;
    }
  }, {
    key: '__syncTransportedSpeed',
    value: function __syncTransportedSpeed(time, position, speed) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__transported), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var transported = _step.value;

          transported.syncSpeed(time, position, speed);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Get current master time. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentTime
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'resetPosition',


    /**
     * Reset next transport position
     *
     * @param {Number} next - transport position
     */
    value: function resetPosition(position) {
      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this, position);else this.__schedulerHook.resetPosition(position);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      return this.__syncTransportedPosition(time, position, speed);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var engine = this.__transportedQueue.head;
      var nextEnginePosition = engine.advancePosition(time, position, speed);
      return this.__transportedQueue.move(engine, nextEnginePosition);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     * @param {Boolean} [seek=false]
     */

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      if (speed !== lastSpeed || seek && speed !== 0) {
        var nextPosition = void 0;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;
          this.__syncTransportedSpeed(time, position, 0);
        } else {
          // change speed without reversing direction
          this.__syncTransportedSpeed(time, position, speed);
        }

        this.resetPosition(nextPosition);
      }
    }

    /**
     * Add a time engine to the transport.
     *
     * @param {Object} engine - engine to be added to the transport
     * @param {Number} position - start position
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var endPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
      var offsetPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var transported = null;

      if (offsetPosition === -Infinity) offsetPosition = 0;

      if (engine.master) throw new Error("object has already been added to a master");

      if (_timeEngine2.default.implementsTransported(engine)) transported = new TransportedTransported(this, engine, startPosition, endPosition, offsetPosition);else if (_timeEngine2.default.implementsSpeedControlled(engine)) transported = new TransportedSpeedControlled(this, engine, startPosition, endPosition, offsetPosition);else if (_timeEngine2.default.implementsScheduled(engine)) transported = new TransportedScheduled(this, engine, startPosition, endPosition, offsetPosition);else throw new Error("object cannot be added to a transport");

      if (transported) {
        var speed = this.__speed;

        addDuplet(this.__engines, this.__transported, engine, transported);

        if (speed !== 0) {
          // sync and start
          var nextEnginePosition = transported.syncPosition(this.currentTime, this.currentPosition, speed);
          var nextPosition = this.__transportedQueue.insert(transported, nextEnginePosition);

          this.resetPosition(nextPosition);
        }
      }

      return transported;
    }

    /**
     * Remove a time engine from the transport.
     *
     * @param {object} engineOrTransported - engine or transported to be removed from the transport
     */

  }, {
    key: 'remove',
    value: function remove(engineOrTransported) {
      var engine = engineOrTransported;
      var transported = removeDuplet(this.__engines, this.__transported, engineOrTransported);

      if (!transported) {
        engine = removeDuplet(this.__transported, this.__engines, engineOrTransported);
        transported = engineOrTransported;
      }

      if (engine && transported) {
        var nextPosition = this.__transportedQueue.remove(transported);

        transported.destroy();

        if (this.__speed !== 0) this.resetPosition(nextPosition);
      } else {
        throw new Error("object has not been added to this transport");
      }
    }

    /**
     * Reset position of the given engine.
     *
     * @param {TimeEngine} transported - Engine to reset
     * @param {Number} position - New position
     */

  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(transported) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      var speed = this.__speed;

      if (speed !== 0) {
        if (position === undefined) position = transported.syncPosition(this.currentTime, this.currentPosition, speed);

        var nextPosition = this.__transportedQueue.move(transported, position);
        this.resetPosition(nextPosition);
      }
    }

    /**
     * Remove all time engines from the transport.
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.syncSpeed(this.currentTime, this.currentPosition, 0);

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.__transported), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var transported = _step2.value;

          transported.destroy();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get current master position. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentPosition
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }
  }]);
  return Transport;
}(_timeEngine2.default);

exports.default = Transport;

},{"../core/audio-context":334,"../core/priority-queue":336,"../core/scheduling-queue":337,"../core/time-engine":338,"./factories":344,"babel-runtime/core-js/get-iterator":175,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],349:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utils = exports.source = exports.sink = exports.operator = exports.core = exports.version = undefined;

var _namespace = require('./operator/_namespace');

Object.defineProperty(exports, 'operator', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_namespace).default;
  }
});

var _namespace2 = require('./sink/_namespace');

Object.defineProperty(exports, 'sink', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_namespace2).default;
  }
});

var _namespace3 = require('./source/_namespace');

Object.defineProperty(exports, 'source', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_namespace3).default;
  }
});

var _namespace4 = require('./utils/_namespace');

Object.defineProperty(exports, 'utils', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_namespace4).default;
  }
});

var _core2 = require('../core');

var _core = _interopRequireWildcard(_core2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var version = exports.version = '1.1.6';

var core = exports.core = _core;

},{"../core":385,"./operator/_namespace":372,"./sink/_namespace":377,"./source/_namespace":380,"./utils/_namespace":381}],350:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sin = Math.sin;
var cos = Math.cos;
var sqrt = Math.sqrt;
var pow = Math.pow;
var _2PI = Math.PI * 2;

// plot (from http://www.earlevel.com/scripts/widgets/20131013/biquads2.js)
// var len = 512;
// var magPlot = [];
// for (var idx = 0; idx < len; idx++) {
//   var w;
//   if (plotType == "linear")
//     w = idx / (len - 1) * Math.PI;  // 0 to pi, linear scale
//   else
//     w = Math.exp(Math.log(1 / 0.001) * idx / (len - 1)) * 0.001 * Math.PI;  // 0.001 to 1, times pi, log scale

//   var phi = Math.pow(Math.sin(w/2), 2);
//   var y = Math.log(Math.pow(a0+a1+a2, 2) - 4*(a0*a1 + 4*a0*a2 + a1*a2)*phi + 16*a0*a2*phi*phi) - Math.log(Math.pow(1+b1+b2, 2) - 4*(b1 + 4*b2 + b1*b2)*phi + 16*b2*phi*phi);
//   y = y * 10 / Math.LN10
//   if (y == -Infinity)
//     y = -200;

//   if (plotType == "linear")
//     magPlot.push([idx / (len - 1) * Fs / 2, y]);
//   else
//     magPlot.push([idx / (len - 1) / 2, y]);

//   if (idx == 0)
//     minVal = maxVal = y;
//   else if (y < minVal)
//     minVal = y;
//   else if (y > maxVal)
//     maxVal = y;
// }

var definitions = {
  type: {
    type: 'enum',
    default: 'lowpass',
    list: ['lowpass', 'highpass', 'bandpass_constant_skirt', 'bandpass', 'bandpass_constant_peak', 'notch', 'allpass', 'peaking', 'lowshelf', 'highshelf'],
    metas: { kind: 'dyanmic' }
  },
  f0: {
    type: 'float',
    default: 1,
    metas: { kind: 'dyanmic' }
  },
  gain: {
    type: 'float',
    default: 1,
    min: 0,
    metas: { kind: 'dyanmic' }
  },
  q: {
    type: 'float',
    default: 1,
    min: 0.001, // PIPO_BIQUAD_MIN_Q
    // max: 1,
    metas: { kind: 'dyanmic' }
  }
  // bandwidth: {
  //   type: 'float',
  //   default: null,
  //   nullable: true,
  //   metas: { kind: 'dyanmic' },
  // },


  /**
   * Biquad filter (Direct form I). If input is of type `vector` the filter is
   * applied on each dimension i parallel.
   *
   * Based on the ["Cookbook formulae for audio EQ biquad filter coefficients"](http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt)
   * by Robert Bristow-Johnson.
   *
   * @memberof module:common.operator
   *
   * @param {Object} options - Override default values.
   * @param {String} [options.type='lowpass'] - Type of the filter. Available
   *  filters: 'lowpass', 'highpass', 'bandpass_constant_skirt', 'bandpass_constant_peak'
   *  (alias 'bandpass'), 'notch', 'allpass', 'peaking', 'lowshelf', 'highshelf'.
   * @param {Number} [options.f0=1] - Cutoff or center frequency of the filter
   *  according to its type.
   * @param {Number} [options.gain=1] - Gain of the filter (in dB).
   * @param {Number} [options.q=1] - Quality factor of the filter.
   *
   * @example
   * import * as lfo from 'waves-lfo/client';
   *
   * const audioInBuffer = new lfo.source.AudioInBuffer({
   *   audioBuffer: buffer,
   * });
   *
   * const biquad = new lfo.operator.Biquad({
   *   type: 'lowpass',
   *   f0: 2000,
   *   gain: 3,
   *   q: 12,
   * });
   *
   * const spectrumDisplay = new lfo.sink.SpectrumDisplay({
   *   canvas: '#spectrum',
   * });
   *
   * audioInBuffer.connect(biquad);
   * biquad.connect(spectrumDisplay);
   *
   * audioInBuffer.start();
   */
};
var Biquad = function (_BaseLfo) {
  (0, _inherits3.default)(Biquad, _BaseLfo);

  function Biquad() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Biquad);
    return (0, _possibleConstructorReturn3.default)(this, (Biquad.__proto__ || (0, _getPrototypeOf2.default)(Biquad)).call(this, definitions, options));
  }

  (0, _createClass3.default)(Biquad, [{
    key: 'onParamUpdate',
    value: function onParamUpdate(name, value, metas) {
      this._calculateCoefs();
    }
  }, {
    key: '_calculateCoefs',
    value: function _calculateCoefs() {
      var sampleRate = this.streamParams.sourceSampleRate;
      var frameType = this.streamParams.frameType;
      var frameSize = this.streamParams.frameSize;

      var type = this.params.get('type');
      var f0 = this.params.get('f0');
      var gain = this.params.get('gain');
      var q = this.params.get('q');
      // const bandwidth = this.params.get('bandwidth');
      var bandwidth = null;

      var b0 = 0,
          b1 = 0,
          b2 = 0,
          a0 = 0,
          a1 = 0,
          a2 = 0;

      var A = pow(10, gain / 40);
      var w0 = _2PI * f0 / sampleRate;
      var cosW0 = cos(w0);
      var sinW0 = sin(w0);
      var alpha = void 0; // depend of the filter type
      var _2RootAAlpha = void 0; // intermediate value for lowshelf and highshelf

      switch (type) {
        // H(s) = 1 / (s^2 + s/Q + 1)
        case 'lowpass':
          alpha = sinW0 / (2 * q);
          b0 = (1 - cosW0) / 2;
          b1 = 1 - cosW0;
          b2 = b0;
          a0 = 1 + alpha;
          a1 = -2 * cosW0;
          a2 = 1 - alpha;
          break;
        // H(s) = s^2 / (s^2 + s/Q + 1)
        case 'highpass':
          alpha = sinW0 / (2 * q);
          b0 = (1 + cosW0) / 2;
          b1 = -(1 + cosW0);
          b2 = b0;
          a0 = 1 + alpha;
          a1 = -2 * cosW0;
          a2 = 1 - alpha;
          break;
        // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
        case 'bandpass_constant_skirt':
          if (bandwidth) {
            // sin(w0)*sinh( ln(2)/2 * BW * w0/sin(w0) )           (case: BW)
          } else {
            alpha = sinW0 / (2 * q);
          }

          b0 = sinW0 / 2;
          b1 = 0;
          b2 = -b0;
          a0 = 1 + alpha;
          a1 = -2 * cosW0;
          a2 = 1 - alpha;
          break;
        // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
        case 'bandpass': // looks like what is gnerally considered as a bandpass
        case 'bandpass_constant_peak':
          if (bandwidth) {
            // sin(w0)*sinh( ln(2)/2 * BW * w0/sin(w0) )           (case: BW)
          } else {
            alpha = sinW0 / (2 * q);
          }

          b0 = alpha;
          b1 = 0;
          b2 = -alpha;
          a0 = 1 + alpha;
          a1 = -2 * cosW0;
          a2 = 1 - alpha;
          break;
        // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
        case 'notch':
          alpha = sinW0 / (2 * q);
          b0 = 1;
          b1 = -2 * cosW0;
          b2 = 1;
          a0 = 1 + alpha;
          a1 = b1;
          a2 = 1 - alpha;
          break;
        // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
        case 'allpass':
          alpha = sinW0 / (2 * q);
          b0 = 1 - alpha;
          b1 = -2 * cosW0;
          b2 = 1 + alpha;
          a0 = b2;
          a1 = b1;
          a2 = b0;
          break;
        // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
        case 'peaking':
          if (bandwidth) {
            // sin(w0)*sinh( ln(2)/2 * BW * w0/sin(w0) )           (case: BW)
          } else {
            alpha = sinW0 / (2 * q);
          }

          b0 = 1 + alpha * A;
          b1 = -2 * cosW0;
          b2 = 1 - alpha * A;
          a0 = 1 + alpha / A;
          a1 = b1;
          a2 = 1 - alpha / A;
          break;
        // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
        case 'lowshelf':
          alpha = sinW0 / (2 * q);
          _2RootAAlpha = 2 * sqrt(A) * alpha;

          b0 = A * (A + 1 - (A - 1) * cosW0 + _2RootAAlpha);
          b1 = 2 * A * (A - 1 - (A + 1) * cosW0);
          b2 = A * (A + 1 - (A - 1) * cosW0 - _2RootAAlpha);
          a0 = A + 1 + (A - 1) * cosW0 + _2RootAAlpha;
          a1 = -2 * (A - 1 + (A + 1) * cosW0);
          a2 = A + 1 + (A - 1) * cosW0 - _2RootAAlpha;
          break;
        // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)
        case 'highshelf':
          alpha = sinW0 / (2 * q);
          _2RootAAlpha = 2 * sqrt(A) * alpha;

          b0 = A * (A + 1 + (A - 1) * cosW0 + _2RootAAlpha);
          b1 = -2 * A * (A - 1 + (A + 1) * cosW0);
          b2 = A * (A + 1 + (A - 1) * cosW0 - _2RootAAlpha);
          a0 = A + 1 - (A - 1) * cosW0 + _2RootAAlpha;
          a1 = 2 * (A - 1 - (A + 1) * cosW0);
          a2 = A + 1 - (A - 1) * cosW0 - _2RootAAlpha;

          break;
      }

      this.coefs = {
        b0: b0 / a0,
        b1: b1 / a0,
        b2: b2 / a0,
        a1: a1 / a0,
        a2: a2 / a0
      };

      // reset state
      if (frameType === 'signal') {
        this.state = { x1: 0, x2: 0, y1: 0, y2: 0 };
      } else {
        this.state = {
          x1: new Float32Array(frameSize),
          x2: new Float32Array(frameSize),
          y1: new Float32Array(frameSize),
          y2: new Float32Array(frameSize)
        };
      }
    }

    /** @private */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      // if no `sampleRate` or `sampleRate` is 0 we shall halt!
      var sampleRate = this.streamParams.sourceSampleRate;

      if (!sampleRate || sampleRate <= 0) throw new Error('Invalid sampleRate value (0) for biquad');

      this._calculateCoefs();
      this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      var frameSize = this.streamParams.frameSize;
      var outData = this.frame.data;
      var inData = frame.data;
      var state = this.state;
      var coefs = this.coefs;

      for (var i = 0; i < frameSize; i++) {
        var x = inData[i];
        var y = coefs.b0 * x + coefs.b1 * state.x1[i] + coefs.b2 * state.x2[i] - coefs.a1 * state.y1[i] - coefs.a2 * state.y2[i];

        outData[i] = y;

        // update states
        state.x2[i] = state.x1[i];
        state.x1[i] = x;
        state.y2[i] = state.y1[i];
        state.y1[i] = y;
      }
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      var frameSize = this.streamParams.frameSize;
      var outData = this.frame.data;
      var inData = frame.data;
      var state = this.state;
      var coefs = this.coefs;

      for (var i = 0; i < frameSize; i++) {
        var x = inData[i];
        var y = coefs.b0 * x + coefs.b1 * state.x1 + coefs.b2 * state.x2 - coefs.a1 * state.y1 - coefs.a2 * state.y2;

        outData[i] = y;

        // update states
        state.x2 = state.x1;
        state.x1 = x;
        state.y2 = state.y1;
        state.y1 = y;
      }
    }
  }]);
  return Biquad;
}(_BaseLfo3.default);

exports.default = Biquad;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],351:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  min: {
    type: 'float',
    default: 0,
    min: -Infinity,
    max: +Infinity
  },
  max: {
    type: 'float',
    default: 1,
    min: -Infinity,
    max: +Infinity
  }
};

/**
 * Clip incomming according to given `min` and `max` parameters
 *
 * @param {Object} options - Override default paramters
 * @param {Number} [options.min=0] - Minimum value
 * @param {Number} [options.max=1] - Maximum value
 */

var Clip = function (_BaseLfo) {
  (0, _inherits3.default)(Clip, _BaseLfo);

  function Clip(options) {
    (0, _classCallCheck3.default)(this, Clip);
    return (0, _possibleConstructorReturn3.default)(this, (Clip.__proto__ || (0, _getPrototypeOf2.default)(Clip)).call(this, definitions, options));
  }

  (0, _createClass3.default)(Clip, [{
    key: 'inputVector',
    value: function inputVector(data) {
      var min = this.params.get('min');
      var max = this.params.get('max');
      var frameSize = this.streamParams.frameSize;
      var outData = this.frame.data;

      // @todo - could handle vector as min and max
      for (var i = 0; i < frameSize; i++) {
        outData[i] = Math.min(max, Math.max(min, data[i]));
      }return outData;
    }
  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.frame.data = this.inputVector(frame.data);
    }
  }, {
    key: 'inputSignal',
    value: function inputSignal(data) {
      var min = this.params.get('min');
      var max = this.params.get('max');
      var frameSize = this.streamParams.frameSize;
      var outData = this.frame.data;

      for (var i = 0; i < frameSize; i++) {
        outData[i] = Math.min(max, Math.max(min, data[i]));
      }return outData;
    }
  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.frame.data = this.inputSignal(frame.data);
    }
  }]);
  return Clip;
}(_BaseLfo3.default);

exports.default = Clip;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],352:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sqrt = Math.sqrt;
var cos = Math.cos;
var PI = Math.PI;

// Dct Type 2 - orthogonal matrix scaling
function getDctWeights(order, N) {
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'htk';

  var weights = new Float32Array(N * order);
  var piOverN = PI / N;
  var scale0 = 1 / sqrt(2);
  var scale = sqrt(2 / N);

  for (var k = 0; k < order; k++) {
    var s = k === 0 ? scale0 * scale : scale;
    // const s = scale; // rta doesn't apply k=0 scaling

    for (var n = 0; n < N; n++) {
      weights[k * N + n] = s * cos(k * (n + 0.5) * piOverN);
    }
  }

  return weights;
}

var definitions = {
  order: {
    type: 'integer',
    default: 12,
    metas: { kind: 'static' }
  }
};

/**
 * Compute the Discrete Cosine Transform of an input `signal` or `vector`.
 * (HTK style weighting).
 *
 * _support `standalone` usage_
 *
 * @memberof module:common.operator
 *
 * @param {Object} options - Override default parameters.
 * @param {Number} [options.order=12] - Number of computed bins.
 *
 * @example
 * import * as lfo from 'waves-lfo/client';
 *
 * // assuming some audio buffer
 * const source = new AudioInBuffer({
 *   audioBuffer: audioBuffer,
 *   useWorker: false,
 * });
 *
 * const slicer = new Slicer({
 *   frameSize: 512,
 *   hopSize: 512,
 * });
 *
 * const dct = new Dct({
 *   order: 12,
 * });
 *
 * const logger = new lfo.sink.Logger({ data: true });
 *
 * source.connect(slicer);
 * slicer.connect(dct);
 * dct.connect(logger);
 *
 * source.start();
 */

var Dct = function (_BaseLfo) {
  (0, _inherits3.default)(Dct, _BaseLfo);

  function Dct() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Dct);
    return (0, _possibleConstructorReturn3.default)(this, (Dct.__proto__ || (0, _getPrototypeOf2.default)(Dct)).call(this, definitions, options));
  }

  /** @private */


  (0, _createClass3.default)(Dct, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      var order = this.params.get('order');
      var inFrameSize = prevStreamParams.frameSize;

      this.streamParams.frameSize = order;
      this.streamParams.frameType = 'vector';
      this.streamParams.description = [];

      this.weightMatrix = getDctWeights(order, inFrameSize);

      this.propagateStreamParams();
    }

    /**
     * Use the `Dct` operator in `standalone` mode (i.e. outside of a graph).
     *
     * @param {Array} values - Input values.
     * @return {Array} - Dct of the input array.
     *
     * @example
     * const dct = new lfo.operator.Dct({ order: 12 });
     * // mandatory for use in standalone mode
     * dct.initStream({ frameSize: 512, frameType: 'signal' });
     * dct.inputSignal(data);
     */

  }, {
    key: 'inputSignal',
    value: function inputSignal(values) {
      var order = this.params.get('order');
      var frameSize = values.length;
      var outFrame = this.frame.data;
      var weights = this.weightMatrix;

      for (var k = 0; k < order; k++) {
        var offset = k * frameSize;
        outFrame[k] = 0;

        for (var n = 0; n < frameSize; n++) {
          outFrame[k] += values[n] * weights[offset + n];
        }
      }

      return outFrame;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.inputSignal(frame.data);
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.inputSignal(frame.data);
    }
  }]);
  return Dct;
}(_BaseLfo3.default);

exports.default = Dct;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],353:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function simpleLinearRegression(values, dt) {
  // means
  var xSum = 0;
  var ySum = 0;
  var length = values.length;

  for (var i = 0; i < length; i++) {
    xSum += i * dt;
    ySum += values[i];
  }

  var xMean = xSum / length;
  var yMean = ySum / length;

  var sumDiffXMeanSquared = 0; // sum[ pow((x - xMean), 2) ]
  var sumDiffYMeanSquared = 0; // sum[ pow((y - yMean), 2) ]
  var sumDiffXYMean = 0; // sum[ (x - xMean)(y - yMean) ]

  for (var _i = 0; _i < length; _i++) {
    var diffXMean = dt * _i - xMean;
    var diffYMean = values[_i] - yMean;

    var diffXMeanSquared = diffXMean * diffXMean;
    var diffYMeanSquared = diffYMean * diffYMean;
    var diffXYMean = diffXMean * diffYMean;

    sumDiffXMeanSquared += diffXMeanSquared;
    sumDiffYMeanSquared += diffYMeanSquared;
    sumDiffXYMean += diffXYMean;
  }

  // horizontal line, all y on same line
  if (sumDiffYMeanSquared === 0) return 0;

  // Pearson correlation coefficient:
  // cf. https://www.youtube.com/watch?v=2SCg8Kuh0tE
  //
  //                 ∑ [ (x - xMean)(y - yMean) ]
  // r = ------------------------------------------------------
  //     sqrt( ∑ [ pow((x - xMean), 2), pow((y - yMean), 2) ] )
  //
  //
  var r = sumDiffXYMean / Math.sqrt(sumDiffXMeanSquared * sumDiffYMeanSquared);

  // then we have:
  // cf. https://www.youtube.com/watch?v=GhrxgbQnEEU
  //
  // y = a + bx
  // where:
  //         Sy
  // b = r * --
  //         Sx
  //
  // a = yMean - b * xMean
  //
  // S for standard deviation
  //            ∑ [ pow((x - xMean), 2) ]
  // Sx = sqrt( -------------------------  )
  //                      N - 1
  var Sx = Math.sqrt(sumDiffXMeanSquared / (length - 1));
  var Sy = Math.sqrt(sumDiffYMeanSquared / (length - 1));
  var b = r * (Sy / Sx);

  return b;
}

var definitions = {
  size: {
    type: 'integer',
    min: 2,
    max: +Infinity,
    default: 3
  },
  useFrameRate: {
    type: 'integer',
    min: 0,
    max: +Infinity,
    default: null,
    nullable: true
  }
};

/**
 * Returns the simple derivative of successive value using
 * simple linear regression.
 * The current implementation assumes a fixed `frameRate` (`frame.time` is ignored)
 *
 * Before the module is filled, it outputs a value of 0.
 *
 * @param {Object} options - Override default parameters
 * @param {Number} [options.size=3] - Size of the window
 * @param {Number} [options.useFrameRate=null] - Override stream frame rate for
 *  the regression
 */

var Delta = function (_BaseLfo) {
  (0, _inherits3.default)(Delta, _BaseLfo);

  function Delta() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Delta);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Delta.__proto__ || (0, _getPrototypeOf2.default)(Delta)).call(this, definitions, options));

    _this.buffers = null;
    _this.ringIndex = 0;
    _this.frameRate = null;
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Delta, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      var frameSize = this.streamParams.frameSize;
      var size = this.params.get('size');
      var bufferSize = frameSize * size;

      this.buffers = [];
      // counter before the operator starts outputing frames
      this.ringIndex = 0;
      this.frameRate = this.params.get('useFrameRate') === null ? this.streamParams.frameRate : this.params.get('useFrameRate');

      for (var i = 0; i < frameSize; i++) {
        this.buffers[i] = new Float32Array(size);
      }this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'resetStream',
    value: function resetStream() {
      (0, _get3.default)(Delta.prototype.__proto__ || (0, _getPrototypeOf2.default)(Delta.prototype), 'resetStream', this).call(this);

      var frameSize = this.streamParams.frameSize;
      var size = this.params.get('size');
      var buffers = this.buffers;

      for (var i = 0; i < frameSize; i++) {
        for (var j = 0; j < size; j++) {
          buffers[i][j] = 0;
        }
      }

      this.ringIndex = 0;
    }

    /**
     * Assume a stream of vector at a fixed `frameRate`.
     */

  }, {
    key: 'inputVector',
    value: function inputVector(data) {
      var size = this.params.get('size');
      var outData = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      // const frameRate = this.streamParams.frameRate;
      var buffers = this.buffers;
      var dt = 1 / this.frameRate;

      // console.log(dt);

      if (this.ringIndex < size) this.ringIndex += 1;

      // copy incomming data into buffer
      for (var i = 0; i < frameSize; i++) {
        var buffer = buffers[i];

        // we need to keep the order of the incomming frames
        // so we have to shift all the values in the buffers
        for (var j = 1; j < size; j++) {
          buffer[j - 1] = buffer[j];
        }buffer[size - 1] = data[i];

        if (this.ringIndex >= size) outData[i] = simpleLinearRegression(buffer, dt);else outData[i] = 0;
      }

      return outData;
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.frame.data = this.inputVector(frame.data);
      // center time according to delta size
      var size = this.params.get('size');
      var frameRate = this.streamParams.frameRate;
      this.frame.time -= 0.5 * (size - 1) / frameRate;
    }
  }]);
  return Delta;
}(_BaseLfo3.default);

exports.default = Delta;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],354:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

var _windows = require('../utils/windows');

var _windows2 = _interopRequireDefault(_windows);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://code.soundsoftware.ac.uk/projects/js-dsp-test/repository/entry/fft/nayuki-obj/fft.js
/*
 * Free Fft and convolution (JavaScript)
 *
 * Copyright (c) 2014 Project Nayuki
 * http://www.nayuki.io/page/free-small-fft-in-multiple-languages
 *
 * (MIT License)
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * - The above copyright notice and this permission notice shall be included in
 *   all copies or substantial portions of the Software.
 * - The Software is provided "as is", without warranty of any kind, express or
 *   implied, including but not limited to the warranties of merchantability,
 *   fitness for a particular purpose and noninfringement. In no event shall the
 *   authors or copyright holders be liable for any claim, damages or other
 *   liability, whether in an action of contract, tort or otherwise, arising from,
 *   out of or in connection with the Software or the use or other dealings in the
 *   Software.
 *
 * Slightly restructured by Chris Cannam, cannam@all-day-breakfast.com
 *
 * @private
 */
/*
 * Construct an object for calculating the discrete Fourier transform (DFT) of
 * size n, where n is a power of 2.
 *
 * @private
 */
function FftNayuki(n) {

  this.n = n;
  this.levels = -1;

  for (var i = 0; i < 32; i++) {
    if (1 << i == n) {
      this.levels = i; // Equal to log2(n)
    }
  }

  if (this.levels == -1) {
    throw "Length is not a power of 2";
  }

  this.cosTable = new Array(n / 2);
  this.sinTable = new Array(n / 2);

  for (var i = 0; i < n / 2; i++) {
    this.cosTable[i] = Math.cos(2 * Math.PI * i / n);
    this.sinTable[i] = Math.sin(2 * Math.PI * i / n);
  }

  /*
   * Computes the discrete Fourier transform (DFT) of the given complex vector,
   * storing the result back into the vector.
   * The vector's length must be equal to the size n that was passed to the
   * object constructor, and this must be a power of 2. Uses the Cooley-Tukey
   * decimation-in-time radix-2 algorithm.
   *
   * @private
   */
  this.forward = function (real, imag) {
    var n = this.n;

    // Bit-reversed addressing permutation
    for (var i = 0; i < n; i++) {
      var j = reverseBits(i, this.levels);

      if (j > i) {
        var temp = real[i];
        real[i] = real[j];
        real[j] = temp;
        temp = imag[i];
        imag[i] = imag[j];
        imag[j] = temp;
      }
    }

    // Cooley-Tukey decimation-in-time radix-2 Fft
    for (var size = 2; size <= n; size *= 2) {
      var halfsize = size / 2;
      var tablestep = n / size;

      for (var i = 0; i < n; i += size) {
        for (var j = i, k = 0; j < i + halfsize; j++, k += tablestep) {
          var tpre = real[j + halfsize] * this.cosTable[k] + imag[j + halfsize] * this.sinTable[k];
          var tpim = -real[j + halfsize] * this.sinTable[k] + imag[j + halfsize] * this.cosTable[k];
          real[j + halfsize] = real[j] - tpre;
          imag[j + halfsize] = imag[j] - tpim;
          real[j] += tpre;
          imag[j] += tpim;
        }
      }
    }

    // Returns the integer whose value is the reverse of the lowest 'bits'
    // bits of the integer 'x'.
    function reverseBits(x, bits) {
      var y = 0;

      for (var i = 0; i < bits; i++) {
        y = y << 1 | x & 1;
        x >>>= 1;
      }

      return y;
    }
  };

  /*
   * Computes the inverse discrete Fourier transform (IDFT) of the given complex
   * vector, storing the result back into the vector.
   * The vector's length must be equal to the size n that was passed to the
   * object constructor, and this must be a power of 2. This is a wrapper
   * function. This transform does not perform scaling, so the inverse is not
   * a true inverse.
   *
   * @private
   */
  this.inverse = function (real, imag) {
    forward(imag, real);
  };
}

var sqrt = Math.sqrt;

var isPowerOfTwo = function isPowerOfTwo(number) {
  while (number % 2 === 0 && number > 1) {
    number = number / 2;
  }return number === 1;
};

var definitions = {
  size: {
    type: 'integer',
    default: 1024,
    metas: { kind: 'static' }
  },
  window: {
    type: 'enum',
    list: ['none', 'hann', 'hanning', 'hamming', 'blackman', 'blackmanharris', 'sine', 'rectangle'],
    default: 'none',
    metas: { kind: 'static' }
  },
  mode: {
    type: 'enum',
    list: ['magnitude', 'power'], // add complex output
    default: 'magnitude'
  },
  norm: {
    type: 'enum',
    default: 'auto',
    list: ['auto', 'none', 'linear', 'power']
  }

  /**
   * Compute the Fast Fourier Transform of an incomming `signal`.
   *
   * Fft implementation by [Nayuki](https://code.soundsoftware.ac.uk/projects/js-dsp-test/repository/entry/fft/nayuki-obj/fft.js).
   *
   * _support `standalone` usage_
   *
   * @memberof module:common.operator
   *
   * @param {Object} options - Override default parameters.
   * @param {Number} [options.size=1024] - Size of the fft, should be a power of 2.
   *  If the frame size of the incomming signal is lower than this value,
   *  it is zero padded to match the fft size.
   * @param {String} [options.window='none'] - Name of the window applied on the
   *  incomming signal. Available windows are: 'none', 'hann', 'hanning',
   *  'hamming', 'blackman', 'blackmanharris', 'sine', 'rectangle'.
   * @param {String} [options.mode='magnitude'] - Type of the output (`magnitude`
   *  or `power`)
   * @param {String} [options.norm='auto'] - Type of normalization applied on the
   *  output. Possible values are 'auto', 'none', 'linear', 'power'. When set to
   *  `auto`, a `linear` normalization is applied on the magnitude spectrum, while
   *  a `power` normalization is applied on the power spectrum.
   *
   * @example
   * import * as lfo from 'waves-lfo/client';
   *
   * // assuming an `audioBuffer` exists
   * const source = new lfo.source.AudioInBuffer({ audioBuffer });
   *
   * const slicer = new lfo.operator.Slicer({
   *   frameSize: 256,
   * });
   *
   * const fft = new lfo.operator.Fft({
   *   mode: 'power',
   *   window: 'hann',
   *   norm: 'power',
   *   size: 256,
   * });
   *
   * source.connect(slicer);
   * slicer.connect(fft);
   * source.start();
   *
   * // > outputs 129 bins containing the values of the power spectrum (including
   * // > DC and Nyuist frequencies).
   *
   * @todo - check if 'rectangle' and 'none' windows are not redondant.
   * @todo - check default values for all params.
   */
};
var Fft = function (_BaseLfo) {
  (0, _inherits3.default)(Fft, _BaseLfo);

  function Fft() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Fft);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Fft.__proto__ || (0, _getPrototypeOf2.default)(Fft)).call(this, definitions, options));

    _this.windowSize = null;
    _this.normalizeCoefs = null;
    _this.window = null;
    _this.real = null;
    _this.imag = null;
    _this.fft = null;

    if (!isPowerOfTwo(_this.params.get('size'))) throw new Error('fftSize must be a power of two');
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Fft, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);
      // set the output frame size
      var inFrameSize = prevStreamParams.frameSize;
      var fftSize = this.params.get('size');
      var mode = this.params.get('mode');
      var norm = this.params.get('norm');
      var windowName = this.params.get('window');
      // window `none` and `rectangle` are aliases
      if (windowName === 'none') windowName = 'rectangle';

      this.streamParams.frameSize = fftSize / 2 + 1;
      this.streamParams.frameType = 'vector';
      this.streamParams.description = [];
      // size of the window to apply on the input frame
      this.windowSize = inFrameSize < fftSize ? inFrameSize : fftSize;

      // references to populate in the window functions (cf. `initWindow`)
      this.normalizeCoefs = { linear: 0, power: 0 };
      this.window = new Float32Array(this.windowSize);

      (0, _windows2.default)(windowName, // name of the window
      this.window, // buffer populated with the window signal
      this.windowSize, // size of the window
      this.normalizeCoefs // object populated with the normalization coefs
      );

      var _normalizeCoefs = this.normalizeCoefs,
          linear = _normalizeCoefs.linear,
          power = _normalizeCoefs.power;


      switch (norm) {
        case 'none':
          this.windowNorm = 1;
          break;

        case 'linear':
          this.windowNorm = linear;
          break;

        case 'power':
          this.windowNorm = power;
          break;

        case 'auto':
          if (mode === 'magnitude') this.windowNorm = linear;else if (mode === 'power') this.windowNorm = power;
          break;
      }

      this.real = new Float32Array(fftSize);
      this.imag = new Float32Array(fftSize);
      this.fft = new FftNayuki(fftSize);

      this.propagateStreamParams();
    }

    /**
     * Use the `Fft` operator in `standalone` mode (i.e. outside of a graph).
     *
     * @param {Array} signal - Input values.
     * @return {Array} - Fft of the input signal.
     *
     * @example
     * const fft = new lfo.operator.Fft({ size: 512, window: 'hann' });
     * // mandatory for use in standalone mode
     * fft.initStream({ frameSize: 256, frameType: 'signal' });
     * fft.inputSignal(signal);
     */

  }, {
    key: 'inputSignal',
    value: function inputSignal(signal) {
      var mode = this.params.get('mode');
      var windowSize = this.windowSize;
      var frameSize = this.streamParams.frameSize;
      var fftSize = this.params.get('size');
      var outData = this.frame.data;

      // apply window on the input signal and reset imag buffer
      for (var i = 0; i < windowSize; i++) {
        this.real[i] = signal[i] * this.window[i] * this.windowNorm;
        this.imag[i] = 0;
      }

      // if real is bigger than input signal, fill with zeros
      for (var _i = windowSize; _i < fftSize; _i++) {
        this.real[_i] = 0;
        this.imag[_i] = 0;
      }

      this.fft.forward(this.real, this.imag);

      if (mode === 'magnitude') {
        var norm = 1 / fftSize;

        // DC index
        var realDc = this.real[0];
        var imagDc = this.imag[0];
        outData[0] = sqrt(realDc * realDc + imagDc * imagDc) * norm;

        // Nquyst index
        var realNy = this.real[fftSize / 2];
        var imagNy = this.imag[fftSize / 2];
        outData[fftSize / 2] = sqrt(realNy * realNy + imagNy * imagNy) * norm;

        // power spectrum
        for (var _i2 = 1, j = fftSize - 1; _i2 < fftSize / 2; _i2++, j--) {
          var real = 0.5 * (this.real[_i2] + this.real[j]);
          var imag = 0.5 * (this.imag[_i2] - this.imag[j]);

          outData[_i2] = 2 * sqrt(real * real + imag * imag) * norm;
        }
      } else if (mode === 'power') {
        var _norm = 1 / (fftSize * fftSize);

        // DC index
        var _realDc = this.real[0];
        var _imagDc = this.imag[0];
        outData[0] = (_realDc * _realDc + _imagDc * _imagDc) * _norm;

        // Nquyst index
        var _realNy = this.real[fftSize / 2];
        var _imagNy = this.imag[fftSize / 2];
        outData[fftSize / 2] = (_realNy * _realNy + _imagNy * _imagNy) * _norm;

        // power spectrum
        for (var _i3 = 1, _j = fftSize - 1; _i3 < fftSize / 2; _i3++, _j--) {
          var _real = 0.5 * (this.real[_i3] + this.real[_j]);
          var _imag = 0.5 * (this.imag[_i3] - this.imag[_j]);

          outData[_i3] = 4 * (_real * _real + _imag * _imag) * _norm;
        }
      }

      return outData;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.inputSignal(frame.data);
    }
  }]);
  return Fft;
}(_BaseLfo3.default);

exports.default = Fft;

},{"../../core/BaseLfo":383,"../utils/windows":382,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],355:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sqrt = Math.sqrt;

var definitions = {
  normalize: {
    type: 'boolean',
    default: true,
    metas: { kind: 'dynamic' }
  },
  power: {
    type: 'boolean',
    default: false,
    metas: { kind: 'dynamic' }
  }

  /**
   * Compute the magnitude of a `vector` input.
   *
   * _support `standalone` usage_
   *
   * @param {Object} options - Override default parameters.
   * @param {Boolean} [options.normalize=true] - Normalize output according to
   *  the vector size.
   * @param {Boolean} [options.power=false] - If true, returns the squared
   *  magnitude (power).
   *
   * @memberof module:common.operator
   *
   * @example
   * import * as lfo from 'waves-lfo/common';
   *
   * const eventIn = new lfo.source.EventIn({ frameSize: 2, frameType: 'vector' });
   * const magnitude = new lfo.operator.Magnitude();
   * const logger = new lfo.sink.Logger({ outFrame: true });
   *
   * eventIn.connect(magnitude);
   * magnitude.connect(logger);
   * eventIn.start();
   *
   * eventIn.process(null, [1, 1]);
   * > [1]
   * eventIn.process(null, [2, 2]);
   * > [2.82842712475]
   * eventIn.process(null, [3, 3]);
   * > [4.24264068712]
   */
};
var Magnitude = function (_BaseLfo) {
  (0, _inherits3.default)(Magnitude, _BaseLfo);

  function Magnitude() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Magnitude);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Magnitude.__proto__ || (0, _getPrototypeOf2.default)(Magnitude)).call(this, definitions, options));

    _this._normalize = _this.params.get('normalize');
    _this._power = _this.params.get('power');
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Magnitude, [{
    key: 'onParamUpdate',
    value: function onParamUpdate(name, value, metas) {
      (0, _get3.default)(Magnitude.prototype.__proto__ || (0, _getPrototypeOf2.default)(Magnitude.prototype), 'onParamUpdate', this).call(this, name, value, metas);

      switch (name) {
        case 'normalize':
          this._normalize = value;
          break;
        case 'power':
          this._power = value;
          break;
      }
    }

    /** @private */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);
      this.streamParams.frameSize = 1;
      this.streamParams.frameType = 'scalar';
      this.streamParams.description = ['magnitude'];
      this.propagateStreamParams();
    }

    /**
     * Use the `Magnitude` operator in `standalone` mode (i.e. outside of a graph).
     *
     * @param {Array|Float32Array} values - Values to process.
     * @return {Number} - Magnitude value.
     *
     * @example
     * import * as lfo from 'waves-lfo/client';
     *
     * const magnitude = new lfo.operator.Magnitude({ power: true });
     * magnitude.initStream({ frameType: 'vector', frameSize: 3 });
     * magnitude.inputVector([3, 3]);
     * > 4.24264068712
     */

  }, {
    key: 'inputVector',
    value: function inputVector(values) {
      var length = values.length;
      var sum = 0;

      for (var i = 0; i < length; i++) {
        sum += values[i] * values[i];
      }var mag = sum;

      if (this._normalize) mag /= length;

      if (!this._power) mag = sqrt(mag);

      return mag;
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.frame.data[0] = this.inputVector(frame.data);
    }
  }]);
  return Magnitude;
}(_BaseLfo3.default);

exports.default = Magnitude;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],356:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sqrt = Math.sqrt;

/**
 * Compute mean and standard deviation of a given `signal`.
 *
 * _support `standalone` usage_
 *
 * @memberof module:common.operator
 *
 * @example
 * import * as lfo from 'waves-lfo/client';
 *
 * const audioContext = new AudioContext();
 *
 * navigator.mediaDevices
 *   .getUserMedia({ audio: true })
 *   .then(init)
 *   .catch((err) => console.error(err.stack));
 *
 * function init(stream) {
 *   const source = audioContext.createMediaStreamSource(stream);
 *
 *   const audioInNode = new lfo.source.AudioInNode({
 *     sourceNode: source,
 *     audioContext: audioContext,
 *   });
 *
 *   const meanStddev = new lfo.operator.MeanStddev();
 *
 *   const traceDisplay = new lfo.sink.TraceDisplay({
 *     canvas: '#trace',
 *   });
 *
 *   audioInNode.connect(meanStddev);
 *   meanStddev.connect(traceDisplay);
 *   audioInNode.start();
 * }
 */

var MeanStddev = function (_BaseLfo) {
  (0, _inherits3.default)(MeanStddev, _BaseLfo);

  function MeanStddev() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, MeanStddev);

    // no options available, just throw an error if some param try to be set.
    return (0, _possibleConstructorReturn3.default)(this, (MeanStddev.__proto__ || (0, _getPrototypeOf2.default)(MeanStddev)).call(this, {}, options));
  }

  /** @private */


  (0, _createClass3.default)(MeanStddev, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      this.streamParams.frameType = 'vector';
      this.streamParams.frameSize = 2;
      this.streamParams.description = ['mean', 'stddev'];

      this.propagateStreamParams();
    }

    /**
     * Use the `MeanStddev` operator in `standalone` mode (i.e. outside of a graph).
     *
     * @param {Array|Float32Array} values - Values to process.
     * @return {Array} - Mean and standart deviation of the input values.
     *
     * @example
     * import * as lfo from 'waves-lfo/client';
     *
     * const meanStddev = new lfo.operator.MeanStddev();
     * meanStddev.initStream({ frameType: 'vector', frameSize: 1024 });
     * meanStddev.inputVector(someSineSignal);
     * > [0, 0.7071]
     */

  }, {
    key: 'inputSignal',
    value: function inputSignal(values) {
      var outData = this.frame.data;
      var length = values.length;

      var mean = 0;
      var m2 = 0;

      // compute mean and variance with Welford algorithm
      // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
      for (var i = 0; i < length; i++) {
        var x = values[i];
        var delta = x - mean;
        mean += delta / (i + 1);
        m2 += delta * (x - mean);
      }

      var variance = m2 / (length - 1);
      var stddev = sqrt(variance);

      outData[0] = mean;
      outData[1] = stddev;

      return outData;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.inputSignal(frame.data);
    }
  }]);
  return MeanStddev;
}(_BaseLfo3.default);

exports.default = MeanStddev;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],357:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _log = require('babel-runtime/core-js/math/log10');

var _log2 = _interopRequireDefault(_log);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var min = Math.min;
var max = Math.max;
var pow = Math.pow;
var log10 = _log2.default;

function hertzToMelHtk(freqHz) {
  return 2595 * (0, _log2.default)(1 + freqHz / 700);
}

function melToHertzHtk(freqMel) {
  return 700 * (Math.pow(10, freqMel / 2595) - 1);
}

/**
 * Returns a description of the weights to apply on the fft bins for each
 * Mel band filter.
 * @note - adapted from imtr-tools/rta
 *
 * @param {Number} nbrBins - Number of fft bins.
 * @param {Number} nbrFilter - Number of mel filters.
 * @param {Number} sampleRate - Sample Rate of the signal.
 * @param {Number} minFreq - Minimum Frequency to be considerered.
 * @param {Number} maxFreq - Maximum frequency to consider.
 * @return {Array<Object>} - Description of the weights to apply on the bins for
 *  each mel filter. Each description has the following structure:
 *  { startIndex: binIndex, centerFreq: binCenterFrequency, weights: [] }
 *
 * @private
 */
function getMelBandWeights(nbrBins, nbrBands, sampleRate, minFreq, maxFreq) {
  var type = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'htk';


  var hertzToMel = null;
  var melToHertz = null;
  var minMel = void 0;
  var maxMel = void 0;

  if (type === 'htk') {
    hertzToMel = hertzToMelHtk;
    melToHertz = melToHertzHtk;
    minMel = hertzToMel(minFreq);
    maxMel = hertzToMel(maxFreq);
  } else {
    throw new Error('Invalid mel band type: "' + type + '"');
  }

  var melBandDescriptions = new Array(nbrBands);
  // center frequencies of Fft bins
  var fftFreqs = new Float32Array(nbrBins);
  // center frequencies of mel bands - uniformly spaced in mel domain between
  // limits, there are 2 more frequencies than the actual number of filters in
  // order to calculate the slopes
  var filterFreqs = new Float32Array(nbrBands + 2);

  var fftSize = (nbrBins - 1) * 2;
  // compute bins center frequencies
  for (var i = 0; i < nbrBins; i++) {
    fftFreqs[i] = sampleRate * i / fftSize;
  }for (var _i = 0; _i < nbrBands + 2; _i++) {
    filterFreqs[_i] = melToHertz(minMel + _i / (nbrBands + 1) * (maxMel - minMel));
  } // loop throught filters
  for (var _i2 = 0; _i2 < nbrBands; _i2++) {
    var minWeightIndexDefined = 0;

    var description = {
      startIndex: null,
      centerFreq: null,
      weights: []

      // define contribution of each bin for the filter at index (i + 1)
      // do not process the last spectrum component (Nyquist)
    };for (var j = 0; j < nbrBins - 1; j++) {
      var posSlopeContrib = (fftFreqs[j] - filterFreqs[_i2]) / (filterFreqs[_i2 + 1] - filterFreqs[_i2]);

      var negSlopeContrib = (filterFreqs[_i2 + 2] - fftFreqs[j]) / (filterFreqs[_i2 + 2] - filterFreqs[_i2 + 1]);
      // lowerSlope and upper slope intersect at zero and with each other
      var contribution = max(0, min(posSlopeContrib, negSlopeContrib));

      if (contribution > 0) {
        if (description.startIndex === null) {
          description.startIndex = j;
          description.centerFreq = filterFreqs[_i2 + 1];
        }

        description.weights.push(contribution);
      }
    }

    // empty filter
    if (description.startIndex === null) {
      description.startIndex = 0;
      description.centerFreq = 0;
    }

    // @todo - do some scaling for Slaney-style mel
    melBandDescriptions[_i2] = description;
  }

  return melBandDescriptions;
}

var definitions = {
  log: {
    type: 'boolean',
    default: false,
    metas: { kind: 'static' }
  },
  nbrBands: {
    type: 'integer',
    default: 24,
    metas: { kind: 'static' }
  },
  minFreq: {
    type: 'float',
    default: 0,
    metas: { kind: 'static' }
  },
  maxFreq: {
    type: 'float',
    default: null,
    nullable: true,
    metas: { kind: 'static' }
  },
  power: {
    type: 'integer',
    default: 1,
    metas: { kind: 'dynamic' }
  }
};

/**
 * Compute the mel bands spectrum from a given spectrum (`vector` type).
 * _Implement the `htk` mel band style._
 *
 * _support `standalone` usage_
 *
 * @memberof module:common.operator
 *
 * @param {Object} options - Override default parameters.
 * @param {Boolean} [options.log=false] - Apply a logarithmic scale on the output.
 * @param {Number} [options.nbrBands=24] - Number of filters defining the mel
 *  bands.
 * @param {Number} [options.minFreq=0] - Minimum frequency to consider.
 * @param {Number} [options.maxFreq=null] - Maximum frequency to consider.
 *  If `null`, is set to Nyquist frequency.
 * @param {Number} [options.power=1] - Apply a power scaling on each mel band.
 *
 * @todo - implement Slaney style mel bands
 *
 * @example
 * import lfo from 'waves-lfo/node'
 *
 * // read a file from path (node only source)
 * const audioInFile = new lfo.source.AudioInFile({
 *   filename: 'path/to/file',
 *   frameSize: 512,
 * });
 *
 * const slicer = new lfo.operator.Slicer({
 *   frameSize: 256,
 *   hopSize: 256,
 * });
 *
 * const fft = new lfo.operator.Fft({
 *   size: 1024,
 *   window: 'hann',
 *   mode: 'power',
 *   norm: 'power',
 * });
 *
 * const mel = new lfo.operator.Mel({
 *   log: true,
 *   nbrBands: 24,
 * });
 *
 * const logger = new lfo.sink.Logger({ data: true });
 *
 * audioInFile.connect(slicer);
 * slicer.connect(fft);
 * fft.connect(mel);
 * mel.connect(logger);
 *
 * audioInFile.start();
 */

var Mel = function (_BaseLfo) {
  (0, _inherits3.default)(Mel, _BaseLfo);

  function Mel() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Mel);
    return (0, _possibleConstructorReturn3.default)(this, (Mel.__proto__ || (0, _getPrototypeOf2.default)(Mel)).call(this, definitions, options));
  }

  /** @private */


  (0, _createClass3.default)(Mel, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      var nbrBins = prevStreamParams.frameSize;
      var nbrBands = this.params.get('nbrBands');
      var sampleRate = this.streamParams.sourceSampleRate;
      var minFreq = this.params.get('minFreq');
      var maxFreq = this.params.get('maxFreq');

      //
      this.streamParams.frameSize = nbrBands;
      this.streamParams.frameType = 'vector';
      this.streamParams.description = [];

      if (maxFreq === null) maxFreq = this.streamParams.sourceSampleRate / 2;

      this.melBandDescriptions = getMelBandWeights(nbrBins, nbrBands, sampleRate, minFreq, maxFreq);

      this.propagateStreamParams();
    }

    /**
     * Use the `Mel` operator in `standalone` mode (i.e. outside of a graph).
     *
     * @param {Array} spectrum - Fft bins.
     * @return {Array} - Mel bands.
     *
     * @example
     * const mel = new lfo.operator.Mel({ nbrBands: 24 });
     * // mandatory for use in standalone mode
     * mel.initStream({ frameSize: 256, frameType: 'vector', sourceSampleRate: 44100 });
     * mel.inputVector(fftBins);
     */

  }, {
    key: 'inputVector',
    value: function inputVector(bins) {

      var power = this.params.get('power');
      var log = this.params.get('log');
      var melBands = this.frame.data;
      var nbrBands = this.streamParams.frameSize;
      var scale = 1;

      var minLogValue = 1e-48;
      var minLog = -480;

      if (log) scale *= nbrBands;

      for (var i = 0; i < nbrBands; i++) {
        var _melBandDescriptions$ = this.melBandDescriptions[i],
            startIndex = _melBandDescriptions$.startIndex,
            weights = _melBandDescriptions$.weights;

        var value = 0;

        for (var j = 0; j < weights.length; j++) {
          value += weights[j] * bins[startIndex + j];
        } // apply same logic as in PiPoBands
        if (scale !== 1) value *= scale;

        if (log) {
          if (value > minLogValue) value = 10 * log10(value);else value = minLog;
        }

        if (power !== 1) value = pow(value, power);

        melBands[i] = value;
      }

      return melBands;
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.inputVector(frame.data);
    }
  }]);
  return Mel;
}(_BaseLfo3.default);

exports.default = Mel;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/math/log10":178,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],358:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  // array defining the frameSizes of the input streamss
  // e.g. if [3, 2, 1], we wait for 3 different sources of respective 3, 2, 1 frameSizes
  frameSizes: {
    type: 'any',
    default: null,
    constant: true
  }

  /**
   * Merge multiple vector frames. The order of execution depends on the
   * order the branching was initially made. The first branche is master
   * on the time and trigger the output of the frame.
   *
   * @memberof module:common.operator
   *
   * @param {Object} options - Override default parameters
   * @param {Array} [options.frameSizes=null] - Array that defines the number
   *  of values to pick from each incomming vectors.
   *
   * @example
   * import * as lfo from 'waves-lfo/comon'
   *
   * const eventIn = new lfo.operator.EventIn({
   *   type: 'vector',
   *   frameSize: 4,
   *   frameRate: 0,
   * });
   *
   * const minMax = new lfo.operator.MinMax();
   * const magnitude = new lfo.operator.Magnitude();
   *
   * // take the first 2 values of the first branch and 1 value from the second branch
   * const merge = new lfo.operator.Merger({ frameSizes: [2, 1] });
   *
   * // this defines the order in which Merger will be called
   * eventIn.connect(minMax);
   * eventIn.connect(magnitude);
   *
   * minMax.connect(merger);
   * magnitude.connect(merger);
   */
};
var Merger = function (_BaseLfo) {
  (0, _inherits3.default)(Merger, _BaseLfo);

  function Merger(options) {
    (0, _classCallCheck3.default)(this, Merger);
    return (0, _possibleConstructorReturn3.default)(this, (Merger.__proto__ || (0, _getPrototypeOf2.default)(Merger)).call(this, definitions, options));
  }

  (0, _createClass3.default)(Merger, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      // ...
      var frameSizes = this.params.get('frameSizes');
      var numSources = frameSizes.length;

      var frameSize = 0;
      for (var i = 0; i < numSources; i++) {
        frameSize += frameSizes[i];
      }this.streamParams.frameSize = frameSize;
      this.numSources = numSources;
      this.sourceIndex = 0;

      this.propagateStreamParams();
    }
  }, {
    key: 'processVector',
    value: function processVector() {}
    // processSignal() {} // makes no sens to merge signals (maybe MUX / DEMUX)

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      var currentIndex = this.sourceIndex;
      var frameSizes = this.params.get('frameSizes');
      var numSources = frameSizes.length;
      var input = frame.data;
      var output = this.frame.data;

      // first source define time
      if (currentIndex === 0) this.frame.time = frame.time;

      var currentFrameSize = frameSizes[currentIndex];
      var offset = 0;

      for (var i = 0; i < currentIndex; i++) {
        offset += frameSizes[i];
      } // copy data
      for (var _i = 0; _i < currentFrameSize; _i++) {
        output[offset + _i] = input[_i];
      }this.sourceIndex = (this.sourceIndex + 1) % numSources;

      // we just received the last input, output the frame
      if (this.sourceIndex === 0) this.propagateFrame();
    }
  }]);
  return Merger;
}(_BaseLfo3.default);

exports.default = Merger;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],359:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

var _Fft = require('./Fft');

var _Fft2 = _interopRequireDefault(_Fft);

var _Mel = require('./Mel');

var _Mel2 = _interopRequireDefault(_Mel);

var _Dct = require('./Dct');

var _Dct2 = _interopRequireDefault(_Dct);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  nbrBands: {
    type: 'integer',
    default: 24,
    meta: { kind: 'static' }
  },
  nbrCoefs: {
    type: 'integer',
    default: 12,
    meta: { kind: 'static' }
  },
  minFreq: {
    type: 'float',
    default: 0,
    meta: { kind: 'static' }
  },
  maxFreq: {
    type: 'float',
    default: null,
    nullable: true,
    meta: { kind: 'static' }
  }
};

/**
 * Compute the Mfcc of the incomming `signal`. Is basically a wrapper around
 * [`Fft`]{@link module:common.operator.Fft}, [`Mel`]{@link module:common.operator.Mel}
 * and [`Dct`]{@link module:common.operator.Dct}.
 *
 * _support `standalone` usage_
 *
 * @memberof module:common.operator
 *
 * @param {Object} options - Override default parameters.
 * @param {nbrBands} [options.nbrBands=24] - Number of Mel bands.
 * @param {nbrCoefs} [options.nbrCoefs=12] - Number of output coefs.
 *
 * @see {@link module:common.operator.Fft}
 * @see {@link module:common.operator.Mel}
 * @see {@link module:common.operator.Dct}
 *
 * @example
 * import lfo from 'waves-lfo/node'
 *
 * const audioInFile = new lfo.source.AudioInFile({
 *   filename: 'path/to/file',
 *   frameSize: 512,
 * });
 *
 * const slicer = new lfo.operator.Slicer({
 *   frameSize: 256,
 * });
 *
 * const mfcc = new lfo.operator.Mfcc({
 *   nbrBands: 24,
 *   nbrCoefs: 12,
 * });
 *
 * const logger = new lfo.sink.Logger({ data: true });
 *
 * audioInFile.connect(slicer);
 * slicer.connect(mfcc);
 * mfcc.connect(logger);
 *
 * audioInFile.start();
 */

var Mfcc = function (_BaseLfo) {
  (0, _inherits3.default)(Mfcc, _BaseLfo);

  function Mfcc(options) {
    (0, _classCallCheck3.default)(this, Mfcc);
    return (0, _possibleConstructorReturn3.default)(this, (Mfcc.__proto__ || (0, _getPrototypeOf2.default)(Mfcc)).call(this, definitions, options));
  }

  /** @private */


  (0, _createClass3.default)(Mfcc, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      var nbrBands = this.params.get('nbrBands');
      var nbrCoefs = this.params.get('nbrCoefs');
      var minFreq = this.params.get('minFreq');
      var maxFreq = this.params.get('maxFreq');
      var inputFrameSize = prevStreamParams.frameSize;
      var inputFrameRate = prevStreamParams.frameRate;
      var inputSampleRate = prevStreamParams.sourceSampleRate;
      var nbrBins = inputFrameSize / 2 + 1;

      this.streamParams.frameSize = nbrCoefs;
      this.streamParams.frameType = 'vector';
      this.streamParams.description = [];

      this.fft = new _Fft2.default({
        window: 'hann',
        mode: 'power',
        norm: 'power',
        size: inputFrameSize
      });

      this.mel = new _Mel2.default({
        nbrBands: nbrBands,
        log: true,
        power: 1,
        minFreq: minFreq,
        maxFreq: maxFreq
      });

      this.dct = new _Dct2.default({
        order: nbrCoefs
      });

      // init streams
      this.fft.initStream({
        frameType: 'signal',
        frameSize: inputFrameSize,
        frameRate: inputFrameRate,
        sourceSampleRate: inputSampleRate
      });

      this.mel.initStream({
        frameType: 'vector',
        frameSize: nbrBins,
        frameRate: inputFrameRate,
        sourceSampleRate: inputSampleRate
      });

      this.dct.initStream({
        frameType: 'vector',
        frameSize: nbrBands,
        frameRate: inputFrameRate,
        sourceSampleRate: inputSampleRate
      });

      this.propagateStreamParams();
    }

    /**
     * Use the `Mfcc` operator in `standalone` mode (i.e. outside of a graph).
     *
     * @param {Array} data - Signal chunk to analyse.
     * @return {Array} - Mfcc coefficients.
     *
     * @example
     * const mfcc = new lfo.operator.Mfcc();
     * // mandatory for use in standalone mode
     * mfcc.initStream({ frameSize: 256, frameType: 'vector' });
     * mfcc.inputSignal(signal);
     */

  }, {
    key: 'inputSignal',
    value: function inputSignal(data) {
      var output = this.frame.data;
      var nbrCoefs = this.params.get('nbrCoefs');

      var bins = this.fft.inputSignal(data);
      var melBands = this.mel.inputVector(bins);
      // console.log(melBands);
      var coefs = this.dct.inputSignal(melBands);

      for (var i = 0; i < nbrCoefs; i++) {
        output[i] = coefs[i];
      }return output;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.inputSignal(frame.data);
    }
  }]);
  return Mfcc;
}(_BaseLfo3.default);

exports.default = Mfcc;

},{"../../core/BaseLfo":383,"./Dct":352,"./Fft":354,"./Mel":357,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],360:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Find minimun and maximum values of a given `signal`.
 *
 * _support `standalone` usage_
 *
 * @memberof module:common.operator
 *
 * @example
 * import * as lfo from 'waves-lfo/common';
 *
 * const eventIn = new lfo.source.EventIn({
 *   frameSize: 512,
 *   frameType: 'signal',
 *   sampleRate: 0,
 * });
 *
 * const minMax = new lfo.operator.MinMax();
 *
 * const logger = new lfo.sink.Logger({ data: true });
 *
 * eventIn.connect(minMax);
 * minMax.connect(logger);
 * eventIn.start()
 *
 * // create a frame
 * const signal = new Float32Array(512);
 * for (let i = 0; i < 512; i++)
 *   signal[i] = i + 1;
 *
 * eventIn.process(null, signal);
 * > [1, 512];
 */
var MinMax = function (_BaseLfo) {
  (0, _inherits3.default)(MinMax, _BaseLfo);

  function MinMax() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, MinMax);

    // throw errors if options are given
    return (0, _possibleConstructorReturn3.default)(this, (MinMax.__proto__ || (0, _getPrototypeOf2.default)(MinMax)).call(this, {}, options));
  }

  /** @private */


  (0, _createClass3.default)(MinMax, [{
    key: 'processStreamParams',
    value: function processStreamParams() {
      var prevStreamParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.prepareStreamParams(prevStreamParams);

      this.streamParams.frameType = 'vector';
      this.streamParams.frameSize = 2;
      this.streamParams.description = ['min', 'max'];

      this.propagateStreamParams();
    }

    /**
     * Use the `MinMax` operator in `standalone` mode (i.e. outside of a graph).
     *
     * @param {Float32Array|Array} data - Input signal.
     * @return {Array} - Min and max values.
     *
     * @example
     * const minMax = new MinMax();
     * minMax.initStream({ frameType: 'signal', frameSize: 10 });
     *
     * minMax.inputSignal([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
     * > [0, 5]
     */

  }, {
    key: 'inputSignal',
    value: function inputSignal(data) {
      var outData = this.frame.data;
      var min = +Infinity;
      var max = -Infinity;

      for (var i = 0, l = data.length; i < l; i++) {
        var value = data[i];
        if (value < min) min = value;
        if (value > max) max = value;
      }

      outData[0] = min;
      outData[1] = max;

      return outData;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.inputSignal(frame.data);
    }
  }]);
  return MinMax;
}(_BaseLfo3.default);

exports.default = MinMax;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],361:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  order: {
    type: 'integer',
    min: 1,
    max: 1e9,
    default: 10,
    metas: { kind: 'dynamic' }
  },
  fill: {
    type: 'float',
    min: -Infinity,
    max: +Infinity,
    default: 0,
    metas: { kind: 'dynamic' }
  }
};

/**
 * Compute a moving average operation on the incomming frames (`scalar` or
 * `vector` type). If the input is of type vector, the moving average is
 * computed for each dimension in parallel. If the source sample rate is defined
 * frame time is shifted to the middle of the window defined by the order.
 *
 * _support `standalone` usage_
 *
 * @memberof module:common.operator
 *
 * @param {Object} options - Override default parameters.
 * @param {Number} [options.order=10] - Number of successive values on which
 *  the average is computed.
 * @param {Number} [options.fill=0] - Value to fill the ring buffer with before
 *  the first input frame.
 *
 * @todo - Implement `processSignal` ?
 *
 * @example
 * import * as lfo from 'waves-lfo/common';
 *
 * const eventIn = new lfo.source.EventIn({
 *   frameSize: 2,
 *   frameType: 'vector'
 * });
 *
 * const movingAverage = new lfo.operator.MovingAverage({
 *   order: 5,
 *   fill: 0
 * });
 *
 * const logger = new lfo.sink.Logger({ data: true });
 *
 * eventIn.connect(movingAverage);
 * movingAverage.connect(logger);
 *
 * eventIn.start();
 *
 * eventIn.process(null, [1, 1]);
 * > [0.2, 0.2]
 * eventIn.process(null, [1, 1]);
 * > [0.4, 0.4]
 * eventIn.process(null, [1, 1]);
 * > [0.6, 0.6]
 * eventIn.process(null, [1, 1]);
 * > [0.8, 0.8]
 * eventIn.process(null, [1, 1]);
 * > [1, 1]
 */

var MovingAverage = function (_BaseLfo) {
  (0, _inherits3.default)(MovingAverage, _BaseLfo);

  function MovingAverage() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, MovingAverage);

    var _this = (0, _possibleConstructorReturn3.default)(this, (MovingAverage.__proto__ || (0, _getPrototypeOf2.default)(MovingAverage)).call(this, definitions, options));

    _this.sum = null;
    _this.ringBuffer = null;
    _this.ringIndex = 0;
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(MovingAverage, [{
    key: 'onParamUpdate',
    value: function onParamUpdate(name, value, metas) {
      (0, _get3.default)(MovingAverage.prototype.__proto__ || (0, _getPrototypeOf2.default)(MovingAverage.prototype), 'onParamUpdate', this).call(this, name, value, metas);

      // @todo - should be done lazily in process
      switch (name) {
        case 'order':
          this.processStreamParams();
          this.resetStream();
          break;
        case 'fill':
          this.resetStream();
          break;
      }
    }

    /** @private */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      var frameSize = this.streamParams.frameSize;
      var order = this.params.get('order');

      this.ringBuffer = new Float32Array(order * frameSize);

      if (frameSize > 1) this.sum = new Float32Array(frameSize);else this.sum = 0;

      this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'resetStream',
    value: function resetStream() {
      (0, _get3.default)(MovingAverage.prototype.__proto__ || (0, _getPrototypeOf2.default)(MovingAverage.prototype), 'resetStream', this).call(this);

      var order = this.params.get('order');
      var fill = this.params.get('fill');
      var ringBuffer = this.ringBuffer;
      var ringLength = ringBuffer.length;

      for (var i = 0; i < ringLength; i++) {
        ringBuffer[i] = fill;
      }var fillSum = order * fill;
      var frameSize = this.streamParams.frameSize;

      if (frameSize > 1) {
        for (var _i = 0; _i < frameSize; _i++) {
          this.sum[_i] = fillSum;
        }
      } else {
        this.sum = fillSum;
      }

      this.ringIndex = 0;
    }

    /** @private */

  }, {
    key: 'processScalar',
    value: function processScalar(frame) {
      this.frame.data[0] = this.inputScalar(frame.data[0]);
    }

    /**
     * Use the `MovingAverage` operator in `standalone` mode (i.e. outside of a
     * graph) with a `scalar` input.
     *
     * @param {Number} value - Value to feed the moving average with.
     * @return {Number} - Average value.
     *
     * @example
     * import * as lfo from 'waves-lfo/client';
     *
     * const movingAverage = new lfo.operator.MovingAverage({ order: 5 });
     * movingAverage.initStream({ frameSize: 1, frameType: 'scalar' });
     *
     * movingAverage.inputScalar(1);
     * > 0.2
     * movingAverage.inputScalar(1);
     * > 0.4
     * movingAverage.inputScalar(1);
     * > 0.6
     */

  }, {
    key: 'inputScalar',
    value: function inputScalar(value) {
      var order = this.params.get('order');
      var ringIndex = this.ringIndex;
      var ringBuffer = this.ringBuffer;
      var sum = this.sum;

      sum -= ringBuffer[ringIndex];
      sum += value;

      this.sum = sum;
      this.ringBuffer[ringIndex] = value;
      this.ringIndex = (ringIndex + 1) % order;

      return sum / order;
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.inputVector(frame.data);
    }

    /**
     * Use the `MovingAverage` operator in `standalone` mode (i.e. outside of a
     * graph) with a `vector` input.
     *
     * @param {Array} values - Values to feed the moving average with.
     * @return {Float32Array} - Average value for each dimension.
     *
     * @example
     * import * as lfo from 'waves-lfo/client';
     *
     * const movingAverage = new lfo.operator.MovingAverage({ order: 5 });
     * movingAverage.initStream({ frameSize: 2, frameType: 'scalar' });
     *
     * movingAverage.inputArray([1, 1]);
     * > [0.2, 0.2]
     * movingAverage.inputArray([1, 1]);
     * > [0.4, 0.4]
     * movingAverage.inputArray([1, 1]);
     * > [0.6, 0.6]
     */

  }, {
    key: 'inputVector',
    value: function inputVector(values) {
      var order = this.params.get('order');
      var outFrame = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      var ringIndex = this.ringIndex;
      var ringOffset = ringIndex * frameSize;
      var ringBuffer = this.ringBuffer;
      var sum = this.sum;
      var scale = 1 / order;

      for (var i = 0; i < frameSize; i++) {
        var ringBufferIndex = ringOffset + i;
        var value = values[i];
        var localSum = sum[i];

        localSum -= ringBuffer[ringBufferIndex];
        localSum += value;

        this.sum[i] = localSum;
        outFrame[i] = localSum * scale;
        ringBuffer[ringBufferIndex] = value;
      }

      this.ringIndex = (ringIndex + 1) % order;

      return outFrame;
    }

    /** @private */

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      this.prepareFrame();
      this.processFunction(frame);

      var order = this.params.get('order');
      var time = frame.time;
      // shift time to take account of the added latency
      if (this.streamParams.sourceSampleRate) time -= 0.5 * (order - 1) / this.streamParams.sourceSampleRate;

      this.frame.time = time;
      this.frame.metadata = frame.metadata;

      this.propagateFrame();
    }
  }]);
  return MovingAverage;
}(_BaseLfo3.default);

exports.default = MovingAverage;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],362:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  order: {
    type: 'integer',
    min: 1,
    max: 1e9,
    default: 9,
    metas: { kind: 'static' }
  },
  fill: {
    type: 'float',
    min: -Infinity,
    max: +Infinity,
    default: 0,
    metas: { kind: 'static' }
  }
};

/**
 * Compute a moving median operation on the incomming frames (`scalar` or
 * `vector` type). If the input is of type vector, the moving median is
 * computed for each dimension in parallel. If the source sample rate is defined
 * frame time is shifted to the middle of the window defined by the order.
 *
 * _support `standalone` usage_
 *
 * @memberof module:common.operator
 *
 * @param {Object} options - Override default parameters.
 * @param {Number} [options.order=9] - Number of successive values in which
 *  the median is searched. This value must be odd. _dynamic parameter_
 * @param {Number} [options.fill=0] - Value to fill the ring buffer with before
 *  the first input frame. _dynamic parameter_
 *
 * @todo - Implement `processSignal`
 *
 * @example
 * import * as lfo from 'waves-lfo/common';
 *
 * const eventIn = new lfo.source.EventIn({
 *   frameSize: 2,
 *   frameType: 'vector',
 * });
 *
 * const movingMedian = new lfo.operator.MovingMedian({
 *   order: 5,
 *   fill: 0,
 * });
 *
 * const logger = new lfo.sink.Logger({ data: true });
 *
 * eventIn.connect(movingMedian);
 * movingMedian.connect(logger);
 *
 * eventIn.start();
 *
 * eventIn.processFrame(null, [1, 1]);
 * > [0, 0]
 * eventIn.processFrame(null, [2, 2]);
 * > [0, 0]
 * eventIn.processFrame(null, [3, 3]);
 * > [1, 1]
 * eventIn.processFrame(null, [4, 4]);
 * > [2, 2]
 * eventIn.processFrame(null, [5, 5]);
 * > [3, 3]
 */

var MovingMedian = function (_BaseLfo) {
  (0, _inherits3.default)(MovingMedian, _BaseLfo);

  function MovingMedian() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, MovingMedian);

    var _this = (0, _possibleConstructorReturn3.default)(this, (MovingMedian.__proto__ || (0, _getPrototypeOf2.default)(MovingMedian)).call(this, definitions, options));

    _this.ringBuffer = null;
    _this.sortBuffer = null;
    _this.ringIndex = 0;

    _this._ensureOddOrder();
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(MovingMedian, [{
    key: '_ensureOddOrder',
    value: function _ensureOddOrder() {
      if (this.params.get('order') % 2 === 0) throw new Error('Invalid value ' + order + ' for param "order" - must be odd');
    }

    /** @private */

  }, {
    key: 'onParamUpdate',
    value: function onParamUpdate(name, value, metas) {
      (0, _get3.default)(MovingMedian.prototype.__proto__ || (0, _getPrototypeOf2.default)(MovingMedian.prototype), 'onParamUpdate', this).call(this, name, value, metas);

      switch (name) {
        case 'order':
          this._ensureOddOrder();
          this.processStreamParams();
          this.resetStream();
          break;
        case 'fill':
          this.resetStream();
          break;
      }
    }

    /** @private */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);
      // outType is similar to input type

      var frameSize = this.streamParams.frameSize;
      var order = this.params.get('order');

      this.ringBuffer = new Float32Array(frameSize * order);
      this.sortBuffer = new Float32Array(frameSize * order);

      this.minIndices = new Uint32Array(frameSize);

      this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'resetStream',
    value: function resetStream() {
      (0, _get3.default)(MovingMedian.prototype.__proto__ || (0, _getPrototypeOf2.default)(MovingMedian.prototype), 'resetStream', this).call(this);

      var fill = this.params.get('fill');
      var ringBuffer = this.ringBuffer;
      var ringLength = ringBuffer.length;

      for (var i = 0; i < ringLength; i++) {
        this.ringBuffer[i] = fill;
      }this.ringIndex = 0;
    }

    /** @private */

  }, {
    key: 'processScalar',
    value: function processScalar(frame) {
      this.frame.data[0] = this.inputScalar(frame.data[0]);
    }

    /**
     * Allows for the use of a `MovingMedian` outside a graph (e.g. inside
     * another node), in this case `processStreamParams` and `resetStream`
     * should be called manually on the node.
     *
     * @param {Number} value - Value to feed the moving median with.
     * @return {Number} - Median value.
     *
     * @example
     * import * as lfo from 'waves-lfo/client';
     *
     * const movingMedian = new MovingMedian({ order: 5 });
     * movingMedian.initStream({ frameSize: 1, frameType: 'scalar' });
     *
     * movingMedian.inputScalar(1);
     * > 0
     * movingMedian.inputScalar(2);
     * > 0
     * movingMedian.inputScalar(3);
     * > 1
     * movingMedian.inputScalar(4);
     * > 2
     */

  }, {
    key: 'inputScalar',
    value: function inputScalar(value) {
      var ringIndex = this.ringIndex;
      var ringBuffer = this.ringBuffer;
      var sortBuffer = this.sortBuffer;
      var order = this.params.get('order');
      var medianIndex = (order - 1) / 2;
      var startIndex = 0;

      ringBuffer[ringIndex] = value;

      for (var i = 0; i <= medianIndex; i++) {
        var min = +Infinity;
        var minIndex = null;

        for (var j = startIndex; j < order; j++) {
          if (i === 0) sortBuffer[j] = ringBuffer[j];

          if (sortBuffer[j] < min) {
            min = sortBuffer[j];
            minIndex = j;
          }
        }

        // swap minIndex and startIndex
        var cache = sortBuffer[startIndex];
        sortBuffer[startIndex] = sortBuffer[minIndex];
        sortBuffer[minIndex] = cache;

        startIndex += 1;
      }

      var median = sortBuffer[medianIndex];
      this.ringIndex = (ringIndex + 1) % order;

      return median;
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.inputVector(frame.data);
    }

    /**
     * Allows for the use of a `MovingMedian` outside a graph (e.g. inside
     * another node), in this case `processStreamParams` and `resetStream`
     * should be called manually on the node.
     *
     * @param {Array} values - Values to feed the moving median with.
     * @return {Float32Array} - Median values for each dimension.
     *
     * @example
     * import * as lfo from 'waves-lfo/client';
     *
     * const movingMedian = new MovingMedian({ order: 3, fill: 0 });
     * movingMedian.initStream({ frameSize: 3, frameType: 'vector' });
     *
     * movingMedian.inputArray([1, 1]);
     * > [0, 0]
     * movingMedian.inputArray([2, 2]);
     * > [1, 1]
     * movingMedian.inputArray([3, 3]);
     * > [2, 2]
     */

  }, {
    key: 'inputVector',
    value: function inputVector(values) {
      var order = this.params.get('order');
      var ringBuffer = this.ringBuffer;
      var ringIndex = this.ringIndex;
      var sortBuffer = this.sortBuffer;
      var outFrame = this.frame.data;
      var minIndices = this.minIndices;
      var frameSize = this.streamParams.frameSize;
      var medianIndex = Math.floor(order / 2);
      var startIndex = 0;

      for (var i = 0; i <= medianIndex; i++) {

        for (var j = 0; j < frameSize; j++) {
          outFrame[j] = +Infinity;
          minIndices[j] = 0;

          for (var k = startIndex; k < order; k++) {
            var index = k * frameSize + j;

            // update ring buffer corresponding to current
            if (k === ringIndex && i === 0) ringBuffer[index] = values[j];

            // copy value in sort buffer on first pass
            if (i === 0) sortBuffer[index] = ringBuffer[index];

            // find minium in the remaining array
            if (sortBuffer[index] < outFrame[j]) {
              outFrame[j] = sortBuffer[index];
              minIndices[j] = index;
            }
          }

          // swap minimum and curent index
          var swapIndex = startIndex * frameSize + j;
          var v = sortBuffer[swapIndex];
          sortBuffer[swapIndex] = sortBuffer[minIndices[j]];
          sortBuffer[minIndices[j]] = v;

          // store this minimum value as current result
          outFrame[j] = sortBuffer[swapIndex];
        }

        startIndex += 1;
      }

      this.ringIndex = (ringIndex + 1) % order;

      return this.frame.data;
    }

    /** @private */

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      this.preprocessFrame();
      this.processFunction(frame);

      var order = this.params.get('order');
      var time = frame.time;
      // shift time to take account of the added latency
      if (this.streamParams.sourceSampleRate) time -= 0.5 * (order - 1) / this.streamParams.sourceSampleRate;

      this.frame.time = time;
      this.frame.metadata = frame.metadata;

      this.propagateFrame(time, this.outFrame, metadata);
    }
  }]);
  return MovingMedian;
}(_BaseLfo3.default);

exports.default = MovingMedian;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],363:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  // float or array
  factor: {
    type: 'any',
    default: 1
  }
};

/**
 * Multiply a given signal or vector by a given factor. On vector
 * streams, `factor` can be an array of values to apply on each dimension of the
 * vector frames.
 *
 * _support `standalone` usage_
 *
 * @param {Object} options - override default values
 * @param {Number|Array} [options.factor=1] - factor or array of factor to
 *  apply on the incomming frame. Setting an array is only defined in case of
 *  a vector stream.
 *
 * @memberof module:common.operator
 *
 * @example
 * import * as lfo from 'waves-lfo/common';
 *
 * const eventIn = new lfo.operator.EventIn({
 *   type: 'vector',
 *   frameSize: 2,
 *   frameRate: 0,
 * });
 * const scaler = new lfo.operator.Multiplier({ factor: 0.1 });
 *
 * eventIn.connect(scaler);
 *
 * eventIn.process(null, [2, 3]);
 * > [0.2, 0.3]
 */

var Multiplier = function (_BaseLfo) {
  (0, _inherits3.default)(Multiplier, _BaseLfo);

  function Multiplier(options) {
    (0, _classCallCheck3.default)(this, Multiplier);
    return (0, _possibleConstructorReturn3.default)(this, (Multiplier.__proto__ || (0, _getPrototypeOf2.default)(Multiplier)).call(this, definitions, options));
  }

  /**
   * Use the `Multiplier` operator in standalone mode.
   *
   * @param {Float32Array|Array} data - Input vector
   * @return {Array} - Scaled values
   *
   * @example
   * const scaler = new Multiplier({ factor: [2, 4] });
   * scaler.initStream({ frameType: 'vector', frameSize: 2 });
   *
   * scaler.inputVector([3, 2]);
   * > [6, 8]
   */


  (0, _createClass3.default)(Multiplier, [{
    key: 'inputVector',
    value: function inputVector(data) {
      var output = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      var factor = this.params.get('factor');

      if (Array.isArray(factor)) {
        for (var i = 0; i < frameSize; i++) {
          output[i] = data[i] * factor[i];
        }
      } else {
        for (var _i = 0; _i < frameSize; _i++) {
          output[_i] = data[_i] * factor;
        }
      }

      return output;
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.frame.data = this.inputVector(frame.data);
    }

    /**
     * Use the `Multiplier` operator in standalone mode.
     *
     * @param {Float32Array|Array} data - Input signal.
     * @return {Array} - Scaled signal.
     *
     * @example
     * const scaler = new Multiplier({ factor: 0.1 });
     * scaler.initStream({ frameType: 'signal', frameSize: 2 });
     *
     * scaler.inputVector([1, 2]);
     * > [0.1, 0.2]
     */

  }, {
    key: 'inputSignal',
    value: function inputSignal(data) {
      var output = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      var factor = this.params.get('factor');

      for (var i = 0; i < frameSize; i++) {
        output[i] = data[i] * factor;
      }return output;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.frame.data = this.inputSignal(frame.data);
    }
  }]);
  return Multiplier;
}(_BaseLfo3.default);

exports.default = Multiplier;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],364:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  state: {
    type: 'enum',
    default: 'on',
    list: ['on', 'off'],
    metas: { kind: 'dynamic' }
  }
};

/**
 * The OnOff operator allows to stop the propagation of the stream in a
 * subgraph. When "on", frames are propagated, when "off" the propagation is
 * stopped.
 *
 * The `streamParams` propagation is never bypassed so the subsequent subgraph
 * is always ready for incomming frames.
 *
 * @memberof module:common.operator
 *
 * @param {Object} options - Override default parameters.
 * @param {String} [options.state='on'] - Default state.
 *
 * @example
 * import * as lfo from 'waves-lfo/common';
 *
 * const frames = [
 *   { time: 0, data: [1, 2] },
 *   { time: 1, data: [3, 4] },
 *   { time: 2, data: [5, 6] },
 * ];
 *
 * const eventIn = new EventIn({
 *   frameSize: 2,
 *   frameRate: 0,
 *   frameType: 'vector',
 * });
 *
 * const onOff = new OnOff();
 *
 * const logger = new Logger({ data: true });
 *
 * eventIn.connect(onOff);
 * onOff.connect(logger);
 *
 * eventIn.start();
 *
 * eventIn.processFrame(frames[0]);
 * > [0, 1]
 *
 * // bypass subgraph
 * onOff.setState('off');
 * eventIn.processFrame(frames[1]);
 *
 * // re-open subgraph
 * onOff.setState('on');
 * eventIn.processFrame(frames[2]);
 * > [5, 6]
 */

var OnOff = function (_BaseLfo) {
  (0, _inherits3.default)(OnOff, _BaseLfo);

  function OnOff() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, OnOff);

    var _this = (0, _possibleConstructorReturn3.default)(this, (OnOff.__proto__ || (0, _getPrototypeOf2.default)(OnOff)).call(this, definitions, options));

    _this.state = _this.params.get('state');
    return _this;
  }

  /**
   * Set the state of the `OnOff`.
   *
   * @param {String} state - New state of the operator (`on` or `off`)
   */


  (0, _createClass3.default)(OnOff, [{
    key: 'setState',
    value: function setState(state) {
      if (definitions.state.list.indexOf(state) === -1) throw new Error('Invalid switch state value "' + state + '" [valid values: "on"/"off"]');

      this.state = state;
    }

    // define all possible stream API
    /** @private */

  }, {
    key: 'processScalar',
    value: function processScalar() {}
    /** @private */

  }, {
    key: 'processVector',
    value: function processVector() {}
    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal() {}

    /** @private */

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      if (this.state === 'on') {
        this.prepareFrame();

        this.frame.time = frame.time;
        this.frame.metadata = frame.metadata;
        this.frame.data = frame.data;

        this.propagateFrame();
      }
    }
  }]);
  return OnOff;
}(_BaseLfo3.default);

exports.default = OnOff;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],365:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  exponent: {
    type: 'float',
    default: 1
  }
};

/**
 * Apply an exponant power to the stream.
 *
 * @param {Object} options - Override default parameters
 * @param {Number} exponent - Exponent
 */

var Power = function (_BaseLfo) {
  (0, _inherits3.default)(Power, _BaseLfo);

  function Power(options) {
    (0, _classCallCheck3.default)(this, Power);
    return (0, _possibleConstructorReturn3.default)(this, (Power.__proto__ || (0, _getPrototypeOf2.default)(Power)).call(this, definitions, options));
  }

  (0, _createClass3.default)(Power, [{
    key: 'inputVector',
    value: function inputVector(data) {
      var outData = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      var exponent = this.params.get('exponent');

      for (var i = 0; i < frameSize; i++) {
        outData[i] = Math.pow(data[i], exponent);
      }return outData;
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.inputVector(frame.data);
    }
  }, {
    key: 'inputSignal',
    value: function inputSignal(data) {
      var outData = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      var exponent = this.params.get('exponent');

      for (var i = 0; i < frameSize; i++) {
        outData[i] = Math.pow(data[i], exponent);
      }return outData;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.inputSignal(frame.data);
    }
  }]);
  return Power;
}(_BaseLfo3.default);

exports.default = Power;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],366:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sqrt = Math.sqrt;

var definitions = {
  power: {
    type: 'boolean',
    default: false,
    metas: { kind: 'dynamic' }
  }
};

/**
 * Compute the Root Mean Square of a `signal`.
 *
 * _support `standalone` usage_
 *
 * @memberof module:common.operator
 *
 * @param {Object} options - Override default parameters.
 * @param {Boolean} [options.power=false] - If `true` remove the "R" of the
 *  "Rms" and return the squared result (i.e. power).
 *
 * @example
 * import * as lfo from 'waves-lfo/client';
 *
 * // assuming some `AudioBuffer`
 * const audioInBuffer = new lfo.source.AudioInBuffer({
 *   audioBuffer: audioBuffer,
 *   frameSize: 512,
 * });
 *
 * const rms = new lfo.operator.Rms();
 * const logger = new lfo.sink.Logger({ data: true });
 *
 * audioInBuffer.connect(rms);
 * rms.connect(logger);
 *
 * audioInBuffer.start();
 */

var Rms = function (_BaseLfo) {
  (0, _inherits3.default)(Rms, _BaseLfo);

  function Rms() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Rms);
    return (0, _possibleConstructorReturn3.default)(this, (Rms.__proto__ || (0, _getPrototypeOf2.default)(Rms)).call(this, definitions, options));
  }

  /** @private */


  (0, _createClass3.default)(Rms, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      this.streamParams.frameSize = 1;
      this.streamParams.frameType = 'scalar';
      this.streamParams.description = ['rms'];

      this.propagateStreamParams();
    }

    /**
     * Allows for the use of a `Rms` outside a graph (e.g. inside
     * another node). Return the rms of the given signal block.
     *
     * @param {Number} signal - Signal block to be computed.
     * @return {Number} - rms of the input signal.
     *
     * @example
     * import * as lfo from 'waves-lfo/client';
     *
     * const rms = new lfo.operator.Rms();
     * rms.initStream({ frameType: 'signal', frameSize: 1000 });
     *
     * const results = rms.inputSignal([...values]);
     */

  }, {
    key: 'inputSignal',
    value: function inputSignal(signal) {
      var power = this.params.get('power');
      var length = signal.length;
      var rms = 0;

      for (var i = 0; i < length; i++) {
        rms += signal[i] * signal[i];
      }rms = rms / length;

      if (!power) rms = sqrt(rms);

      return rms;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.frame.data[0] = this.inputSignal(frame.data);
    }
  }]);
  return Rms;
}(_BaseLfo3.default);

exports.default = Rms;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],367:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  type: {
    type: 'enum',
    list: ['linear'],
    default: 'linear',
    metas: {
      kind: 'dynamic'
    }
  },
  inputMin: {
    type: 'float',
    default: 0,
    min: -Infinity,
    max: +Infinity,
    metas: {
      kind: 'dynamic'
    }
  },
  inputMax: {
    type: 'float',
    default: 1,
    min: -Infinity,
    max: +Infinity,
    metas: {
      kind: 'dynamic'
    }
  },
  outputMin: {
    type: 'float',
    default: 1,
    min: -Infinity,
    max: +Infinity,
    metas: {
      kind: 'dynamic'
    }
  },
  outputMax: {
    type: 'float',
    default: 1,
    min: -Infinity,
    max: +Infinity,
    metas: {
      kind: 'dynamic'
    }
  }

  /**
   * Apply a linear scale on the incomming stream. The output is not clipped.
   *
   * @todo - implement log and exp scale
   *
   * @param {Object} options - Override default options
   * @param {Number} [options.inputMin=0] - Input Minimum
   * @param {Number} [options.inputMax=1] - Input Maximum
   * @param {Number} [options.outputMin=0] - Output Minimum
   * @param {Number} [options.outputMax=1] - Output Maximum
   */
};
var Scale = function (_BaseLfo) {
  (0, _inherits3.default)(Scale, _BaseLfo);

  function Scale(options) {
    (0, _classCallCheck3.default)(this, Scale);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Scale.__proto__ || (0, _getPrototypeOf2.default)(Scale)).call(this, definitions, options));

    _this.scale = null;
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Scale, [{
    key: '_setScaleFunction',
    value: function _setScaleFunction() {
      var inputMin = this.params.get('inputMin');
      var inputMax = this.params.get('inputMax');
      var outputMin = this.params.get('outputMin');
      var outputMax = this.params.get('outputMax');

      var a = (outputMax - outputMin) / (inputMax - inputMin);
      var b = outputMin - a * inputMin;

      this.scale = function (x) {
        return a * x + b;
      };
    }

    /** @private */

  }, {
    key: 'onParamUpdate',
    value: function onParamUpdate(name, value, metas) {
      (0, _get3.default)(Scale.prototype.__proto__ || (0, _getPrototypeOf2.default)(Scale.prototype), 'onParamUpdate', this).call(this, name, value, metas);

      if (name !== 'type') this._setScaleFunction();
    }

    /** @private */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      this._setScaleFunction();

      this.propagateStreamParams();
    }
  }, {
    key: 'inputVector',
    value: function inputVector(data) {
      var outData = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      var scale = this.scale;

      for (var i = 0; i < frameSize; i++) {
        outData[i] = scale(data[i]);
      }return outData;
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      this.frame.data = this.inputVector(frame.data);
    }
  }, {
    key: 'inputSignal',
    value: function inputSignal(data) {
      var outData = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      var scale = this.scale;

      for (var i = 0; i < frameSize; i++) {
        outData[i] = scale(data[i]);
      }return outData;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.frame.data = this.inputVector(frame.data);
    }
  }]);
  return Scale;
}(_BaseLfo3.default);

exports.default = Scale;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],368:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

var _MovingAverage = require('./MovingAverage');

var _MovingAverage2 = _interopRequireDefault(_MovingAverage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var min = Math.min;
var max = Math.max;

var definitions = {
  logInput: {
    type: 'boolean',
    default: false,
    metas: { kind: 'dyanmic' }
  },
  minInput: {
    type: 'float',
    default: 0.000000000001,
    metas: { kind: 'dyanmic' }
  },
  filterOrder: {
    type: 'integer',
    default: 5,
    metas: { kind: 'dyanmic' }
  },
  threshold: {
    type: 'float',
    default: 3,
    metas: { kind: 'dyanmic' }
  },
  offThreshold: {
    type: 'float',
    default: -Infinity,
    metas: { kind: 'dyanmic' }
  },
  minInter: {
    type: 'float',
    default: 0.050,
    metas: { kind: 'dyanmic' }
  },
  maxDuration: {
    type: 'float',
    default: Infinity,
    metas: { kind: 'dyanmic' }
  }

  /**
   * Create segments based on attacks.
   *
   * @memberof module:common.operator
   *
   * @param {Object} options - Override default parameters.
   * @param {Boolean} [options.logInput=false] - Apply log on the input.
   * @param {Number} [options.minInput=0.000000000001] - Minimum value to use as
   *  input.
   * @param {Number} [options.filterOrder=5] - Order of the internally used moving
   *  average.
   * @param {Number} [options.threshold=3] - Threshold that triggers a segment
   *  start.
   * @param {Number} [options.offThreshold=-Infinity] - Threshold that triggers
   *  a segment end.
   * @param {Number} [options.minInter=0.050] - Minimum delay between two semgents.
   * @param {Number} [options.maxDuration=Infinity] - Maximum duration of a segment.
   *
   * @example
   * import * as lfo from 'waves-lfo/client';
   *
   * // assuming a stream from the microphone
   * const source = audioContext.createMediaStreamSource(stream);
   *
   * const audioInNode = new lfo.source.AudioInNode({
   *   sourceNode: source,
   *   audioContext: audioContext,
   * });
   *
   * const slicer = new lfo.operator.Slicer({
   *   frameSize: frameSize,
   *   hopSize: hopSize,
   *   centeredTimeTags: true
   * });
   *
   * const power = new lfo.operator.RMS({
   *   power: true,
   * });
   *
   * const segmenter = new lfo.operator.Segmenter({
   *   logInput: true,
   *   filterOrder: 5,
   *   threshold: 3,
   *   offThreshold: -Infinity,
   *   minInter: 0.050,
   *   maxDuration: 0.050,
   * });
   *
   * const logger = new lfo.sink.Logger({ time: true });
   *
   * audioInNode.connect(slicer);
   * slicer.connect(power);
   * power.connect(segmenter);
   * segmenter.connect(logger);
   *
   * audioInNode.start();
   */
};
var Segmenter = function (_BaseLfo) {
  (0, _inherits3.default)(Segmenter, _BaseLfo);

  function Segmenter(options) {
    (0, _classCallCheck3.default)(this, Segmenter);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Segmenter.__proto__ || (0, _getPrototypeOf2.default)(Segmenter)).call(this, definitions, options));

    _this.insideSegment = false;
    _this.onsetTime = -Infinity;

    // stats
    _this.min = Infinity;
    _this.max = -Infinity;
    _this.sum = 0;
    _this.sumOfSquares = 0;
    _this.count = 0;

    var minInput = _this.params.get('minInput');
    var fill = minInput;

    if (_this.params.get('logInput') && minInput > 0) fill = Math.log(minInput);

    _this.movingAverage = new _MovingAverage2.default({
      order: _this.params.get('filterOrder'),
      fill: fill
    });

    _this.lastMvavrg = fill;
    return _this;
  }

  (0, _createClass3.default)(Segmenter, [{
    key: 'onParamUpdate',
    value: function onParamUpdate(name, value, metas) {
      (0, _get3.default)(Segmenter.prototype.__proto__ || (0, _getPrototypeOf2.default)(Segmenter.prototype), 'onParamUpdate', this).call(this, name, value, metas);

      if (name === 'filterOrder') this.movingAverage.params.set('order', value);
    }
  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      this.streamParams.frameType = 'vector';
      this.streamParams.frameSize = 5;
      this.streamParams.frameRate = 0;
      this.streamParams.description = ['duration', 'min', 'max', 'mean', 'stddev'];

      this.movingAverage.initStream(prevStreamParams);

      this.propagateStreamParams();
    }
  }, {
    key: 'resetStream',
    value: function resetStream() {
      (0, _get3.default)(Segmenter.prototype.__proto__ || (0, _getPrototypeOf2.default)(Segmenter.prototype), 'resetStream', this).call(this);
      this.movingAverage.resetStream();
      this.resetSegment();
    }
  }, {
    key: 'finalizeStream',
    value: function finalizeStream(endTime) {
      if (this.insideSegment) this.outputSegment(endTime);

      (0, _get3.default)(Segmenter.prototype.__proto__ || (0, _getPrototypeOf2.default)(Segmenter.prototype), 'finalizeStream', this).call(this, endTime);
    }
  }, {
    key: 'resetSegment',
    value: function resetSegment() {
      this.insideSegment = false;
      this.onsetTime = -Infinity;
      // stats
      this.min = Infinity;
      this.max = -Infinity;
      this.sum = 0;
      this.sumOfSquares = 0;
      this.count = 0;
    }
  }, {
    key: 'outputSegment',
    value: function outputSegment(endTime) {
      var outData = this.frame.data;
      outData[0] = endTime - this.onsetTime;
      outData[1] = this.min;
      outData[2] = this.max;

      var norm = 1 / this.count;
      var mean = this.sum * norm;
      var meanOfSquare = this.sumOfSquares * norm;
      var squareOfmean = mean * mean;

      outData[3] = mean;
      outData[4] = 0;

      if (meanOfSquare > squareOfmean) outData[4] = Math.sqrt(meanOfSquare - squareOfmean);

      this.frame.time = this.onsetTime;

      this.propagateFrame();
    }
  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      var logInput = this.params.get('logInput');
      var minInput = this.params.get('minInput');
      var threshold = this.params.get('threshold');
      var minInter = this.params.get('minInter');
      var maxDuration = this.params.get('maxDuration');
      var offThreshold = this.params.get('offThreshold');
      var rawValue = frame.data[0];
      var time = frame.time;
      var value = Math.max(rawValue, minInput);

      if (logInput) value = Math.log(value);

      var diff = value - this.lastMvavrg;
      this.lastMvavrg = this.movingAverage.inputScalar(value);

      // update frame metadata
      this.frame.metadata = frame.metadata;

      if (diff > threshold && time - this.onsetTime > minInter) {
        if (this.insideSegment) this.outputSegment(time);

        // start segment
        this.insideSegment = true;
        this.onsetTime = time;
        this.max = -Infinity;
      }

      if (this.insideSegment) {
        this.min = min(this.min, rawValue);
        this.max = max(this.max, rawValue);
        this.sum += rawValue;
        this.sumOfSquares += rawValue * rawValue;
        this.count++;

        if (time - this.onsetTime >= maxDuration || value <= offThreshold) {
          this.outputSegment(time);
          this.insideSegment = false;
        }
      }
    }
  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      this.prepareFrame();
      this.processFunction(frame);
      // do not propagate here as the frameRate is now zero
    }
  }]);
  return Segmenter;
}(_BaseLfo3.default);

exports.default = Segmenter;

},{"../../core/BaseLfo":383,"./MovingAverage":361,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],369:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  index: {
    type: 'integer',
    default: 0,
    metas: { kind: 'static' }
  },
  indexes: {
    type: 'any',
    default: null,
    nullable: true,
    metas: { kind: 'dynamic' }
  }
};

/**
 * Select one or several indexes from a `vector` input. If only one index is
 * selected, the output will be of type `scalar`, otherwise the output will
 * be a vector containing the selected indexes.
 *
 * @memberof module:common.operator
 *
 * @param {Object} options - Override default values.
 * @param {Number} options.index - Index to select from the input frame.
 * @param {Array<Number>} options.indexes - Indices to select from the input
 *  frame, if defined, take precedance over `option.index`.
 *
 * @example
 * import * as lfo from 'waves-lfo/common';
 *
 * const eventIn = new lfo.source.EventIn({
 *   frameType: 'vector',
 *   frameSize: 3,
 * });
 *
 * const select = new lfo.operator.Select({
 *   indexes: [2, 0],
 * });
 *
 * eventIn.start();
 * eventIn.process(0, [0, 2, 4]);
 * > [4, 0]
 * eventIn.process(0, [1, 3, 5]);
 * > [5, 1]
 */

var Select = function (_BaseLfo) {
  (0, _inherits3.default)(Select, _BaseLfo);

  function Select() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Select);
    return (0, _possibleConstructorReturn3.default)(this, (Select.__proto__ || (0, _getPrototypeOf2.default)(Select)).call(this, definitions, options));
  }

  /** @private */


  (0, _createClass3.default)(Select, [{
    key: 'onParamUpdate',
    value: function onParamUpdate(name, value) {
      var metas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      (0, _get3.default)(Select.prototype.__proto__ || (0, _getPrototypeOf2.default)(Select.prototype), 'onParamUpdate', this).call(this, name, value, metas);

      var index = this.params.get('index');
      var indexes = this.params.get('indexes');

      this.select = indexes !== null ? indexes : [index];
    }

    /** @private */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      var _this2 = this;

      this.prepareStreamParams(prevStreamParams);

      var index = this.params.get('index');
      var indexes = this.params.get('indexes');

      var max = indexes !== null ? Math.max.apply(null, indexes) : index;

      if (max >= prevStreamParams.frameSize) throw new Error('Invalid select index "' + max + '"');

      this.streamParams.frameType = indexes !== null ? 'vector' : 'scalar';
      this.streamParams.frameSize = indexes !== null ? indexes.length : 1;

      this.select = indexes !== null ? indexes : [index];

      // steal description() from parent
      if (prevStreamParams.description) {
        this.select.forEach(function (val, index) {
          _this2.streamParams.description[index] = prevStreamParams.description[val];
        });
      }

      this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {
      var data = frame.data;
      var outData = this.frame.data;
      var select = this.select;

      for (var i = 0; i < select.length; i++) {
        outData[i] = data[select[i]];
      }
    }
  }]);
  return Select;
}(_BaseLfo3.default);

exports.default = Select;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],370:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  frameSize: {
    type: 'integer',
    default: 512,
    metas: { kind: 'static' }
  },
  hopSize: { // should be nullable
    type: 'integer',
    default: null,
    nullable: true,
    metas: { kind: 'static' }
  },
  centeredTimeTags: {
    type: 'boolean',
    default: false
  }

  /**
   * Change the `frameSize` and `hopSize` of a `signal` input according to
   * the given options.
   * This operator updates the stream parameters according to its configuration.
   *
   * @memberof module:common.operator
   *
   * @param {Object} options - Override default parameters.
   * @param {Number} [options.frameSize=512] - Frame size of the output signal.
   * @param {Number} [options.hopSize=null] - Number of samples between two
   *  consecutive frames. If null, `hopSize` is set to `frameSize`.
   * @param {Boolean} [options.centeredTimeTags] - Move the time tag to the middle
   *  of the frame.
   *
   * @example
   * import * as lfo from 'waves-lfo/common';
   *
   * const eventIn = new lfo.source.EventIn({
   *   frameType: 'signal',
   *   frameSize: 10,
   *   sampleRate: 2,
   * });
   *
   * const slicer = new lfo.operator.Slicer({
   *   frameSize: 4,
   *   hopSize: 2
   * });
   *
   * const logger = new lfo.sink.Logger({ time: true, data: true });
   *
   * eventIn.connect(slicer);
   * slicer.connect(logger);
   * eventIn.start();
   *
   * eventIn.process(0, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * > { time: 0, data: [0, 1, 2, 3] }
   * > { time: 1, data: [2, 3, 4, 5] }
   * > { time: 2, data: [4, 5, 6, 7] }
   * > { time: 3, data: [6, 7, 8, 9] }
   */
};
var Slicer = function (_BaseLfo) {
  (0, _inherits3.default)(Slicer, _BaseLfo);

  function Slicer() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Slicer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Slicer.__proto__ || (0, _getPrototypeOf2.default)(Slicer)).call(this, definitions, options));

    var hopSize = _this.params.get('hopSize');
    var frameSize = _this.params.get('frameSize');

    if (!hopSize) _this.params.set('hopSize', frameSize);

    _this.params.addListener(_this.onParamUpdate.bind(_this));

    _this.frameIndex = 0;
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Slicer, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      var hopSize = this.params.get('hopSize');
      var frameSize = this.params.get('frameSize');

      this.streamParams.frameSize = frameSize;
      this.streamParams.frameRate = prevStreamParams.sourceSampleRate / hopSize;

      if (this.streamParams.frameSize === 1) this.streamParams.frameType = 'scalar';else this.streamParams.frameType = 'signal';

      this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'resetStream',
    value: function resetStream() {
      (0, _get3.default)(Slicer.prototype.__proto__ || (0, _getPrototypeOf2.default)(Slicer.prototype), 'resetStream', this).call(this);
      this.frameIndex = 0;
    }

    /** @private */

  }, {
    key: 'finalizeStream',
    value: function finalizeStream(endTime) {
      if (this.frameIndex > 0) {
        var frameRate = this.streamParams.frameRate;
        var frameSize = this.streamParams.frameSize;
        var data = this.frame.data;
        // set the time of the last frame
        this.frame.time += 1 / frameRate;

        for (var i = this.frameIndex; i < frameSize; i++) {
          data[i] = 0;
        }this.propagateFrame();
      }

      (0, _get3.default)(Slicer.prototype.__proto__ || (0, _getPrototypeOf2.default)(Slicer.prototype), 'finalizeStream', this).call(this, endTime);
    }

    /** @private */

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      this.prepareFrame();
      this.processFunction(frame);
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      var time = frame.time;
      var block = frame.data;
      var metadata = frame.metadata;

      var centeredTimeTags = this.params.get('centeredTimeTags');
      var hopSize = this.params.get('hopSize');
      var outFrame = this.frame.data;
      var frameSize = this.streamParams.frameSize;
      var sampleRate = this.streamParams.sourceSampleRate;
      var samplePeriod = 1 / sampleRate;
      var blockSize = block.length;

      var frameIndex = this.frameIndex;
      var blockIndex = 0;

      while (blockIndex < blockSize) {
        var numSkip = 0;

        // skip block samples for negative frameIndex (frameSize < hopSize)
        if (frameIndex < 0) {
          numSkip = -frameIndex;
          frameIndex = 0; // reset `frameIndex`
        }

        if (numSkip < blockSize) {
          blockIndex += numSkip; // skip block segment
          // can copy all the rest of the incoming block
          var numCopy = blockSize - blockIndex;
          // connot copy more than what fits into the frame
          var maxCopy = frameSize - frameIndex;

          if (numCopy >= maxCopy) numCopy = maxCopy;

          // copy block segment into frame
          var copy = block.subarray(blockIndex, blockIndex + numCopy);
          outFrame.set(copy, frameIndex);
          // advance block and frame index
          blockIndex += numCopy;
          frameIndex += numCopy;

          // send frame when completed
          if (frameIndex === frameSize) {
            // define time tag for the outFrame according to configuration
            if (centeredTimeTags) this.frame.time = time + (blockIndex - frameSize / 2) * samplePeriod;else this.frame.time = time + (blockIndex - frameSize) * samplePeriod;

            this.frame.metadata = metadata;
            // forward to next nodes
            this.propagateFrame();

            // shift frame left
            if (hopSize < frameSize) outFrame.set(outFrame.subarray(hopSize, frameSize), 0);

            frameIndex -= hopSize; // hop forward
          }
        } else {
          // skip entire block
          var blockRest = blockSize - blockIndex;
          frameIndex += blockRest;
          blockIndex += blockRest;
        }
      }

      this.frameIndex = frameIndex;
    }
  }]);
  return Slicer;
}(_BaseLfo3.default);

exports.default = Slicer;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],371:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ceil = Math.ceil;

/**
 * paper: http://recherche.ircam.fr/equipes/pcm/cheveign/pss/2002_JASA_YIN.pdf
 * implementation based on https://github.com/ashokfernandez/Yin-Pitch-Tracking
 * @private
 */

var definitions = {
  threshold: {
    type: 'float',
    default: 0.1, // default from paper
    metas: { kind: 'static' }
  },
  downSamplingExp: { // downsampling factor
    type: 'integer',
    default: 2,
    min: 0,
    max: 3,
    metas: { kind: 'static' }
  },
  minFreq: { //
    type: 'float',
    default: 60, // mean 735 samples
    min: 0,
    metas: { kind: 'static' }
  }

  /**
   * Yin fundamental frequency estimator, based on algorithm described in
   * [YIN, a fundamental frequency estimator for speech and music](http://recherche.ircam.fr/equipes/pcm/cheveign/pss/2002_JASA_YIN.pdf)
   * by Cheveigne and Kawahara.
   * On each frame, this operator propagate a vector containing the following
   * values: `frequency`, `probability`.
   *
   * For good results the input frame size should be large (1024 or 2048).
   *
   * _support `standalone` usage_
   *
   * @note - In node for a frame of 2048 samples, average computation time is:
   *         0.00016742283339993389 second.
   *
   * @memberof module:common.operator
   *
   * @param {Object} options - Override default parameters.
   * @param {Number} [options.threshold=0.1] - Absolute threshold to test the
   *  normalized difference (see paper for more informations).
   * @param {Number} [options.downSamplingExp=2] - Down sample the input frame by
   *  a factor of 2 at the power of `downSamplingExp` (min=0 and max=3) for
   *  performance improvements.
   * @param {Number} [options.minFreq=60] - Minimum frequency the operator can
   *  search for. This parameter defines the size of the autocorrelation performed
   *  on the signal, the input frame size should be around 2 time this size for
   *  good results (i.e. `inputFrameSize ≈ 2 * (samplingRate / minFreq)`).
   *
   * @example
   * import * as lfo from 'waves-lfo/client';
   *
   * // assuming some AudioBuffer
   * const source = new lfo.source.AudioInBuffer({
   *   audioBuffer: audioBuffer,
   * });
   *
   * const slicer = new lfo.operator.Slicer({
   *   frameSize: 2048,
   * });
   *
   * const yin = new lfo.operator.Yin();
   * const logger = new lfo.sink.Logger({ data: true });
   *
   * source.connect(slicer);
   * slicer.connect(yin);
   * yin.connect(logger);
   *
   * source.start();
   */
};
var Yin = function (_BaseLfo) {
  (0, _inherits3.default)(Yin, _BaseLfo);

  function Yin(options) {
    (0, _classCallCheck3.default)(this, Yin);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Yin.__proto__ || (0, _getPrototypeOf2.default)(Yin)).call(this, definitions, options));

    _this.probability = 0;
    _this.pitch = -1;

    _this.test = 0;
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(Yin, [{
    key: '_downsample',
    value: function _downsample(input, size, output, downSamplingExp) {
      var outputSize = size >> downSamplingExp;
      var i = void 0,
          j = void 0;

      switch (downSamplingExp) {
        case 0:
          // no down sampling
          for (i = 0; i < size; i++) {
            output[i] = input[i];
          }break;
        case 1:
          for (i = 0, j = 0; i < outputSize; i++, j += 2) {
            output[i] = 0.5 * (input[j] + input[j + 1]);
          }break;
        case 2:
          for (i = 0, j = 0; i < outputSize; i++, j += 4) {
            output[i] = 0.25 * (input[j] + input[j + 1] + input[j + 2] + input[j + 3]);
          }break;
        case 3:
          for (i = 0, j = 0; i < outputSize; i++, j += 8) {
            output[i] = 0.125 * (input[j] + input[j + 1] + input[j + 2] + input[j + 3] + input[j + 4] + input[j + 5] + input[j + 6] + input[j + 7]);
          }break;
      }

      return outputSize;
    }

    /** @private */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      this.streamParams.frameType = 'vector';
      this.streamParams.frameSize = 2;
      this.streamParams.description = ['frequency', 'confidence'];

      this.inputFrameSize = prevStreamParams.frameSize;
      // handle params
      var sourceSampleRate = this.streamParams.sourceSampleRate;
      var downSamplingExp = this.params.get('downSamplingExp');
      var downFactor = 1 << downSamplingExp; // 2^n
      var downSR = sourceSampleRate / downFactor;
      var downFrameSize = this.inputFrameSize / downFactor; // n_tick_down // 1 / 2^n

      var minFreq = this.params.get('minFreq');
      // limit min freq, cf. paper IV. sensitivity to parameters
      var minFreqNbrSamples = downSR / minFreq;
      // const bufferSize = prevStreamParams.frameSize;
      this.halfBufferSize = downFrameSize / 2;

      // minimum error to not crash but not enought to have results
      if (minFreqNbrSamples > this.halfBufferSize) throw new Error('Invalid input frame size, too small for given "minFreq"');

      this.downSamplingExp = downSamplingExp;
      this.downSamplingRate = downSR;
      this.downFrameSize = downFrameSize;
      this.buffer = new Float32Array(downFrameSize);
      // autocorrelation buffer
      this.yinBuffer = new Float32Array(this.halfBufferSize);

      this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: '_downsample',
    value: function _downsample(input, size, output, downSamplingExp) {
      var outputSize = size >> downSamplingExp;
      var i = void 0,
          j = void 0;

      switch (downSamplingExp) {
        case 0:
          // no down sampling
          for (i = 0; i < size; i++) {
            output[i] = input[i];
          }break;
        case 1:
          for (i = 0, j = 0; i < outputSize; i++, j += 2) {
            output[i] = 0.5 * (input[j] + input[j + 1]);
          }break;
        case 2:
          for (i = 0, j = 0; i < outputSize; i++, j += 4) {
            output[i] = 0.25 * (input[j] + input[j + 1] + input[j + 2] + input[j + 3]);
          }break;
        case 3:
          for (i = 0, j = 0; i < outputSize; i++, j += 8) {
            output[i] = 0.125 * (input[j] + input[j + 1] + input[j + 2] + input[j + 3] + input[j + 4] + input[j + 5] + input[j + 6] + input[j + 7]);
          }break;
      }

      return outputSize;
    }

    /**
     * Step 1, 2 and 3 - Squared difference of the shifted signal with itself.
     * cumulative mean normalized difference.
     *
     * @private
     */

  }, {
    key: '_normalizedDifference',
    value: function _normalizedDifference(buffer) {
      var halfBufferSize = this.halfBufferSize;
      var yinBuffer = this.yinBuffer;
      var sum = 0;

      // difference for different shift values (tau)
      for (var tau = 0; tau < halfBufferSize; tau++) {
        var squaredDifference = 0; // reset buffer

        // take difference of the signal with a shifted version of itself then
        // sqaure the result
        for (var i = 0; i < halfBufferSize; i++) {
          var delta = buffer[i] - buffer[i + tau];
          squaredDifference += delta * delta;
        }

        // step 3 - normalize yinBuffer
        if (tau > 0) {
          sum += squaredDifference;
          yinBuffer[tau] = squaredDifference * (tau / sum);
        }
      }

      yinBuffer[0] = 1;
    }

    /**
     * Step 4 - find first best tau that is under the thresold.
     *
     * @private
     */

  }, {
    key: '_absoluteThreshold',
    value: function _absoluteThreshold() {
      var threshold = this.params.get('threshold');
      var yinBuffer = this.yinBuffer;
      var halfBufferSize = this.halfBufferSize;
      var tau = void 0;

      for (tau = 1; tau < halfBufferSize; tau++) {
        if (yinBuffer[tau] < threshold) {
          // keep increasing tau if next value is better
          while (tau + 1 < halfBufferSize && yinBuffer[tau + 1] < yinBuffer[tau]) {
            tau += 1;
          } // best tau found , yinBuffer[tau] can be seen as an estimation of
          // aperiodicity then: periodicity = 1 - aperiodicity
          this.probability = 1 - yinBuffer[tau];
          break;
        }
      }

      // return -1 if not match found
      return tau === halfBufferSize ? -1 : tau;
    }

    /**
     * Step 5 - Find a better fractionnal approximate of tau.
     * this can probably be simplified...
     *
     * @private
     */

  }, {
    key: '_parabolicInterpolation',
    value: function _parabolicInterpolation(tauEstimate) {
      var halfBufferSize = this.halfBufferSize;
      var yinBuffer = this.yinBuffer;
      var betterTau = void 0;
      // @note - tauEstimate cannot be zero as the loop start at 1 in step 4
      var x0 = tauEstimate - 1;
      var x2 = tauEstimate < halfBufferSize - 1 ? tauEstimate + 1 : tauEstimate;

      // if `tauEstimate` is last index, we can't interpolate
      if (x2 === tauEstimate) {
        betterTau = tauEstimate;
      } else {
        var s0 = yinBuffer[x0];
        var s1 = yinBuffer[tauEstimate];
        var s2 = yinBuffer[x2];

        // @note - don't fully understand this formula neither...
        betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
      }

      return betterTau;
    }

    /**
     * Use the `Yin` operator in `standalone` mode (i.e. outside of a graph).
     *
     * @param {Array|Float32Array} input - The signal fragment to process.
     * @return {Array} - Array containing the `frequency`, `energy`, `periodicity`
     *  and `AC1`
     *
     * @example
     * import * as lfo from 'waves-lfo/client';
     *
     * const yin = new lfo.operator.Yin();
     * yin.initStream({
     *   frameSize: 2048,
     *   frameType: 'signal',
     *   sourceSampleRate: 44100
     * });
     *
     * const results = yin.inputSignal(signal);
     */

  }, {
    key: 'inputSignal',
    value: function inputSignal(input) {
      this.pitch = -1;
      this.probability = 0;

      var buffer = this.buffer;
      var inputFrameSize = this.inputFrameSize;
      var downSamplingExp = this.downSamplingExp;
      var sampleRate = this.downSamplingRate;
      var outData = this.frame.data;
      var tauEstimate = -1;

      // subsampling
      this._downsample(input, inputFrameSize, buffer, downSamplingExp);
      // step 1, 2, 3 - normalized squared difference of the signal with a
      // shifted version of itself
      this._normalizedDifference(buffer);
      // step 4 - find first best tau estimate that is over the threshold
      tauEstimate = this._absoluteThreshold();

      if (tauEstimate !== -1) {
        // step 5 - so far tau is an integer shift of the signal, check if
        // there is a better fractionnal value around
        tauEstimate = this._parabolicInterpolation(tauEstimate);
        this.pitch = sampleRate / tauEstimate;
      }

      outData[0] = this.pitch;
      outData[1] = this.probability;

      return outData;
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      this.inputSignal(frame.data);
    }
  }]);
  return Yin;
}(_BaseLfo3.default);

exports.default = Yin;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],372:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Biquad = require('./Biquad');

var _Biquad2 = _interopRequireDefault(_Biquad);

var _Clip = require('./Clip');

var _Clip2 = _interopRequireDefault(_Clip);

var _Dct = require('./Dct');

var _Dct2 = _interopRequireDefault(_Dct);

var _Delta = require('./Delta');

var _Delta2 = _interopRequireDefault(_Delta);

var _Fft = require('./Fft');

var _Fft2 = _interopRequireDefault(_Fft);

var _Magnitude = require('./Magnitude');

var _Magnitude2 = _interopRequireDefault(_Magnitude);

var _MeanStddev = require('./MeanStddev');

var _MeanStddev2 = _interopRequireDefault(_MeanStddev);

var _Mel = require('./Mel');

var _Mel2 = _interopRequireDefault(_Mel);

var _Merger = require('./Merger');

var _Merger2 = _interopRequireDefault(_Merger);

var _Mfcc = require('./Mfcc');

var _Mfcc2 = _interopRequireDefault(_Mfcc);

var _MinMax = require('./MinMax');

var _MinMax2 = _interopRequireDefault(_MinMax);

var _MovingAverage = require('./MovingAverage');

var _MovingAverage2 = _interopRequireDefault(_MovingAverage);

var _MovingMedian = require('./MovingMedian');

var _MovingMedian2 = _interopRequireDefault(_MovingMedian);

var _OnOff = require('./OnOff');

var _OnOff2 = _interopRequireDefault(_OnOff);

var _Power = require('./Power');

var _Power2 = _interopRequireDefault(_Power);

var _Rms = require('./Rms');

var _Rms2 = _interopRequireDefault(_Rms);

var _Multiplier = require('./Multiplier');

var _Multiplier2 = _interopRequireDefault(_Multiplier);

var _Scale = require('./Scale');

var _Scale2 = _interopRequireDefault(_Scale);

var _Segmenter = require('./Segmenter');

var _Segmenter2 = _interopRequireDefault(_Segmenter);

var _Select = require('./Select');

var _Select2 = _interopRequireDefault(_Select);

var _Slicer = require('./Slicer');

var _Slicer2 = _interopRequireDefault(_Slicer);

var _Yin = require('./Yin');

var _Yin2 = _interopRequireDefault(_Yin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  Biquad: _Biquad2.default,
  Clip: _Clip2.default,
  Dct: _Dct2.default,
  Delta: _Delta2.default,
  Fft: _Fft2.default,
  Magnitude: _Magnitude2.default,
  MeanStddev: _MeanStddev2.default,
  Mel: _Mel2.default,
  Merger: _Merger2.default,
  Mfcc: _Mfcc2.default,
  MinMax: _MinMax2.default,
  MovingAverage: _MovingAverage2.default,
  MovingMedian: _MovingMedian2.default,
  OnOff: _OnOff2.default,
  Power: _Power2.default,
  Rms: _Rms2.default,
  Multiplier: _Multiplier2.default,
  Scale: _Scale2.default,
  Segmenter: _Segmenter2.default,
  Select: _Select2.default,
  Slicer: _Slicer2.default,
  Yin: _Yin2.default
};

},{"./Biquad":350,"./Clip":351,"./Dct":352,"./Delta":353,"./Fft":354,"./Magnitude":355,"./MeanStddev":356,"./Mel":357,"./Merger":358,"./Mfcc":359,"./MinMax":360,"./MovingAverage":361,"./MovingMedian":362,"./Multiplier":363,"./OnOff":364,"./Power":365,"./Rms":366,"./Scale":367,"./Segmenter":368,"./Select":369,"./Slicer":370,"./Yin":371}],373:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  processStreamParams: {
    type: 'any',
    default: null,
    nullable: true,
    metas: { kind: 'dynamic' }
  },
  processFrame: {
    type: 'any',
    default: null,
    nullable: true,
    metas: { kind: 'dynamic' }
  },
  finalizeStream: {
    type: 'any',
    default: null,
    nullable: true,
    metas: { kind: 'dynamic' }
  }
};

/**
 * Create a bridge between the graph and application logic. Handle `push`
 * and `pull` paradigms.
 *
 * This sink can handle any type of input (`signal`, `vector`, `scalar`)
 *
 * @memberof module:common.sink
 *
 * @param {Object} options - Override default parameters.
 * @param {Function} [options.processFrame=null] - Callback executed on each
 *  `processFrame` call.
 * @param {Function} [options.finalizeStream=null] - Callback executed on each
 *  `finalizeStream` call.
 *
 * @see {@link module:core.BaseLfo#processFrame}
 * @see {@link module:core.BaseLfo#processStreamParams}
 *
 * @example
 * import * as lfo from 'waves-lfo/common';
 *
 * const frames = [
 *  { time: 0, data: [0, 1] },
 *  { time: 1, data: [1, 2] },
 * ];
 *
 * const eventIn = new EventIn({
 *   frameType: 'vector',
 *   frameSize: 2,
 *   frameRate: 1,
 * });
 *
 * const bridge = new Bridge({
 *   processFrame: (frame) => console.log(frame),
 * });
 *
 * eventIn.connect(bridge);
 * eventIn.start();
 *
 * // callback executed on each frame
 * eventIn.processFrame(frame[0]);
 * > { time: 0, data: [0, 1] }
 * eventIn.processFrame(frame[1]);
 * > { time: 1, data: [1, 2] }
 *
 * // pull current frame when needed
 * console.log(bridge.frame);
 * > { time: 1, data: [1, 2] }
 */

var Bridge = function (_BaseLfo) {
  (0, _inherits3.default)(Bridge, _BaseLfo);

  function Bridge() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Bridge);
    return (0, _possibleConstructorReturn3.default)(this, (Bridge.__proto__ || (0, _getPrototypeOf2.default)(Bridge)).call(this, definitions, options));
  }

  /** @private */


  (0, _createClass3.default)(Bridge, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      var processStreamParamsCallback = this.params.get('processStreamParams');

      if (processStreamParamsCallback !== null) processStreamParamsCallback(this.streamParams);

      this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'finalizeStream',
    value: function finalizeStream(endTime) {
      var finalizeStreamCallback = this.params.get('finalizeStream');

      if (finalizeStreamCallback !== null) finalizeStreamCallback(endTime);
    }

    // process any type
    /** @private */

  }, {
    key: 'processScalar',
    value: function processScalar() {}
    /** @private */

  }, {
    key: 'processVector',
    value: function processVector() {}
    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal() {}

    /** @private */

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      this.prepareFrame();

      var processFrameCallback = this.params.get('processFrame');
      var output = this.frame;
      output.data = new Float32Array(this.streamParams.frameSize);
      // pull interface (we copy data since we don't know what could
      // be done outside the graph)
      for (var i = 0; i < this.streamParams.frameSize; i++) {
        output.data[i] = frame.data[i];
      }output.time = frame.time;
      output.metadata = frame.metadata;

      // `push` interface
      if (processFrameCallback !== null) processFrameCallback(output);
    }
  }]);
  return Bridge;
}(_BaseLfo3.default);

exports.default = Bridge;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],374:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  separateArrays: {
    type: 'boolean',
    default: false,
    constant: true
  },
  callback: {
    type: 'any',
    default: null,
    nullable: true,
    metas: { kind: 'dynamic' }
  }
};

/**
 * Record input frames from a graph. This sink can handle `signal`, `vector`
 * or `scalar` inputs.
 *
 * When the recording is stopped (either by calling `stop` on the node or when
 * the stream is finalized), the callback given as parameter is executed with
 * the recorder data as argument.
 *
 *
 * @param {Object} options - Override default parameters.
 * @param {Boolean} [options.separateArrays=false] - Format of the retrieved
 *  values:
 *  - when `false`, format is [{ time, data }, { time, data }, ...]
 *  - when `true`, format is { time: [...], data: [...] }
 * @param {Function} [options.callback] - Callback to execute when a new record
 *  is ended. This can happen when:
 *  - `stop` is called on the recorder
 *  - `stop` is called on the source.
 *
 * @todo - Add auto record param.
 *
 * @memberof module:common.sink
 *
 * @example
 * import * as lfo from 'waves-lfo/common';
 *
 * const eventIn = new lfo.source.EventIn({
 *  frameType: 'vector',
 *  frameSize: 2,
 *  frameRate: 0,
 * });
 *
 * const recorder = new lfo.sink.DataRecorder({
 *   callback: (data) => console.log(data),
 * });
 *
 * eventIn.connect(recorder);
 * eventIn.start();
 * recorder.start();
 *
 * eventIn.process(0, [0, 1]);
 * eventIn.process(1, [1, 2]);
 *
 * recorder.stop();
 * > [{ time: 0, data: [0, 1] }, { time: 1, data: [1, 2] }];
 */

var DataRecorder = function (_BaseLfo) {
  (0, _inherits3.default)(DataRecorder, _BaseLfo);

  function DataRecorder() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, DataRecorder);

    /**
     * Define if the node is currently recording.
     *
     * @type {Boolean}
     * @name isRecording
     * @instance
     * @memberof module:sink.SignalRecorder
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (DataRecorder.__proto__ || (0, _getPrototypeOf2.default)(DataRecorder)).call(this, definitions, options));

    _this.isRecording = false;
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(DataRecorder, [{
    key: '_initStore',
    value: function _initStore() {
      var separateArrays = this.params.get('separateArrays');

      if (separateArrays) this._store = { time: [], data: [] };else this._store = [];
    }

    /** @private */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);
      this._initStore();
      this.propagateStreamParams();
    }

    /**
     * Start recording.
     *
     * @see {@link module:client.sink.DataRecorder#stop}
     */

  }, {
    key: 'start',
    value: function start() {
      this.isRecording = true;
    }

    /**
     * Stop recording and execute the callback defined in parameters.
     *
     * @see {@link module:client.sink.DataRecorder#start}
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (this.isRecording) {
        this.isRecording = false;
        var callback = this.params.get('callback');

        if (callback !== null) callback(this._store);

        this._initStore();
      }
    }

    /** @private */

  }, {
    key: 'finalizeStream',
    value: function finalizeStream() {
      this.stop();
    }

    // handle any input types
    /** @private */

  }, {
    key: 'processScalar',
    value: function processScalar(frame) {}
    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {}
    /** @private */

  }, {
    key: 'processVector',
    value: function processVector(frame) {}
  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      if (this.isRecording) {
        this.prepareFrame(frame);

        var separateArrays = this.params.get('separateArrays');
        var entry = {
          time: frame.time,
          data: new Float32Array(frame.data)
        };

        if (!separateArrays) {
          this._store.push(entry);
        } else {
          this._store.time.push(entry.time);
          this._store.data.push(entry.data);
        }
      }
    }
  }]);
  return DataRecorder;
}(_BaseLfo3.default);

exports.default = DataRecorder;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],375:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  time: {
    type: 'boolean',
    default: false,
    metas: { kind: 'dynamic' }
  },
  data: {
    type: 'boolean',
    default: false,
    metas: { kind: 'dynamic' }
  },
  metadata: {
    type: 'boolean',
    default: false,
    metas: { kind: 'dynamic' }
  },
  streamParams: {
    type: 'boolean',
    default: false,
    metas: { kind: 'dynamic' }
  },
  frameIndex: {
    type: 'boolean',
    default: false,
    metas: { kind: 'dynamic' }
  }

  /**
   * Log `frame.time`, `frame.data`, `frame.metadata` and/or
   * `streamAttributes` of any node in the console.
   *
   * This sink can handle any type if input (`signal`, `vector`, `scalar`)
   *
   * @param {Object} options - Override parameters default values.
   * @param {Boolean} [options.time=false] - Log incomming `frame.time` if `true`.
   * @param {Boolean} [options.data=false] - Log incomming `frame.data` if `true`.
   * @param {Boolean} [options.metadata=false] - Log incomming `frame.metadata`
   *  if `true`.
   * @param {Boolean} [options.streamParams=false] - Log `streamParams` of the
   *  previous node when graph is started.
   * @param {Boolean} [options.frameIndex=false] - Log index of the incomming
   *  `frame`.
   *
   * @memberof module:common.sink
   *
   * @example
   * import * as lfo from 'waves-lfo/common';
   *
   * const logger = new lfo.sink.Logger({ data: true });
   * whateverOperator.connect(logger);
   */
};
var Logger = function (_BaseLfo) {
  (0, _inherits3.default)(Logger, _BaseLfo);

  function Logger(options) {
    (0, _classCallCheck3.default)(this, Logger);
    return (0, _possibleConstructorReturn3.default)(this, (Logger.__proto__ || (0, _getPrototypeOf2.default)(Logger)).call(this, definitions, options));
  }

  /** @private */


  (0, _createClass3.default)(Logger, [{
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      if (this.params.get('streamParams') === true) console.log(prevStreamParams);

      this.frameIndex = 0;
    }

    /** @private */

  }, {
    key: 'processFunction',
    value: function processFunction(frame) {
      if (this.params.get('frameIndex') === true) console.log(this.frameIndex++);

      if (this.params.get('time') === true) console.log(frame.time);

      if (this.params.get('data') === true) console.log(frame.data);

      if (this.params.get('metadata') === true) console.log(frame.metadata);
    }
  }]);
  return Logger;
}(_BaseLfo3.default);

exports.default = Logger;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],376:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo2 = require('../../core/BaseLfo');

var _BaseLfo3 = _interopRequireDefault(_BaseLfo2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  duration: {
    type: 'float',
    default: 10,
    min: 0,
    metas: { kind: 'static' }
  },
  callback: {
    type: 'any',
    default: null,
    nullable: true,
    metas: { kind: 'dynamic' }
  },
  ignoreLeadingZeros: {
    type: 'boolean',
    default: true,
    metas: { kind: 'static' }
  },
  retrieveAudioBuffer: {
    type: 'boolean',
    default: false,
    constant: true
  },
  audioContext: {
    type: 'any',
    default: null,
    nullable: true
  }
};

/**
 * Record an `signal` input stream of arbitrary duration and retrieve it
 * when done.
 *
 * When recording is stopped (either when the `stop` method is called, the
 * defined duration has been recorded, or the source of the graph finalized
 * the stream), the callback given as parameter is executed  with the
 * `AudioBuffer` or `Float32Array` containing the recorded signal as argument.
 *
 * @todo - add option to return only the Float32Array and not an audio buffer
 *  (node compliant) `retrieveAudioBuffer: false`
 *
 * @param {Object} options - Override default parameters.
 * @param {Number} [options.duration=10] - Maximum duration of the recording.
 * @param {Number} [options.callback] - Callback to execute when a new record is
 *  ended. This can happen: `stop` is called on the recorder, `stop` is called
 *  on the source or when the buffer is full according to the given `duration`.
 * @param {Object} [options.ignoreLeadingZeros=true] - Start the effective
 *  recording on the first non-zero value.
 * @param {Boolean} [options.retrieveAudioBuffer=false] - Define if an `AudioBuffer`
 *  should be retrieved or only the raw Float32Array of data.
 *  (works only in browser)
 * @param {AudioContext} [options.audioContext=null] - If
 *  `retrieveAudioBuffer` is set to `true`, audio context to be used
 *  in order to create the final audio buffer.
 *  (works only in browser)
 *
 * @memberof module:common.sink
 *
 * @example
 * import * as lfo from 'waves-lfo/client';
 *
 * const audioContext = new AudioContext();
 *
 * navigator.mediaDevices
 *   .getUserMedia({ audio: true })
 *   .then(init)
 *   .catch((err) => console.error(err.stack));
 *
 * function init(stream) {
 *   const source = audioContext.createMediaStreamSource(stream);
 *
 *   const audioInNode = new lfo.source.AudioInNode({
 *     sourceNode: source,
 *     audioContext: audioContext,
 *   });
 *
 *   const signalRecorder = new lfo.sink.SignalRecorder({
 *     duration: 6,
 *     retrieveAudioBuffer: true,
 *     audioContext: audioContext,
 *     callback: (buffer) => {
 *       const bufferSource = audioContext.createBufferSource();
 *       bufferSource.buffer = buffer;
 *       bufferSource.connect(audioContext.destination);
 *       bufferSource.start();
 *     }
 *   });
 *
 *   audioInNode.connect(signalRecorder);
 *   audioInNode.start();
 *   signalRecorder.start();
 * });
 */

var SignalRecorder = function (_BaseLfo) {
  (0, _inherits3.default)(SignalRecorder, _BaseLfo);

  function SignalRecorder() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SignalRecorder);

    /**
     * Define is the node is currently recording or not.
     *
     * @type {Boolean}
     * @name isRecording
     * @instance
     * @memberof module:client.sink.SignalRecorder
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (SignalRecorder.__proto__ || (0, _getPrototypeOf2.default)(SignalRecorder)).call(this, definitions, options));

    _this.isRecording = false;

    var retrieveAudioBuffer = _this.params.get('retrieveAudioBuffer');
    var audioContext = _this.params.get('audioContext');
    // needed to retrieve an AudioBuffer
    if (retrieveAudioBuffer && audioContext === null) throw new Error('Invalid parameter "audioContext": an AudioContext must be provided when `retrieveAudioBuffer` is set to `true`');

    _this._audioContext = audioContext;
    _this._ignoreZeros = false;
    _this._isInfiniteBuffer = false;
    _this._stack = [];
    _this._buffer = null;
    _this._bufferLength = null;
    _this._currentIndex = null;
    return _this;
  }

  (0, _createClass3.default)(SignalRecorder, [{
    key: '_initBuffer',
    value: function _initBuffer() {
      this._buffer = new Float32Array(this._bufferLength);
      this._stack.length = 0;
      this._currentIndex = 0;
    }

    /** @private */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams(prevStreamParams) {
      this.prepareStreamParams(prevStreamParams);

      var duration = this.params.get('duration');
      var sampleRate = this.streamParams.sourceSampleRate;

      if (isFinite(duration)) {
        this._isInfiniteBuffer = false;
        this._bufferLength = sampleRate * duration;
      } else {
        this._isInfiniteBuffer = true;
        this._bufferLength = sampleRate * 10;
      }

      this._initBuffer();
      this.propagateStreamParams();
    }

    /**
     * Start recording.
     */

  }, {
    key: 'start',
    value: function start() {
      this.isRecording = true;
      this._ignoreZeros = this.params.get('ignoreLeadingZeros');
    }

    /**
     * Stop recording and execute the callback defined in parameters.
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (this.isRecording) {
        // ignore next incomming frame
        this.isRecording = false;

        var retrieveAudioBuffer = this.params.get('retrieveAudioBuffer');
        var callback = this.params.get('callback');
        var currentIndex = this._currentIndex;
        var buffer = this._buffer;
        var output = void 0;

        if (!this._isInfiniteBuffer) {
          output = new Float32Array(currentIndex);
          output.set(buffer.subarray(0, currentIndex), 0);
        } else {
          var bufferLength = this._bufferLength;
          var stack = this._stack;

          output = new Float32Array(stack.length * bufferLength + currentIndex);

          // copy all stacked buffers
          for (var i = 0; i < stack.length; i++) {
            var stackedBuffer = stack[i];
            output.set(stackedBuffer, bufferLength * i);
          };
          // copy data contained in current buffer
          output.set(buffer.subarray(0, currentIndex), stack.length * bufferLength);
        }

        if (retrieveAudioBuffer && this._audioContext) {
          var length = output.length;
          var sampleRate = this.streamParams.sourceSampleRate;
          var audioBuffer = this._audioContext.createBuffer(1, length, sampleRate);
          var channelData = audioBuffer.getChannelData(0);
          channelData.set(output, 0);

          callback(audioBuffer);
        } else {
          callback(output);
        }

        // reinit buffer, stack, and currentIndex
        this._initBuffer();
      }
    }

    /** @private */

  }, {
    key: 'finalizeStream',
    value: function finalizeStream(endTime) {
      this.stop();
    }

    /** @private */

  }, {
    key: 'processSignal',
    value: function processSignal(frame) {
      if (!this.isRecording) return;

      var block = null;
      var input = frame.data;
      var bufferLength = this._bufferLength;
      var buffer = this._buffer;

      if (this._ignoreZeros === false) {
        block = new Float32Array(input);
      } else if (input[input.length - 1] !== 0) {
        // find first index where value !== 0
        var i = void 0;

        for (i = 0; i < input.length; i++) {
          if (input[i] !== 0) break;
        } // copy non zero segment
        block = new Float32Array(input.subarray(i));
        // don't repeat this logic once a non-zero value has been found
        this._ignoreZeros = false;
      }

      if (block !== null) {
        var availableSpace = bufferLength - this._currentIndex;
        var currentBlock = void 0;

        if (availableSpace < block.length) currentBlock = block.subarray(0, availableSpace);else currentBlock = block;

        buffer.set(currentBlock, this._currentIndex);
        this._currentIndex += currentBlock.length;

        if (this._isInfiniteBuffer && this._currentIndex === bufferLength) {
          this._stack.push(buffer);

          currentBlock = block.subarray(availableSpace);
          this._buffer = new Float32Array(bufferLength);
          this._buffer.set(currentBlock, 0);
          this._currentIndex = currentBlock.length;
        }

        //  stop if the buffer is finite and full
        if (!this._isInfiniteBuffer && this._currentIndex === bufferLength) this.stop();
      }
    }
  }]);
  return SignalRecorder;
}(_BaseLfo3.default);

exports.default = SignalRecorder;

},{"../../core/BaseLfo":383,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],377:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Bridge = require('./Bridge');

var _Bridge2 = _interopRequireDefault(_Bridge);

var _DataRecorder = require('./DataRecorder');

var _DataRecorder2 = _interopRequireDefault(_DataRecorder);

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _SignalRecorder = require('./SignalRecorder');

var _SignalRecorder2 = _interopRequireDefault(_SignalRecorder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  Bridge: _Bridge2.default,
  DataRecorder: _DataRecorder2.default,
  Logger: _Logger2.default,
  SignalRecorder: _SignalRecorder2.default
};

},{"./Bridge":373,"./DataRecorder":374,"./Logger":375,"./SignalRecorder":376}],378:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo = require('../../core/BaseLfo');

var _BaseLfo2 = _interopRequireDefault(_BaseLfo);

var _SourceMixin2 = require('../../core/SourceMixin');

var _SourceMixin3 = _interopRequireDefault(_SourceMixin2);

var _ticker = require('@ircam/ticker');

var _ticker2 = _interopRequireDefault(_ticker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var definitions = {
  source: {
    type: 'any',
    default: null,
    metas: {
      kind: 'static'
    }
  }

  /**
   * Regenerate a vector stream (possibly in time) in time from a recording.
   * The given recording should comply with the format output by the DataRecorder
   * lfo.
   *
   *
   * @param {Object} options - Override parameters' default values.
   * @param {Array<Object>} [options.source] - Actual recording to process. Should
   *  be compliant with format output by the DataRecorder
   *
   * @see {@link module:common.sink.DataRecorder}
   */
};
var DataReader = function (_SourceMixin) {
  (0, _inherits3.default)(DataReader, _SourceMixin);

  function DataReader(options) {
    (0, _classCallCheck3.default)(this, DataReader);

    var _this = (0, _possibleConstructorReturn3.default)(this, (DataReader.__proto__ || (0, _getPrototypeOf2.default)(DataReader)).call(this, definitions, options));

    _this.sourceStartTime = null;
    _this.sourceEndTime = null;

    _this._ticker = null;
    _this._frames = null;
    _this._frameIndex = 0;
    _this._numFrames = null;
    _this._hasStarted = false;

    /**
     * define if the recording has the format:
     * { time: [...], data: [[...], [...]] } // true
     * or
     * [{ time, data }, { time, data }]
     */
    _this._separateArrayFrames = null;

    _this.processFrame = _this.processFrame.bind(_this);
    return _this;
  }

  (0, _createClass3.default)(DataReader, [{
    key: 'processStreamParams',
    value: function processStreamParams() {
      var source = this.params.get('source');

      try {
        source = JSON.parse();
      } catch (err) {} // already JSON, do nothing

      if (source === null) throw new Error('Undefined DataReader source');

      this.streamParams = source.streamParams;
      this._frames = source.frames;

      if (this.streamParams === undefined || this._frames === undefined) throw new Error('Invalid DataReader source');

      var frameRate = this.streamParams.frameRate;
      var frames = this._frames;
      var numFrames = this._separateArrayFrames ? frames.time.length : frames.length;
      var separateArrayFrames = Array.isArray(frames[0].time) ? true : false;

      if (frameRate === 0) {
        // the recording doesn't have a frameRate, estimate from 10 first frames
        var max = Math.min(10, numFrames);
        var sum = 0;

        for (var i = 0; i < max - 1; i++) {
          var time0 = separateArrayFrames ? frames.time[i] : frames[i].time;
          var time1 = separateArrayFrames ? frames.time[i + 1] : frames[i + 1].time;
          var dt = time1 - time0;
          sum += dt;
        }

        var _period = sum / (max - 1);
        this.streamParams.frameRate = 1 / _period;
      }

      this.sourceStartTime = separateArrayFrames ? frames.time[0] : frames[0].time;
      this.sourceEndTime = separateArrayFrames ? frames.time[numFrames - 1] : frames[numFrames - 1].time;
      this._numFrames = numFrames;
      this._separateArrayFrames = separateArrayFrames;

      var period = 1 / this.streamParams.frameRate;

      // keep only one ticker instance
      if (this._ticker === null) this._ticker = new _ticker2.default(period * 1000, this.processFrame);else this._ticker.period = period * 1000;

      this.propagateStreamParams();
    }

    /**
     * Start output stream.
     */

  }, {
    key: 'start',
    value: function start() {
      var _this2 = this;

      if (this.initialized === false) {
        if (this.initPromise === null) // init has not yet been called
          this.initPromise = this.init();

        return this.initPromise.then(function () {
          return _this2.start();
        });
      }

      this._hasStarted = true;
      this._ticker.start();
    }

    /**
     * Stop the output stream and the pointer.
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (this._hasStarted === true) {
        this._ticker.stop();
        // const end time
        var period = 1 / this.streamParams.frameRate;
        var offset = this.sourceStartTime;
        var endTime = this._frameIndex * period + offset;

        this._frameIndex = 0;
        this._hasStarted = false;

        this.finalizeStream(endTime);
      }
    }

    /**
     * Stop the output stream without reseting the pointer.
     */

  }, {
    key: 'pause',
    value: function pause() {
      if (this._hasStarted === true) {
        this._ticker.stop();

        this._hasStarted = false;
      }
    }

    /**
     * Go to a given time. The given time must be in the boundaries defined by the
     *
     *
     */

  }, {
    key: 'seek',
    value: function seek(time) {
      // find the index closest to the given time
      var duration = this.sourceEndTime - this.sourceStartTime;
      var offset = this.sourceStartTime;
      var phase = (time - offset) / (duration - offset);
      var index = Math.floor(phase * this._numFrames);

      this._frameIndex = index;
    }
  }, {
    key: 'prepareFrame',
    value: function prepareFrame() {
      // this prevent seek before start...
      // if (this._reinit === true) // source has been updated
      //   this._frameIndex = 0;

      (0, _get3.default)(DataReader.prototype.__proto__ || (0, _getPrototypeOf2.default)(DataReader.prototype), 'prepareFrame', this).call(this);
    }

    /**
     * Ticker callback
     * @private
     */

  }, {
    key: 'processFrame',
    value: function processFrame(logicalTime) {
      this.prepareFrame();

      var frame = void 0;

      if (this._separateArrayFrames) {
        var time = this._frames.time[this._frameIndex];
        var data = this._frames.data[this._frameIndex];

        frame = { time: time, data: data };
      } else {
        frame = this._frames[this._frameIndex];
      }

      this._frameIndex += 1;
      this.frame = frame;

      this.propagateFrame();

      if (this._frameIndex >= this._numFrames) this.stop();
    }
  }]);
  return DataReader;
}((0, _SourceMixin3.default)(_BaseLfo2.default));

exports.default = DataReader;

},{"../../core/BaseLfo":383,"../../core/SourceMixin":384,"@ircam/ticker":174,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/get":193,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],379:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isFinite = require('babel-runtime/core-js/number/is-finite');

var _isFinite2 = _interopRequireDefault(_isFinite);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseLfo = require('../../core/BaseLfo');

var _BaseLfo2 = _interopRequireDefault(_BaseLfo);

var _SourceMixin2 = require('../../core/SourceMixin');

var _SourceMixin3 = _interopRequireDefault(_SourceMixin2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// http://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser
var isNode = new Function('try { return this === global; } catch(e) { return false }');

/**
 * Create a function that returns time in seconds according to the current
 * environnement (node or browser).
 * If running in node the time rely on `process.hrtime`, while if in the browser
 * it is provided by the `currentTime` of an `AudioContext`, this context can
 * optionnaly be provided to keep time consistency between several `EventIn`
 * nodes.
 *
 * @param {AudioContext} [audioContext=null] - Optionnal audio context.
 * @return {Function}
 * @private
 */
function getTimeFunction() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  if (isNode()) {
    return function () {
      var t = process.hrtime();
      return t[0] + t[1] * 1e-9;
    };
  } else {
    return function () {
      return performance.now() / 1000;
    };
  }
}

var definitions = {
  absoluteTime: {
    type: 'boolean',
    default: false,
    constant: true
  },
  audioContext: {
    type: 'any',
    default: null,
    constant: true,
    nullable: true
  },
  frameType: {
    type: 'enum',
    list: ['signal', 'vector', 'scalar'],
    default: 'signal',
    constant: true
  },
  frameSize: {
    type: 'integer',
    default: 1,
    min: 1,
    max: +Infinity, // not recommended...
    metas: { kind: 'static' }
  },
  sampleRate: {
    type: 'float',
    default: null,
    min: 0,
    max: +Infinity, // same here
    nullable: true,
    metas: { kind: 'static' }
  },
  frameRate: {
    type: 'float',
    default: null,
    min: 0,
    max: +Infinity, // same here
    nullable: true,
    metas: { kind: 'static' }
  },
  description: {
    type: 'any',
    default: null,
    constant: true
  }
};

/**
 * The `EventIn` operator allows to manually create a stream of data or to feed
 * a stream from another source (e.g. sensors) into a processing graph.
 *
 * @param {Object} options - Override parameters' default values.
 * @param {String} [options.frameType='signal'] - Type of the input - allowed
 * values: `signal`,  `vector` or `scalar`.
 * @param {Number} [options.frameSize=1] - Size of the output frame.
 * @param {Number} [options.sampleRate=null] - Sample rate of the source stream,
 *  if of type `signal`.
 * @param {Number} [options.frameRate=null] - Rate of the source stream, if of
 *  type `vector`.
 * @param {Array|String} [options.description] - Optionnal description
 *  describing the dimensions of the output frame
 * @param {Boolean} [options.absoluteTime=false] - Define if time should be used
 *  as forwarded as given in the process method, or relatively to the time of
 *  the first `process` call after start.
 *
 * @memberof module:common.source
 *
 * @todo - Add a `logicalTime` parameter to tag frame according to frame rate.
 *
 * @example
 * import * as lfo from 'waves-lfo/client';
 *
 * const eventIn = new lfo.source.EventIn({
 *   frameType: 'vector',
 *   frameSize: 3,
 *   frameRate: 1 / 50,
 *   description: ['alpha', 'beta', 'gamma'],
 * });
 *
 * // connect source to operators and sink(s)
 *
 * // initialize and start the graph
 * eventIn.start();
 *
 * // feed `deviceorientation` data into the graph
 * window.addEventListener('deviceorientation', (e) => {
 *   const frame = {
 *     time: window.performace.now() / 1000,
 *     data: [e.alpha, e.beta, e.gamma],
 *   };
 *
 *   eventIn.processFrame(frame);
 * }, false);
 */

var EventIn = function (_SourceMixin) {
  (0, _inherits3.default)(EventIn, _SourceMixin);

  function EventIn() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, EventIn);

    var _this = (0, _possibleConstructorReturn3.default)(this, (EventIn.__proto__ || (0, _getPrototypeOf2.default)(EventIn)).call(this, definitions, options));

    var audioContext = _this.params.get('audioContext');
    _this._getTime = getTimeFunction(audioContext);
    _this._startTime = null;
    _this._systemTime = null;
    _this._absoluteTime = _this.params.get('absoluteTime');
    return _this;
  }

  /**
   * Propagate the `streamParams` in the graph and allow to push frames into
   * the graph. Any call to `process` or `processFrame` before `start` will be
   * ignored.
   *
   * @see {@link module:core.BaseLfo#processStreamParams}
   * @see {@link module:core.BaseLfo#resetStream}
   * @see {@link module:common.source.EventIn#stop}
   */


  (0, _createClass3.default)(EventIn, [{
    key: 'start',
    value: function start() {
      var _this2 = this;

      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (this.initialized === false) {
        if (this.initPromise === null) // init has not yet been called
          this.initPromise = this.init();

        return this.initPromise.then(function () {
          return _this2.start(startTime);
        });
      }

      this._startTime = startTime;
      this._systemTime = null; // value set in the first `process` call

      this.started = true;
    }

    /**
     * Finalize the stream and stop the whole graph. Any call to `process` or
     * `processFrame` after `stop` will be ignored.
     *
     * @see {@link module:core.BaseLfo#finalizeStream}
     * @see {@link module:common.source.EventIn#start}
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (this.started && this._startTime !== null) {
        var currentTime = this._getTime();
        var endTime = this.frame.time + (currentTime - this._systemTime);

        this.finalizeStream(endTime);
        this.started = false;
      }
    }

    /** @private */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams() {
      var frameSize = this.params.get('frameSize');
      var frameType = this.params.get('frameType');
      var sampleRate = this.params.get('sampleRate');
      var frameRate = this.params.get('frameRate');
      var description = this.params.get('description');

      // init operator's stream params
      this.streamParams.frameSize = frameType === 'scalar' ? 1 : frameSize;
      this.streamParams.frameType = frameType;
      this.streamParams.description = description;

      if (frameType === 'signal') {
        if (sampleRate === null) throw new Error('Undefined "sampleRate" for "signal" stream');

        this.streamParams.sourceSampleRate = sampleRate;
        this.streamParams.frameRate = sampleRate / frameSize;
        this.streamParams.sourceSampleCount = frameSize;
      } else if (frameType === 'vector' || frameType === 'scalar') {
        if (frameRate === null) throw new Error('Undefined "frameRate" for "' + frameType + '" stream');

        this.streamParams.frameRate = frameRate;
        this.streamParams.sourceSampleRate = frameRate;
        this.streamParams.sourceSampleCount = 1;
      }

      this.propagateStreamParams();
    }

    /** @private */

  }, {
    key: 'processFunction',
    value: function processFunction(frame) {
      var currentTime = this._getTime();
      var inData = frame.data.length ? frame.data : [frame.data];
      var outData = this.frame.data;
      // if no time provided, use system time
      var time = (0, _isFinite2.default)(frame.time) ? frame.time : currentTime;

      if (this._startTime === null) this._startTime = time;

      if (this._absoluteTime === false) time = time - this._startTime;

      for (var i = 0, l = this.streamParams.frameSize; i < l; i++) {
        outData[i] = inData[i];
      }this.frame.time = time;
      this.frame.metadata = frame.metadata;
      // store current time to compute `endTime` on stop
      this._systemTime = currentTime;
    }

    /**
     * Alternative interface to propagate a frame in the graph. Pack `time`,
     * `data` and `metadata` in a frame object.
     *
     * @param {Number} time - Frame time.
     * @param {Float32Array|Array} data - Frame data.
     * @param {Object} metadata - Optionnal frame metadata.
     *
     * @example
     * eventIn.process(1, [0, 1, 2]);
     * // is equivalent to
     * eventIn.processFrame({ time: 1, data: [0, 1, 2] });
     */

  }, {
    key: 'process',
    value: function process(time, data) {
      var metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      this.processFrame({ time: time, data: data, metadata: metadata });
    }

    /**
     * Propagate a frame object in the graph.
     *
     * @param {Object} frame - Input frame.
     * @param {Number} frame.time - Frame time.
     * @param {Float32Array|Array} frame.data - Frame data.
     * @param {Object} [frame.metadata=undefined] - Optionnal frame metadata.
     *
     * @example
     * eventIn.processFrame({ time: 1, data: [0, 1, 2] });
     */

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      if (!this.started) return;

      this.prepareFrame();
      this.processFunction(frame);
      this.propagateFrame();
    }
  }]);
  return EventIn;
}((0, _SourceMixin3.default)(_BaseLfo2.default));

exports.default = EventIn;

}).call(this,require('_process'))

},{"../../core/BaseLfo":383,"../../core/SourceMixin":384,"_process":165,"babel-runtime/core-js/number/is-finite":179,"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],380:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EventIn = require('./EventIn');

var _EventIn2 = _interopRequireDefault(_EventIn);

var _DataReader = require('./DataReader');

var _DataReader2 = _interopRequireDefault(_DataReader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  EventIn: _EventIn2.default,
  DataReader: _DataReader2.default
};

},{"./DataReader":378,"./EventIn":379}],381:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _windows = require('./windows');

var _windows2 = _interopRequireDefault(_windows);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  initWindow: _windows2.default
}; // export { default as initWindow } from './windows';

},{"./windows":382}],382:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

// shortcuts / helpers
var PI = Math.PI;
var cos = Math.cos;
var sin = Math.sin;
var sqrt = Math.sqrt;

// window creation functions
function initHannWindow(buffer, size, normCoefs) {
  var linSum = 0;
  var powSum = 0;
  var step = 2 * PI / size;

  for (var i = 0; i < size; i++) {
    var phi = i * step;
    var value = 0.5 - 0.5 * cos(phi);

    buffer[i] = value;

    linSum += value;
    powSum += value * value;
  }

  normCoefs.linear = size / linSum;
  normCoefs.power = sqrt(size / powSum);
}

function initHammingWindow(buffer, size, normCoefs) {
  var linSum = 0;
  var powSum = 0;
  var step = 2 * PI / size;

  for (var i = 0; i < size; i++) {
    var phi = i * step;
    var value = 0.54 - 0.46 * cos(phi);

    buffer[i] = value;

    linSum += value;
    powSum += value * value;
  }

  normCoefs.linear = size / linSum;
  normCoefs.power = sqrt(size / powSum);
}

function initBlackmanWindow(buffer, size, normCoefs) {
  var linSum = 0;
  var powSum = 0;
  var step = 2 * PI / size;

  for (var i = 0; i < size; i++) {
    var phi = i * step;
    var value = 0.42 - 0.5 * cos(phi) + 0.08 * cos(2 * phi);

    buffer[i] = value;

    linSum += value;
    powSum += value * value;
  }

  normCoefs.linear = size / linSum;
  normCoefs.power = sqrt(size / powSum);
}

function initBlackmanHarrisWindow(buffer, size, normCoefs) {
  var linSum = 0;
  var powSum = 0;
  var a0 = 0.35875;
  var a1 = 0.48829;
  var a2 = 0.14128;
  var a3 = 0.01168;
  var step = 2 * PI / size;

  for (var i = 0; i < size; i++) {
    var phi = i * step;
    var value = a0 - a1 * cos(phi) + a2 * cos(2 * phi);-a3 * cos(3 * phi);

    buffer[i] = value;

    linSum += value;
    powSum += value * value;
  }

  normCoefs.linear = size / linSum;
  normCoefs.power = sqrt(size / powSum);
}

function initSineWindow(buffer, size, normCoefs) {
  var linSum = 0;
  var powSum = 0;
  var step = PI / size;

  for (var i = 0; i < size; i++) {
    var phi = i * step;
    var value = sin(phi);

    buffer[i] = value;

    linSum += value;
    powSum += value * value;
  }

  normCoefs.linear = size / linSum;
  normCoefs.power = sqrt(size / powSum);
}

function initRectangleWindow(buffer, size, normCoefs) {
  for (var i = 0; i < size; i++) {
    buffer[i] = 1;
  } // @todo - check if these are proper values
  normCoefs.linear = 1;
  normCoefs.power = 1;
}

/**
 * Create a buffer with window signal.
 *
 * @memberof module:common.utils
 *
 * @param {String} name - Name of the window.
 * @param {Float32Array} buffer - Buffer to be populated with the window signal.
 * @param {Number} size - Size of the buffer.
 * @param {Object} normCoefs - Object to be populated with the normailzation
 *  coefficients.
 */
function initWindow(name, buffer, size, normCoefs) {
  name = name.toLowerCase();

  switch (name) {
    case 'hann':
    case 'hanning':
      initHannWindow(buffer, size, normCoefs);
      break;
    case 'hamming':
      initHammingWindow(buffer, size, normCoefs);
      break;
    case 'blackman':
      initBlackmanWindow(buffer, size, normCoefs);
      break;
    case 'blackmanharris':
      initBlackmanHarrisWindow(buffer, size, normCoefs);
      break;
    case 'sine':
      initSineWindow(buffer, size, normCoefs);
      break;
    case 'rectangle':
      initRectangleWindow(buffer, size, normCoefs);
      break;
  }
}

exports.default = initWindow;

},{}],383:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _parameters = require('@ircam/parameters');

var _parameters2 = _interopRequireDefault(_parameters);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var id = 0;

/**
 * Base `lfo` class to be extended in order to create new nodes.
 *
 * Nodes are divided in 3 categories:
 * - **`source`** are responsible for acquering a signal and its properties
 *   (frameRate, frameSize, etc.)
 * - **`sink`** are endpoints of the graph, such nodes can be recorders,
 *   visualizers, etc.
 * - **`operator`** are used to make computation on the input signal and
 *   forward the results below in the graph.
 *
 * In most cases the methods to override / extend are:
 * - the **`constructor`** to define the parameters of the new lfo node.
 * - the **`processStreamParams`** method to define how the node modify the
 *   stream attributes (e.g. by changing the frame size)
 * - the **`process{FrameType}`** method to define the operations that the
 *   node apply on the stream. The type of input a node can handle is defined
 *   by its implemented interface, if it implements `processSignal`, a stream
 *   of type `signal` can be processed, `processVector` to handle
 *   an input of type `vector`.
 *
 * <span class="warning">_This class should be considered abstract and only
 * be used as a base class to extend._</span>
 *
 * #### overview of the interface
 *
 * **initModule**
 *
 * Returns a Promise that resolves when the module is initialized. Is
 * especially important for modules that rely on asynchronous underlying APIs.
 *
 * **processStreamParams(prevStreamParams)**
 *
 * `base` class (default implementation)
 * - call `prepareStreamParams`
 * - call `propagateStreamParams`
 *
 * `child` class
 * - override some of the inherited `streamParams`
 * - creates the any related logic buffers
 * - call `propagateStreamParams`
 *
 * _should not call `super.processStreamParams`_
 *
 * **prepareStreamParams()**
 *
 * - assign prevStreamParams to this.streamParams
 * - check if the class implements the correct `processInput` method
 *
 * _shouldn't be extended, only consumed in `processStreamParams`_
 *
 * **propagateStreamParams()**
 *
 * - creates the `frameData` buffer
 * - propagate `streamParams` to children
 *
 * _shouldn't be extended, only consumed in `processStreamParams`_
 *
 * **processFrame()**
 *
 * `base` class (default implementation)
 * - call `prepareFrame`
 * - assign frameTime and frameMetadata to identity
 * - call the proper function according to inputType
 * - call `propagateFrame`
 *
 * `child` class
 * - call `prepareFrame`
 * - do whatever you want with incomming frame
 * - call `propagateFrame`
 *
 * _should not call `super.processFrame`_
 *
 * **prepareFrame()**
 *
 * - if `reinit` and trigger `processStreamParams` if needed
 *
 * _shouldn't be extended, only consumed in `processFrame`_
 *
 * **propagateFrame()**
 *
 * - propagate frame to children
 *
 * _shouldn't be extended, only consumed in `processFrame`_
 *
 * @memberof module:core
 */

var BaseLfo = function () {
  function BaseLfo() {
    var definitions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, BaseLfo);

    this.cid = id++;

    /**
     * Parameter bag containing parameter instances.
     *
     * @type {Object}
     * @name params
     * @instance
     * @memberof module:core.BaseLfo
     */
    this.params = (0, _parameters2.default)(definitions, options);
    // listen for param updates
    this.params.addListener(this.onParamUpdate.bind(this));

    /**
     * Description of the stream output of the node.
     * Set to `null` when the node is destroyed.
     *
     * @type {Object}
     * @property {Number} frameSize - Frame size at the output of the node.
     * @property {Number} frameRate - Frame rate at the output of the node.
     * @property {String} frameType - Frame type at the output of the node,
     *  possible values are `signal`, `vector` or `scalar`.
     * @property {Array|String} description - If type is `vector`, describe
     *  the dimension(s) of output stream.
     * @property {Number} sourceSampleRate - Sample rate of the source of the
     *  graph. _The value should be defined by sources and never modified_.
     * @property {Number} sourceSampleCount - Number of consecutive discrete
     *  time values contained in the data frame output by the source.
     *  _The value should be defined by sources and never modified_.
     *
     * @name streamParams
     * @instance
     * @memberof module:core.BaseLfo
     */
    this.streamParams = {
      frameType: null,
      frameSize: 1,
      frameRate: 0,
      description: null,
      sourceSampleRate: 0,
      sourceSampleCount: null
    };

    /**
     * Current frame. This object and its data are updated at each incomming
     * frame without reallocating memory.
     *
     * @type {Object}
     * @name frame
     * @property {Number} time - Time of the current frame.
     * @property {Float32Array} data - Data of the current frame.
     * @property {Object} metadata - Metadata associted to the current frame.
     * @instance
     * @memberof module:core.BaseLfo
     */
    this.frame = {
      time: 0,
      data: null,
      metadata: {}
    };

    /**
     * List of nodes connected to the ouput of the node (lower in the graph).
     * At each frame, the node forward its `frame` to to all its `nextModules`.
     *
     * @type {Array<BaseLfo>}
     * @name nextModules
     * @instance
     * @memberof module:core.BaseLfo
     * @see {@link module:core.BaseLfo#connect}
     * @see {@link module:core.BaseLfo#disconnect}
     */
    this.nextModules = [];

    /**
     * The node from which the node receive the frames (upper in the graph).
     *
     * @type {BaseLfo}
     * @name prevModule
     * @instance
     * @memberof module:core.BaseLfo
     * @see {@link module:core.BaseLfo#connect}
     * @see {@link module:core.BaseLfo#disconnect}
     */
    this.prevModule = null;

    /**
     * Is set to true when a static parameter is updated. On the next input
     * frame all the subgraph streamParams starting from this node will be
     * updated.
     *
     * @type {Boolean}
     * @name _reinit
     * @instance
     * @memberof module:core.BaseLfo
     * @private
     */
    this._reinit = false;
  }

  /**
   * Returns an object describing each available parameter of the node.
   *
   * @return {Object}
   */


  (0, _createClass3.default)(BaseLfo, [{
    key: 'getParamsDescription',
    value: function getParamsDescription() {
      return this.params.getDefinitions();
    }

    /**
     * Reset all parameters to their initial value (as defined on instantication)
     *
     * @see {@link module:core.BaseLfo#streamParams}
     */

  }, {
    key: 'resetParams',
    value: function resetParams() {
      this.params.reset();
    }

    /**
     * Function called when a param is updated. By default set the `_reinit`
     * flag to `true` if the param is `static` one. This method should be
     * extended to handle particular logic bound to a specific parameter.
     *
     * @param {String} name - Name of the parameter.
     * @param {Mixed} value - Value of the parameter.
     * @param {Object} metas - Metadata associated to the parameter.
     */

  }, {
    key: 'onParamUpdate',
    value: function onParamUpdate(name, value) {
      var metas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (metas.kind === 'static') this._reinit = true;
    }

    /**
     * Connect the current node (`prevModule`) to another node (`nextOp`).
     * A given node can be connected to several operators and propagate frames
     * to each of them.
     *
     * @param {BaseLfo} next - Next operator in the graph.
     * @see {@link module:core.BaseLfo#processFrame}
     * @see {@link module:core.BaseLfo#disconnect}
     */

  }, {
    key: 'connect',
    value: function connect(next) {
      var _this = this;

      if (this.streamParams === null || next.streamParams === null) throw new Error('Invalid connection: cannot connect a dead node');

      if (this.streamParams.frameType !== null) {
        // graph has already been started
        // next.processStreamParams(this.streamParams);
        next.initModule().then(function () {
          next.processStreamParams(_this.streamParams);
          // we can forward frame from now
          _this.nextModules.push(next);
          next.prevModule = _this;
        });
      } else {
        this.nextModules.push(next);
        next.prevModule = this;
      }
    }

    /**
     * Remove the given operator from its previous operators' `nextModules`.
     *
     * @param {BaseLfo} [next=null] - The operator to disconnect from the current
     *  operator. If `null` disconnect all the next operators.
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      var _this2 = this;

      var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (next === null) {
        this.nextModules.forEach(function (next) {
          return _this2.disconnect(next);
        });
      } else {
        var index = this.nextModules.indexOf(this);
        this.nextModules.splice(index, 1);
        next.prevModule = null;
      }
    }

    /**
     * Destroy all the nodes in the sub-graph starting from the current node.
     * When detroyed, the `streamParams` of the node are set to `null`, the
     * operator is then considered as `dead` and cannot be reconnected.
     *
     * @see {@link module:core.BaseLfo#connect}
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      // destroy all chidren
      var index = this.nextModules.length;

      while (index--) {
        this.nextModules[index].destroy();
      } // disconnect itself from the previous operator
      if (this.prevModule) this.prevModule.disconnect(this);

      // mark the object as dead
      this.streamParams = null;
    }

    /**
     * Return a `Promise` that resolve when the module is ready to be consumed.
     * Some modules relies on asynchronous APIs at initialization and thus could
     * be not ready to be consumed when the graph starts.
     * A module should be consider as initialized when all next modules (children)
     * are themselves initialized. The event bubbles up from sinks to sources.
     * When all its next operators are ready, a source can consider the whole graph
     * as ready and then start to produce frames.
     * The default implementation resolves when all next operators are resolved
     * themselves.
     * An operator relying on external async API must override this method to
     * resolve only when its dependecy is ready.
     *
     * @return Promise
     * @todo - Handle dynamic connections
     */

  }, {
    key: 'initModule',
    value: function initModule() {
      var nextPromises = this.nextModules.map(function (module) {
        return module.initModule();
      });

      return _promise2.default.all(nextPromises);
    }

    /**
     * Helper to initialize the stream in standalone mode.
     *
     * @param {Object} [streamParams={}] - Parameters of the stream.
     *
     * @see {@link module:core.BaseLfo#processStreamParams}
     * @see {@link module:core.BaseLfo#resetStream}
     */

  }, {
    key: 'initStream',
    value: function initStream() {
      var streamParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.processStreamParams(streamParams);
      this.resetStream();
    }

    /**
     * Reset the `frame.data` buffer by setting all its values to 0.
     * A source operator should call `processStreamParams` and `resetStream` when
     * started, each of these method propagate through the graph automaticaly.
     *
     * @see {@link module:core.BaseLfo#processStreamParams}
     */

  }, {
    key: 'resetStream',
    value: function resetStream() {
      // buttom up
      for (var i = 0, l = this.nextModules.length; i < l; i++) {
        this.nextModules[i].resetStream();
      } // no buffer for `scalar` type or sink node
      // @note - this should be reviewed
      if (this.streamParams.frameType !== 'scalar' && this.frame.data !== null) {
        var frameSize = this.streamParams.frameSize;
        var data = this.frame.data;

        for (var _i = 0; _i < frameSize; _i++) {
          data[_i] = 0;
        }
      }
    }

    /**
     * Finalize the stream. A source node should call this method when stopped,
     * `finalizeStream` is automatically propagated throught the graph.
     *
     * @param {Number} endTime - Logical time at which the graph is stopped.
     */

  }, {
    key: 'finalizeStream',
    value: function finalizeStream(endTime) {
      for (var i = 0, l = this.nextModules.length; i < l; i++) {
        this.nextModules[i].finalizeStream(endTime);
      }
    }

    /**
     * Initialize or update the operator's `streamParams` according to the
     * previous operators `streamParams` values.
     *
     * When implementing a new operator this method should:
     * 1. call `this.prepareStreamParams` with the given `prevStreamParams`
     * 2. optionnally change values to `this.streamParams` according to the
     *    logic performed by the operator.
     * 3. optionnally allocate memory for ring buffers, etc.
     * 4. call `this.propagateStreamParams` to trigger the method on the next
     *    operators in the graph.
     *
     * @param {Object} prevStreamParams - `streamParams` of the previous operator.
     *
     * @see {@link module:core.BaseLfo#prepareStreamParams}
     * @see {@link module:core.BaseLfo#propagateStreamParams}
     */

  }, {
    key: 'processStreamParams',
    value: function processStreamParams() {
      var prevStreamParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.prepareStreamParams(prevStreamParams);
      this.propagateStreamParams();
    }

    /**
     * Common logic to do at the beginning of the `processStreamParam`, must be
     * called at the beginning of any `processStreamParam` implementation.
     *
     * The method mainly check if the current node implement the interface to
     * handle the type of frame propagated by it's parent:
     * - to handle a `vector` frame type, the class must implement `processVector`
     * - to handle a `signal` frame type, the class must implement `processSignal`
     * - in case of a 'scalar' frame type, the class can implement any of the
     * following by order of preference: `processScalar`, `processVector`,
     * `processSignal`.
     *
     * @param {Object} prevStreamParams - `streamParams` of the previous operator.
     *
     * @see {@link module:core.BaseLfo#processStreamParams}
     * @see {@link module:core.BaseLfo#propagateStreamParams}
     */

  }, {
    key: 'prepareStreamParams',
    value: function prepareStreamParams() {
      var prevStreamParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      (0, _assign2.default)(this.streamParams, prevStreamParams);
      var prevFrameType = prevStreamParams.frameType;

      switch (prevFrameType) {
        case 'scalar':
          if (this.processScalar) this.processFunction = this.processScalar;else if (this.processVector) this.processFunction = this.processVector;else if (this.processSignal) this.processFunction = this.processSignal;else throw new Error(this.constructor.name + ' - no "process" function found');
          break;
        case 'vector':
          if (!('processVector' in this)) throw new Error(this.constructor.name + ' - "processVector" is not defined');

          this.processFunction = this.processVector;
          break;
        case 'signal':
          if (!('processSignal' in this)) throw new Error(this.constructor.name + ' - "processSignal" is not defined');

          this.processFunction = this.processSignal;
          break;
        default:
          // defaults to processFunction
          break;
      }
    }

    /**
     * Create the `this.frame.data` buffer and forward the operator's `streamParam`
     * to all its next operators, must be called at the end of any
     * `processStreamParams` implementation.
     *
     * @see {@link module:core.BaseLfo#processStreamParams}
     * @see {@link module:core.BaseLfo#prepareStreamParams}
     */

  }, {
    key: 'propagateStreamParams',
    value: function propagateStreamParams() {
      this.frame.data = new Float32Array(this.streamParams.frameSize);

      for (var i = 0, l = this.nextModules.length; i < l; i++) {
        this.nextModules[i].processStreamParams(this.streamParams);
      }
    }

    /**
     * Define the particular logic the operator applies to the stream.
     * According to the frame type of the previous node, the method calls one
     * of the following method `processVector`, `processSignal` or `processScalar`
     *
     * @param {Object} frame - Frame (time, data, and metadata) as given by the
     *  previous operator. The incomming frame should never be modified by
     *  the operator.
     *
     * @see {@link module:core.BaseLfo#prepareFrame}
     * @see {@link module:core.BaseLfo#propagateFrame}
     * @see {@link module:core.BaseLfo#processStreamParams}
     */

  }, {
    key: 'processFrame',
    value: function processFrame(frame) {
      this.prepareFrame();

      // frameTime and frameMetadata defaults to identity
      this.frame.time = frame.time;
      this.frame.metadata = frame.metadata;

      this.processFunction(frame);
      this.propagateFrame();
    }

    /**
     * Pointer to the method called in `processFrame` according to the
     * frame type of the previous operator. Is dynamically assigned in
     * `prepareStreamParams`.
     *
     * @see {@link module:core.BaseLfo#prepareStreamParams}
     * @see {@link module:core.BaseLfo#processFrame}
     */

  }, {
    key: 'processFunction',
    value: function processFunction(frame) {
      this.frame = frame;
    }

    /**
     * Common logic to perform at the beginning of the `processFrame`.
     *
     * @see {@link module:core.BaseLfo#processFrame}
     */

  }, {
    key: 'prepareFrame',
    value: function prepareFrame() {
      if (this._reinit === true) {
        var streamParams = this.prevModule !== null ? this.prevModule.streamParams : {};
        this.initStream(streamParams);
        this._reinit = false;
      }
    }

    /**
     * Forward the current `frame` to the next operators, is called at the end of
     * `processFrame`.
     *
     * @see {@link module:core.BaseLfo#processFrame}
     */

  }, {
    key: 'propagateFrame',
    value: function propagateFrame() {
      for (var i = 0, l = this.nextModules.length; i < l; i++) {
        this.nextModules[i].processFrame(this.frame);
      }
    }
  }]);
  return BaseLfo;
}();

exports.default = BaseLfo;

},{"@ircam/parameters":173,"babel-runtime/core-js/object/assign":180,"babel-runtime/core-js/promise":186,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192}],384:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Interface added to `LfoCore to implement source
 *
 * Source have some responsability on graph as they mostly control its whole
 * lifecycle. They must implement the start and stop method in order to
 * make sure the graph is initialized and set `started` to true.
 * A source should never accept and propagate incomming frames until `started`
 * is set to `true`.
 *
 * @name SourceMixin
 * @memberof module:core
 * @mixin
 *
 * @example
 * class MySource extends SourceMixin(BaseLfo) {}
 */
var SourceMixin = function SourceMixin(superclass) {
  return function (_superclass) {
    (0, _inherits3.default)(_class, _superclass);

    function _class() {
      var _ref;

      (0, _classCallCheck3.default)(this, _class);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = _class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call.apply(_ref, [this].concat(args)));

      _this.initialized = false;
      _this.initPromise = null;
      _this.started = false;

      _this.start = _this.start.bind(_this);
      _this.stop = _this.stop.bind(_this);
      return _this;
    }

    /**
     * Initialize the graph by calling `initModule`. When the returned `Promise`
     * fulfills, the graph can be considered as initialized and `start` can be
     * called safely. If `start` is called whithout explicit `init`, `init` is
     * made internally, actual start of the graph is then not garanteed to be
     * synchronous.
     *
     * @memberof module:core.SourceMixin
     * @instance
     * @name init
     *
     * @return Promise
     *
     * @example
     * // safe initialization and start
     * source.init().then(() => source.start())
     * // safe initialization and start
     * source.start();
     */


    (0, _createClass3.default)(_class, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        this.initPromise = this.initModule().then(function () {
          _this2.initStream(); // this is synchronous
          _this2.initialized = true;
          return _promise2.default.resolve(true);
        });

        return this.initPromise;
      }

      /**
       * Interface method to implement that starts the graph.
       *
       * The method main purpose is to make sure take verify initialization step and
       * set `started` to `true` when done.
       * Should behave synchronously when called inside `init().then()` and async
       * if called without init step.
       *
       * @memberof module:core.SourceMixin
       * @instance
       * @name start
       *
       * @example
       * // basic `start` implementation
       * start() {
       *   if (this.initialized === false) {
       *     if (this.initPromise === null) // init has not yet been called
       *       this.initPromise = this.init();
       *
       *     this.initPromise.then(this.start);
       *     return;
       *   }
       *
       *   this.started = true;
       * }
       */

    }, {
      key: "start",
      value: function start() {}

      /**
       * Interface method to implement that stops the graph.
       *
       * @memberof module:core.SourceMixin
       * @instance
       * @name stop
       *
       * @example
       * // basic `stop` implementation
       * stop() {
       *   this.started = false;
       * }
       */

    }, {
      key: "stop",
      value: function stop() {}

      /**
       * The implementation should never allow incomming frames
       * if `this.started` is not `true`.
       *
       * @memberof module:core.SourceMixin
       * @instance
       * @name processFrame
       *
       * @param {Object} frame
       *
       * @example
       * // basic `processFrame` implementation
       * processFrame(frame) {
       *   if (this.started === true) {
       *     this.prepareFrame();
       *     this.processFunction(frame);
       *     this.propagateFrame();
       *   }
       * }
       */

    }, {
      key: "processFrame",
      value: function processFrame(frame) {}
    }]);
    return _class;
  }(superclass);
};

exports.default = SourceMixin;

},{"babel-runtime/core-js/object/get-prototype-of":184,"babel-runtime/core-js/promise":186,"babel-runtime/helpers/classCallCheck":191,"babel-runtime/helpers/createClass":192,"babel-runtime/helpers/inherits":194,"babel-runtime/helpers/possibleConstructorReturn":195}],385:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _BaseLfo = require('./BaseLfo');

Object.defineProperty(exports, 'BaseLfo', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_BaseLfo).default;
  }
});

var _SourceMixin = require('./SourceMixin');

Object.defineProperty(exports, 'SourceMixin', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SourceMixin).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var version = exports.version = '1.1.6';

},{"./BaseLfo":383,"./SourceMixin":384}],386:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _namespace = require('../core/namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _Layer2 = require('../core/Layer');

var _Layer3 = _interopRequireDefault(_Layer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Simplified Layer for Axis. The main difference with a regular layer is that
 * an axis layer use the `Timeline~timeContext` attributes to render it's layout
 * and stay synchronized with the tracks visible area. All getters and setters
 * to the `TimelineTimeContext` attributes are bypassed.
 *
 * It also handle it's own data and its updates. The `_generateData` method is
 * responsible to create some usefull data to visualize
 *
 * [example usage of the layer-axis](./examples/layer-axis.html)
 */
var AxisLayer = function (_Layer) {
  (0, _inherits3.default)(AxisLayer, _Layer);

  /**
   * @param {Function} generator - A function to create data according to
   *    the `Timeline~timeContext`.
   * @param {Object} options - Layer options, cf. Layer for available options.
   */
  function AxisLayer(generator, options) {
    (0, _classCallCheck3.default)(this, AxisLayer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (AxisLayer.__proto__ || (0, _getPrototypeOf2.default)(AxisLayer)).call(this, 'entity', [], options));

    _this._generator = generator;
    return _this;
  }

  /** @private */


  (0, _createClass3.default)(AxisLayer, [{
    key: '_generateData',


    /**
     * This method is the main difference with a classical layer. An `AxisLayer`
     * instance generates and maintains it's own data.
     */
    value: function _generateData() {
      var data = this._generator(this.timeContext);
      // prepend first arguments of splice for an apply
      data.unshift(0, this.data[0].length);
      // make sure to keep the same reference
      Array.prototype.splice.apply(this.data[0], data);
    }

    /**
     * Updates the rendering context for the shapes.
     */

  }, {
    key: '_updateRenderingContext',
    value: function _updateRenderingContext() {
      this._renderingContext.timeToPixel = this.timeContext.timeToPixel;
      this._renderingContext.valueToPixel = this._valueToPixel;
      this._renderingContext.height = this.params.height;
      // this._renderingContext.width  = this.timeContext.timeToPixel(this.timeContext.duration);

      // for foreign object issue in chrome
      this._renderingContext.offsetX = this.timeContext.timeToPixel(this.timeContext.offset);
      this._renderingContext.visibleWidth = this.timeContext.visibleWidth;
    }

    /**
     * Generates the data and update the layer.
     */

  }, {
    key: 'update',
    value: function update() {
      this._generateData();
      (0, _get3.default)(AxisLayer.prototype.__proto__ || (0, _getPrototypeOf2.default)(AxisLayer.prototype), 'update', this).call(this);
    }

    /**
     * Render the DOM in memory on layer creation to be able to use it before
     * the layer is actually inserted in the DOM
     */

  }, {
    key: '_renderContainer',
    value: function _renderContainer() {
      // wrapper group for `start, top and context flip matrix
      this.$el = document.createElementNS(_namespace2.default, 'g');
      if (this.params.className !== null) {
        this.$el.classList.add('layer', this.params.className);
      }

      // group to apply offset
      this.$offset = document.createElementNS(_namespace2.default, 'g');
      this.$offset.classList.add('offset', 'items');
      // layer background
      this.$background = document.createElementNS(_namespace2.default, 'rect');
      this.$background.classList.add('background');
      this.$background.style.fillOpacity = 0;
      this.$background.style.pointerEvents = 'none';
      // create the DOM tree
      this.$el.appendChild(this.$offset);
      this.$offset.appendChild(this.$background);
    }

    /**
     * Updates the layout of the layer.
     */

  }, {
    key: 'updateContainer',
    value: function updateContainer() {
      this._updateRenderingContext();

      var top = this.params.top;
      var height = this.params.height;
      var left = Math.max(0, -this._renderingContext.offsetX);
      // matrix to invert the coordinate system
      var translateMatrix = 'matrix(1, 0, 0, -1, 0, ' + (top + height) + ')';
      this.$el.setAttributeNS(null, 'transform', translateMatrix);

      // keep background on the visible area
      this.$background.setAttributeNS(null, 'height', height);
      this.$background.setAttributeNS(null, 'width', this.timeContext.visibleWidth);
      this.$background.setAttributeNS(null, 'x', left);
    }
  }, {
    key: 'stretchRatio',
    set: function set(value) {
      return;
    }
    /** @private */
    ,

    /** @private */
    get: function get() {
      return;
    }
    /** @private */

  }, {
    key: 'offset',
    set: function set(value) {
      return;
    }
    /** @private */
    ,
    get: function get() {
      return;
    }
    /** @private */

  }, {
    key: 'start',
    set: function set(value) {
      return;
    }
    /** @private */
    ,
    get: function get() {
      return;
    }
    /** @private */

  }, {
    key: 'duration',
    set: function set(value) {
      return;
    },
    get: function get() {
      return;
    }

    /**
     * The generator that creates the data to be rendered to display the axis.
     *
     * @type {Function}
     */

  }, {
    key: 'generator',
    set: function set(func) {
      this._generator = func;
    }

    /**
     * The generator that creates the data to be rendered to display the axis.
     *
     * @type {Function}
     */
    ,
    get: function get() {
      return this._generator;
    }
  }]);
  return AxisLayer;
}(_Layer3.default);

exports.default = AxisLayer;

},{"../core/Layer":395,"../core/namespace":400,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/get":453,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],387:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * A generator to create data for grid axis according to a `bpm` and a `meter`.
 *
 * [example usage](./examples/layer-axis.html)
 *
 * @param {Number} bpm - Number of beats per minutes
 * @param {String} signature - Meter of the mesure (`'4/4'`, `'3/8'`, ...)
 * @return {Function} - Function that generate data to be diplayed
 */
function gridAxisGenerator(bpm, signature) {
  var _bps = bpm / 60; // sec
  var _unit = 1 / parseInt(signature.split('/')[1], 10);
  var _nbrUnitsPerMesure = parseInt(signature.split('/')[0], 10);

  return function (timeContext) {
    var duration = timeContext.visibleDuration;
    var offset = timeContext.offset;
    var data = [];

    // const min = Math.min(-offset, 0);
    var min = -offset;
    // remove the timeline's offset to keep the layer centered
    var max = duration - offset;

    // define pixels for 1 second
    var pixelsPerSecond = timeContext.computedPixelsPerSecond;
    // time for one _unit
    var unitTime = 1 / _bps;
    // define the first tick > min
    var modulo = min % unitTime;
    var mult = (min - modulo) / unitTime;
    var firstTickTime = unitTime * mult;
    // track which position of current beat in the mesure
    var positionInMesure = mult % _nbrUnitsPerMesure;

    // remove not focused beats, if zoomed out
    var pixelsPerTick = pixelsPerSecond / _bps;
    var minStep = 5;

    // time should be
    for (var time = firstTickTime; time < max; time += unitTime) {
      // find first beat
      var focused = positionInMesure++ % _nbrUnitsPerMesure === 0;
      // ignore if pixels per ticks is too small
      if (pixelsPerTick <= minStep && !focused) {
        continue;
      }

      data.push({ time: time, focused: focused });
    }

    return data;
  };
}

exports.default = gridAxisGenerator;

},{}],388:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _format = require('../utils/format');

/**
 * A generator to create data for time axis.
 *
 * [example usage](./examples/layer-axis.html)
 *
 * @return {Function} - The configured function returning the data when called.
 */
function timeAxisGenerator() {
  // add factory to share API with bpmGenerator
  return function (timeContext) {
    var duration = timeContext.visibleDuration;
    var offset = timeContext.offset;
    var data = [];

    // const min = Math.min(-offset, 0);
    var min = -offset;
    // remove the timeline's offset to keep the layer centered
    var max = duration - offset;

    // define pixels for 1 second
    var pixelsPerSecond = timeContext.computedPixelsPerSecond;
    var minStep = 7;

    // define all display information according to the pixelsPerSecond ratio
    var step = void 0,
        type = void 0,
        toFixed = void 0,
        markerModulo = void 0,
        includeModulo = void 0;

    if (pixelsPerSecond * 4 > minStep) {
      step = 1; // the step to use to compute time
      toFixed = 0;
      markerModulo = 60; // a timestamp every 5 stepixelsPerSecond
      includeModulo = 5; // a tick every 5 stepixelsPerSecond
      type = '60sec';
    }

    if (pixelsPerSecond * 2 > minStep) {
      step = 1;
      toFixed = 0;
      markerModulo = 30;
      includeModulo = 1;
      type = '30sec';
    }

    if (pixelsPerSecond > minStep) {
      step = 1;
      toFixed = 0;
      markerModulo = 10;
      includeModulo = 1;
      type = 'sec';
    }

    if (pixelsPerSecond / 10 > minStep) {
      step = 1 / 10;
      toFixed = 1;
      markerModulo = 10;
      includeModulo = 1;
      type = 'ds';
    }

    if (pixelsPerSecond / 100 > minStep) {
      step = 1 / 100;
      toFixed = 2;
      markerModulo = 10;
      includeModulo = 1;
      type = 'cs';
    }

    if (pixelsPerSecond / 1000 > minStep) {
      step = 1 / 1000;
      toFixed = 3;
      markerModulo = 10;
      includeModulo = 1;
      type = 'ms';
    }

    for (var time = min; time < max; time += step) {
      var formattedTime = time.toFixed(toFixed);

      if (Math.round(formattedTime / step) % includeModulo !== 0) {
        continue;
      }

      // avoid floating point errors
      var focused = Math.round(formattedTime / step) % markerModulo === 0 ? true : false;

      var datum = { time: formattedTime, focused: focused };

      if (focused === true) {
        var date = new Date(1000 * formattedTime);
        var _min = (0, _format.padLeft)(date.getMinutes(), 0, 2);
        var sec = (0, _format.padLeft)(date.getSeconds(), 0, 2);
        var milli = (0, _format.padLeft)(date.getMilliseconds(), 0, 3);
        var label = _min + ':' + sec + ':' + milli;

        datum.label = label;
      }

      data.push(datum);
    }

    return data;
  };
}

exports.default = timeAxisGenerator;

},{"../utils/format":435}],389:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Is an abstract class or interface to be overriden in order to define the way
 * a given shape should behave when selected or edited by a user. Instances of
 * `BaseBehavior` are internally used by `Layer` instances to modify the data
 * according to a user interaction and a given shape. A single instance of
 * `Behavior` is created in one given shape.
 *
 * By default, the only method to override to define a new behavior for a
 * shape is the `edit` method. However, if needed in special cases, all the
 * selection handling can be overriden too.
 *
 * The flow is the following:
 * `Event`  - (forwarded to) -> `Layer` - (command) -> `Behavior` - (modify) -> `data` - (upates) -> `Shape`
 *
 * The behavior responsability is then to modify the data according to the
 * user interactions, while shapes are always a view of the current state of the
 * data.
 */
var BaseBehavior = function () {
  function BaseBehavior() {
    (0, _classCallCheck3.default)(this, BaseBehavior);

    this._selectedItems = new _set2.default(); // no duplicate in Set
    this._selectedClass = null;
    this._layer = null;
  }

  (0, _createClass3.default)(BaseBehavior, [{
    key: 'initialize',
    value: function initialize(layer) {
      this._layer = layer;
      this._selectedClass = layer.params.selectedClassName;
    }

    /**
     * Destroy the references to the selected items.
     *
     * @type {String}
     * @todo - rename to `clearSelection` (removing the class) ?
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this._selectedItems.clear();
    }

    /**
     * The class to add to the shapes when selected.
     *
     * @type {String}
     */

  }, {
    key: 'select',


    /**
     * @param {Element} $item - The item to select.
     * @param {Object} datum - Not used in this implementation. Could be
     *    used to mark the data as selected.
     * @todo - Pass the shape object to get the accessors ?
     */
    value: function select($item, datum) {
      $item.classList.add(this.selectedClass);
      this._selectedItems.add($item);
    }

    /**
     * @param {Element} $item - The item to unselect.
     * @param {Object} datum - Not used in this implementation. Could be
     *    used to mark the data as selected.
     * @todo - Pass the shape object to get the accessors ?
     */

  }, {
    key: 'unselect',
    value: function unselect($item, datum) {
      $item.classList.remove(this.selectedClass);
      this._selectedItems.delete($item);
    }

    /**
     * @param {Element} $item - The item to toggle selection.
     * @param {Object} datum - Not used in this implementation. Could be
     *    used to mark the data as selected.
     * @todo - Pass the shape object to get the accessors ?
     */

  }, {
    key: 'toggleSelection',
    value: function toggleSelection($item, datum) {
      var method = this._selectedItems.has($item) ? 'unselect' : 'select';
      this[method]($item);
    }

    /**
     * Interface method to override in order to define its particular behavior when
     * interacted with.
     *
     * @param {Object} renderingContext - The layer rendering context.
     * @param {BaseShape} shape - The shape object to be edited.
     * @param {Object|Array} datum - The related datum to modify.
     * @param {Number} dx - The value of the interaction in the x axis (in pixels).
     * @param {Number} dy - The value of the interaction in the y axis (in pixels).
     * @param {Element} $target - The target DOM element of the interaction.
     */

  }, {
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, $target) {
      // must be implemented in children
    }
  }, {
    key: 'selectedClass',
    set: function set(value) {
      this._selectedClass = value;
    }

    /**
     * The class to add to the shapes when selected.
     *
     * @type {String}
     */
    ,
    get: function get() {
      return this._selectedClass;
    }

    /**
     * An array containing all the selected items of the layer.
     *
     * @type {Array}
     */

  }, {
    key: 'selectedItems',
    get: function get() {
      return [].concat((0, _toConsumableArray3.default)(this._selectedItems));
    }
  }]);
  return BaseBehavior;
}();

exports.default = BaseBehavior;

},{"babel-runtime/core-js/set":448,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/toConsumableArray":457}],390:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseBehavior2 = require('./BaseBehavior');

var _BaseBehavior3 = _interopRequireDefault(_BaseBehavior2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Defines the default behavior for a breakpoint function.
 *
 * [example usage](./examples/layer-breakpoint.html)
 */
var BreakpointBehavior = function (_BaseBehavior) {
  (0, _inherits3.default)(BreakpointBehavior, _BaseBehavior);

  function BreakpointBehavior() {
    (0, _classCallCheck3.default)(this, BreakpointBehavior);
    return (0, _possibleConstructorReturn3.default)(this, (BreakpointBehavior.__proto__ || (0, _getPrototypeOf2.default)(BreakpointBehavior)).apply(this, arguments));
  }

  (0, _createClass3.default)(BreakpointBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var data = this._layer.data;
      var layerHeight = renderingContext.height;
      // current position
      var x = renderingContext.timeToPixel(shape.cx(datum));
      var y = renderingContext.valueToPixel(shape.cy(datum));
      // target position
      var targetX = x + dx;
      var targetY = y - dy;

      if (data.length > 2) {
        // create a sorted map of all `x` positions
        var xMap = data.map(function (d) {
          return renderingContext.timeToPixel(shape.cx(d));
        });
        xMap.sort(function (a, b) {
          return a < b ? -1 : 1;
        });
        // find index of our shape x position
        var index = xMap.indexOf(x);
        // lock to next siblings
        if (targetX < xMap[index - 1] || targetX > xMap[index + 1]) {
          targetX = x;
        }
      }

      // lock in y axis
      if (targetY < 0) {
        targetY = 0;
      } else if (targetY > layerHeight) {
        targetY = layerHeight;
      }

      // update datum with new values
      shape.cx(datum, renderingContext.timeToPixel.invert(targetX));
      shape.cy(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }]);
  return BreakpointBehavior;
}(_BaseBehavior3.default);

exports.default = BreakpointBehavior;

},{"./BaseBehavior":389,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],391:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseBehavior2 = require('./BaseBehavior');

var _BaseBehavior3 = _interopRequireDefault(_BaseBehavior2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Defines the default behavior for a marker.
 *
 * [example usage](./examples/layer-marker.html)
 */
var MarkerBehavior = function (_BaseBehavior) {
  (0, _inherits3.default)(MarkerBehavior, _BaseBehavior);

  function MarkerBehavior() {
    (0, _classCallCheck3.default)(this, MarkerBehavior);
    return (0, _possibleConstructorReturn3.default)(this, (MarkerBehavior.__proto__ || (0, _getPrototypeOf2.default)(MarkerBehavior)).apply(this, arguments));
  }

  (0, _createClass3.default)(MarkerBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var x = renderingContext.timeToPixel(shape.x(datum));
      var targetX = x + dx > 0 ? x + dx : 0;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
    }
  }]);
  return MarkerBehavior;
}(_BaseBehavior3.default);

exports.default = MarkerBehavior;

},{"./BaseBehavior":389,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],392:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseBehavior2 = require('./BaseBehavior');

var _BaseBehavior3 = _interopRequireDefault(_BaseBehavior2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Defines the default behavior for a segment.
 *
 * [example usage](./examples/layer-marker.html)
 */
var SegmentBehavior = function (_BaseBehavior) {
  (0, _inherits3.default)(SegmentBehavior, _BaseBehavior);

  function SegmentBehavior() {
    (0, _classCallCheck3.default)(this, SegmentBehavior);
    return (0, _possibleConstructorReturn3.default)(this, (SegmentBehavior.__proto__ || (0, _getPrototypeOf2.default)(SegmentBehavior)).apply(this, arguments));
  }

  (0, _createClass3.default)(SegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var classList = target.classList;
      var action = 'move';

      if (classList.contains('handler') && classList.contains('left')) {
        action = 'resizeLeft';
      } else if (classList.contains('handler') && classList.contains('right')) {
        action = 'resizeRight';
      }

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      var height = renderingContext.valueToPixel(shape.height(datum));
      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = y - dy;

      // lock in layer's y axis
      if (targetY < 0) {
        targetY = 0;
      } else if (targetY + height > layerHeight) {
        targetY = layerHeight - height;
      }

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.y(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }]);
  return SegmentBehavior;
}(_BaseBehavior3.default);

exports.default = SegmentBehavior;

},{"./BaseBehavior":389,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],393:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * TimeContextBehavior is used internally in Layers to modify their TimeContext.
 * This object is different from other Shapes Behaviors and exists mostly to decrease the size of the Layer.
 * All the code here could be considered as part of the layer.
 */
var TimeContextBehavior = function () {
  function TimeContextBehavior() {
    (0, _classCallCheck3.default)(this, TimeContextBehavior);
  }

  (0, _createClass3.default)(TimeContextBehavior, [{
    key: 'edit',
    value: function edit(layer, dx, dy, target) {
      var timeContext = layer.timeContext;

      if (target.classList.contains('handler') && target.classList.contains('left')) {
        this._editLeft(timeContext, dx);
      } else if (target.classList.contains('handler') && target.classList.contains('right')) {
        this._editRight(timeContext, dx);
      } else if (target.classList.contains('segment')) {
        this._move(timeContext, dx);
      }
    }
  }, {
    key: '_editLeft',
    value: function _editLeft(timeContext, dx) {
      // edit `start`, `offset` and `duration`
      var x = timeContext.parent.timeToPixel(timeContext.start);
      var offset = timeContext.timeToPixel(timeContext.offset);
      var width = timeContext.timeToPixel(timeContext.duration);

      var targetX = x + dx;
      var targetOffset = offset - dx;
      var targetWidth = Math.max(width - dx, 1);

      timeContext.start = timeContext.parent.timeToPixel.invert(targetX);
      timeContext.offset = timeContext.timeToPixel.invert(targetOffset);
      timeContext.duration = timeContext.timeToPixel.invert(targetWidth);
    }
  }, {
    key: '_editRight',
    value: function _editRight(timeContext, dx) {
      var width = timeContext.timeToPixel(timeContext.duration);
      var targetWidth = Math.max(width + dx, 1);

      timeContext.duration = timeContext.timeToPixel.invert(targetWidth);
    }
  }, {
    key: '_move',
    value: function _move(timeContext, dx) {
      var x = timeContext.parent.timeToPixel(timeContext.start);
      var targetX = Math.max(x + dx, 0);

      timeContext.start = timeContext.parent.timeToPixel.invert(targetX);
    }
  }, {
    key: 'stretch',
    value: function stretch(layer, dx, dy, target) {
      var timeContext = layer.timeContext;
      var lastDuration = timeContext.duration;
      var lastOffset = timeContext.offset;

      this.edit(layer, dx, dy, target);

      var newDuration = timeContext.duration;
      var ratio = newDuration / lastDuration;

      timeContext.stretchRatio *= ratio;
      timeContext.offset = lastOffset;
      timeContext.duration = lastDuration;
    }
  }]);
  return TimeContextBehavior;
}();

exports.default = TimeContextBehavior;

},{"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452}],394:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseBehavior2 = require('./BaseBehavior');

var _BaseBehavior3 = _interopRequireDefault(_BaseBehavior2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Defines the default behavior for a trace visualization.
 *
 * [example usage](./examples/layer-trace.html)
 */
var TraceBehavior = function (_BaseBehavior) {
  (0, _inherits3.default)(TraceBehavior, _BaseBehavior);

  function TraceBehavior() {
    (0, _classCallCheck3.default)(this, TraceBehavior);
    return (0, _possibleConstructorReturn3.default)(this, (TraceBehavior.__proto__ || (0, _getPrototypeOf2.default)(TraceBehavior)).apply(this, arguments));
  }

  (0, _createClass3.default)(TraceBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      if (target.classList.contains('min')) {
        this._editRange(renderingContext, shape, datum, dx, dy, 'min');
      } else if (target.classList.contains('max')) {
        this._editRange(renderingContext, shape, datum, dx, dy, 'max');
      } else {
        this._editMean(renderingContext, shape, datum, dx, dy);
      }
    }
  }, {
    key: '_editMean',
    value: function _editMean(renderingContext, shape, datum, dx, dy) {
      // work in pixel domain
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.mean(datum));

      var targetX = x + dx;
      var targetY = y - dy;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.mean(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }, {
    key: '_editRange',
    value: function _editRange(renderingContext, shape, datum, dx, dy, rangeSide) {
      var range = renderingContext.valueToPixel(shape.range(datum));

      var targetRange = rangeSide === 'min' ? range + 2 * dy : range - 2 * dy;
      targetRange = Math.max(targetRange, 0);

      shape.range(datum, renderingContext.valueToPixel.invert(targetRange));
    }
  }]);
  return TraceBehavior;
}(_BaseBehavior3.default);

exports.default = TraceBehavior;

},{"./BaseBehavior":389,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],395:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _events = require('events');

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _scales = require('../utils/scales');

var _scales2 = _interopRequireDefault(_scales);

var _Segment = require('../shapes/Segment');

var _Segment2 = _interopRequireDefault(_Segment);

var _BaseShape = require('../shapes/BaseShape');

var _BaseShape2 = _interopRequireDefault(_BaseShape);

var _TimeContextBehavior = require('../behaviors/TimeContextBehavior');

var _TimeContextBehavior2 = _interopRequireDefault(_TimeContextBehavior);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// time context bahevior
var timeContextBehavior = null;
var timeContextBehaviorCtor = _TimeContextBehavior2.default;

/**
 * The layer class is the main visualization class. It is mainly defines by its
 * related `LayerTimeContext` which determines its position in the overall
 * timeline (through the `start`, `duration`, `offset` and `stretchRatio`
 * attributes) and by it's registered Shape which defines how to display the
 * data associated to the layer. Each created layer must be inserted into a
 * `Track` instance in order to be displayed.
 *
 * _Note: in the context of the layer, an __item__ is the SVG element
 * returned by a `Shape` instance and associated with a particular __datum__._
 *
 * ### Layer DOM structure
 * ```
 * <g class="layer" transform="translate(${start}, 0)">
 *   <svg class="bounding-box" width="${duration}">
 *     <g class="offset" transform="translate(${offset, 0})">
 *       <!-- background -->
 *       <rect class="background"></rect>
 *       <!-- shapes and common shapes are inserted here -->
 *     </g>
 *     <g class="interactions"><!-- for feedback --></g>
 *   </svg>
 * </g>
 * ```
 */

var Layer = function (_EventEmitter) {
  (0, _inherits3.default)(Layer, _EventEmitter);

  /**
   * @param {String} dataType - Defines how the layer should look at the data.
   *    Can be 'entity' or 'collection'.
   * @param {(Array|Object)} data - The data associated to the layer.
   * @param {Object} options - Configures the layer.
   * @param {Number} [options.height=100] - Defines the height of the layer.
   * @param {Number} [options.top=0] - Defines the top position of the layer.
   * @param {Number} [options.opacity=1] - Defines the opacity of the layer.
   * @param {Number} [options.yDomain=[0,1]] - Defines boundaries of the data
   *    values in y axis (for exemple to display an audio buffer, this attribute
   *    should be set to [-1, 1].
   * @param {String} [options.className=null] - An optionnal class to add to each
   *    created shape.
   * @param {String} [options.className='selected'] - The class to add to a shape
   *    when selected.
   * @param {Number} [options.contextHandlerWidth=2] - The width of the handlers
   *    displayed to edit the layer.
   * @param {Number} [options.hittable=false] - Defines if the layer can be interacted
   *    with. Basically, the layer is not returned by `BaseState.getHitLayers` when
   *    set to false (a common use case is a layer that contains a cursor)
   * @param {Number} [zIndex=0] - zIndex of the layer, should be >= 0
   */
  function Layer(dataType, data) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck3.default)(this, Layer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Layer.__proto__ || (0, _getPrototypeOf2.default)(Layer)).call(this));

    var defaults = {
      height: 100,
      top: 0,
      opacity: 1,
      yDomain: [0, 1],
      className: null,
      selectedClassName: 'selected',
      contextHandlerWidth: 2,
      hittable: true, // when false the layer is not returned by `BaseState.getHitLayers`
      id: '', // used ?
      overflow: 'hidden', // usefull ?
      zIndex: 0 // zIndex of the layer, cannot be negative
    };

    /**
     * Parameters of the layers, `defaults` overrided with options.
     * @type {Object}
     */
    _this.params = (0, _assign2.default)({}, defaults, options);
    /**
     * Defines how the layer should look at the data (`'entity'` or `'collection'`).
     * @type {String}
     */
    _this.dataType = dataType; // 'entity' || 'collection';
    /** @type {LayerTimeContext} */
    _this.timeContext = null;
    /** @type {Element} */
    _this.$el = null;
    /** @type {Element} */
    _this.$background = null;
    /** @type {Element} */
    _this.$boundingBox = null;
    /** @type {Element} */
    _this.$offset = null;
    /** @type {Element} */
    _this.$interactions = null;
    /**
     * A Segment instanciated to interact with the Layer itself.
     * @type {Segment}
     */
    _this.contextShape = null;

    _this._shapeConfiguration = null; // { ctor, accessors, options }
    _this._commonShapeConfiguration = null; // { ctor, accessors, options }
    _this._$itemShapeMap = new _map2.default();
    _this._$itemDataMap = new _map2.default();
    _this._$itemCommonShapeMap = new _map2.default();

    _this._isContextEditable = false;
    _this._behavior = null;

    _this._height = _this.params.height;
    _this._top = _this.params.top;

    _this.data = data;

    // console.log(this.params.yDomain);
    // console.log([this._height, 0])
    _this._valueToPixel = _scales2.default.linear().domain(_this.params.yDomain).range([0, _this._height]);
    // .range([this._height, 0]);

    // initialize timeContext layout
    _this._renderContainer();
    // creates the timeContextBehavior for all layers
    if (timeContextBehavior === null) {
      timeContextBehavior = new timeContextBehaviorCtor();
    }
    return _this;
  }

  /**
   * Destroy the layer, clear all references.
   */


  (0, _createClass3.default)(Layer, [{
    key: 'destroy',
    value: function destroy() {
      this.timeContext = null;
      this.data = null;
      this.params = null;
      this._behavior = null;

      this._$itemShapeMap.clear();
      this._$itemDataMap.clear();
      this._$itemCommonShapeMap.clear();

      this.removeAllListeners();
    }

    /**
     * Allows to override default the `TimeContextBehavior` used to edit the layer.
     *
     * @param {Object} ctor
     */

  }, {
    key: 'updateHeight',
    value: function updateHeight(prevTrackHeight, newTrackHeight) {
      var ratio = newTrackHeight / prevTrackHeight;

      this._height = this._height * ratio;
      this._top = this._top * ratio;
      this._valueToPixel.range([0, this._height]);
    }

    // --------------------------------------
    // Initialization
    // --------------------------------------

    /**
     * Renders the DOM in memory on layer creation to be able to use it before
     * the layer is actually inserted in the DOM.
     */

  }, {
    key: '_renderContainer',
    value: function _renderContainer() {
      var _this2 = this;

      // wrapper group for `start, top and context flip matrix
      this.$el = document.createElementNS(_namespace2.default, 'g');
      this.$el.classList.add('layer');

      if (this.params.className !== null) this.$el.classList.add(this.params.className);

      // clip the context with a `svg` element
      this.$boundingBox = document.createElementNS(_namespace2.default, 'svg');
      this.$boundingBox.classList.add('bounding-box');
      this.$boundingBox.style.overflow = this.params.overflow;
      // group to apply offset
      this.$offset = document.createElementNS(_namespace2.default, 'g');
      this.$offset.classList.add('offset', 'items');
      // layer background
      this.$background = document.createElementNS(_namespace2.default, 'rect');
      this.$background.setAttributeNS(null, 'height', '100%');
      this.$background.setAttributeNS(null, 'width', '100%');
      this.$background.classList.add('background');
      this.$background.style.fillOpacity = 0;
      this.$background.style.pointerEvents = 'none';
      // context interactions
      this.$interactions = document.createElementNS(_namespace2.default, 'g');
      this.$interactions.classList.add('interactions');
      this.$interactions.style.display = 'none';
      // @NOTE: works but king of ugly... should be cleaned
      this.contextShape = new _Segment2.default();
      this.contextShape.install({
        opacity: function opacity() {
          return 0.1;
        },
        color: function color() {
          return '#787878';
        },
        width: function width() {
          return _this2.timeContext.duration;
        },
        height: function height() {
          return _this2._renderingContext.valueToPixel.domain()[1];
        },
        y: function y() {
          return _this2._renderingContext.valueToPixel.domain()[0];
        }
      });

      this.$interactions.appendChild(this.contextShape.render());
      // create the DOM tree
      this.$el.appendChild(this.$boundingBox);
      this.$boundingBox.appendChild(this.$offset);
      this.$offset.appendChild(this.$background);
      this.$boundingBox.appendChild(this.$interactions);
    }

    // --------------------------------------
    // Component Configuration
    // --------------------------------------

    /**
     * Sets the context of the layer, thus defining its `start`, `duration`,
     * `offset` and `stretchRatio`.
     *
     * @param {TimeContext} timeContext - The timeContext in which the layer is displayed.
     */

  }, {
    key: 'setTimeContext',
    value: function setTimeContext(timeContext) {
      this.timeContext = timeContext;
      // create a mixin to pass to the shapes
      this._renderingContext = {};
      this._updateRenderingContext();
    }

    /**
     * Register a shape and its configuration to use in order to render the data.
     *
     * @param {BaseShape} ctor - The constructor of the shape to be used.
     * @param {Object} [accessors={}] - Defines how the shape should adapt to a particular data struture.
     * @param {Object} [options={}] - Global configuration for the shapes, is specific to each `Shape`.
     */

  }, {
    key: 'configureShape',
    value: function configureShape(ctor) {
      var accessors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      this._shapeConfiguration = { ctor: ctor, accessors: accessors, options: options };
    }

    /**
     * Optionnaly register a shape to be used accros the entire collection.
     *
     * @param {BaseShape} ctor - The constructor of the shape to be used.
     * @param {Object} [accessors={}] - Defines how the shape should adapt to a particular data struture.
     * @param {Object} [options={}] - Global configuration for the shapes, is specific to each `Shape`.
     */

  }, {
    key: 'configureCommonShape',
    value: function configureCommonShape(ctor) {
      var accessors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      this._commonShapeConfiguration = { ctor: ctor, accessors: accessors, options: options };
    }

    /**
     * Register the behavior to use when interacting with a shape.
     *
     * @param {BaseBehavior} behavior
     */

  }, {
    key: 'setBehavior',
    value: function setBehavior(behavior) {
      behavior.initialize(this);
      this._behavior = behavior;
    }

    /**
     * Updates the values stored int the `_renderingContext` passed  to shapes
     * for rendering and updating.
     */

  }, {
    key: '_updateRenderingContext',
    value: function _updateRenderingContext() {
      this._renderingContext.timeToPixel = this.timeContext.timeToPixel;
      this._renderingContext.valueToPixel = this._valueToPixel;

      var height = this._height;
      var width = this.timeContext.timeToPixel(this.timeContext.duration);
      var offsetX = this.timeContext.timeToPixel(this.timeContext.offset);
      var startX = this.timeContext.parent.timeToPixel(this.timeContext.start);
      var trackOffsetX = this.timeContext.parent.timeToPixel(this.timeContext.parent.offset);
      var visibleWidth = this.timeContext.parent.visibleWidth;

      // @todo - make this mess more readable
      var minX = Math.max(-offsetX, 0);
      var trackDecay = trackOffsetX + startX;
      if (trackDecay < 0) minX = -trackDecay;

      var maxX = minX;
      maxX += width - minX < visibleWidth ? width : visibleWidth;

      this._renderingContext.width = width;
      this._renderingContext.height = height;
      this._renderingContext.offsetX = offsetX;
      this._renderingContext.startX = startX;
      this._renderingContext.minX = minX;
      this._renderingContext.maxX = maxX;
      // needed for canvas foreignObjects in chrome and safari
      this._renderingContext.trackOffsetX = trackOffsetX;
      // this._renderingContext.visibleWidth = visibleWidth;
    }

    // --------------------------------------
    // Behavior Accessors
    // --------------------------------------

    /**
     * Returns the items marked as selected.
     *
     * @type {Array<Element>}
     */

  }, {
    key: 'select',


    /**
     * Mark item(s) as selected.
     *
     * @param {Element|Element[]} $items
     */
    value: function select() {
      for (var _len = arguments.length, $items = Array(_len), _key = 0; _key < _len; _key++) {
        $items[_key] = arguments[_key];
      }

      if (!this._behavior) {
        return;
      }
      if (!$items.length) {
        $items = this._$itemDataMap.keys();
      }
      if (Array.isArray($items[0])) {
        $items = $items[0];
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)($items), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var $item = _step.value;

          var datum = this._$itemDataMap.get($item);
          this._behavior.select($item, datum);
          this._toFront($item);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Removes item(s) from selected items.
     *
     * @param {Element|Element[]} $items
     */

  }, {
    key: 'unselect',
    value: function unselect() {
      for (var _len2 = arguments.length, $items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        $items[_key2] = arguments[_key2];
      }

      if (!this._behavior) {
        return;
      }
      if (!$items.length) {
        $items = this._$itemDataMap.keys();
      }
      if (Array.isArray($items[0])) {
        $items = $items[0];
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)($items), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var $item = _step2.value;

          var datum = this._$itemDataMap.get($item);
          this._behavior.unselect($item, datum);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    /**
     * Toggle item(s) selection state according to their current state.
     *
     * @param {Element|Element[]} $items
     */

  }, {
    key: 'toggleSelection',
    value: function toggleSelection() {
      for (var _len3 = arguments.length, $items = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        $items[_key3] = arguments[_key3];
      }

      if (!this._behavior) {
        return;
      }
      if (!$items.length) {
        $items = this._$itemDataMap.keys();
      }
      if (Array.isArray($items[0])) {
        $items = $items[0];
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator3.default)($items), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var $item = _step3.value;

          var datum = this._$itemDataMap.get($item);
          this._behavior.toggleSelection($item, datum);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    /**
     * Edit item(s) according to the `edit` defined in the registered `Behavior`.
     *
     * @param {Element|Element[]} $items - Item(s) to edit
     * @param {Number} dx - Modification to apply in the x axis (in pixel domain)
     * @param {Number} dy - Modification to apply in the y axis (in pixel domain)
     * @param {Element} $target - Target of the interaction (for example, left
     *  handler DOM element in a segment).
     */

  }, {
    key: 'edit',
    value: function edit($items, dx, dy, $target) {
      if (!this._behavior) {
        return;
      }
      $items = !Array.isArray($items) ? [$items] : $items;

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator3.default)($items), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var $item = _step4.value;

          var shape = this._$itemShapeMap.get($item);
          var datum = this._$itemDataMap.get($item);

          this._behavior.edit(this._renderingContext, shape, datum, dx, dy, $target);
          this.emit('edit', shape, datum);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }

    /**
     * Defines if the `Layer`, and thus the `LayerTimeContext` is editable or not.
     *
     * @params {Boolean} [bool=true]
     */

  }, {
    key: 'setContextEditable',
    value: function setContextEditable() {
      var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var display = bool ? 'block' : 'none';
      this.$interactions.style.display = display;
      this._isContextEditable = bool;
    }

    /**
     * Edit the layer and thus its related `LayerTimeContext` attributes.
     *
     * @param {Number} dx - The modification to apply in the x axis (in pixels).
     * @param {Number} dy - The modification to apply in the y axis (in pixels).
     * @param {Element} $target - The target of the event of the interaction.
     */

  }, {
    key: 'editContext',
    value: function editContext(dx, dy, $target) {
      timeContextBehavior.edit(this, dx, dy, $target);
    }

    /**
     * Stretch the layer and thus its related `LayerTimeContext` attributes.
     *
     * @param {Number} dx - The modification to apply in the x axis (in pixels).
     * @param {Number} dy - The modification to apply in the y axis (in pixels).
     * @param {Element} $target - The target of the event of the interaction.
     */

  }, {
    key: 'stretchContext',
    value: function stretchContext(dx, dy, $target) {
      timeContextBehavior.stretch(this, dx, dy, $target);
    }

    // --------------------------------------
    // Helpers
    // --------------------------------------

    /**
     * Returns an item from a DOM element related to the shape, null otherwise.
     *
     * @param {Element} $el - the element to be tested
     * @return {Element|null}
     */

  }, {
    key: 'getItemFromDOMElement',
    value: function getItemFromDOMElement($el) {
      var $item = void 0;

      do {
        if ($el.classList && $el.classList.contains('item')) {
          $item = $el;
          break;
        }

        $el = $el.parentNode;
      } while ($el !== null);

      return this.hasItem($item) ? $item : null;
    }

    /**
     * Returns the shape associated to a specific item.
     *
     * @param {Element} $item
     * @return {Shape}
     */

  }, {
    key: 'getShapeFromItem',
    value: function getShapeFromItem($item) {
      return this.hasItem($item) ? this._$itemShapeMap.get($item) : null;
    }

    /**
     * Returns the shape associated to a specific item from any DOM element
     * composing the shape.
     *
     * @param {Element} $item
     * @return {Shape}
     */

  }, {
    key: 'getShapeFromDOMElement',
    value: function getShapeFromDOMElement($el) {
      var $item = this.getItemFromDOMElement($el);
      return this.getShapeFromItem($item);
    }

    /**
     * Returns the datum associated to a specific item.
     *
     * @param {Element} $item
     * @return {Object|Array|null}
     */

  }, {
    key: 'getDatumFromItem',
    value: function getDatumFromItem($item) {
      var datum = this._$itemDataMap.get($item);
      return datum ? datum : null;
    }

    /**
     * Returns the datum associated to a specific item from any DOM element
     * composing the shape. Basically a shortcut for `getItemFromDOMElement` and
     * `getDatumFromItem` methods.
     *
     * @param {Element} $el
     * @return {Object|Array|null}
     */

  }, {
    key: 'getDatumFromDOMElement',
    value: function getDatumFromDOMElement($el) {
      var $item = this.getItemFromDOMElement($el);
      return this.getDatumFromItem($item);
    }

    /**
     * Tests if the given DOM element is an item of the layer.
     *
     * @param {Element} $item - The item to be tested.
     * @return {Boolean}
     */

  }, {
    key: 'hasItem',
    value: function hasItem($item) {
      return this._$itemDataMap.has($item);
    }

    /**
     * Defines if a given element belongs to the layer. Is more general than
     * `hasItem`, can mostly used to check interactions elements.
     *
     * @param {Element} $el - The DOM element to be tested.
     * @return {bool}
     */

  }, {
    key: 'hasElement',
    value: function hasElement($el) {
      do {
        if ($el === this.$el) {
          return true;
        }

        $el = $el.parentNode;
      } while ($el !== null);

      return false;
    }

    /**
     * Retrieve all the items in a given area as defined in the registered `Shape~inArea` method.
     *
     * @param {Object} area - The area in which to find the elements
     * @param {Number} area.top
     * @param {Number} area.left
     * @param {Number} area.width
     * @param {Number} area.height
     * @return {Array} - list of the items presents in the area
     */

  }, {
    key: 'getItemsInArea',
    value: function getItemsInArea(area) {
      var start = this.timeContext.parent.timeToPixel(this.timeContext.start);
      var duration = this.timeContext.timeToPixel(this.timeContext.duration);
      var offset = this.timeContext.timeToPixel(this.timeContext.offset);
      var top = this._top;
      // be aware af context's translations - constrain in working view
      var x1 = Math.max(area.left, start);
      var x2 = Math.min(area.left + area.width, start + duration);
      x1 -= start + offset;
      x2 -= start + offset;
      // keep consistent with context y coordinates system
      var y1 = this._height - (area.top + area.height);
      var y2 = this._height - area.top;

      y1 += this._top;
      y2 += this._top;

      var $filteredItems = [];

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator3.default)(this._$itemDataMap.entries()), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _step5$value = (0, _slicedToArray3.default)(_step5.value, 2),
              $item = _step5$value[0],
              datum = _step5$value[1];

          var shape = this._$itemShapeMap.get($item);
          var inArea = shape.inArea(this._renderingContext, datum, x1, y1, x2, y2);

          if (inArea) {
            $filteredItems.push($item);
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return $filteredItems;
    }

    // --------------------------------------
    // Rendering / Display methods
    // --------------------------------------

    /**
     * Moves an item to the end of the layer to display it front of its
     * siblings (svg z-index...).
     *
     * @param {Element} $item - The item to be moved.
     */

  }, {
    key: '_toFront',
    value: function _toFront($item) {
      this.$offset.appendChild($item);
    }

    /**
     * Create the DOM structure of the shapes according to the given data. Inspired
     * from the `enter` and `exit` d3.js paradigm, this method should be called
     * each time a datum is added or removed from the data. While the DOM is
     * created the `update` method must be called in order to update the shapes
     * attributes and thus place them where they should.
     */

  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      // render `commonShape` only once
      if (this._commonShapeConfiguration !== null && this._$itemCommonShapeMap.size === 0) {
        var _commonShapeConfigura = this._commonShapeConfiguration,
            ctor = _commonShapeConfigura.ctor,
            accessors = _commonShapeConfigura.accessors,
            options = _commonShapeConfigura.options;

        var $group = document.createElementNS(_namespace2.default, 'g');
        var shape = new ctor(options);

        shape.install(accessors);
        $group.appendChild(shape.render());
        $group.classList.add('item', 'common', shape.getClassName());

        this._$itemCommonShapeMap.set($group, shape);
        this.$offset.appendChild($group);
      }

      // append elements all at once
      var fragment = document.createDocumentFragment();
      var values = this._$itemDataMap.values(); // iterator

      // enter
      this.data.forEach(function (datum) {
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = (0, _getIterator3.default)(values), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var value = _step6.value;
            if (value === datum) {
              return;
            }
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }

        var _shapeConfiguration = _this3._shapeConfiguration,
            ctor = _shapeConfiguration.ctor,
            accessors = _shapeConfiguration.accessors,
            options = _shapeConfiguration.options;

        var shape = new ctor(options);
        shape.install(accessors);

        var $el = shape.render(_this3._renderingContext);
        $el.classList.add('item', shape.getClassName());

        _this3._$itemShapeMap.set($el, shape);
        _this3._$itemDataMap.set($el, datum);

        fragment.appendChild($el);
      });

      this.$offset.appendChild(fragment);

      // remove
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = (0, _getIterator3.default)(this._$itemDataMap.entries()), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var _step7$value = (0, _slicedToArray3.default)(_step7.value, 2),
              $item = _step7$value[0],
              datum = _step7$value[1];

          if (this.data.indexOf(datum) !== -1) {
            continue;
          }

          var _shape = this._$itemShapeMap.get($item);

          this.$offset.removeChild($item);
          _shape.destroy();
          // a removed item cannot be selected
          if (this._behavior) {
            this._behavior.unselect($item, datum);
          }

          this._$itemDataMap.delete($item);
          this._$itemShapeMap.delete($item);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }

    /**
     * Updates the container of the layer and the attributes of the existing shapes.
     */

  }, {
    key: 'update',
    value: function update() {
      this.updateContainer();
      this.updateShapes();
    }

    /**
     * Updates the container of the layer.
     */

  }, {
    key: 'updateContainer',
    value: function updateContainer() {
      this._updateRenderingContext();

      var timeContext = this.timeContext;
      var width = timeContext.timeToPixel(timeContext.duration);
      // x is relative to timeline's timeContext
      var x = timeContext.parent.timeToPixel(timeContext.start);
      var offset = timeContext.timeToPixel(timeContext.offset);
      var top = this._top;
      var height = this._height;
      // matrix to invert the coordinate system
      var translateMatrix = 'matrix(1, 0, 0, -1, ' + x + ', ' + (top + height) + ')';
      this.$el.setAttributeNS(null, 'transform', translateMatrix);
      // this.$el.setAttributeNS(null, 'transform', `translate(${x}, ${top})`);

      this.$boundingBox.setAttributeNS(null, 'width', width);
      this.$boundingBox.setAttributeNS(null, 'height', height);
      this.$boundingBox.style.opacity = this.params.opacity;

      this.$offset.setAttributeNS(null, 'transform', 'translate(' + offset + ', 0)');
      // maintain context shape
      this.contextShape.update(this._renderingContext, this.timeContext, 0);
    }

    /**
     * Updates the attributes of all the `Shape` instances rendered into the layer.
     *
     * @todo - allow to filter which shape(s) should be updated.
     */

  }, {
    key: 'updateShapes',
    value: function updateShapes() {
      var _this4 = this;

      this._updateRenderingContext();
      // update common shapes
      this._$itemCommonShapeMap.forEach(function (shape, $item) {
        shape.update(_this4._renderingContext, _this4.data);
      });

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = (0, _getIterator3.default)(this._$itemDataMap.entries()), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var _step8$value = (0, _slicedToArray3.default)(_step8.value, 2),
              $item = _step8$value[0],
              datum = _step8$value[1];

          var shape = this._$itemShapeMap.get($item);
          shape.update(this._renderingContext, datum);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
  }, {
    key: 'start',


    /**
     * Returns `LayerTimeContext`'s `start` time domain value.
     *
     * @type {Number}
     */
    get: function get() {
      return this.timeContext.start;
    }

    /**
     * Sets `LayerTimeContext`'s `start` time domain value.
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      this.timeContext.start = value;
    }

    /**
     * Returns `LayerTimeContext`'s `offset` time domain value.
     *
     * @type {Number}
     */

  }, {
    key: 'offset',
    get: function get() {
      return this.timeContext.offset;
    }

    /**
     * Sets `LayerTimeContext`'s `offset` time domain value.
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      this.timeContext.offset = value;
    }

    /**
     * Returns `LayerTimeContext`'s `duration` time domain value.
     *
     * @type {Number}
     */

  }, {
    key: 'duration',
    get: function get() {
      return this.timeContext.duration;
    }

    /**
     * Sets `LayerTimeContext`'s `duration` time domain value.
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      this.timeContext.duration = value;
    }

    /**
     * Returns `LayerTimeContext`'s `stretchRatio` time domain value.
     *
     * @type {Number}
     */

  }, {
    key: 'stretchRatio',
    get: function get() {
      return this.timeContext.stretchRatio;
    }

    /**
     * Sets `LayerTimeContext`'s `stretchRatio` time domain value.
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      this.timeContext.stretchRatio = value;
    }

    /**
     * Set the domain boundaries of the data for the y axis.
     *
     * @type {Array}
     */

  }, {
    key: 'yDomain',
    set: function set(domain) {
      this.params.yDomain = domain;
      this._valueToPixel.domain(domain);
    }

    /**
     * Returns the domain boundaries of the data for the y axis.
     *
     * @type {Array}
     */
    ,
    get: function get() {
      return this.params.yDomain;
    }

    /**
     * Sets the opacity of the whole layer.
     *
     * @type {Number}
     */

  }, {
    key: 'opacity',
    set: function set(value) {
      this.params.opacity = value;
    }

    /**
     * Returns the opacity of the whole layer.
     *
     * @type {Number}
     */
    ,
    get: function get() {
      return this.params.opacity;
    }

    /**
     * Returns the transfert function used to display the data in the x axis.
     *
     * @type {Number}
     */

  }, {
    key: 'timeToPixel',
    get: function get() {
      return this.timeContext.timeToPixel;
    }

    /**
     * Returns the transfert function used to display the data in the y axis.
     *
     * @type {Number}
     */

  }, {
    key: 'valueToPixel',
    get: function get() {
      return this._valueToPixel;
    }

    /**
     * Returns an array containing all the displayed items.
     *
     * @type {Array<Element>}
     */

  }, {
    key: 'items',
    get: function get() {
      return (0, _from2.default)(this._$itemDataMap.keys());
    }

    /**
     * Returns the data associated to the layer.
     *
     * @type {Object[]}
     */

  }, {
    key: 'data',
    get: function get() {
      return this._data;
    }

    /**
     * Sets the data associated with the layer.
     *
     * @type {Object|Object[]}
     */
    ,
    set: function set(data) {
      switch (this.dataType) {
        case 'entity':
          if (this._data) {
            // if data already exists, reuse the reference
            this._data[0] = data;
          } else {
            this._data = [data];
          }
          break;
        case 'collection':
          this._data = data;
          break;
      }
    }
  }, {
    key: 'selectedItems',
    get: function get() {
      return this._behavior ? this._behavior.selectedItems : [];
    }
  }], [{
    key: 'configureTimeContextBehavior',
    value: function configureTimeContextBehavior(ctor) {
      timeContextBehaviorCtor = ctor;
    }
  }]);
  return Layer;
}(_events.EventEmitter);

exports.default = Layer;

},{"../behaviors/TimeContextBehavior":393,"../shapes/BaseShape":416,"../shapes/Segment":421,"../utils/scales":436,"./namespace":400,"babel-runtime/core-js/array/from":437,"babel-runtime/core-js/get-iterator":438,"babel-runtime/core-js/map":440,"babel-runtime/core-js/object/assign":441,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455,"babel-runtime/helpers/slicedToArray":456,"events":164}],396:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _scales = require('../utils/scales');

var _scales2 = _interopRequireDefault(_scales);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `LayerTimeContext` instance represents a time segment into a `TimelineTimeContext`.
 * It must be attached to a `TimelineTimeContext` (the one of the timeline it
 * belongs to). It relies on its parent's `timeToPixel` (time to pixel transfert
 * function) to create the time to pixel representation of the Layer (the view) it is attached to.
 *
 * The `layerTimeContext` has four important attributes:
 * - `start` represent the time at which temporal data must be represented
 *   in the timeline (for instance the begining of a soundfile in a DAW).
 * - `offset` represents offset time of the data in the context of a Layer.
 *   (@TODO give a use case example here "crop ?", and/or explain that it's not a common use case).
 * - `duration` is the duration of the view on the data.
 * - `stretchRatio` is the stretch applyed to the temporal data contained in
 *   the view (this value can be seen as a local zoom on the data, or as a stretch
 *   on the time components of the data). When applyed, the stretch ratio maintain
 *   the start position of the view in the timeline.
 *
 * ```
 * + timeline -----------------------------------------------------------------
 * 0         5         10          15          20        25          30 seconds
 * +---+*****************+------------------------------------------+*******+--
 *     |*** soundfile ***|Layer (view on the sound file)            |*******|
 *     +*****************+------------------------------------------+*******+
 *
 *     <---- offset ----><--------------- duration ----------------->
 * <-------- start ----->
 *
 * The parts of the sound file represented with '*' are hidden from the view
 * ```
 *
 * [example usage](./examples/time-contexts.html)
 */
var LayerTimeContext = function () {
  /**
   * @param {TimelineTimeContext} parent - The `TimelineTimeContext` instance of the timeline.
   */
  function LayerTimeContext(parent) {
    (0, _classCallCheck3.default)(this, LayerTimeContext);

    if (!parent) {
      throw new Error('LayerTimeContext must have a parent');
    }

    /**
     * The `TimelineTimeContext` instance of the timeline.
     *
     * @type {TimelineTimeContext}
     */
    this.parent = parent;

    this._timeToPixel = null;
    this._start = 0;
    this._duration = parent.visibleDuration;
    this._offset = 0;
    this._stretchRatio = 1;
    // register into the timeline's TimeContext
    this.parent._children.push(this);
  }

  /**
   * Creates a clone of the current time context.
   *
   * @return {LayerTimeContext}
   */


  (0, _createClass3.default)(LayerTimeContext, [{
    key: 'clone',
    value: function clone() {
      var ctx = new this();

      ctx.parent = this.parent;
      ctx.start = this.start;
      ctx.duration = this.duration;
      ctx.offset = this.offset;
      ctx.stretchRatio = this.stretchRatio; // creates the local scale if needed

      return ctx;
    }

    /**
     * Returns the start position of the time context (in seconds).
     *
     * @type {Number}
     */

  }, {
    key: 'pixelToTime',


    /**
     * Helper function to convert pixel to time.
     *
     * @param {Number} px
     * @return {Number}
     */
    value: function pixelToTime(px) {
      if (!this._timeToPixel) {
        return this.parent.timeToPixel.invert(px);
      }

      return this._timeToPixel.invert(px);
    }
  }, {
    key: 'start',
    get: function get() {
      return this._start;
    }

    /**
     * Sets the start position of the time context (in seconds).
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      this._start = value;
    }

    /**
     * Returns the duration of the time context (in seconds).
     *
     * @type {Number}
     */

  }, {
    key: 'duration',
    get: function get() {
      return this._duration;
    }

    /**
     * Sets the duration of the time context (in seconds).
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      this._duration = value;
    }

    /**
     * Returns the offset of the time context (in seconds).
     *
     * @type {Number}
     */

  }, {
    key: 'offset',
    get: function get() {
      return this._offset;
    }

    /**
     * Sets the offset of the time context (in seconds).
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      this._offset = value;
    }

    /**
     * Returns the stretch ratio of the time context.
     *
     * @type {Number}
     */

  }, {
    key: 'stretchRatio',
    get: function get() {
      return this._stretchRatio;
    }

    /**
     * Sets the stretch ratio of the time context.
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      // remove local scale if ratio = 1
      if (value === 1) {
        this._timeToPixel = null;
        return;
      }
      // reuse previsously created local scale if exists
      var timeToPixel = this._timeToPixel ? this._timeToPixel : _scales2.default.linear().domain([0, 1]);

      timeToPixel.range([0, this.parent.computedPixelsPerSecond * value]);

      this._timeToPixel = timeToPixel;
      this._stretchRatio = value;
    }

    /**
     * Returns the time to pixel transfert function of the time context. If
     * the `stretchRatio` attribute is equal to 1, this function is the global
     * one from the `TimelineTimeContext` instance.
     *
     * @type {Function}
     */

  }, {
    key: 'timeToPixel',
    get: function get() {
      if (!this._timeToPixel) return this.parent.timeToPixel;

      return this._timeToPixel;
    }
  }]);
  return LayerTimeContext;
}();

exports.default = LayerTimeContext;

},{"../utils/scales":436,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452}],397:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _scales = require('../utils/scales');

var _scales2 = _interopRequireDefault(_scales);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Defines and maintains global aspects of the visualization concerning the
 * relations between time and pixels.
 *
 * The `TimelineTimeContext` instance (unique across a visualization) keeps the
 * main reference on how many pixels should be used to represent one second
 * though its `timeToPixel` method. The attributes `zoom`, `offset` (i.e. from
 * origin) and `visibleWidth` allow for navigating in time and for maintaining
 * view consistency upon the DOM structure (`<svg>` and `<g>` tags) created by
 * the registered tracks.
 *
 * It also maintain an array of all references to `LayerTimeContext` instances
 * to propagate to `layers`, changes made on the time to pixel representation.
 *
 * [example usage](./examples/time-contexts.html)
 */
var TimelineTimeContext = function () {
  /**
   * @param {Number} pixelsPerSecond - The number of pixels that should be
   *    used to display one second.
   * @param {Number} visibleWidth - The default with of the visible area
   *    displayed in `tracks` (in pixels).
   */
  function TimelineTimeContext(pixelsPerSecond, visibleWidth) {
    (0, _classCallCheck3.default)(this, TimelineTimeContext);

    this._children = [];

    this._timeToPixel = null;
    this._offset = 0;
    this._zoom = 1;
    this._computedPixelsPerSecond = pixelsPerSecond;
    // params
    this._visibleWidth = visibleWidth;
    this._maintainVisibleDuration = false;

    // create the timeToPixel scale
    var scale = _scales2.default.linear().domain([0, 1]).range([0, pixelsPerSecond]);

    this._timeToPixel = scale;

    this._originalPixelsPerSecond = this._computedPixelsPerSecond;
  }

  /**
   * Returns the number of pixels per seconds ignoring the current zoom value.
   *
   * @type {Number}
   */


  (0, _createClass3.default)(TimelineTimeContext, [{
    key: '_updateTimeToPixelRange',
    value: function _updateTimeToPixelRange() {
      this.timeToPixel.range([0, this._computedPixelsPerSecond]);
    }
  }, {
    key: 'pixelsPerSecond',
    get: function get() {
      return this._originalPixelsPerSecond;
    }

    /**
     * Updates all the caracteristics of this object according to the new
     * given value of pixels per seconds. Propagates the changes to the
     * `LayerTimeContext` children.
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      this._computedPixelsPerSecond = value * this.zoom;
      this._originalPixelsPerSecond = value;
      this._updateTimeToPixelRange();

      // force children scale update
      this._children.forEach(function (child) {
        if (child.stretchRatio !== 1) child.stretchRatio = child.stretchRatio;
      });
    }

    /**
     * Returns the number of pixels per seconds including the current zoom value.
     *
     * @type {Number}
     */

  }, {
    key: 'computedPixelsPerSecond',
    get: function get() {
      return this._computedPixelsPerSecond;
    }

    /**
     * Returns the current offset applied to the registered `Track` instances
     * from origin (in seconds).
     *
     * @type {Number}
     */

  }, {
    key: 'offset',
    get: function get() {
      return this._offset;
    }

    /**
     * Sets the offset to apply to the registered `Track` instances from origin
     * (in seconds).
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      this._offset = value;
    }

    /**
     * Returns the current zoom level applied to the whole visualization.
     *
     * @type {Number}
     */

  }, {
    key: 'zoom',
    get: function get() {
      return this._zoom;
    }

    /**
     * Sets the zoom ratio for the whole visualization.
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      // Compute change to propagate to children who have their own timeToPixel
      var ratioChange = value / this._zoom;
      this._zoom = value;
      this._computedPixelsPerSecond = this._originalPixelsPerSecond * value;
      this._updateTimeToPixelRange();

      this._children.forEach(function (child) {
        if (child.stretchRatio !== 1) child.stretchRatio = child.stretchRatio * ratioChange;
      });
    }

    /**
     * Returns the visible width of the `Track` instances.
     *
     * @type {Number}
     */

  }, {
    key: 'visibleWidth',
    get: function get() {
      return this._visibleWidth;
    }

    /**
     * Sets the visible width of the `Track` instances.
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      var widthRatio = value / this._visibleWidth;
      this._visibleWidth = value;

      if (this.maintainVisibleDuration) this.pixelsPerSecond = this.pixelsPerSecond * widthRatio;
    }

    /**
     * Returns the duration displayed by `Track` instances.
     *
     * @type {Number}
     */

  }, {
    key: 'visibleDuration',
    get: function get() {
      return this.visibleWidth / this._computedPixelsPerSecond;
    }

    /**
     * Returns if the duration displayed by tracks should be maintained when
     * their width is updated.
     *
     * @type {Number}
     */

  }, {
    key: 'maintainVisibleDuration',
    get: function get() {
      return this._maintainVisibleDuration;
    }

    /**
     * Defines if the duration displayed by tracks should be maintained when
     * their width is updated.
     *
     * @type {Boolean}
     */
    ,
    set: function set(bool) {
      this._maintainVisibleDuration = bool;
    }

    /**
     * Returns the time to pixel trasfert function.
     *
     * @type {Function}
     */

  }, {
    key: 'timeToPixel',
    get: function get() {
      return this._timeToPixel;
    }
  }]);
  return TimelineTimeContext;
}();

exports.default = TimelineTimeContext;

},{"../utils/scales":436,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452}],398:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _iterator2 = require('babel-runtime/core-js/symbol/iterator');

var _iterator3 = _interopRequireDefault(_iterator2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _namespace = require('./namespace');

var _namespace2 = _interopRequireDefault(_namespace);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Acts as a placeholder to organize the vertical layout of the visualization
 * and the horizontal alignement to an abscissa that correspond to a common
 * time reference. It basically offer a view on the overall timeline.
 *
 * Tracks are inserted into a given DOM element, allowing to create DAW like
 * representations. Each `Track` instance can host multiple `Layer` instances.
 * A track must be added to a timeline before being updated.
 *
 * ### A timeline with 3 tracks:
 *
 * ```
 * 0                 6                               16
 * +- - - - - - - - -+-------------------------------+- - - - - - -
 * |                 |x track 1 xxxxxxxxxxxxxxxxxxxxx|
 * +- - - - - - - - -+-------------------------------+- - - - - - -
 * |                 |x track 2 xxxxxxxxxxxxxxxxxxxxx|
 * +- - - - - - - - -+-------------------------------+- - - - - - -
 * |                 |x track 3 xxxxxxxxxxxxxxxxxxxxx|
 * +- - - - - - - - ---------------------------------+- - - - - - -
 * +----------------->
 * timeline.timeContext.timeToPixel(timeline.timeContext.offset)
 *
 *                   <------------------------------->
 *                   timeline's tracks defaults to 1000px
 *                   with a default pixelsPerSecond of 100px/s.
 *                   and a default `stretchRatio = 1`
 *                   track1 shows 10 seconds of the timeline
 * ```
 *
 * ### Track DOM structure
 *
 * ```html
 * <svg width="${visibleWidth}">
 *   <!-- background -->
 *   <rect><rect>
 *   <!-- main view -->
 *   <g class="offset" transform="translate(${offset}, 0)">
 *     <g class="layout">
 *       <!-- layers -->
 *     </g>
 *   </g>
 *   <g class="interactions"><!-- for feedback --></g>
 * </svg>
 * ```
 */
var Track = function () {
  /**
   * @param {DOMElement} $el
   * @param {Number} [height = 100]
   */
  function Track($el) {
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    (0, _classCallCheck3.default)(this, Track);

    this._height = height;

    /**
     * The DOM element in which the track is created.
     * @type {Element}
     */
    this.$el = $el;
    /**
     * A placeholder to add shapes for interactions feedback.
     * @type {Element}
     */
    this.$interactions = null;
    /** @type {Element} */
    this.$layout = null;
    /** @type {Element} */
    this.$offset = null;
    /** @type {Element} */
    this.$svg = null;
    /** @type {Element} */
    this.$background = null;

    /**
     * An array of all the layers belonging to the track.
     * @type {Array<Layer>}
     */
    this.layers = [];
    /**
     * The context used to maintain the DOM structure of the track.
     * @type {TimelineTimeContext}
     */
    this.renderingContext = null;

    this._createContainer();
  }

  /**
   * Returns the height of the track.
   *
   * @type {Number}
   */


  (0, _createClass3.default)(Track, [{
    key: 'configure',


    /**
     * This method is called when the track is added to the timeline. The
     * track cannot be updated without being added to a timeline.
     *
     * @private
     * @param {TimelineTimeContext} renderingContext
     */
    value: function configure(renderingContext) {
      this.renderingContext = renderingContext;
    }

    /**
     * Destroy the track. The layers from this track can still be reused elsewhere.
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      var _this = this;

      // Detach everything from the DOM
      this.$el.removeChild(this.$svg);
      this.layers.forEach(function (layer) {
        return _this.$layout.removeChild(layer.$el);
      });
      // clean references
      this.$el = null;
      this.renderingContext = null;
      this.layers.length = 0;
    }

    /**
     * Creates the DOM structure of the track.
     */

  }, {
    key: '_createContainer',
    value: function _createContainer() {
      var $svg = document.createElementNS(_namespace2.default, 'svg');
      $svg.setAttributeNS(null, 'shape-rendering', 'optimizeSpeed');
      $svg.setAttributeNS(null, 'height', this.height);
      $svg.setAttribute('xmlns:xhtml', 'http://www.w3.org/1999/xhtml');
      $svg.classList.add('track');

      var $background = document.createElementNS(_namespace2.default, 'rect');
      $background.setAttributeNS(null, 'height', '100%');
      $background.setAttributeNS(null, 'width', '100%');
      $background.style.fillOpacity = 0;
      // $background.style.pointerEvents = 'none';

      var $defs = document.createElementNS(_namespace2.default, 'defs');

      var $offsetGroup = document.createElementNS(_namespace2.default, 'g');
      $offsetGroup.classList.add('offset');

      var $layoutGroup = document.createElementNS(_namespace2.default, 'g');
      $layoutGroup.classList.add('layout');

      var $interactionsGroup = document.createElementNS(_namespace2.default, 'g');
      $interactionsGroup.classList.add('interactions');

      $offsetGroup.appendChild($layoutGroup);
      $svg.appendChild($defs);
      $svg.appendChild($background);
      $svg.appendChild($offsetGroup);
      $svg.appendChild($interactionsGroup);
      this.$el.appendChild($svg);
      // removes additionnal height added who knows why...
      this.$el.style.fontSize = 0;
      // fixes one of the (many ?) weird canvas rendering bugs in Chrome
      this.$el.style.transform = 'translateZ(0)';

      this.$layout = $layoutGroup;
      this.$offset = $offsetGroup;
      this.$interactions = $interactionsGroup;
      this.$svg = $svg;
      this.$background = $background;
    }

    /**
     * Adds a layer to the track.
     *
     * @param {Layer} layer - the layer to add to the track.
     */

  }, {
    key: 'add',
    value: function add(layer) {
      var insertIndex = null;

      if (layer.params.zIndex < 0) layer.params.zIndex = 0;

      for (var i = 0; i < this.layers.length; i++) {
        if (layer.params.zIndex < this.layers[i].params.zIndex) {
          insertIndex = i;
          break;
        }
      }

      if (insertIndex === null) insertIndex = this.layers.length;

      this.layers.splice(insertIndex, 0, layer);
      // append at the zIndex place
      this.$layout.insertBefore(layer.$el, this.$layout.children[insertIndex]);
    }

    /**
     * Removes a layer from the track. The layer can be reused elsewhere.
     *
     * @param {Layer} layer - the layer to remove from the track.
     */

  }, {
    key: 'remove',
    value: function remove(layer) {
      this.layers.splice(this.layers.indexOf(layer), 1);
      // Removes layer from its container
      this.$layout.removeChild(layer.$el);
    }

    /**
     * Tests if a given element belongs to the track.
     *
     * @param {Element} $el
     * @return {bool}
     */

  }, {
    key: 'hasElement',
    value: function hasElement($el) {
      do {
        if ($el === this.$el) {
          return true;
        }

        $el = $el.parentNode;
      } while ($el !== null);

      return false;
    }

    /**
     * Render all the layers added to the track.
     */

  }, {
    key: 'render',
    value: function render() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;
          layer.render();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Updates the track DOM structure and updates the layers.
     *
     * @param {Array<Layer>} [layers=null] - if not null, a subset of the layers to update.
     */

  }, {
    key: 'update',
    value: function update() {
      var layers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      this.updateContainer();
      this.updateLayers(layers);
    }

    /**
     * Updates the track DOM structure.
     */

  }, {
    key: 'updateContainer',
    value: function updateContainer() {
      var $svg = this.$svg;
      var $offset = this.$offset;
      // Should be in some update layout
      var renderingContext = this.renderingContext;
      var height = this.height;
      var width = Math.round(renderingContext.visibleWidth);
      var offsetX = Math.round(renderingContext.timeToPixel(renderingContext.offset));
      var translate = 'translate(' + offsetX + ', 0)';

      $svg.setAttributeNS(null, 'height', height);
      $svg.setAttributeNS(null, 'width', width);
      $svg.setAttributeNS(null, 'viewbox', '0 0 ' + width + ' ' + height);

      $offset.setAttributeNS(null, 'transform', translate);
    }

    /**
     * Updates the layers.
     *
     * @param {Array<Layer>} [layers=null] - if not null, a subset of the layers to update.
     */

  }, {
    key: 'updateLayers',
    value: function updateLayers() {
      var _this2 = this;

      var layers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      layers = layers === null ? this.layers : layers;

      layers.forEach(function (layer) {
        if (_this2.layers.indexOf(layer) === -1) {
          return;
        }
        layer.update();
      });
    }

    /**
     * Iterates through the added layers.
     */

  }, {
    key: _iterator3.default,
    value: _regenerator2.default.mark(function value() {
      return _regenerator2.default.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield((0, _getIterator3.default)(this.layers), 't0', 1);

            case 1:
            case 'end':
              return _context.stop();
          }
        }
      }, value, this);
    })
  }, {
    key: 'height',
    get: function get() {
      return this._height;
    }

    /**
     * Sets the height of the track.
     *
     * @type {Number}
     */
    ,
    set: function set(value) {
      var _this3 = this;

      var prevHeight = this._height;
      this._height = value;

      this.layers.forEach(function (layer) {
        return layer.updateHeight(prevHeight, _this3._height);
      });
    }
  }]);
  return Track;
}();

exports.default = Track;

},{"./namespace":400,"babel-runtime/core-js/get-iterator":438,"babel-runtime/core-js/symbol/iterator":450,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/regenerator":459}],399:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _Layer = require('./Layer');

var _Layer2 = _interopRequireDefault(_Layer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Collection hosting all the `Track` instances registered into the timeline.
 * It provides shorcuts to trigger `render` / `update` methods on tracks or
 * layers. Extend built-in Array
 */
var TrackCollection = function () {
  function TrackCollection(timeline) {
    (0, _classCallCheck3.default)(this, TrackCollection);

    this._timeline = timeline;
    this._tracks = new _set2.default();
  }

  // @note - should be in the timeline ?
  // @todo - allow to pass an array of layers


  (0, _createClass3.default)(TrackCollection, [{
    key: '_getLayersOrGroups',
    value: function _getLayersOrGroups() {
      var layerOrGroup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var layers = null;

      if (typeof layerOrGroup === 'string') {
        layers = this._timeline.groupedLayers[layerOrGroup];
      } else if (layerOrGroup instanceof _Layer2.default) {
        layers = [layerOrGroup];
      } else {
        layers = this.layers;
      }

      return layers;
    }

    /**
     * @type {Number} - Updates the height of all tracks at once.
     * @todo - Propagate to layers, not usefull for now.
     */

  }, {
    key: 'has',


    /**
     * Check if a given track belongs to the collection.
     *
     * @param {Track} track - Track to be tested
     * @returns {Boolean}
     */
    value: function has(track) {
      return this._tracks.has(track);
    }

    /**
     * Add a track to the collection.
     *
     * @param {Track} track - Track to add to the collection
     */

  }, {
    key: 'add',
    value: function add(track) {
      this._tracks.add(track);
    }

    // @todo

  }, {
    key: 'remove',
    value: function remove(track) {}
  }, {
    key: 'forEach',
    value: function forEach(callback) {
      this._tracks.forEach(callback);
    }

    /**
     * Render all tracks and layers. When done, the timeline triggers a `render` event.
     */

  }, {
    key: 'render',
    value: function render() {
      this._tracks.forEach(function (track) {
        return track.render();
      });
      this._timeline.emit('render');
    }

    /**
     * Updates all tracks and layers. When done, the timeline triggers a
     * `update` event.
     *
     * @todo - filtering is probably broken...
     * @param {Layer|String} layerOrGroup - Filter the layers to update by
     *    passing the `Layer` instance to update or a `groupId`
     */

  }, {
    key: 'update',
    value: function update(layerOrGroup) {
      var layers = this._getLayersOrGroups(layerOrGroup);
      this._tracks.forEach(function (track) {
        return track.update(layers);
      });
      this._timeline.emit('update', layers);
    }

    /**
     * Updates all `Track` containers, layers are not updated with this method.
     * When done, the timeline triggers a `update:containers` event.
     */

  }, {
    key: 'updateContainer',
    value: function updateContainer() /* trackOrTrackIds */{
      this._tracks.forEach(function (track) {
        return track.updateContainer();
      });
      this._timeline.emit('update:containers');
    }

    /**
     * Updates all layers. When done, the timeline triggers a `update:layers` event.
     *
     * @todo - filtering is probably broken...
     * @param {Layer|String} layerOrGroup - Filter the layers to update by
     *    passing the `Layer` instance to update or a `groupId`
     */

  }, {
    key: 'updateLayers',
    value: function updateLayers(layerOrGroup) {
      var layers = this._getLayersOrGroups(layerOrGroup);
      this._tracks.forEach(function (track) {
        return track.updateLayers(layers);
      });
      this._timeline.emit('update:layers', layers);
    }
  }, {
    key: 'height',
    set: function set(value) {
      this._tracks.forEach(function (track) {
        return track.height = value;
      });
    }

    /**
     * An array of all registered layers.
     *
     * @type {Array<Layer>}
     */

  }, {
    key: 'layers',
    get: function get() {
      var layers = [];
      this._tracks.forEach(function (track) {
        return layers = layers.concat(track.layers);
      });

      return layers;
    }
  }]);
  return TrackCollection;
}();

exports.default = TrackCollection;

},{"./Layer":395,"babel-runtime/core-js/set":448,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452}],400:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'http://www.w3.org/2000/svg';

},{}],401:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _Keyboard = require('../interactions/Keyboard');

var _Keyboard2 = _interopRequireDefault(_Keyboard);

var _LayerTimeContext = require('./LayerTimeContext');

var _LayerTimeContext2 = _interopRequireDefault(_LayerTimeContext);

var _Surface = require('../interactions/Surface');

var _Surface2 = _interopRequireDefault(_Surface);

var _TimelineTimeContext = require('./TimelineTimeContext');

var _TimelineTimeContext2 = _interopRequireDefault(_TimelineTimeContext);

var _Track = require('./Track');

var _Track2 = _interopRequireDefault(_Track);

var _TrackCollection = require('./TrackCollection');

var _TrackCollection2 = _interopRequireDefault(_TrackCollection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Is the main entry point to create a temporal visualization.
 *
 * A `timeline` instance mainly provides the context for any visualization of
 * temporal data and maintains the hierarchy of `Track`, `Layer` and `Shape`
 * over the entiere visualisation.
 *
 * Its main responsabilites are:
 * - maintaining the temporal consistency accross the visualisation through
 *   its `timeContext` property (instance of `TimelineTimeContext`).
 * - handling interactions to its current state (acting here as a simple
 *   state machine).
 *
 * @TODO insert figure
 *
 * It also contains a reference to all the register track allowing to `render`
 * or `update` all the layer from a single entry point.
 *
 * ## Example Usage
 *
 * ```js
 * const visibleWidth = 500; // default width in pixels for all created `Track`
 * const duration = 10; // the visible area represents 10 seconds
 * const pixelsPerSeconds = visibleWidth / duration;
 * const timeline = new ui.core.Timeline(pixelsPerSecond, width);
 * ```
 */
var Timeline = function (_events$EventEmitter) {
  (0, _inherits3.default)(Timeline, _events$EventEmitter);

  /**
   * @param {Number} [pixelsPerSecond=100] - the default scaling between time and pixels.
   * @param {Number} [visibleWidth=1000] - the default visible area for all registered tracks.
   */
  function Timeline() {
    var pixelsPerSecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
    var visibleWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;

    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$registerKeyboard = _ref.registerKeyboard,
        registerKeyboard = _ref$registerKeyboard === undefined ? true : _ref$registerKeyboard;

    (0, _classCallCheck3.default)(this, Timeline);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Timeline.__proto__ || (0, _getPrototypeOf2.default)(Timeline)).call(this));

    _this._tracks = new _TrackCollection2.default(_this);
    _this._state = null;

    // default interactions
    _this._surfaceCtor = _Surface2.default;

    // stores
    _this._trackById = {};
    _this._groupedLayers = {};
    _this._$elInteractionsMap = new _map2.default();

    /** @type {TimelineTimeContext} - master time context for the visualization. */
    _this.timeContext = new _TimelineTimeContext2.default(pixelsPerSecond, visibleWidth);

    if (registerKeyboard) _this.createInteraction(_Keyboard2.default, document);
    return _this;
  }

  /**
   * Returns `TimelineTimeContext`'s `offset` time domain value.
   *
   * @type {Number} [offset=0]
   */


  (0, _createClass3.default)(Timeline, [{
    key: 'configureSurface',


    /**
     * Overrides the default `Surface` that is instanciated on each `Track`
     * instance. This methos should be called before adding any `Track` instance
     * to the current `timeline`.
     *
     * @param {EventSource} ctor - The constructor to use in order to catch mouse
     *    events on each `Track` instances.
     */
    value: function configureSurface(ctor) {
      this._surfaceCtor = ctor;
    }

    /**
     * Factory method to add interaction modules the timeline should listen to.
     * By default, the timeline instanciate a global `Keyboard` instance and a
     * `Surface` instance on each container.
     * Should be used to install new interactions implementing the `EventSource` interface.
     *
     * @param {EventSource} ctor - The contructor of the interaction module to instanciate.
     * @param {Element} $el - The DOM element which will be binded to the `EventSource` module.
     * @param {Object} [options={}] - Options to be applied to the `ctor`.
     */

  }, {
    key: 'createInteraction',
    value: function createInteraction(ctor, $el) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var interaction = new ctor($el, options);
      interaction.on('event', function (e) {
        return _this2._handleEvent(e);
      });

      // store interaction associated to the DOM element
      if (!this._$elInteractionsMap.has($el)) this._$elInteractionsMap.set($el, new _set2.default());

      var interactionSet = this._$elInteractionsMap.get($el);
      interactionSet.add(interaction);
    }

    /**
     * Returns a list of the layers situated under the position of a `WaveEvent`.
     *
     * @param {WavesEvent} e - An event triggered by a `WaveEvent`
     * @return {Array} - Matched layers
     */

  }, {
    key: 'getHitLayers',
    value: function getHitLayers(e) {
      var clientX = e.originalEvent.clientX;
      var clientY = e.originalEvent.clientY;
      var layers = [];

      this.layers.forEach(function (layer) {
        if (!layer.params.hittable) {
          return;
        }
        var boundingRect = layer.$el.getBoundingClientRect();

        if (clientX > boundingRect.left && clientX < boundingRect.right && clientY > boundingRect.top && clientY < boundingRect.bottom) {
          layers.push(layer);
        }
      });

      return layers;
    }

    /**
     * The callback that is used to listen to interactions modules.
     *
     * @param {WaveEvent} e - An event generated by an interaction modules (`EventSource`).
     */

  }, {
    key: '_handleEvent',
    value: function _handleEvent(e) {
      var hitLayers = e.source === 'surface' ? this.getHitLayers(e) : null;
      // emit event as a middleware
      this.emit('event', e, hitLayers);
      // propagate to the state
      if (this._state) this._state.handleEvent(e, hitLayers);
    }

    /**
     * Updates the state of the timeline.
     *
     * @type {BaseState}
     */

  }, {
    key: 'add',


    /**
     * Adds a new track to the timeline.
     *
     * @param {Track} track - The new track to be registered in the timeline.
     * @param {String} [trackId=null] - Optionnal unique id to associate with
     *    the track, this id only exists in timeline's context and should be used
     *    in conjonction with `addLayer` method.
     */
    value: function add(track) {
      var trackId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.tracks.has(track)) throw new Error('track already added to the timeline');

      this._registerTrackId(track, trackId);
      track.configure(this.timeContext);

      this.tracks.add(track);
      this.createInteraction(this._surfaceCtor, track.$el);
    }

    /**
     * Removes a track from the timeline.
     *
     * @param {Track} track - the track to remove from the timeline.
     * @todo not implemented.
     */

  }, {
    key: 'remove',
    value: function remove(track) {
      // should destroy all interactions too, avoid ghost eventListeners
      var $el = track.$el;
      var interactions = this._$elInteractionsMap.get($el);

      if (interactions) interactions.forEach(function (interaction) {
        return interaction.destroy();
      });

      track.destroy();
    }

    /**
     * Helper to create a new `Track` instance. The `track` is added,
     * rendered and updated before being returned.
     *
     * @param {Element} $el - The DOM element where the track should be inserted.
     * @param {Number} trackHeight - The height of the newly created track.
     * @param {String} [trackId=null] - Optionnal unique id to associate with
     *    the track, this id only exists in timeline's context and should be used in
     *    conjonction with `addLayer` method.
     * @return {Track}
     */

  }, {
    key: 'createTrack',
    value: function createTrack($el) {
      var trackHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      var trackId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var track = new _Track2.default($el, trackHeight);
      // Add track to the timeline
      this.add(track, trackId);
      track.render();
      track.update();

      return track;
    }

    /**
     * If track id is defined, associate a track with a unique id.
     */

  }, {
    key: '_registerTrackId',
    value: function _registerTrackId(track, trackId) {
      if (trackId !== null) {
        if (this._trackById[trackId] !== undefined) {
          throw new Error('trackId: "' + trackId + '" is already used');
        }

        this._trackById[trackId] = track;
      }
    }

    /**
     * Helper to add a `Layer` instance into a given `Track`. Is designed to be
     * used in conjonction with the `Timeline~getLayersByGroup` method. The
     * layer is internally rendered and updated.
     *
     * @param {Layer} layer - The `Layer` instance to add into the visualization.
     * @param {(Track|String)} trackOrTrackId - The `Track` instance (or its `id`
     *    as defined in the `createTrack` method) where the `Layer` instance should be inserted.
     * @param {String} [groupId='default'] - An optionnal group id in which the
     *    `Layer` should be inserted.
     * @param {Boolean} [isAxis] - Set to `true` if the added `layer` is an
     *    instance of `AxisLayer` (these layers shares the `TimlineTimeContext` instance
     *    of the timeline).
     */

  }, {
    key: 'addLayer',
    value: function addLayer(layer, trackOrTrackId) {
      var groupId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
      var isAxis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var track = trackOrTrackId;

      if (typeof trackOrTrackId === 'string') {
        track = this.getTrackById(trackOrTrackId);
      }

      // creates the `LayerTimeContext` if not present
      if (!layer.timeContext) {
        var timeContext = isAxis ? this.timeContext : new _LayerTimeContext2.default(this.timeContext);

        layer.setTimeContext(timeContext);
      }

      // we should have a Track instance at this point
      track.add(layer);

      if (!this._groupedLayers[groupId]) {
        this._groupedLayers[groupId] = [];
      }

      this._groupedLayers[groupId].push(layer);

      layer.render();
      layer.update();
    }

    /**
     * Removes a layer from its track. The layer is detatched from the DOM but
     * can still be reused later.
     *
     * @param {Layer} layer - The layer to remove.
     */

  }, {
    key: 'removeLayer',
    value: function removeLayer(layer) {
      this.tracks.forEach(function (track) {
        var index = track.layers.indexOf(layer);
        if (index !== -1) {
          track.remove(layer);
        }
      });

      // clean references in helpers
      for (var groupId in this._groupedLayers) {
        var group = this._groupedLayers[groupId];
        var index = group.indexOf(layer);

        if (index !== -1) {
          group.splice(layer, 1);
        }

        if (!group.length) {
          delete this._groupedLayers[groupId];
        }
      }
    }

    /**
     * Returns a `Track` instance from it's given id.
     *
     * @param {String} trackId
     * @return {Track}
     */

  }, {
    key: 'getTrackById',
    value: function getTrackById(trackId) {
      return this._trackById[trackId];
    }

    /**
     * Returns the track containing a given DOM Element, returns null if no match found.
     *
     * @param {Element} $el - The DOM Element to be tested.
     * @return {Track}
     */

  }, {
    key: 'getTrackFromDOMElement',
    value: function getTrackFromDOMElement($el) {
      var $svg = null;
      var track = null;
      // find the closest `.track` element
      do {
        if ($el.classList.contains('track')) {
          $svg = $el;
        }
        $el = $el.parentNode;
      } while ($svg === null);
      // find the related `Track`
      this.tracks.forEach(function (_track) {
        if (_track.$svg === $svg) {
          track = _track;
        }
      });

      return track;
    }

    /**
     * Returns an array of layers from their given group id.
     *
     * @param {String} groupId - The id of the group as defined in `addLayer`.
     * @return {(Array|undefined)}
     */

  }, {
    key: 'getLayersByGroup',
    value: function getLayersByGroup(groupId) {
      return this._groupedLayers[groupId];
    }
  }, {
    key: 'offset',
    get: function get() {
      return this.timeContext.offset;
    }

    /**
     * Updates `TimelineTimeContext`'s `offset` time domain value.
     *
     * @type {Number} [offset=0]
     */
    ,
    set: function set(value) {
      this.timeContext.offset = value;
    }

    /**
     * Returns the `TimelineTimeContext`'s `zoom` value.
     *
     * @type {Number} [offset=0]
     */

  }, {
    key: 'zoom',
    get: function get() {
      return this.timeContext.zoom;
    }

    /**
     * Updates the `TimelineTimeContext`'s `zoom` value.
     *
     * @type {Number} [offset=0]
     */
    ,
    set: function set(value) {
      this.timeContext.zoom = value;
    }

    /**
     * Returns the `TimelineTimeContext`'s `pixelsPerSecond` ratio.
     *
     * @type {Number} [offset=0]
     */

  }, {
    key: 'pixelsPerSecond',
    get: function get() {
      return this.timeContext.pixelsPerSecond;
    }

    /**
     * Updates the `TimelineTimeContext`'s `pixelsPerSecond` ratio.
     *
     * @type {Number} [offset=0]
     */
    ,
    set: function set(value) {
      this.timeContext.pixelsPerSecond = value;
    }

    /**
     * Returns the `TimelineTimeContext`'s `visibleWidth` pixel domain value.
     *
     * @type {Number} [offset=0]
     */

  }, {
    key: 'visibleWidth',
    get: function get() {
      return this.timeContext.visibleWidth;
    }

    /**
     * Updates the `TimelineTimeContext`'s `visibleWidth` pixel domain value.
     *
     * @type {Number} [offset=0]
     */
    ,
    set: function set(value) {
      this.timeContext.visibleWidth = value;
    }

    /**
     * Returns `TimelineTimeContext`'s `timeToPixel` transfert function.
     *
     * @type {Function}
     */

  }, {
    key: 'timeToPixel',
    get: function get() {
      return this.timeContext.timeToPixel;
    }

    /**
     * Returns `TimelineTimeContext`'s `visibleDuration` helper value.
     *
     * @type {Number}
     */

  }, {
    key: 'visibleDuration',
    get: function get() {
      return this.timeContext.visibleDuration;
    }

    /**
     * Updates the `TimelineTimeContext`'s `maintainVisibleDuration` value.
     * Defines if the duration of the visible area should be maintain when
     * the `visibleWidth` attribute is updated.
     *
     * @type {Boolean}
     */

  }, {
    key: 'maintainVisibleDuration',
    set: function set(bool) {
      this.timeContext.maintainVisibleDuration = bool;
    }

    /**
     * Returns `TimelineTimeContext`'s `maintainVisibleDuration` current value.
     *
     * @type {Boolean}
     */
    ,
    get: function get() {
      return this.timeContext.maintainVisibleDuration;
    }

    /**
     * Object maintaining arrays of `Layer` instances ordered by their `groupId`.
     * Is used internally by the `TrackCollection` instance.
     *
     * @type {Object}
     */

  }, {
    key: 'groupedLayers',
    get: function get() {
      return this._groupedLayers;
    }
  }, {
    key: 'state',
    set: function set(state) {
      if (this._state) this._state.exit();

      this._state = state;

      if (this._state) this._state.enter();
    }

    /**
     * Returns the current state of the timeline.
     *
     * @type {BaseState}
     */
    ,
    get: function get() {
      return this._state;
    }

    /**
     * Returns the `TrackCollection` instance.
     *
     * @type {TrackCollection}
     */

  }, {
    key: 'tracks',
    get: function get() {
      return this._tracks;
    }

    /**
     * Returns the list of all registered layers.
     *
     * @type {Array}
     */

  }, {
    key: 'layers',
    get: function get() {
      return this._tracks.layers;
    }
  }]);
  return Timeline;
}(_events2.default.EventEmitter);

exports.default = Timeline;

},{"../interactions/Keyboard":413,"../interactions/Surface":414,"./LayerTimeContext":396,"./TimelineTimeContext":397,"./Track":398,"./TrackCollection":399,"babel-runtime/core-js/map":440,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/core-js/set":448,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455,"events":164}],402:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Layer2 = require('../core/Layer');

var _Layer3 = _interopRequireDefault(_Layer2);

var _Dot = require('../shapes/Dot');

var _Dot2 = _interopRequireDefault(_Dot);

var _Line = require('../shapes/Line');

var _Line2 = _interopRequireDefault(_Line);

var _BreakpointBehavior = require('../behaviors/BreakpointBehavior');

var _BreakpointBehavior2 = _interopRequireDefault(_BreakpointBehavior);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper to create a breakpoint function layer.
 *
 * [example usage](./examples/layer-breakpoint.html)
 */
var BreakpointLayer = function (_Layer) {
  (0, _inherits3.default)(BreakpointLayer, _Layer);

  /**
   * @param {Array} data - The data to render.
   * @param {Object} options - An object to configure the layer.
   * @param {Object} accessors - The accessors to configure the mapping
   *    between shapes and data.
   */
  function BreakpointLayer(data) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var accessors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck3.default)(this, BreakpointLayer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (BreakpointLayer.__proto__ || (0, _getPrototypeOf2.default)(BreakpointLayer)).call(this, 'collection', data, options));

    var color = options.color;
    var commonShapeOptions = {};

    if (color) {
      accessors.color = function () {
        return color;
      };
      commonShapeOptions.color = color;
    }

    _this.configureCommonShape(_Line2.default, accessors, commonShapeOptions);
    _this.configureShape(_Dot2.default, accessors, {});
    _this.setBehavior(new _BreakpointBehavior2.default());
    return _this;
  }

  return BreakpointLayer;
}(_Layer3.default);

exports.default = BreakpointLayer;

},{"../behaviors/BreakpointBehavior":390,"../core/Layer":395,"../shapes/Dot":418,"../shapes/Line":419,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],403:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Layer2 = require('../core/Layer');

var _Layer3 = _interopRequireDefault(_Layer2);

var _Cursor = require('../shapes/Cursor');

var _Cursor2 = _interopRequireDefault(_Cursor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper to create a cursor layer.
 *
 * [example usage](./examples/layer-cursor.html)
 */
var CursorLayer = function (_Layer) {
  (0, _inherits3.default)(CursorLayer, _Layer);

  /**
   * @param {Object} options - An object to configure the layer.
   */
  function CursorLayer() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, CursorLayer);

    var defaults = {
      color: 'red',
      hittable: false // kind of pass through layer
    };

    var data = { currentPosition: 0 };

    options = (0, _assign2.default)(defaults, options);

    var _this = (0, _possibleConstructorReturn3.default)(this, (CursorLayer.__proto__ || (0, _getPrototypeOf2.default)(CursorLayer)).call(this, 'entity', data, options));

    _this.configureShape(_Cursor2.default, { x: function x(d) {
        return d.currentPosition;
      } }, {
      color: options.color
    });
    return _this;
  }

  (0, _createClass3.default)(CursorLayer, [{
    key: 'currentPosition',
    set: function set(value) {
      this.data[0].currentPosition = value;
    },
    get: function get() {
      return this.data[0].currentPosition;
    }
  }]);
  return CursorLayer;
}(_Layer3.default);

exports.default = CursorLayer;

},{"../core/Layer":395,"../shapes/Cursor":417,"babel-runtime/core-js/object/assign":441,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],404:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _AxisLayer2 = require('../axis/AxisLayer');

var _AxisLayer3 = _interopRequireDefault(_AxisLayer2);

var _Ticks = require('../shapes/Ticks');

var _Ticks2 = _interopRequireDefault(_Ticks);

var _gridAxisGenerator = require('../axis/gridAxisGenerator');

var _gridAxisGenerator2 = _interopRequireDefault(_gridAxisGenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper to create a grid layer
 *
 * [example usage](./examples/layer-axis.html)
 */
var GridAxisLayer = function (_AxisLayer) {
  (0, _inherits3.default)(GridAxisLayer, _AxisLayer);

  /**
   * @param {Object} options - An object to configure the layer.
   */
  function GridAxisLayer(options) {
    (0, _classCallCheck3.default)(this, GridAxisLayer);

    options = (0, _assign2.default)({
      color: 'steelblue',
      bpm: 60,
      signature: '4/4'
    }, options);

    var _this = (0, _possibleConstructorReturn3.default)(this, (GridAxisLayer.__proto__ || (0, _getPrototypeOf2.default)(GridAxisLayer)).call(this, (0, _gridAxisGenerator2.default)(options.bpm, options.signature), options));

    _this.configureShape(_Ticks2.default, {}, {
      color: options.color
    });
    return _this;
  }

  return GridAxisLayer;
}(_AxisLayer3.default);

exports.default = GridAxisLayer;

},{"../axis/AxisLayer":386,"../axis/gridAxisGenerator":387,"../shapes/Ticks":422,"babel-runtime/core-js/object/assign":441,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],405:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Layer2 = require('../core/Layer');

var _Layer3 = _interopRequireDefault(_Layer2);

var _Marker = require('../shapes/Marker');

var _Marker2 = _interopRequireDefault(_Marker);

var _MarkerBehavior = require('../behaviors/MarkerBehavior');

var _MarkerBehavior2 = _interopRequireDefault(_MarkerBehavior);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper to create a marker layer.
 *
 * [example usage](./examples/layer-breakpoint.html)
 */
var MarkerLayer = function (_Layer) {
  (0, _inherits3.default)(MarkerLayer, _Layer);

  /**
   * @param {Array} data - The data to render.
   * @param {Object} options - An object to configure the layer.
   * @param {Object} accessors - The accessors to configure the mapping
   *    between shapes and data.
   */
  function MarkerLayer(data) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var accessors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck3.default)(this, MarkerLayer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (MarkerLayer.__proto__ || (0, _getPrototypeOf2.default)(MarkerLayer)).call(this, 'collection', data, options));

    options = (0, _assign2.default)({
      displayHandlers: true,
      displayLabels: false
    }, options);

    var color = options.color;

    if (color) accessors.color = function () {
      return color;
    };

    _this.configureShape(_Marker2.default, accessors, {
      displayHandlers: options.displayHandlers,
      opacity: options.opacity
    });

    _this.setBehavior(new _MarkerBehavior2.default());
    return _this;
  }

  return MarkerLayer;
}(_Layer3.default);

exports.default = MarkerLayer;

},{"../behaviors/MarkerBehavior":391,"../core/Layer":395,"../shapes/Marker":420,"babel-runtime/core-js/object/assign":441,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],406:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Layer2 = require('../core/Layer');

var _Layer3 = _interopRequireDefault(_Layer2);

var _Segment = require('../shapes/Segment');

var _Segment2 = _interopRequireDefault(_Segment);

var _SegmentBehavior = require('../behaviors/SegmentBehavior');

var _SegmentBehavior2 = _interopRequireDefault(_SegmentBehavior);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper to create a segment layer.
 *
 * [example usage](./examples/layer-segment.html)
 */
var SegmentLayer = function (_Layer) {
  (0, _inherits3.default)(SegmentLayer, _Layer);

  /**
   * @param {Array} data - The data to render.
   * @param {Object} options - An object to configure the layer.
   * @param {Object} accessors - The accessors to configure the mapping
   *    between shapes and data.
   */
  function SegmentLayer(data) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var accessors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck3.default)(this, SegmentLayer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SegmentLayer.__proto__ || (0, _getPrototypeOf2.default)(SegmentLayer)).call(this, 'collection', data, options));

    options = (0, _assign2.default)({
      displayHandlers: true,
      opacity: 0.6
    }, options);

    _this.configureShape(_Segment2.default, accessors, {
      displayHandlers: options.displayHandlers,
      opacity: options.opacity
    });

    _this.setBehavior(new _SegmentBehavior2.default());
    return _this;
  }

  return SegmentLayer;
}(_Layer3.default);

exports.default = SegmentLayer;

},{"../behaviors/SegmentBehavior":392,"../core/Layer":395,"../shapes/Segment":421,"babel-runtime/core-js/object/assign":441,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],407:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Layer2 = require('../core/Layer');

var _Layer3 = _interopRequireDefault(_Layer2);

var _Ticks = require('../shapes/Ticks');

var _Ticks2 = _interopRequireDefault(_Ticks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper to create a tick layer. Can be seen as a grid axis with user defined data
 * or as a marker layer with entity based data.
 */
var TickLayer = function (_Layer) {
  (0, _inherits3.default)(TickLayer, _Layer);

  /**
   * @param {Array} data - The data to render.
   * @param {Object} options - An object to configure the layer.
   * @param {Object} accessors - The accessors to configure the mapping
   *    between shapes and data.
   */
  function TickLayer(data, options, accessors) {
    (0, _classCallCheck3.default)(this, TickLayer);

    options = (0, _assign2.default)({}, options);

    var _this = (0, _possibleConstructorReturn3.default)(this, (TickLayer.__proto__ || (0, _getPrototypeOf2.default)(TickLayer)).call(this, 'entity', data, options));

    var config = options.color ? { color: options.color } : undefined;
    _this.configureShape(_Ticks2.default, accessors, config);
    return _this;
  }

  return TickLayer;
}(_Layer3.default);

exports.default = TickLayer;

},{"../core/Layer":395,"../shapes/Ticks":422,"babel-runtime/core-js/object/assign":441,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],408:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _AxisLayer2 = require('../axis/AxisLayer');

var _AxisLayer3 = _interopRequireDefault(_AxisLayer2);

var _Ticks = require('../shapes/Ticks');

var _Ticks2 = _interopRequireDefault(_Ticks);

var _timeAxisGenerator = require('../axis/timeAxisGenerator');

var _timeAxisGenerator2 = _interopRequireDefault(_timeAxisGenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper to create a time axis layer
 *
 * [example usage](./examples/layer-axis.html)
 */
var TimeAxisLayer = function (_AxisLayer) {
  (0, _inherits3.default)(TimeAxisLayer, _AxisLayer);

  /**
   * @param {Object} options - An object to configure the layer.
   */
  function TimeAxisLayer(options) {
    (0, _classCallCheck3.default)(this, TimeAxisLayer);

    options = (0, _assign2.default)({ color: 'steelblue' }, options);

    var _this = (0, _possibleConstructorReturn3.default)(this, (TimeAxisLayer.__proto__ || (0, _getPrototypeOf2.default)(TimeAxisLayer)).call(this, (0, _timeAxisGenerator2.default)(), options));

    _this.configureShape(_Ticks2.default, {}, {
      color: options.color
    });
    return _this;
  }

  return TimeAxisLayer;
}(_AxisLayer3.default);

exports.default = TimeAxisLayer;

},{"../axis/AxisLayer":386,"../axis/timeAxisGenerator":388,"../shapes/Ticks":422,"babel-runtime/core-js/object/assign":441,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],409:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Layer2 = require('../core/Layer');

var _Layer3 = _interopRequireDefault(_Layer2);

var _TracePath = require('../shapes/TracePath');

var _TracePath2 = _interopRequireDefault(_TracePath);

var _TraceDots = require('../shapes/TraceDots');

var _TraceDots2 = _interopRequireDefault(_TraceDots);

var _TraceBehavior = require('../behaviors/TraceBehavior');

var _TraceBehavior2 = _interopRequireDefault(_TraceBehavior);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helper to create a trace layer.
 *
 * [example usage](./examples/layer-trace.html)
 */
var TraceLayer = function (_Layer) {
  (0, _inherits3.default)(TraceLayer, _Layer);

  /**
   * @param {Array} data - The data to render.
   * @param {Object} options - An object to configure the layer.
   * @param {Object} accessors - The accessors to configure the mapping
   *    between shapes and data.
   */
  function TraceLayer(data) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var accessors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck3.default)(this, TraceLayer);

    options = (0, _assign2.default)({ displayDots: true }, options);

    var _this = (0, _possibleConstructorReturn3.default)(this, (TraceLayer.__proto__ || (0, _getPrototypeOf2.default)(TraceLayer)).call(this, options.displayDots ? 'collection' : 'entity', data, options));

    var shapeOptions = {};
    if (options.meanColor !== undefined) {
      shapeOptions.meanColor = options.meanColor;
    }
    if (options.rangeColor !== undefined) {
      shapeOptions.rangeColor = options.rangeColor;
    }
    if (options.displayMean !== undefined) {
      shapeOptions.displayMean = options.displayMean;
    }

    if (options.displayDots) {
      _this.configureCommonShape(_TracePath2.default, accessors, shapeOptions);
      _this.configureShape(_TraceDots2.default, accessors, shapeOptions);
    } else {
      _this.configureShape(_TracePath2.default, accessors, shapeOptions);
    }

    _this.setBehavior(new _TraceBehavior2.default());
    return _this;
  }

  return TraceLayer;
}(_Layer3.default);

exports.default = TraceLayer;

},{"../behaviors/TraceBehavior":394,"../core/Layer":395,"../shapes/TraceDots":423,"../shapes/TracePath":424,"babel-runtime/core-js/object/assign":441,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],410:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _Layer2 = require('../core/Layer');

var _Layer3 = _interopRequireDefault(_Layer2);

var _Waveform = require('../shapes/Waveform');

var _Waveform2 = _interopRequireDefault(_Waveform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaults = {
  yDomain: [-1, 1],
  channel: 0,
  color: 'steelblue',
  renderingStrategy: 'svg'
};

/**
 * Helper to create a waveform layer.
 *
 * [example usage](./examples/layer-waveform.html)
 */

var WaveformLayer = function (_Layer) {
  (0, _inherits3.default)(WaveformLayer, _Layer);

  /**
   * @param {AudioBuffer} buffer - The audio buffer to display.
   * @param {Object} options - An object to configure the layer.
   */
  function WaveformLayer(buffer, options) {
    (0, _classCallCheck3.default)(this, WaveformLayer);

    options = (0, _assign2.default)({}, defaults, options);

    var _this = (0, _possibleConstructorReturn3.default)(this, (WaveformLayer.__proto__ || (0, _getPrototypeOf2.default)(WaveformLayer)).call(this, 'entity', buffer.getChannelData(options.channel), options));

    _this.configureShape(_Waveform2.default, {}, {
      sampleRate: buffer.sampleRate,
      color: options.color,
      renderingStrategy: options.renderingStrategy
    });
    return _this;
  }

  return WaveformLayer;
}(_Layer3.default);

exports.default = WaveformLayer;

},{"../core/Layer":395,"../shapes/Waveform":425,"babel-runtime/core-js/object/assign":441,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],411:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utils = exports.axis = exports.helpers = exports.states = exports.interactions = exports.behaviors = exports.shapes = exports.core = undefined;

var _LayerTimeContext = require('./core/LayerTimeContext');

var _LayerTimeContext2 = _interopRequireDefault(_LayerTimeContext);

var _Layer = require('./core/Layer');

var _Layer2 = _interopRequireDefault(_Layer);

var _namespace = require('./core/namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _TimelineTimeContext = require('./core/TimelineTimeContext');

var _TimelineTimeContext2 = _interopRequireDefault(_TimelineTimeContext);

var _timeline = require('./core/timeline');

var _timeline2 = _interopRequireDefault(_timeline);

var _TrackCollection = require('./core/TrackCollection');

var _TrackCollection2 = _interopRequireDefault(_TrackCollection);

var _Track = require('./core/Track');

var _Track2 = _interopRequireDefault(_Track);

var _BaseShape = require('./shapes/BaseShape');

var _BaseShape2 = _interopRequireDefault(_BaseShape);

var _Cursor = require('./shapes/Cursor');

var _Cursor2 = _interopRequireDefault(_Cursor);

var _Dot = require('./shapes/Dot');

var _Dot2 = _interopRequireDefault(_Dot);

var _Line = require('./shapes/Line');

var _Line2 = _interopRequireDefault(_Line);

var _Marker = require('./shapes/Marker');

var _Marker2 = _interopRequireDefault(_Marker);

var _Segment = require('./shapes/Segment');

var _Segment2 = _interopRequireDefault(_Segment);

var _Ticks = require('./shapes/Ticks');

var _Ticks2 = _interopRequireDefault(_Ticks);

var _TraceDots = require('./shapes/TraceDots');

var _TraceDots2 = _interopRequireDefault(_TraceDots);

var _TracePath = require('./shapes/TracePath');

var _TracePath2 = _interopRequireDefault(_TracePath);

var _Waveform = require('./shapes/Waveform');

var _Waveform2 = _interopRequireDefault(_Waveform);

var _BaseBehavior = require('./behaviors/BaseBehavior');

var _BaseBehavior2 = _interopRequireDefault(_BaseBehavior);

var _BreakpointBehavior = require('./behaviors/BreakpointBehavior');

var _BreakpointBehavior2 = _interopRequireDefault(_BreakpointBehavior);

var _MarkerBehavior = require('./behaviors/MarkerBehavior');

var _MarkerBehavior2 = _interopRequireDefault(_MarkerBehavior);

var _SegmentBehavior = require('./behaviors/SegmentBehavior');

var _SegmentBehavior2 = _interopRequireDefault(_SegmentBehavior);

var _TimeContextBehavior = require('./behaviors/TimeContextBehavior');

var _TimeContextBehavior2 = _interopRequireDefault(_TimeContextBehavior);

var _TraceBehavior = require('./behaviors/TraceBehavior');

var _TraceBehavior2 = _interopRequireDefault(_TraceBehavior);

var _EventSource = require('./interactions/EventSource');

var _EventSource2 = _interopRequireDefault(_EventSource);

var _Keyboard = require('./interactions/Keyboard');

var _Keyboard2 = _interopRequireDefault(_Keyboard);

var _Surface = require('./interactions/Surface');

var _Surface2 = _interopRequireDefault(_Surface);

var _WaveEvent = require('./interactions/WaveEvent');

var _WaveEvent2 = _interopRequireDefault(_WaveEvent);

var _BaseState = require('./states/BaseState');

var _BaseState2 = _interopRequireDefault(_BaseState);

var _BreakpointState = require('./states/BreakpointState');

var _BreakpointState2 = _interopRequireDefault(_BreakpointState);

var _BrushZoomState = require('./states/BrushZoomState');

var _BrushZoomState2 = _interopRequireDefault(_BrushZoomState);

var _CenteredZoomState = require('./states/CenteredZoomState');

var _CenteredZoomState2 = _interopRequireDefault(_CenteredZoomState);

var _ContextEditionState = require('./states/ContextEditionState');

var _ContextEditionState2 = _interopRequireDefault(_ContextEditionState);

var _EditionState = require('./states/EditionState');

var _EditionState2 = _interopRequireDefault(_EditionState);

var _SelectionState = require('./states/SelectionState');

var _SelectionState2 = _interopRequireDefault(_SelectionState);

var _SimpleEditionState = require('./states/SimpleEditionState');

var _SimpleEditionState2 = _interopRequireDefault(_SimpleEditionState);

var _BreakpointLayer = require('./helpers/BreakpointLayer');

var _BreakpointLayer2 = _interopRequireDefault(_BreakpointLayer);

var _CursorLayer = require('./helpers/CursorLayer');

var _CursorLayer2 = _interopRequireDefault(_CursorLayer);

var _GridAxisLayer = require('./helpers/GridAxisLayer');

var _GridAxisLayer2 = _interopRequireDefault(_GridAxisLayer);

var _MarkerLayer = require('./helpers/MarkerLayer');

var _MarkerLayer2 = _interopRequireDefault(_MarkerLayer);

var _SegmentLayer = require('./helpers/SegmentLayer');

var _SegmentLayer2 = _interopRequireDefault(_SegmentLayer);

var _TickLayer = require('./helpers/TickLayer');

var _TickLayer2 = _interopRequireDefault(_TickLayer);

var _TimeAxisLayer = require('./helpers/TimeAxisLayer');

var _TimeAxisLayer2 = _interopRequireDefault(_TimeAxisLayer);

var _TraceLayer = require('./helpers/TraceLayer');

var _TraceLayer2 = _interopRequireDefault(_TraceLayer);

var _WaveformLayer = require('./helpers/WaveformLayer');

var _WaveformLayer2 = _interopRequireDefault(_WaveformLayer);

var _AxisLayer = require('./axis/AxisLayer');

var _AxisLayer2 = _interopRequireDefault(_AxisLayer);

var _gridAxisGenerator = require('./axis/gridAxisGenerator');

var _gridAxisGenerator2 = _interopRequireDefault(_gridAxisGenerator);

var _timeAxisGenerator = require('./axis/timeAxisGenerator');

var _timeAxisGenerator2 = _interopRequireDefault(_timeAxisGenerator);

var _format = require('./utils/format');

var _format2 = _interopRequireDefault(_format);

var _OrthogonalData = require('./utils/OrthogonalData');

var _OrthogonalData2 = _interopRequireDefault(_OrthogonalData);

var _scales = require('./utils/scales');

var _scales2 = _interopRequireDefault(_scales);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// axis
// core
var core = exports.core = {
  LayerTimeContext: _LayerTimeContext2.default, Layer: _Layer2.default, namespace: _namespace2.default,
  TimelineTimeContext: _TimelineTimeContext2.default, Timeline: _timeline2.default, TrackCollection: _TrackCollection2.default, Track: _Track2.default
};

// utils


// helpers


// states


// interactions


// behaviors


// shapes
var shapes = exports.shapes = {
  BaseShape: _BaseShape2.default, Cursor: _Cursor2.default, Dot: _Dot2.default, Line: _Line2.default, Marker: _Marker2.default, Segment: _Segment2.default,
  Ticks: _Ticks2.default, TracePath: _TracePath2.default, TraceDots: _TraceDots2.default, Waveform: _Waveform2.default
};

var behaviors = exports.behaviors = {
  BaseBehavior: _BaseBehavior2.default, BreakpointBehavior: _BreakpointBehavior2.default, MarkerBehavior: _MarkerBehavior2.default, SegmentBehavior: _SegmentBehavior2.default,
  TimeContextBehavior: _TimeContextBehavior2.default, TraceBehavior: _TraceBehavior2.default
};

var interactions = exports.interactions = { EventSource: _EventSource2.default, Keyboard: _Keyboard2.default, Surface: _Surface2.default, WaveEvent: _WaveEvent2.default };

var states = exports.states = {
  BaseState: _BaseState2.default, BreakpointState: _BreakpointState2.default, BrushZoomState: _BrushZoomState2.default, CenteredZoomState: _CenteredZoomState2.default,
  ContextEditionState: _ContextEditionState2.default, EditionState: _EditionState2.default, SelectionState: _SelectionState2.default, SimpleEditionState: _SimpleEditionState2.default
};

var helpers = exports.helpers = {
  BreakpointLayer: _BreakpointLayer2.default, CursorLayer: _CursorLayer2.default, GridAxisLayer: _GridAxisLayer2.default, MarkerLayer: _MarkerLayer2.default, SegmentLayer: _SegmentLayer2.default,
  TickLayer: _TickLayer2.default, TimeAxisLayer: _TimeAxisLayer2.default, TraceLayer: _TraceLayer2.default, WaveformLayer: _WaveformLayer2.default
};

var axis = exports.axis = {
  AxisLayer: _AxisLayer2.default, timeAxisGenerator: _timeAxisGenerator2.default, gridAxisGenerator: _gridAxisGenerator2.default
};

var utils = exports.utils = {
  format: _format2.default, OrthogonalData: _OrthogonalData2.default, scales: _scales2.default
};

},{"./axis/AxisLayer":386,"./axis/gridAxisGenerator":387,"./axis/timeAxisGenerator":388,"./behaviors/BaseBehavior":389,"./behaviors/BreakpointBehavior":390,"./behaviors/MarkerBehavior":391,"./behaviors/SegmentBehavior":392,"./behaviors/TimeContextBehavior":393,"./behaviors/TraceBehavior":394,"./core/Layer":395,"./core/LayerTimeContext":396,"./core/TimelineTimeContext":397,"./core/Track":398,"./core/TrackCollection":399,"./core/namespace":400,"./core/timeline":401,"./helpers/BreakpointLayer":402,"./helpers/CursorLayer":403,"./helpers/GridAxisLayer":404,"./helpers/MarkerLayer":405,"./helpers/SegmentLayer":406,"./helpers/TickLayer":407,"./helpers/TimeAxisLayer":408,"./helpers/TraceLayer":409,"./helpers/WaveformLayer":410,"./interactions/EventSource":412,"./interactions/Keyboard":413,"./interactions/Surface":414,"./interactions/WaveEvent":415,"./shapes/BaseShape":416,"./shapes/Cursor":417,"./shapes/Dot":418,"./shapes/Line":419,"./shapes/Marker":420,"./shapes/Segment":421,"./shapes/Ticks":422,"./shapes/TraceDots":423,"./shapes/TracePath":424,"./shapes/Waveform":425,"./states/BaseState":426,"./states/BreakpointState":427,"./states/BrushZoomState":428,"./states/CenteredZoomState":429,"./states/ContextEditionState":430,"./states/EditionState":431,"./states/SelectionState":432,"./states/SimpleEditionState":433,"./utils/OrthogonalData":434,"./utils/format":435,"./utils/scales":436}],412:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Abstract class to extend to create new sources of interactions.
 * A `Surface` and `Keyboard` event sources are provided.
 */
var EventSource = function (_EventEmitter) {
  (0, _inherits3.default)(EventSource, _EventEmitter);

  function EventSource($el) {
    (0, _classCallCheck3.default)(this, EventSource);

    /**
     * The element on which the listener is added
     * @type {Element}
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (EventSource.__proto__ || (0, _getPrototypeOf2.default)(EventSource)).call(this));

    _this.$el = $el;
    return _this;
  }

  (0, _createClass3.default)(EventSource, [{
    key: 'destroy',
    value: function destroy() {
      this.unbindEvents();
    }
  }, {
    key: 'createEvent',
    value: function createEvent(type, e) {}
  }, {
    key: 'bindEvents',
    value: function bindEvents() {}
  }, {
    key: 'unbindEvents',
    value: function unbindEvents() {}
  }]);
  return EventSource;
}(_events.EventEmitter);

exports.default = EventSource;

},{"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455,"events":164}],413:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _EventSource2 = require('./EventSource');

var _EventSource3 = _interopRequireDefault(_EventSource2);

var _WaveEvent = require('./WaveEvent');

var _WaveEvent2 = _interopRequireDefault(_WaveEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A global event sourve for the keyboard. Only one instance of this source
 * can be created. The first created timeline instanciate the singleton, each
 * subsequent instanciation returns the first created instance.
 */
var Keyboard = function (_EventSource) {
  (0, _inherits3.default)(Keyboard, _EventSource);

  /**
   * @param {Element} $el - The element on which to install the listener.
   */
  function Keyboard($el) {
    (0, _classCallCheck3.default)(this, Keyboard);

    /**
     * The name of the source
     * @type {String}
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (Keyboard.__proto__ || (0, _getPrototypeOf2.default)(Keyboard)).call(this, $el));

    _this.sourceName = 'keyboard';

    _this._onKeyDown = _this._onKeyDown.bind(_this);
    _this._onKeyUp = _this._onKeyUp.bind(_this);

    _this.bindEvents();
    return _this;
  }

  (0, _createClass3.default)(Keyboard, [{
    key: 'createEvent',
    value: function createEvent(type, e) {
      var event = new _WaveEvent2.default(this.sourceName, type, e);

      event.shiftKey = e.shiftKey;
      event.ctrlKey = e.ctrlKey;
      event.altKey = e.altKey;
      event.metaKey = e.metaKey;
      event.which = e.which;
      event.char = String.fromCharCode(e.which);

      return event;
    }
  }, {
    key: 'bindEvents',
    value: function bindEvents() {
      this.$el.addEventListener('keydown', this._onKeyDown, false);
      this.$el.addEventListener('keyup', this._onKeyUp, false);
    }
  }, {
    key: 'unbindEvents',
    value: function unbindEvents() {
      this.$el.removeEventListener('keydown', this._onKeyDown, false);
      this.$el.removeEventListener('keyup', this._onKeyUp, false);
    }
  }, {
    key: '_onKeyDown',
    value: function _onKeyDown(e) {
      var event = this.createEvent('keydown', e);
      this.emit('event', event);
    }
  }, {
    key: '_onKeyUp',
    value: function _onKeyUp(e) {
      var event = this.createEvent('keyup', e);
      this.emit('event', event);
    }
  }]);
  return Keyboard;
}(_EventSource3.default);

exports.default = Keyboard;

},{"./EventSource":412,"./WaveEvent":415,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],414:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _EventSource2 = require('./EventSource');

var _EventSource3 = _interopRequireDefault(_EventSource2);

var _WaveEvent = require('./WaveEvent');

var _WaveEvent2 = _interopRequireDefault(_WaveEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Normalizes mouse user interactions with the timeline upon the DOM
 * container element of `Track` instances. As soon as a `track` is added to a
 * `timeline`, its attached `Surface` instance will emit the mouse events.
 */
var Surface = function (_EventSource) {
  (0, _inherits3.default)(Surface, _EventSource);

  /**
   * @param {DOMElement} el - The DOM element to listen.
   * @todo - Add some padding to the surface.
   */
  function Surface($el) {
    (0, _classCallCheck3.default)(this, Surface);

    /**
     * The name of the event source.
     * @type {String}
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (Surface.__proto__ || (0, _getPrototypeOf2.default)(Surface)).call(this, $el));

    _this.sourceName = 'surface';
    _this._mouseDownEvent = null;
    _this._lastEvent = null;

    _this._onMouseDown = _this._onMouseDown.bind(_this);
    _this._onMouseMove = _this._onMouseMove.bind(_this);
    _this._onMouseUp = _this._onMouseUp.bind(_this);
    _this._onClick = _this._onClick.bind(_this);
    _this._onDblClick = _this._onDblClick.bind(_this);
    _this._onMouseOver = _this._onMouseOver.bind(_this);
    _this._onMouseOut = _this._onMouseOut.bind(_this);

    _this.bindEvents();
    return _this;
  }

  /**
   * Factory method for `Event` class
   */


  (0, _createClass3.default)(Surface, [{
    key: 'createEvent',
    value: function createEvent(type, e) {
      var event = new _WaveEvent2.default(this.sourceName, type, e);

      var pos = this._getRelativePosition(e);
      event.x = pos.x;
      event.y = pos.y;

      return event;
    }

    /**
     * Keep this private to avoid double event binding. Main logic of the surface
     * is here. Should be extended with needed events (mouseenter, mouseleave,
     * wheel ...).
     *
     * @todo - throttle
     * @private
     */

  }, {
    key: 'bindEvents',
    value: function bindEvents() {
      // Bind callbacks
      this.$el.addEventListener('mousedown', this._onMouseDown, false);
      this.$el.addEventListener('click', this._onClick, false);
      this.$el.addEventListener('dblclick', this._onDblClick, false);
      this.$el.addEventListener('mouseover', this._onMouseOver, false);
      this.$el.addEventListener('mouseout', this._onMouseOut, false);
    }
  }, {
    key: 'unbindEvents',
    value: function unbindEvents() {
      // Bind callbacks
      this.$el.removeEventListener('mousedown', this._onMouseDown, false);
      this.$el.removeEventListener('click', this._onClick, false);
      this.$el.removeEventListener('dblclick', this._onDblClick, false);
      this.$el.removeEventListener('mouseover', this._onMouseOver, false);
      this.$el.removeEventListener('mouseout', this._onMouseOut, false);

      window.removeEventListener('mousemove', this._onMouseMove);
      window.removeEventListener('mouseup', this._onMouseUp);
    }

    /**
     * Returns the x, y coordinates coordinates relative to the surface element.
     *
     * @param {Event} e - Raw event from listener.
     * @return {Object}
     * @todo - handle padding.
     */

  }, {
    key: '_getRelativePosition',
    value: function _getRelativePosition(e) {
      // @TODO: should be able to ignore padding
      var x = 0;
      var y = 0;
      var clientRect = this.$el.getBoundingClientRect();
      var scrollLeft = document.body.scrollLeft + document.documentElement.scrollLeft;
      var scrollTop = document.body.scrollTop + document.documentElement.scrollTop;

      // Adapted from http://www.quirksmode.org/js/events_properties.html#position
      if (e.pageX || e.pageY) {
        x = e.pageX;
        y = e.pageY;
      } else if (e.clientX || e.clientY) {
        // Normalize to pageX, pageY
        x = e.clientX + scrollLeft;
        y = e.clientY + scrollTop;
      }

      // clientRect refers to the client, not to the page
      x = x - (clientRect.left + scrollLeft);
      y = y - (clientRect.top + scrollTop);

      return { x: x, y: y };
    }
  }, {
    key: '_defineArea',
    value: function _defineArea(e, mouseDownEvent, lastEvent) {
      if (!mouseDownEvent || !lastEvent) {
        return;
      }
      e.dx = e.x - lastEvent.x;
      e.dy = e.y - lastEvent.y;

      var left = mouseDownEvent.x < e.x ? mouseDownEvent.x : e.x;
      var top = mouseDownEvent.y < e.y ? mouseDownEvent.y : e.y;
      var width = Math.abs(Math.round(e.x - mouseDownEvent.x));
      var height = Math.abs(Math.round(e.y - mouseDownEvent.y));

      e.area = { left: left, top: top, width: width, height: height };
    }
  }, {
    key: '_onMouseDown',
    value: function _onMouseDown(e) {
      // by removing the previous selection we prevent bypassing the mousemove events coming from SVG in Firefox.
      window.getSelection().removeAllRanges();
      var event = this.createEvent('mousedown', e);

      this._mouseDownEvent = event;
      this._lastEvent = event;
      // Register mousemove and mouseup listeners on window
      window.addEventListener('mousemove', this._onMouseMove, false);
      window.addEventListener('mouseup', this._onMouseUp, false);

      this.emit('event', event);
    }
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(e) {
      var event = this.createEvent('mousemove', e);
      this._defineArea(event, this._mouseDownEvent, this._lastEvent);
      // Update `lastEvent` for next call
      this._lastEvent = event;

      this.emit('event', event);
    }
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp(e) {
      var event = this.createEvent('mouseup', e);
      this._defineArea(event, this._mouseDownEvent, this._lastEvent);

      this._mouseDownEvent = null;
      this._lastEvent = null;
      // Remove mousemove and mouseup listeners on window
      window.removeEventListener('mousemove', this._onMouseMove);
      window.removeEventListener('mouseup', this._onMouseUp);

      this.emit('event', event);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      var event = this.createEvent('click', e);
      this.emit('event', event);
    }
  }, {
    key: '_onDblClick',
    value: function _onDblClick(e) {
      var event = this.createEvent('dblclick', e);
      this.emit('event', event);
    }
  }, {
    key: '_onMouseOver',
    value: function _onMouseOver(e) {
      var event = this.createEvent('mouseover', e);
      this.emit('event', event);
    }
  }, {
    key: '_onMouseOut',
    value: function _onMouseOut(e) {
      var event = this.createEvent('mouseout', e);
      this.emit('event', event);
    }
  }]);
  return Surface;
}(_EventSource3.default);

exports.default = Surface;

},{"./EventSource":412,"./WaveEvent":415,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],415:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Object template for all events. Event sources should use this event template
 * in order to keep consistency with existing sources.
 */
var WaveEvent =
/**
 * @param {String} source - The name of the source (`keyboard`, `surface`, ...).
 * @param {String} type - The type of the source (`mousedown`, `keyup`, ...).
 * @param {Event} originalEvent - The original event as emitted by the browser.
 */
function WaveEvent(source, type, originalEvent) {
  (0, _classCallCheck3.default)(this, WaveEvent);

  this.source = source;
  this.type = type;
  this.originalEvent = originalEvent;

  this.target = originalEvent.target;
  this.currentTarget = originalEvent.currentTarget;
};

exports.default = WaveEvent;

},{"babel-runtime/helpers/classCallCheck":451}],416:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _namespace = require('../core/namespace');

var _namespace2 = _interopRequireDefault(_namespace);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Is an abstract class or interface to be overriden in order to define new
 * shapes. Shapes define the way a given datum should be rendered, they are
 * the smallest unit of rendering into a timeline.
 *
 * All the life cycle of `Shape` instances is handled into the `Layer` instance
 * they are attach to. As a consequence, they should be mainly considered as
 * private objects. The only place they should be interacted with is in `Behavior`
 * definitions, to test which element of the shape is the target of the
 * interaction and define the interaction according to that test.
 *
 * Depending of its implementation a `Shape` can be used along with `entity` or
 * `collection` data type. Some shapes are then created to use data considered
 * as a single entity (Waveform, TracePath, Line), while others are defined to
 * be used with data seen as a collection, each shape rendering a single entry
 * of the collection. The shapes working with entity type data should therefore
 * be used in an `entity` configured `Layer`. Note that if they are registered
 * as "commonShape" in a `collection` type `Layer`, they will behave the exact
 * same way. These kind of shapes are noted: "entity shape".
 *
 * ### Available `collection` shapes:
 * - Marker / Annotated Marker
 * - Segment / Annotated Segment
 * - Dot
 * - TraceDots
 *
 * ### Available `entity` shapes:
 * - Line
 * - Tick (for axis)
 * - Waveform
 * - TracePath
 */
var BaseShape = function () {
  /**
   * @param {Object} options - override default configuration
   */
  function BaseShape() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, BaseShape);

    /** @type {Element} - Svg element to be returned by the `render` method. */
    this.$el = null;
    /** @type {String} - Svg namespace. */
    this.ns = _namespace2.default;
    /** @type {Object} - Object containing the global parameters of the shape */
    this.params = (0, _assign2.default)({}, this._getDefaults(), options);
    // create accessors methods and set default accessor functions
    var accessors = this._getAccessorList();
    this._createAccessors(accessors);
    this._setDefaultAccessors(accessors);
  }

  /**
   * Destroy the shape and clean references. Interface method called from the `layer`.
   */


  (0, _createClass3.default)(BaseShape, [{
    key: 'destroy',
    value: function destroy() {
      // this.group = null;
      this.$el = null;
    }

    /**
     * Interface method to override when extending this base class. The method
     * is called by the `Layer~render` method. Returns the name of the shape,
     * used as a class in the element group (defaults to `'shape'`).
     *
     * @return {String}
     */

  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'shape';
    }

    /**
     * @todo not implemented
     * allow to install defs in the track svg element. Should be called when
     * adding the `Layer` to the `Track`.
     */
    // setSvgDefinition(defs) {}

    /**
     * Returns the defaults for global configuration of the shape.
     * @protected
     * @return {Object}
     */

  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {};
    }

    /**
     * Returns an object where keys are the accessors methods names to create
     * and values are the default values for each given accessor.
     *
     * @protected
     * @todo rename ?
     * @return {Object}
     */

  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return {};
    }

    /**
     * Interface method called by Layer when creating a shape. Install the
     * given accessors on the shape, overriding the default accessors.
     *
     * @param {Object<String, function>} accessors
     */

  }, {
    key: 'install',
    value: function install(accessors) {
      for (var key in accessors) {
        this[key] = accessors[key];
      }
    }

    /**
     * Generic method to create accessors. Adds getters en setters to the
     * prototype if not already present.
     */

  }, {
    key: '_createAccessors',
    value: function _createAccessors(accessors) {
      this._accessors = {};
      // add it to the prototype
      var proto = (0, _getPrototypeOf2.default)(this);
      // create a getter / setter for each accessors
      // setter : `this.x = callback`
      // getter : `this.x(datum)`
      (0, _keys2.default)(accessors).forEach(function (name) {
        if (proto.hasOwnProperty(name)) {
          return;
        }

        (0, _defineProperty2.default)(proto, name, {
          get: function get() {
            return this._accessors[name];
          },
          set: function set(func) {
            this._accessors[name] = func;
          }
        });
      });
    }

    /**
     * Create a function to be used as a default accessor for each accesors
     */

  }, {
    key: '_setDefaultAccessors',
    value: function _setDefaultAccessors(accessors) {
      var _this = this;

      (0, _keys2.default)(accessors).forEach(function (name) {
        var defaultValue = accessors[name];
        var accessor = function accessor(d) {
          var v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (v === null) {
            return d[name] || defaultValue;
          }
          d[name] = v;
        };
        // set accessor as the default one
        _this[name] = accessor;
      });
    }

    /**
     * Interface method called by `Layer~render`. Creates the DOM structure of
     * the shape.
     *
     * @param {Object} renderingContext - the renderingContext of the layer
     *    which owns this shape.
     * @return {Element} - the DOM element to insert in the item's group.
     */

  }, {
    key: 'render',
    value: function render(renderingContext) {}

    /**
     * Interface method called by `Layer~update`. Updates the DOM structure of the shape.
     *
     * @param {Object} renderingContext - The `renderingContext` of the layer
     *    which owns this shape.
     * @param {Object|Array} datum - The datum associated to the shape.
     */

  }, {
    key: 'update',
    value: function update(renderingContext, datum) {}

    /**
     * Interface method to override called by `Layer~getItemsInArea`. Defines if
     * the shape is considered to be the given area. Arguments are passed in pixel domain.
     *
     * @param {Object} renderingContext - the renderingContext of the layer which
     *    owns this shape.
     * @param {Object|Array} datum - The datum associated to the shape.
     * @param {Number} x1 - The x component of the top-left corner of the area to test.
     * @param {Number} y1 - The y component of the top-left corner of the area to test.
     * @param {Number} x2 - The x component of the bottom-right corner of the area to test.
     * @param {Number} y2 - The y component of the bottom-right corner of the area to test.
     * @return {Boolean} - Returns `true` if the is considered to be in the given area, `false` otherwise.
     */

  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {}
  }]);
  return BaseShape;
}();

exports.default = BaseShape;

},{"../core/namespace":400,"babel-runtime/core-js/object/assign":441,"babel-runtime/core-js/object/define-property":443,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/core-js/object/keys":446,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452}],417:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseShape2 = require('./BaseShape');

var _BaseShape3 = _interopRequireDefault(_BaseShape2);

var _namespace = require('../core/namespace');

var _namespace2 = _interopRequireDefault(_namespace);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A shape to display a cursor.
 *
 * [example usage](./examples/layer-cursor.html)
 */
var Cursor = function (_BaseShape) {
  (0, _inherits3.default)(Cursor, _BaseShape);

  function Cursor() {
    (0, _classCallCheck3.default)(this, Cursor);
    return (0, _possibleConstructorReturn3.default)(this, (Cursor.__proto__ || (0, _getPrototypeOf2.default)(Cursor)).apply(this, arguments));
  }

  (0, _createClass3.default)(Cursor, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'cursor';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        color: '#000000',
        opacity: 1
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      this.$el = document.createElementNS(_namespace2.default, 'line');
      this.$el.setAttributeNS(null, 'x', 0);
      this.$el.setAttributeNS(null, 'y1', 0);
      this.$el.setAttributeNS(null, 'shape-rendering', 'crispEdges');
      this.$el.style.stroke = this.params.color;

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var floatX = renderingContext.timeToPixel(this.x(datum));
      var x = Math.round(floatX);

      this.$el.setAttributeNS(null, 'transform', 'translate(' + x + ', 0)');
      this.$el.setAttributeNS(null, 'y2', renderingContext.height);
    }

    /**
     * The cursor cannot be selected.
     * @return {Boolean} false
     */

  }, {
    key: 'inArea',
    value: function inArea() {
      return false;
    }
  }]);
  return Cursor;
}(_BaseShape3.default);

exports.default = Cursor;

},{"../core/namespace":400,"./BaseShape":416,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],418:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseShape2 = require('./BaseShape');

var _BaseShape3 = _interopRequireDefault(_BaseShape2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A shape to display a dot.
 *
 * [example usage](./examples/layer-breakpoint.html)
 */
var Dot = function (_BaseShape) {
  (0, _inherits3.default)(Dot, _BaseShape);

  function Dot() {
    (0, _classCallCheck3.default)(this, Dot);
    return (0, _possibleConstructorReturn3.default)(this, (Dot.__proto__ || (0, _getPrototypeOf2.default)(Dot)).apply(this, arguments));
  }

  (0, _createClass3.default)(Dot, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'dot';
    }

    // @TODO rename : confusion between accessors and meta-accessors

  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { cx: 0, cy: 0, r: 3, color: '#000000' };
    }
  }, {
    key: 'render',
    value: function render() {
      if (this.$el) {
        return this.$el;
      }

      this.$el = document.createElementNS(this.ns, 'circle');

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var cx = renderingContext.timeToPixel(this.cx(datum));
      var cy = renderingContext.valueToPixel(this.cy(datum));
      var r = this.r(datum);
      var color = this.color(datum);

      this.$el.setAttributeNS(null, 'transform', 'translate(' + cx + ', ' + cy + ')');
      this.$el.setAttributeNS(null, 'r', r);
      this.$el.style.fill = color;
    }

    // x1, x2, y1, y2 => in pixel domain

  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
      var cx = renderingContext.timeToPixel(this.cx(datum));
      var cy = renderingContext.valueToPixel(this.cy(datum));

      if (cx > x1 && cx < x2 && cy > y1 && cy < y2) {
        return true;
      }

      return false;
    }
  }]);
  return Dot;
}(_BaseShape3.default);

exports.default = Dot;

},{"./BaseShape":416,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],419:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseShape2 = require('./BaseShape');

var _BaseShape3 = _interopRequireDefault(_BaseShape2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A shape to display a line. Its main use is as common shape to create a
 * breakpoint visualization. (entity shape)
 *
 * [example usage](./examples/layer-breakpoint.html)
 */
var Line = function (_BaseShape) {
  (0, _inherits3.default)(Line, _BaseShape);

  function Line() {
    (0, _classCallCheck3.default)(this, Line);
    return (0, _possibleConstructorReturn3.default)(this, (Line.__proto__ || (0, _getPrototypeOf2.default)(Line)).apply(this, arguments));
  }

  (0, _createClass3.default)(Line, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'line';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { cx: 0, cy: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return { color: '#000000' };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = document.createElementNS(this.ns, 'path');
      // this.el.setAttributeNS(null, 'shape-rendering', 'crispEdges');
      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, data) {
      var _this2 = this;

      data = data.slice(0);
      data.sort(function (a, b) {
        return _this2.cx(a) < _this2.cx(b) ? -1 : 1;
      });

      var path = 'M';
      var length = data.length;

      for (var i = 0; i < length; i++) {
        var datum = data[i];
        var x = renderingContext.timeToPixel(this.cx(datum));
        var y = renderingContext.valueToPixel(this.cy(datum)) - 0.5;
        path += x + ',' + y;

        if (i < length - 1) path += 'L';
      }

      this.$el.setAttributeNS(null, 'd', path);
      this.$el.style.stroke = this.params.color;
      this.$el.style.fill = 'none';

      data = null;
    }
  }]);
  return Line;
}(_BaseShape3.default);

exports.default = Line;

},{"./BaseShape":416,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],420:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseShape2 = require('./BaseShape');

var _BaseShape3 = _interopRequireDefault(_BaseShape2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A shape to display a marker.
 *
 * [example usage](./examples/layer-marker.html)
 */
var Marker = function (_BaseShape) {
  (0, _inherits3.default)(Marker, _BaseShape);

  function Marker() {
    (0, _classCallCheck3.default)(this, Marker);
    return (0, _possibleConstructorReturn3.default)(this, (Marker.__proto__ || (0, _getPrototypeOf2.default)(Marker)).apply(this, arguments));
  }

  (0, _createClass3.default)(Marker, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'marker';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0, color: '#ff0000', label: '' };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        handlerWidth: 7,
        handlerHeight: 10,
        displayHandlers: true,
        opacity: 1,
        color: 'red',
        displayLabels: false,
        labelWidth: 60
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) return this.$el;

      var height = renderingContext.height;

      this.$el = document.createElementNS(this.ns, 'g');
      this.$line = document.createElementNS(this.ns, 'line');

      // draw line
      this.$line.setAttributeNS(null, 'x', 0);
      this.$line.setAttributeNS(null, 'y1', 0);
      this.$line.setAttributeNS(null, 'shape-rendering', 'crispEdges');

      this.$el.appendChild(this.$line);

      if (this.params.displayHandlers) {
        this.$handler = document.createElementNS(this.ns, 'rect');

        this.$handler.setAttributeNS(null, 'x', -this.params.handlerWidth / 2);
        this.$handler.setAttributeNS(null, 'width', this.params.handlerWidth);
        this.$handler.setAttributeNS(null, 'height', this.params.handlerHeight);
        this.$handler.setAttributeNS(null, 'shape-rendering', 'crispEdges');

        this.$el.appendChild(this.$handler);
      }

      if (this.params.displayLabels) {
        // prefer html `div` over svg `text` tag because we then use the `contenteditable` property
        this.$foreignObject = document.createElementNS(this.ns, 'foreignObject');

        this.$label = document.createElement('div');
        this.$label.style.display = 'block';
        this.$label.style.width = this.params.labelWidth + 'px';
        this.$label.style.fontSize = '12px';
        this.$label.style.fontFamily = 'arial';
        this.$label.style.userSelect = 'none';
        this.$label.style.outlineWidth = '1px';

        this.$foreignObject.appendChild(this.$label);
        this.$el.appendChild(this.$foreignObject);
      }

      this.$el.style.opacity = this.params.opacity;

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var x = renderingContext.timeToPixel(this.x(datum));
      var color = this.color(datum);
      var height = renderingContext.height;

      this.$el.setAttributeNS(null, 'transform', 'translate(' + x + ', 0)');

      this.$line.setAttributeNS(null, 'y2', height);
      this.$line.style.stroke = color;

      if (this.params.displayHandlers) {
        this.$handler.setAttributeNS(null, 'y', height - this.params.handlerHeight);
        this.$handler.style.fill = color;
      }

      if (this.params.displayLabels) {
        var matrix = 'matrix(1, 0, 0, -1, ' + this.params.handlerWidth + ', ' + (height - 2) + ')';
        this.$foreignObject.setAttributeNS(null, 'transform', matrix);
        this.$label.innerHTML = this.label(datum);
      }
    }
  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
      // handlers only are selectable
      var x = renderingContext.timeToPixel(this.x(datum));
      var shapeX1 = x - (this.params.handlerWidth - 1) / 2;
      var shapeX2 = shapeX1 + this.params.handlerWidth;
      var shapeY1 = renderingContext.height - this.params.handlerHeight;
      var shapeY2 = renderingContext.height;

      var xOverlap = Math.max(0, Math.min(x2, shapeX2) - Math.max(x1, shapeX1));
      var yOverlap = Math.max(0, Math.min(y2, shapeY2) - Math.max(y1, shapeY1));
      var area = xOverlap * yOverlap;

      return area > 0;
    }
  }]);
  return Marker;
}(_BaseShape3.default);

exports.default = Marker;

},{"./BaseShape":416,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],421:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseShape2 = require('./BaseShape');

var _BaseShape3 = _interopRequireDefault(_BaseShape2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A shape to display a segment.
 *
 * [example usage](./examples/layer-segment.html)
 */
var Segment = function (_BaseShape) {
  (0, _inherits3.default)(Segment, _BaseShape);

  function Segment() {
    (0, _classCallCheck3.default)(this, Segment);
    return (0, _possibleConstructorReturn3.default)(this, (Segment.__proto__ || (0, _getPrototypeOf2.default)(Segment)).apply(this, arguments));
  }

  (0, _createClass3.default)(Segment, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'segment';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0, y: 0, width: 0, height: 1, color: '#000000', opacity: 1, label: '' };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        displayHandlers: true,
        handlerWidth: 2,
        handlerOpacity: 0.8,
        opacity: 0.6,
        displayLabels: false
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = document.createElementNS(this.ns, 'g');

      this.$segment = document.createElementNS(this.ns, 'rect');
      this.$segment.classList.add('segment');
      this.$segment.style.opacity = this.params.opacity;
      this.$segment.setAttributeNS(null, 'shape-rendering', 'crispEdges');

      this.$el.appendChild(this.$segment);

      if (this.params.displayHandlers) {
        this.$leftHandler = document.createElementNS(this.ns, 'rect');
        this.$leftHandler.classList.add('left', 'handler');
        this.$leftHandler.setAttributeNS(null, 'width', this.params.handlerWidth);
        this.$leftHandler.setAttributeNS(null, 'shape-rendering', 'crispEdges');
        this.$leftHandler.style.opacity = this.params.handlerOpacity;
        this.$leftHandler.style.cursor = 'ew-resize';

        this.$rightHandler = document.createElementNS(this.ns, 'rect');
        this.$rightHandler.classList.add('right', 'handler');
        this.$rightHandler.setAttributeNS(null, 'width', this.params.handlerWidth);
        this.$rightHandler.setAttributeNS(null, 'shape-rendering', 'crispEdges');
        this.$rightHandler.style.opacity = this.params.handlerOpacity;
        this.$rightHandler.style.cursor = 'ew-resize';

        this.$el.appendChild(this.$leftHandler);
        this.$el.appendChild(this.$rightHandler);
      }

      if (this.params.displayLabels) {
        // prefer html `div` over svg `text` tag because we then use the `contenteditable` property
        this.$foreignObject = document.createElementNS(this.ns, 'foreignObject');

        this.$label = document.createElement('div');
        this.$label.style.display = 'block';
        this.$label.style.width = '50px';
        this.$label.style.fontSize = '12px';
        this.$label.style.fontFamily = 'arial';
        this.$label.style.userSelect = 'none';
        this.$label.style.outlineWidth = '1px';

        this.$foreignObject.appendChild(this.$label);
        this.$el.appendChild(this.$foreignObject);
      }

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var x = renderingContext.timeToPixel(this.x(datum));
      var y = renderingContext.valueToPixel(this.y(datum));

      var width = renderingContext.timeToPixel(this.width(datum));
      var height = renderingContext.valueToPixel(this.height(datum));
      var color = this.color(datum);
      var opacity = this.opacity(datum);

      this.$el.setAttributeNS(null, 'transform', 'translate(' + x + ', ' + y + ')');
      this.$el.style.opacity = opacity;

      this.$segment.setAttributeNS(null, 'width', Math.max(width, 0));
      this.$segment.setAttributeNS(null, 'height', height);
      this.$segment.style.fill = color;

      if (this.params.displayHandlers) {
        // display handlers
        this.$leftHandler.setAttributeNS(null, 'height', height);
        this.$leftHandler.setAttributeNS(null, 'transform', 'translate(0, 0)');
        this.$leftHandler.style.fill = color;

        var rightHandlerTranslate = 'translate(' + (width - this.params.handlerWidth) + ', 0)';
        this.$rightHandler.setAttributeNS(null, 'height', height);
        this.$rightHandler.setAttributeNS(null, 'transform', rightHandlerTranslate);
        this.$rightHandler.style.fill = color;
      }

      if (this.params.displayLabels) {
        var matrix = 'matrix(1, 0, 0, -1, 4, ' + (height - 2) + ')';
        this.$foreignObject.setAttributeNS(null, 'transform', matrix);
        this.$label.innerHTML = this.label(datum);
      }
    }
  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
      var shapeX1 = renderingContext.timeToPixel(this.x(datum));
      var shapeX2 = renderingContext.timeToPixel(this.x(datum) + this.width(datum));
      var shapeY1 = renderingContext.valueToPixel(this.y(datum));
      var shapeY2 = renderingContext.valueToPixel(this.y(datum) + this.height(datum));

      // http://jsfiddle.net/uthyZ/ - check overlaping area
      var xOverlap = Math.max(0, Math.min(x2, shapeX2) - Math.max(x1, shapeX1));
      var yOverlap = Math.max(0, Math.min(y2, shapeY2) - Math.max(y1, shapeY1));
      var area = xOverlap * yOverlap;

      return area > 0;
    }
  }]);
  return Segment;
}(_BaseShape3.default);

exports.default = Segment;

},{"./BaseShape":416,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],422:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseShape2 = require('./BaseShape');

var _BaseShape3 = _interopRequireDefault(_BaseShape2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Kind of Marker for entity oriented data. Usefull to display a grid.
 */
var Ticks = function (_BaseShape) {
  (0, _inherits3.default)(Ticks, _BaseShape);

  function Ticks() {
    (0, _classCallCheck3.default)(this, Ticks);
    return (0, _possibleConstructorReturn3.default)(this, (Ticks.__proto__ || (0, _getPrototypeOf2.default)(Ticks)).apply(this, arguments));
  }

  (0, _createClass3.default)(Ticks, [{
    key: '_getClassName',
    value: function _getClassName() {
      return 'tick';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { time: 0, focused: true, label: '' };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        color: 'steelblue',
        focusedOpacity: 0.8,
        defaultOpacity: 0.3
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      this.$el = document.createElementNS(this.ns, 'g');
      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, data) {
      var _this2 = this;

      while (this.$el.firstChild) {
        this.$el.removeChild(this.$el.firstChild);
      }

      var fragment = document.createDocumentFragment();
      var layerHeight = renderingContext.height; // valueToPixel(1);

      data.forEach(function (datum) {
        var x = renderingContext.timeToPixel(_this2.time(datum));
        var opacity = _this2.focused(datum) ? _this2.params.focusedOpacity : _this2.params.defaultOpacity;

        var height = layerHeight;

        var tick = document.createElementNS(_this2.ns, 'line');
        tick.classList.add('tick');

        tick.setAttributeNS(null, 'x1', 0);
        tick.setAttributeNS(null, 'x2', 0);
        tick.setAttributeNS(null, 'y1', 0);
        tick.setAttributeNS(null, 'y2', height);

        tick.setAttributeNS(null, 'fill', 'none');
        tick.setAttributeNS(null, 'stroke', _this2.params.color);
        tick.setAttributeNS(null, 'shape-rendering', 'crispEdges');
        tick.setAttributeNS(null, 'transform', 'translate(' + x + ', 0)');
        tick.setAttributeNS(null, 'opacity', opacity);

        _this2.$el.appendChild(tick);

        var label = _this2.label(datum);

        if (label) {
          var $label = document.createElementNS(_this2.ns, 'text');
          $label.classList.add('label');
          var $text = document.createTextNode(label);
          $label.appendChild($text);
          $label.setAttributeNS(null, 'transform', 'matrix(1, 0, 0, -1, ' + (x + 2) + ', ' + (height + 2) + ')');
          // firefox problem here
          // $label.setAttributeNS(null, 'alignment-baseline', 'text-before-edge');
          $label.setAttributeNS(null, 'y', '10');

          $label.style.fontSize = '10px';
          $label.style.lineHeight = '10px';
          $label.style.fontFamily = 'monospace';
          $label.style.color = '#676767';
          $label.style.opacity = 0.9;
          $label.style.mozUserSelect = 'none';
          $label.style.webkitUserSelect = 'none';
          $label.style.userSelect = 'none';

          // const bg = document.createElementNS(this.ns, 'rect');
          // bg.setAttributeNS(null, 'width', '100%');
          // bg.setAttributeNS(null, 'height', '100%');
          // bg.setAttributeNS(null, 'fill', '#ffffff');
          // label.appendChild(bg);

          _this2.$el.appendChild($label);
        }
      });

      this.$el.appendChild(fragment);
    }
  }]);
  return Ticks;
}(_BaseShape3.default);

exports.default = Ticks;

},{"./BaseShape":416,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],423:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseShape2 = require('./BaseShape');

var _BaseShape3 = _interopRequireDefault(_BaseShape2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A shape to display dots in a trace visualization (mean / range).
 *
 * [example usage](./examples/layer-trace.html)
 */
var TraceDots = function (_BaseShape) {
  (0, _inherits3.default)(TraceDots, _BaseShape);

  function TraceDots() {
    (0, _classCallCheck3.default)(this, TraceDots);
    return (0, _possibleConstructorReturn3.default)(this, (TraceDots.__proto__ || (0, _getPrototypeOf2.default)(TraceDots)).apply(this, arguments));
  }

  (0, _createClass3.default)(TraceDots, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'trace-dots';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0, mean: 0, range: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        meanRadius: 3,
        rangeRadius: 3,
        meanColor: '#232323',
        rangeColor: 'steelblue'
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }
      // container
      this.$el = document.createElementNS(this.ns, 'g');
      // draw mean dot
      this.$mean = document.createElementNS(this.ns, 'circle');
      this.$mean.setAttributeNS(null, 'r', this.params.meanRadius);
      this.$mean.setAttributeNS(null, 'stroke', this.params.meanColor);
      this.$mean.setAttributeNS(null, 'fill', 'transparent');
      this.$mean.classList.add('mean');
      // range dots (0 => top, 1 => bottom)
      this.$max = document.createElementNS(this.ns, 'circle');
      this.$max.setAttributeNS(null, 'r', this.params.meanRadius);
      this.$max.setAttributeNS(null, 'stroke', this.params.rangeColor);
      this.$max.setAttributeNS(null, 'fill', 'transparent');
      this.$max.classList.add('max');

      this.$min = document.createElementNS(this.ns, 'circle');
      this.$min.setAttributeNS(null, 'r', this.params.meanRadius);
      this.$min.setAttributeNS(null, 'stroke', this.params.rangeColor);
      this.$min.setAttributeNS(null, 'fill', 'transparent');
      this.$min.classList.add('min');

      this.$el.appendChild(this.$mean);
      this.$el.appendChild(this.$max);
      this.$el.appendChild(this.$min);

      return this.$el;
    }

    // @TODO use accessors

  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var mean = this.mean(datum);
      var range = this.range(datum);
      var x = this.x(datum);
      // y positions
      var meanPos = '' + renderingContext.valueToPixel(mean);
      this.$mean.setAttributeNS(null, 'transform', 'translate(0, ' + meanPos + ')');

      var halfRange = range / 2;
      var max = renderingContext.valueToPixel(mean + halfRange);
      var min = renderingContext.valueToPixel(mean - halfRange);
      var xPos = renderingContext.timeToPixel(x);

      this.$max.setAttributeNS(null, 'transform', 'translate(0, ' + max + ')');
      this.$min.setAttributeNS(null, 'transform', 'translate(0, ' + min + ')');
      this.$el.setAttributeNS(null, 'transform', 'translate(' + xPos + ', 0)');
    }
  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
      var x = renderingContext.timeToPixel(this.x(datum));
      var mean = renderingContext.valueToPixel(this.mean(datum));
      var range = renderingContext.valueToPixel(this.range(datum));
      var min = mean - range / 2;
      var max = mean + range / 2;

      if (x > x1 && x < x2 && (min > y1 || max < y2)) {
        return true;
      }

      return false;
    }
  }]);
  return TraceDots;
}(_BaseShape3.default);

exports.default = TraceDots;

},{"./BaseShape":416,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],424:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseShape2 = require('./BaseShape');

var _BaseShape3 = _interopRequireDefault(_BaseShape2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A shape to display paths in a trace visualization (mean / range). (entity shape)
 *
 * [example usage](./examples/layer-trace.html)
 */
var TracePath = function (_BaseShape) {
  (0, _inherits3.default)(TracePath, _BaseShape);

  function TracePath() {
    (0, _classCallCheck3.default)(this, TracePath);
    return (0, _possibleConstructorReturn3.default)(this, (TracePath.__proto__ || (0, _getPrototypeOf2.default)(TracePath)).apply(this, arguments));
  }

  (0, _createClass3.default)(TracePath, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'trace-common';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0, mean: 0, range: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        rangeColor: 'steelblue',
        meanColor: '#232323',
        displayMean: true
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }
      this.$el = document.createElementNS(this.ns, 'g');
      // range path
      this.$range = document.createElementNS(this.ns, 'path');
      this.$el.appendChild(this.$range);

      // mean line
      if (this.params.displayMean) {
        this.$mean = document.createElementNS(this.ns, 'path');
        this.$el.appendChild(this.$mean);
      }

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, data) {
      var _this2 = this;

      // order data by x position
      data = data.slice(0);
      data.sort(function (a, b) {
        return _this2.x(a) < _this2.x(b) ? -1 : 1;
      });

      if (this.params.displayMean) {
        this.$mean.setAttributeNS(null, 'd', this._buildMeanLine(renderingContext, data));
        this.$mean.setAttributeNS(null, 'stroke', this.params.meanColor);
        this.$mean.setAttributeNS(null, 'fill', 'none');
      }

      this.$range.setAttributeNS(null, 'd', this._buildRangeZone(renderingContext, data));
      this.$range.setAttributeNS(null, 'stroke', 'none');
      this.$range.setAttributeNS(null, 'fill', this.params.rangeColor);
      this.$range.setAttributeNS(null, 'opacity', '0.4');

      data = null;
    }
  }, {
    key: '_buildMeanLine',
    value: function _buildMeanLine(renderingContext, data) {
      var _this3 = this;

      var instructions = data.map(function (datum, index) {
        var x = renderingContext.timeToPixel(_this3.x(datum));
        var y = renderingContext.valueToPixel(_this3.mean(datum));
        return x + ',' + y;
      });

      return 'M' + instructions.join('L');
    }
  }, {
    key: '_buildRangeZone',
    value: function _buildRangeZone(renderingContext, data) {
      var length = data.length;
      // const lastIndex = data
      var instructionsStart = '';
      var instructionsEnd = '';

      for (var i = 0; i < length; i++) {
        var datum = data[i];
        var mean = this.mean(datum);
        var halfRange = this.range(datum) / 2;

        var x = renderingContext.timeToPixel(this.x(datum));
        var y0 = renderingContext.valueToPixel(mean + halfRange);
        var y1 = renderingContext.valueToPixel(mean - halfRange);

        var start = x + ',' + y0;
        var end = x + ',' + y1;

        instructionsStart = instructionsStart === '' ? start : instructionsStart + 'L' + start;

        instructionsEnd = instructionsEnd === '' ? end : end + 'L' + instructionsEnd;
      }

      var instructions = 'M' + instructionsStart + 'L' + instructionsEnd + 'Z';
      return instructions;
    }
  }]);
  return TracePath;
}(_BaseShape3.default);

exports.default = TracePath;

},{"./BaseShape":416,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],425:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseShape2 = require('./BaseShape');

var _BaseShape3 = _interopRequireDefault(_BaseShape2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var xhtmlNS = 'http://www.w3.org/1999/xhtml';

/**
 * A shape to display a waveform. (for entity data)
 *
 * [example usage](./examples/layer-waveform.html)
 *
 * @todo - fix problems with canvas strategy.
 */

var Waveform = function (_BaseShape) {
  (0, _inherits3.default)(Waveform, _BaseShape);

  function Waveform() {
    (0, _classCallCheck3.default)(this, Waveform);
    return (0, _possibleConstructorReturn3.default)(this, (Waveform.__proto__ || (0, _getPrototypeOf2.default)(Waveform)).apply(this, arguments));
  }

  (0, _createClass3.default)(Waveform, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'waveform';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      // return { y: 0 };
      return {};
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        sampleRate: 44100,
        color: '#000000',
        opacity: 1
        // renderingStrategy: 'svg' // canvas is bugged (translation, etc...)
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) return this.$el;

      // if (this.params.renderingStrategy === 'svg') {

      this.$el = document.createElementNS(this.ns, 'path');
      this.$el.setAttributeNS(null, 'fill', 'none');
      this.$el.setAttributeNS(null, 'shape-rendering', 'crispEdges');
      this.$el.setAttributeNS(null, 'stroke', this.params.color);
      this.$el.style.opacity = this.params.opacity;

      // } else if (this.params.renderingStrategy === 'canvas') {

      //   this.$el = document.createElementNS(this.ns, 'foreignObject');
      //   this.$el.setAttributeNS(null, 'width', renderingContext.width);
      //   this.$el.setAttributeNS(null, 'height', renderingContext.height);

      //   const canvas = document.createElementNS(xhtmlNS, 'xhtml:canvas');

      //   this._ctx = canvas.getContext('2d');
      //   this._ctx.canvas.width = renderingContext.width;
      //   this._ctx.canvas.height = renderingContext.height;

      //   this.$el.appendChild(canvas);
      // }

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      // define nbr of samples per pixels
      var sliceMethod = datum instanceof Float32Array ? 'subarray' : 'slice';
      var nbrSamples = datum.length;
      var duration = nbrSamples / this.params.sampleRate;
      var width = renderingContext.timeToPixel(duration);
      var samplesPerPixel = nbrSamples / width;

      if (!samplesPerPixel || datum.length < samplesPerPixel) {
        return;
      }

      var minX = renderingContext.minX,
          maxX = renderingContext.maxX;

      // get min/max per pixels, clamped to the visible area

      var invert = renderingContext.timeToPixel.invert;
      var sampleRate = this.params.sampleRate;
      var minMax = [];

      for (var px = minX; px < maxX; px++) {
        var startTime = invert(px);
        var startSample = startTime * sampleRate;
        var extract = datum[sliceMethod](startSample, startSample + samplesPerPixel);

        var min = Infinity;
        var max = -Infinity;

        for (var j = 0, l = extract.length; j < l; j++) {
          var sample = extract[j];
          if (sample < min) min = sample;
          if (sample > max) max = sample;
        }
        // disallow Infinity
        min = !isFinite(min) ? 0 : min;
        max = !isFinite(max) ? 0 : max;

        minMax.push([px, min, max]);
      }

      if (minMax.length) {

        var PIXEL = 0;
        var MIN = 1;
        var MAX = 2;

        // rendering strategies
        // if (this.params.renderingStrategy === 'svg') {

        var d = 'M';

        for (var i = 0, _l = minMax.length; i < _l; i++) {
          var _datum = minMax[i];
          var x = _datum[PIXEL];
          var y1 = Math.round(renderingContext.valueToPixel(_datum[MIN]));
          var y2 = Math.round(renderingContext.valueToPixel(_datum[MAX]));

          d += x + ',' + y1 + 'L' + x + ',' + y2;

          if (i < _l - 1) d += 'L';
        }

        this.$el.setAttributeNS(null, 'd', d);

        // } else if (this.params.renderingStrategy === 'canvas') {

        //   this._ctx.canvas.width = width;
        //   this.$el.setAttribute('width', width);
        //   // fix chrome bug with translate
        //   if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        //     this.$el.setAttribute('x', renderingContext.offsetX);
        //   }

        //   this._ctx.strokeStyle = this.params.color;
        //   this._ctx.globalAlpha = this.params.opacity;
        //   this._ctx.moveTo(renderingContext.timeToPixel(0), renderingContext.valueToPixel(0));

        //   minMax.forEach((datum) => {
        //     const x  = datum[PIXEL];
        //     let y1 = Math.round(renderingContext.valueToPixel(datum[MIN]));
        //     let y2 = Math.round(renderingContext.valueToPixel(datum[MAX]));

        //     this._ctx.moveTo(x, y1);
        //     this._ctx.lineTo(x, y2);
        //   });

        //   this._ctx.stroke();
        // }
      }
    }
  }]);
  return Waveform;
}(_BaseShape3.default);

exports.default = Waveform;

},{"./BaseShape":416,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],426:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `State` instances are used to define the application logic by precising
 * specific user interaction cases, and how they impact the overal temporal
 * representation. The abstractions extending this base class should be
 * considered as the main interface between the visualization and the
 * application logic. All provided states should be seen as simple examples for
 * rapid prototyping,
 *
 * States manage interactions like zooming, browsing, or editing the timeline.
 * Customized states should extend this BaseState.
 */
var BaseState = function () {
  /**
   * Returns timeline tracks collection.
   *
   * @type {TrackCollection}
   */
  function BaseState(timeline) {
    (0, _classCallCheck3.default)(this, BaseState);

    /**
     * A reference to the timeline on which the state should be installed.
     * @type {Timeline}
     */
    this.timeline = timeline;
  }

  /**
   * Returns timeline tracks collection.
   *
   * @type {TrackCollection<Track>}
   */


  (0, _createClass3.default)(BaseState, [{
    key: "enter",


    /**
     * Called when the timeline is entering the state.
     */
    value: function enter() {}

    /**
     * Called when the timeline is leaving the state.
     */

  }, {
    key: "exit",
    value: function exit() {}

    /**
     * Main interface method to override when creating a new `State`. Handle event
     * from mouse or keyboard, should define behavior according to the event
     * (aka. mousedown, mouseup, ...).
     *
     * @param {WaveEvent} e - the event to process.
     * @param {Array} hitLayers - the layers hit by the mouse event (if surface
     * event).
     */

  }, {
    key: "handleEvent",
    value: function handleEvent(e, hitLayers) {}
  }, {
    key: "tracks",
    get: function get() {
      return this.timeline.tracks;
    }

    /**
     * Returns all registered layers.
     *
     * @type {Array<Layer>}
     */

  }, {
    key: "layers",
    get: function get() {
      return this.timeline.tracks.layers;
    }
  }]);
  return BaseState;
}();

exports.default = BaseState;

},{"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452}],427:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseState2 = require('./BaseState');

var _BaseState3 = _interopRequireDefault(_BaseState2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A state to interact with a breakpoint function, mimicing Max/MSP's
 * breakpoint function interactions.
 *
 * [example usage](./examples/layer-breakpint.html)
 */
var BreakpointState = function (_BaseState) {
  (0, _inherits3.default)(BreakpointState, _BaseState);

  function BreakpointState(timeline, datumGenerator) {
    (0, _classCallCheck3.default)(this, BreakpointState);

    var _this = (0, _possibleConstructorReturn3.default)(this, (BreakpointState.__proto__ || (0, _getPrototypeOf2.default)(BreakpointState)).call(this, timeline));

    _this.datumGenerator = datumGenerator;
    _this.currentEditedLayer = null;
    _this.currentTarget = null;
    return _this;
  }

  (0, _createClass3.default)(BreakpointState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {}
  }, {
    key: 'handleEvent',
    value: function handleEvent(e, hitLayers) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e, hitLayers);
          break;
        case 'mousemove':
          this.onMouseMove(e, hitLayers);
          break;
        case 'mouseup':
          this.onMouseUp(e, hitLayers);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e, hitLayers) {
      var _this2 = this;

      this.mouseDown = true;
      // keep target consistent with mouse down
      this.currentTarget = e.target;
      var updatedLayer = null;

      var layers = hitLayers;

      layers.forEach(function (layer) {
        layer.unselect();
        var item = layer.getItemFromDOMElement(e.target);

        if (item === null) {
          // create an item
          var time = layer.timeToPixel.invert(e.x) - _this2.timeline.offset;
          var value = layer.valueToPixel.invert(layer.params.height - e.y);
          var datum = _this2.datumGenerator(time, value);

          layer.data.push(datum);
          updatedLayer = layer;
        } else {
          // if shift is pressed, remove the item
          if (e.originalEvent.shiftKey) {
            var data = layer.data;
            var _datum = layer.getDatumFromItem(item);
            data.splice(data.indexOf(_datum), 1);

            updatedLayer = layer;
          } else {
            _this2.currentEditedLayer = layer;
            layer.select(item);
          }
        }
      });

      if (updatedLayer) {
        this.timeline.tracks.render(updatedLayer);
        this.timeline.tracks.update(updatedLayer);
      }
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this3 = this;

      if (!this.mouseDown || !this.currentEditedLayer) {
        return;
      }

      var layer = this.currentEditedLayer;
      var items = layer.selectedItems;
      // the loop should be in layer to match select / unselect API
      items.forEach(function (item) {
        layer.edit(item, e.dx, e.dy, _this3.currentTarget);
      });

      layer.update(items);
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this.currentEditedLayer = null;
      this.mouseDown = false;
    }
  }]);
  return BreakpointState;
}(_BaseState3.default);

exports.default = BreakpointState;

},{"./BaseState":426,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],428:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _namespace = require('../core/namespace');

var _namespace2 = _interopRequireDefault(_namespace);

var _BaseState2 = require('./BaseState');

var _BaseState3 = _interopRequireDefault(_BaseState2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Protools like zoom with zone selection. Press space bar to reset zoom.
 *
 * [example usage](./examples/states-zoom.html)
 *
 * @todo - could also handle `g` and `h` keys to zoom-in, zoom-out.
 */
var BrushZoomState = function (_BaseState) {
  (0, _inherits3.default)(BrushZoomState, _BaseState);

  function BrushZoomState(timeline) {
    (0, _classCallCheck3.default)(this, BrushZoomState);
    return (0, _possibleConstructorReturn3.default)(this, (BrushZoomState.__proto__ || (0, _getPrototypeOf2.default)(BrushZoomState)).call(this, timeline));
  }

  (0, _createClass3.default)(BrushZoomState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
        case 'keydown':
          this.onKeyDown(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      var _this2 = this;

      this.brushes = [];
      this.startX = e.x;
      // create brush in each containers
      this.tracks.forEach(function (track) {
        var interactions = track.$interactions;

        var brush = document.createElementNS(_namespace2.default, 'rect');
        brush.setAttributeNS(null, 'height', track.height);
        brush.setAttributeNS(null, 'y', 0);
        brush.style.fill = '#787878';
        brush.style.opacity = 0.2;

        interactions.appendChild(brush);

        _this2.brushes.push(brush);
      });
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      // update brush
      var width = Math.abs(e.x - this.startX);
      var x = Math.min(e.x, this.startX);

      this.brushes.forEach(function (brush) {
        brush.setAttributeNS(null, 'width', width);
        brush.setAttributeNS(null, 'x', x);
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      // remove brush
      this.brushes.forEach(function (brush) {
        brush.parentNode.removeChild(brush);
      });

      // update timeContext
      var startX = this.startX;
      var endX = e.x;
      // return if no drag
      if (Math.abs(startX - endX) < 1) {
        return;
      }

      var leftX = Math.max(0, Math.min(startX, endX));
      var rightX = Math.max(startX, endX);

      var minTime = this.timeline.timeToPixel.invert(leftX);
      var maxTime = this.timeline.timeToPixel.invert(rightX);

      var deltaDuration = maxTime - minTime;
      var zoom = this.timeline.visibleDuration / deltaDuration;

      this.timeline.offset -= minTime;
      this.timeline.zoom *= zoom;

      this.tracks.update();
    }
  }, {
    key: 'onKeyDown',
    value: function onKeyDown(e) {
      // reset on space bar
      if (e.originalEvent.keyCode === 32) {
        this.timeline.offset = 0;
        this.timeline.zoom = 1;
        this.tracks.update();
      }
    }
  }]);
  return BrushZoomState;
}(_BaseState3.default);

exports.default = BrushZoomState;

},{"../core/namespace":400,"./BaseState":426,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],429:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _scales = require('../utils/scales');

var _scales2 = _interopRequireDefault(_scales);

var _BaseState2 = require('./BaseState');

var _BaseState3 = _interopRequireDefault(_BaseState2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `CenteredZoomState` is a timeline state mimicing the `Live` zoom interaction. It allows the user to browse the timeline by clicking on a track, and then
 * - moving down to zoom in
 * - moving up to zoom out
 * - moving left to move in time, after
 * - moving right to move in time, before
 *
 * [example usage](./examples/states-zoom.html)
 */
var CenteredZoomState = function (_BaseState) {
  (0, _inherits3.default)(CenteredZoomState, _BaseState);

  function CenteredZoomState(timeline) {
    (0, _classCallCheck3.default)(this, CenteredZoomState);

    var _this = (0, _possibleConstructorReturn3.default)(this, (CenteredZoomState.__proto__ || (0, _getPrototypeOf2.default)(CenteredZoomState)).call(this, timeline));

    _this.currentLayer = null;
    // Set max/min zoom
    // maxZoom: 1px per sample
    // minZoom: 10 000 px per 1 hour
    // with a default to 44.1kHz sample rate
    _this.maxZoom = 44100 * 1 / _this.timeline.timeContext.pixelsPerSecond;
    _this.minZoom = 10000 / 3600 / _this.timeline.timeContext.pixelsPerSecond;
    return _this;
  }

  (0, _createClass3.default)(CenteredZoomState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.initialZoom = this.timeline.timeContext.zoom;
      this.initialY = e.y;

      this._pixelToExponent = _scales2.default.linear().domain([0, 100]) // 100px => factor 2
      .range([0, 1]);
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      // prevent annoying text selection when dragging
      e.originalEvent.preventDefault();

      var timeContext = this.timeline.timeContext;
      var lastCenterTime = timeContext.timeToPixel.invert(e.x);
      var exponent = this._pixelToExponent(e.y - this.initialY);
      var targetZoom = this.initialZoom * Math.pow(2, exponent); // -1...1 -> 1/2...2

      timeContext.zoom = Math.min(Math.max(targetZoom, this.minZoom), this.maxZoom);

      var newCenterTime = timeContext.timeToPixel.invert(e.x);
      var delta = newCenterTime - lastCenterTime;

      // Apply new offset to keep it centered to the mouse
      timeContext.offset += delta + timeContext.timeToPixel.invert(e.dx);

      // Other possible experiments with centered-zoom-state
      //
      // Example 1: Prevent timeline.offset to be negative
      // timeContext.offset = Math.min(timeContext.offset, 0);
      //
      // Example 2: Keep in container when zoomed out
      // if (timeContext.stretchRatio < 1) {
      //   const minOffset = timeContext.timeToPixel.invert(0);
      //   const maxOffset = timeContext.timeToPixel.invert(view.width - timeContext.timeToPixel(timeContext.duration));
      //   timeContext.offset = Math.max(timeContext.offset, minOffset);
      //   timeContext.offset = Math.min(timeContext.offset, maxOffset);
      // }

      this.timeline.tracks.update();
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {}
  }]);
  return CenteredZoomState;
}(_BaseState3.default);

exports.default = CenteredZoomState;

},{"../utils/scales":436,"./BaseState":426,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],430:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseState2 = require('./BaseState');

var _BaseState3 = _interopRequireDefault(_BaseState2);

var _TimeContextBehavior = require('../behaviors/TimeContextBehavior');

var _TimeContextBehavior2 = _interopRequireDefault(_TimeContextBehavior);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A state to interact directly with layers time contexts.
 *
 * [example usage, see. advanced usage](./examples/layer-waveform.html)
 */
var ContextEditionState = function (_BaseState) {
  (0, _inherits3.default)(ContextEditionState, _BaseState);

  function ContextEditionState(timeline) {
    (0, _classCallCheck3.default)(this, ContextEditionState);
    return (0, _possibleConstructorReturn3.default)(this, (ContextEditionState.__proto__ || (0, _getPrototypeOf2.default)(ContextEditionState)).call(this, timeline));
  }

  (0, _createClass3.default)(ContextEditionState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.mouseDown = true;
      this.currentTarget = e.target;

      for (var i = 0, l = this.layers.length; i < l; i++) {
        var layer = this.layers[i];
        if (layer.hasElement(e.target)) {
          this.currentLayer = layer;
          break;
        }
      }
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      if (!this.mouseDown || !this.currentLayer) {
        return;
      }

      var layer = this.currentLayer;
      var target = this.currentTarget;

      // in this example the context is stretched when shift is pressed
      if (!e.originalEvent.shiftKey) {
        layer.editContext(e.dx, e.dy, target);
      } else {
        layer.stretchContext(e.dx, e.dy, target);
      }

      this.timeline.tracks.update(layer);
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this.mouseDown = false;
      this.currentTarget = null;
      this.currentLayer = null;
    }
  }]);
  return ContextEditionState;
}(_BaseState3.default);

exports.default = ContextEditionState;

},{"../behaviors/TimeContextBehavior":393,"./BaseState":426,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],431:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseState2 = require('./BaseState');

var _BaseState3 = _interopRequireDefault(_BaseState2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A state to edit shapes in the more general way. Interact only with selected shapes.
 */
var EditionState = function (_BaseState) {
  (0, _inherits3.default)(EditionState, _BaseState);

  function EditionState(timeline) {
    (0, _classCallCheck3.default)(this, EditionState);

    var _this = (0, _possibleConstructorReturn3.default)(this, (EditionState.__proto__ || (0, _getPrototypeOf2.default)(EditionState)).call(this, timeline));

    _this.currentEditedLayer = null;
    _this.currentTarget = null;
    return _this;
  }

  (0, _createClass3.default)(EditionState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {}
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.currentTarget = e.target;
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this2 = this;

      this.layers.forEach(function (layer) {
        var items = layer.selectedItems;

        layer.edit(items, e.dx, e.dy, _this2.currentTarget);
        layer.update(items);
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this.currentEditedLayer = null;
      this.mouseDown = false;
    }
  }]);
  return EditionState;
}(_BaseState3.default);

exports.default = EditionState;

},{"./BaseState":426,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],432:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseState2 = require('./BaseState');

var _BaseState3 = _interopRequireDefault(_BaseState2);

var _namespace = require('../core/namespace');

var _namespace2 = _interopRequireDefault(_namespace);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A state to select shapes.
 */
var SelectionState = function (_BaseState) {
  (0, _inherits3.default)(SelectionState, _BaseState);

  function SelectionState(timeline /*, options = {} */) {
    (0, _classCallCheck3.default)(this, SelectionState);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SelectionState.__proto__ || (0, _getPrototypeOf2.default)(SelectionState)).call(this, timeline /*, options */));

    _this.currentLayer = null;
    // need a cached
    _this.selectedItems = null;
    _this.mouseDown = false;
    _this.shiftKey = false;

    _this._layerSelectedItemsMap = new _map2.default();
    return _this;
  }

  (0, _createClass3.default)(SelectionState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {
      var containers = this.timeline.containers;

      for (var id in containers) {
        this._removeBrush(containers[id]);
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
        case 'click':
          this.onClick(e);
          break;
        case 'keydown':
          this.onKey(e);
          break;
        case 'keyup':
          this.onKey(e);
          break;
      }
    }
  }, {
    key: '_addBrush',
    value: function _addBrush(track) {
      if (track.$brush) {
        return;
      }

      var brush = document.createElementNS(_namespace2.default, 'rect');
      brush.style.fill = '#686868';
      brush.style.opacity = 0.2;

      track.$interactions.appendChild(brush);
      track.$brush = brush;
    }
  }, {
    key: '_removeBrush',
    value: function _removeBrush(track) {
      if (track.$brush === null) {
        return;
      }

      this._resetBrush(track);
      track.$interactions.removeChild(track.$brush);
      delete track.$brush;
    }
  }, {
    key: '_resetBrush',
    value: function _resetBrush(track) {
      var $brush = track.$brush;
      // reset brush element
      $brush.setAttributeNS(null, 'transform', 'translate(0, 0)');
      $brush.setAttributeNS(null, 'width', 0);
      $brush.setAttributeNS(null, 'height', 0);
    }
  }, {
    key: '_updateBrush',
    value: function _updateBrush(e, track) {
      var $brush = track.$brush;
      var translate = 'translate(' + e.area.left + ', ' + e.area.top + ')';

      $brush.setAttributeNS(null, 'transform', translate);
      $brush.setAttributeNS(null, 'width', e.area.width);
      $brush.setAttributeNS(null, 'height', e.area.height);
    }
  }, {
    key: 'onKey',
    value: function onKey(e) {
      this.shiftKey = e.shiftKey;
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      var _this2 = this;

      this._currentTrack = this.timeline.getTrackFromDOMElement(e.target);
      if (!this._currentTrack) {
        return;
      }

      this._addBrush(this._currentTrack);

      // recreate the map
      this._layerSelectedItemsMap = new _map2.default();
      this._currentTrack.layers.forEach(function (layer) {
        _this2._layerSelectedItemsMap.set(layer, layer.selectedItems.slice(0));
      });
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this3 = this;

      this._updateBrush(e, this._currentTrack);

      this._currentTrack.layers.forEach(function (layer) {
        var currentSelection = layer.selectedItems;
        var currentItems = layer.getItemsInArea(e.area);

        // if is not pressed
        if (!e.originalEvent.shiftKey) {
          layer.unselect(currentSelection);
          layer.select(currentItems);
        } else {
          var toSelect = [];
          var toUnselect = [];
          // use the selection from the previous drag
          var previousSelection = _this3._layerSelectedItemsMap.get(layer);
          // toUnselect = toUnselect.concat(previousSelectedItems);

          currentItems.forEach(function (item) {
            if (previousSelection.indexOf(item) === -1) {
              toSelect.push(item);
            } else {
              toUnselect.push(item);
            }
          });

          currentSelection.forEach(function (item) {
            if (currentItems.indexOf(item) === -1 && previousSelection.indexOf(item) === -1) {
              toUnselect.push(item);
            }
          });

          layer.unselect(toUnselect);
          layer.select(toSelect);
        }
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this._removeBrush(this._currentTrack);
    }
  }, {
    key: 'onClick',
    value: function onClick(e) {
      if (!this._currentTrack) {
        return;
      }

      this._currentTrack.layers.forEach(function (layer) {
        var item = layer.getItemFromDOMElement(e.target);

        if (!e.originalEvent.shiftKey) {
          layer.unselect();
        }

        if (item) {
          layer.toggleSelection(item);
        }
      });
    }
  }]);
  return SelectionState;
}(_BaseState3.default);

exports.default = SelectionState;

},{"../core/namespace":400,"./BaseState":426,"babel-runtime/core-js/map":440,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],433:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _BaseState2 = require('./BaseState');

var _BaseState3 = _interopRequireDefault(_BaseState2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A state to select and edit shapes in a simple way. (kind of plug n play state)
 */
var SimpleEditionState = function (_BaseState) {
  (0, _inherits3.default)(SimpleEditionState, _BaseState);

  function SimpleEditionState(timeline) {
    (0, _classCallCheck3.default)(this, SimpleEditionState);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SimpleEditionState.__proto__ || (0, _getPrototypeOf2.default)(SimpleEditionState)).call(this, timeline));

    _this.currentEditedLayer = null;
    _this.currentTarget = null;
    return _this;
  }

  (0, _createClass3.default)(SimpleEditionState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {}
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      var _this2 = this;

      // keep target consistent with mouse down
      this.currentTarget = e.target;

      this.layers.forEach(function (layer) {
        if (!layer.hasElement(_this2.currentTarget)) {
          return;
        }

        if (!e.originalEvent.shiftKey) {
          layer.unselect();
        }

        var item = layer.getItemFromDOMElement(_this2.currentTarget);

        if (item === null) {
          return;
        }

        _this2.currentEditedLayer = layer;
        requestAnimationFrame(function () {
          layer.select(item);
        });
      });
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      if (!this.currentEditedLayer) {
        return;
      }

      var layer = this.currentEditedLayer;
      var items = layer.selectedItems;

      layer.edit(items, e.dx, e.dy, this.currentTarget);
      requestAnimationFrame(function () {
        layer.update(items);
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this.currentEditedLayer = null;
    }
  }]);
  return SimpleEditionState;
}(_BaseState3.default);

exports.default = SimpleEditionState;

},{"./BaseState":426,"babel-runtime/core-js/object/get-prototype-of":445,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452,"babel-runtime/helpers/inherits":454,"babel-runtime/helpers/possibleConstructorReturn":455}],434:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * OrthogonalData transforms an object of arrays `{foo: [1, 2], bar: [3, 4]}`
 * to or from an array of objects `[{foo: 1, bar: 3}, {foo: 2, bar: 4}]`
 */
var OrthogonalData = function () {
  function OrthogonalData() {
    (0, _classCallCheck3.default)(this, OrthogonalData);

    this._cols = null; // Object of arrays
    this._rows = null; // Array of objects
  }

  /**
   * Check the consistency of the data.
   */


  (0, _createClass3.default)(OrthogonalData, [{
    key: "_checkConsistency",
    value: function _checkConsistency() {
      var size = null;

      for (var key in this._cols) {
        var col = this._cols[key];
        var colLength = col.length;

        if (size !== null && size !== colLength) {
          throw new Error(this.prototype.constructor.name + ": inconsistent data");
        } else if (size === null) {
          size = colLength;
        }
      }
    }

    /**
     * Updates array of objects from object of arrays.
     */

  }, {
    key: "updateFromCols",
    value: function updateFromCols() {
      var _this = this;

      var keys = (0, _keys2.default)(this._cols);

      keys.forEach(function (key, i) {
        var col = _this._cols[key];

        col.forEach(function (value, index) {
          if (_this._rows[index] === undefined) _this._rows[index] = {};
          _this._rows[index][key] = value;
        });
      });

      this._checkConsistency();
    }

    /**
     * Updates object of arrays from array of objects.
     */

  }, {
    key: "updateFromRows",
    value: function updateFromRows() {
      var _this2 = this;

      this._rows.forEach(function (obj, index) {
        for (var key in obj) {
          if (index === 0) _this2._cols[key] = [];
          _this2._cols[key].push(obj[key]);
        }
      });

      this._checkConsistency();
    }

    /**
     * Sets an object of arrays.
     *
     * @type {Object<String, Array>}
     */

  }, {
    key: "cols",
    set: function set(obj) {
      this._cols = obj;
      this._rows = [];

      this.updateFromCols();
    }

    /**
     * Returns an object of arrays.
     *
     * @type {Object<String, Array>}
     */
    ,
    get: function get() {
      return this._cols;
    }

    /**
     * Sets an array of objects.
     *
     * @type {Array<Object>}
     */

  }, {
    key: "rows",
    set: function set(arr) {
      this._rows = arr;
      this._cols = {};

      this.updateFromRows();
    }

    /**
     * Returns an array of objects.
     *
     * @type {Array<Object>}
     */
    ,
    get: function get() {
      return this._rows;
    }
  }]);
  return OrthogonalData;
}();

exports.default = OrthogonalData;

},{"babel-runtime/core-js/object/keys":446,"babel-runtime/helpers/classCallCheck":451,"babel-runtime/helpers/createClass":452}],435:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Add `sign` to the left of a given `input` until it matches match `length`
 *
 * @param {String} input - String to format
 * @param {String} sign - Character to add to the left
 * @param {Number} length - Length of the output string
 */
var padLeft = exports.padLeft = function padLeft(input, sign, length) {
  input += ''; // make sure we deal with a string

  while (input.length < length) {
    input = sign + input;
  }return input;
};

},{}],436:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Lightweight scales mimicing the `d3.js` functionnal API.
 */
exports.default = {
  /**
   * A linear scale interpolating values between a `domain` and a `range`.
   * @return {Function}
   */
  linear: function linear() {
    var _domain = [0, 1];
    var _range = [0, 1];

    var _slope = 1;
    var _intercept = 0;

    function _updateCoefs() {
      _slope = (_range[1] - _range[0]) / (_domain[1] - _domain[0]);
      _intercept = _range[0] - _slope * _domain[0];
    }

    function scale(value) {
      return _slope * value + _intercept;
    }

    scale.invert = function (value) {
      return (value - _intercept) / _slope;
    };

    scale.domain = function () {
      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (arr === null) {
        return _domain;
      }

      _domain = arr;
      _updateCoefs();

      return scale;
    };

    scale.range = function () {
      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (arr === null) {
        return _range;
      }

      _range = arr;
      _updateCoefs();

      return scale;
    };

    return scale;
  }
};

},{}],437:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":460}],438:[function(require,module,exports){
arguments[4][175][0].apply(exports,arguments)
},{"core-js/library/fn/get-iterator":461,"dup":175}],439:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/is-iterable"), __esModule: true };
},{"core-js/library/fn/is-iterable":462}],440:[function(require,module,exports){
arguments[4][177][0].apply(exports,arguments)
},{"core-js/library/fn/map":463,"dup":177}],441:[function(require,module,exports){
arguments[4][180][0].apply(exports,arguments)
},{"core-js/library/fn/object/assign":464,"dup":180}],442:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"core-js/library/fn/object/create":465,"dup":48}],443:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"core-js/library/fn/object/define-property":466,"dup":49}],444:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"core-js/library/fn/object/get-own-property-descriptor":467,"dup":50}],445:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"core-js/library/fn/object/get-prototype-of":468,"dup":51}],446:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"core-js/library/fn/object/keys":469,"dup":52}],447:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"core-js/library/fn/object/set-prototype-of":470,"dup":53}],448:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"core-js/library/fn/set":471,"dup":187}],449:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"core-js/library/fn/symbol":472,"dup":55}],450:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"core-js/library/fn/symbol/iterator":473,"dup":56}],451:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"dup":58}],452:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"../core-js/object/define-property":443,"dup":59}],453:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"../core-js/object/get-own-property-descriptor":444,"../core-js/object/get-prototype-of":445,"dup":60}],454:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"../core-js/object/create":442,"../core-js/object/set-prototype-of":447,"../helpers/typeof":458,"dup":61}],455:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"../helpers/typeof":458,"dup":62}],456:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _isIterable2 = require("../core-js/is-iterable");

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = require("../core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
},{"../core-js/get-iterator":438,"../core-js/is-iterable":439}],457:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _from = require("../core-js/array/from");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};
},{"../core-js/array/from":437}],458:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"../core-js/symbol":449,"../core-js/symbol/iterator":450,"dup":63}],459:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"dup":64,"regenerator-runtime":571}],460:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;
},{"../../modules/_core":488,"../../modules/es6.array.from":552,"../../modules/es6.string.iterator":564}],461:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');
},{"../modules/core.get-iterator":550,"../modules/es6.string.iterator":564,"../modules/web.dom.iterable":570}],462:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.is-iterable');
},{"../modules/core.is-iterable":551,"../modules/es6.string.iterator":564,"../modules/web.dom.iterable":570}],463:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
module.exports = require('../modules/_core').Map;
},{"../modules/_core":488,"../modules/es6.map":554,"../modules/es6.object.to-string":562,"../modules/es6.string.iterator":564,"../modules/es7.map.to-json":566,"../modules/web.dom.iterable":570}],464:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;
},{"../../modules/_core":488,"../../modules/es6.object.assign":555}],465:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};
},{"../../modules/_core":488,"../../modules/es6.object.create":556}],466:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};
},{"../../modules/_core":488,"../../modules/es6.object.define-property":557}],467:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-descriptor');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyDescriptor(it, key){
  return $Object.getOwnPropertyDescriptor(it, key);
};
},{"../../modules/_core":488,"../../modules/es6.object.get-own-property-descriptor":558}],468:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/_core').Object.getPrototypeOf;
},{"../../modules/_core":488,"../../modules/es6.object.get-prototype-of":559}],469:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;
},{"../../modules/_core":488,"../../modules/es6.object.keys":560}],470:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;
},{"../../modules/_core":488,"../../modules/es6.object.set-prototype-of":561}],471:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
module.exports = require('../modules/_core').Set;
},{"../modules/_core":488,"../modules/es6.object.to-string":562,"../modules/es6.set":563,"../modules/es6.string.iterator":564,"../modules/es7.set.to-json":567,"../modules/web.dom.iterable":570}],472:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;
},{"../../modules/_core":488,"../../modules/es6.object.to-string":562,"../../modules/es6.symbol":565,"../../modules/es7.symbol.async-iterator":568,"../../modules/es7.symbol.observable":569}],473:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');
},{"../../modules/_wks-ext":547,"../../modules/es6.string.iterator":564,"../../modules/web.dom.iterable":570}],474:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],475:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],476:[function(require,module,exports){
module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};
},{}],477:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":507}],478:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":498}],479:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":539,"./_to-iobject":541,"./_to-length":542}],480:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":482,"./_ctx":490,"./_iobject":504,"./_to-length":542,"./_to-object":543}],481:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":506,"./_is-object":507,"./_wks":548}],482:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":481}],483:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof')
  , TAG = require('./_wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./_cof":484,"./_wks":548}],484:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],485:[function(require,module,exports){
'use strict';
var dP          = require('./_object-dp').f
  , create      = require('./_object-create')
  , redefineAll = require('./_redefine-all')
  , ctx         = require('./_ctx')
  , anInstance  = require('./_an-instance')
  , defined     = require('./_defined')
  , forOf       = require('./_for-of')
  , $iterDefine = require('./_iter-define')
  , step        = require('./_iter-step')
  , setSpecies  = require('./_set-species')
  , DESCRIPTORS = require('./_descriptors')
  , fastKey     = require('./_meta').fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./_an-instance":476,"./_ctx":490,"./_defined":491,"./_descriptors":492,"./_for-of":498,"./_iter-define":510,"./_iter-step":512,"./_meta":516,"./_object-create":518,"./_object-dp":519,"./_redefine-all":531,"./_set-species":534}],486:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof')
  , from    = require('./_array-from-iterable');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};
},{"./_array-from-iterable":478,"./_classof":483}],487:[function(require,module,exports){
'use strict';
var global         = require('./_global')
  , $export        = require('./_export')
  , meta           = require('./_meta')
  , fails          = require('./_fails')
  , hide           = require('./_hide')
  , redefineAll    = require('./_redefine-all')
  , forOf          = require('./_for-of')
  , anInstance     = require('./_an-instance')
  , isObject       = require('./_is-object')
  , setToStringTag = require('./_set-to-string-tag')
  , dP             = require('./_object-dp').f
  , each           = require('./_array-methods')(0)
  , DESCRIPTORS    = require('./_descriptors');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function(target, iterable){
      anInstance(target, C, NAME, '_c');
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        anInstance(this, C, KEY);
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)dP(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./_an-instance":476,"./_array-methods":480,"./_descriptors":492,"./_export":496,"./_fails":497,"./_for-of":498,"./_global":499,"./_hide":501,"./_is-object":507,"./_meta":516,"./_object-dp":519,"./_redefine-all":531,"./_set-to-string-tag":535}],488:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],489:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp')
  , createDesc      = require('./_property-desc');

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};
},{"./_object-dp":519,"./_property-desc":530}],490:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":474}],491:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],492:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":497}],493:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":499,"./_is-object":507}],494:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],495:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys')
  , gOPS    = require('./_object-gops')
  , pIE     = require('./_object-pie');
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};
},{"./_object-gops":524,"./_object-keys":527,"./_object-pie":528}],496:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , ctx       = require('./_ctx')
  , hide      = require('./_hide')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":488,"./_ctx":490,"./_global":499,"./_hide":501}],497:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],498:[function(require,module,exports){
var ctx         = require('./_ctx')
  , call        = require('./_iter-call')
  , isArrayIter = require('./_is-array-iter')
  , anObject    = require('./_an-object')
  , toLength    = require('./_to-length')
  , getIterFn   = require('./core.get-iterator-method')
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;
},{"./_an-object":477,"./_ctx":490,"./_is-array-iter":505,"./_iter-call":508,"./_to-length":542,"./core.get-iterator-method":549}],499:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],500:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],501:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":492,"./_object-dp":519,"./_property-desc":530}],502:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":499}],503:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":492,"./_dom-create":493,"./_fails":497}],504:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":484}],505:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./_iterators')
  , ITERATOR   = require('./_wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./_iterators":513,"./_wks":548}],506:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":484}],507:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],508:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./_an-object":477}],509:[function(require,module,exports){
'use strict';
var create         = require('./_object-create')
  , descriptor     = require('./_property-desc')
  , setToStringTag = require('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":501,"./_object-create":518,"./_property-desc":530,"./_set-to-string-tag":535,"./_wks":548}],510:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./_library')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , hide           = require('./_hide')
  , has            = require('./_has')
  , Iterators      = require('./_iterators')
  , $iterCreate    = require('./_iter-create')
  , setToStringTag = require('./_set-to-string-tag')
  , getPrototypeOf = require('./_object-gpo')
  , ITERATOR       = require('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":496,"./_has":500,"./_hide":501,"./_iter-create":509,"./_iterators":513,"./_library":515,"./_object-gpo":525,"./_redefine":532,"./_set-to-string-tag":535,"./_wks":548}],511:[function(require,module,exports){
var ITERATOR     = require('./_wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./_wks":548}],512:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],513:[function(require,module,exports){
module.exports = {};
},{}],514:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./_object-keys":527,"./_to-iobject":541}],515:[function(require,module,exports){
module.exports = true;
},{}],516:[function(require,module,exports){
var META     = require('./_uid')('meta')
  , isObject = require('./_is-object')
  , has      = require('./_has')
  , setDesc  = require('./_object-dp').f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !require('./_fails')(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
},{"./_fails":497,"./_has":500,"./_is-object":507,"./_object-dp":519,"./_uid":545}],517:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":497,"./_iobject":504,"./_object-gops":524,"./_object-keys":527,"./_object-pie":528,"./_to-object":543}],518:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":477,"./_dom-create":493,"./_enum-bug-keys":494,"./_html":502,"./_object-dps":520,"./_shared-key":536}],519:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":477,"./_descriptors":492,"./_ie8-dom-define":503,"./_to-primitive":544}],520:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":477,"./_descriptors":492,"./_object-dp":519,"./_object-keys":527}],521:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":492,"./_has":500,"./_ie8-dom-define":503,"./_object-pie":528,"./_property-desc":530,"./_to-iobject":541,"./_to-primitive":544}],522:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject')
  , gOPN      = require('./_object-gopn').f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":523,"./_to-iobject":541}],523:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":494,"./_object-keys-internal":526}],524:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],525:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = require('./_has')
  , toObject    = require('./_to-object')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":500,"./_shared-key":536,"./_to-object":543}],526:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":479,"./_has":500,"./_shared-key":536,"./_to-iobject":541}],527:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":494,"./_object-keys-internal":526}],528:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],529:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":488,"./_export":496,"./_fails":497}],530:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],531:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function(target, src, safe){
  for(var key in src){
    if(safe && target[key])target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};
},{"./_hide":501}],532:[function(require,module,exports){
module.exports = require('./_hide');
},{"./_hide":501}],533:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":477,"./_ctx":490,"./_is-object":507,"./_object-gopd":521}],534:[function(require,module,exports){
'use strict';
var global      = require('./_global')
  , core        = require('./_core')
  , dP          = require('./_object-dp')
  , DESCRIPTORS = require('./_descriptors')
  , SPECIES     = require('./_wks')('species');

module.exports = function(KEY){
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./_core":488,"./_descriptors":492,"./_global":499,"./_object-dp":519,"./_wks":548}],535:[function(require,module,exports){
var def = require('./_object-dp').f
  , has = require('./_has')
  , TAG = require('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":500,"./_object-dp":519,"./_wks":548}],536:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":537,"./_uid":545}],537:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":499}],538:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":491,"./_to-integer":540}],539:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":540}],540:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],541:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":491,"./_iobject":504}],542:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":540}],543:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":491}],544:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":507}],545:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],546:[function(require,module,exports){
var global         = require('./_global')
  , core           = require('./_core')
  , LIBRARY        = require('./_library')
  , wksExt         = require('./_wks-ext')
  , defineProperty = require('./_object-dp').f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};
},{"./_core":488,"./_global":499,"./_library":515,"./_object-dp":519,"./_wks-ext":547}],547:[function(require,module,exports){
exports.f = require('./_wks');
},{"./_wks":548}],548:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":499,"./_shared":537,"./_uid":545}],549:[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./_classof":483,"./_core":488,"./_iterators":513,"./_wks":548}],550:[function(require,module,exports){
var anObject = require('./_an-object')
  , get      = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./_an-object":477,"./_core":488,"./core.get-iterator-method":549}],551:[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').isIterable = function(it){
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    || Iterators.hasOwnProperty(classof(O));
};
},{"./_classof":483,"./_core":488,"./_iterators":513,"./_wks":548}],552:[function(require,module,exports){
'use strict';
var ctx            = require('./_ctx')
  , $export        = require('./_export')
  , toObject       = require('./_to-object')
  , call           = require('./_iter-call')
  , isArrayIter    = require('./_is-array-iter')
  , toLength       = require('./_to-length')
  , createProperty = require('./_create-property')
  , getIterFn      = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":489,"./_ctx":490,"./_export":496,"./_is-array-iter":505,"./_iter-call":508,"./_iter-detect":511,"./_to-length":542,"./_to-object":543,"./core.get-iterator-method":549}],553:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables')
  , step             = require('./_iter-step')
  , Iterators        = require('./_iterators')
  , toIObject        = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./_add-to-unscopables":475,"./_iter-define":510,"./_iter-step":512,"./_iterators":513,"./_to-iobject":541}],554:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.1 Map Objects
module.exports = require('./_collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./_collection":487,"./_collection-strong":485}],555:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":496,"./_object-assign":517}],556:[function(require,module,exports){
var $export = require('./_export')
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: require('./_object-create')});
},{"./_export":496,"./_object-create":518}],557:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":492,"./_export":496,"./_object-dp":519}],558:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = require('./_to-iobject')
  , $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./_object-gopd":521,"./_object-sap":529,"./_to-iobject":541}],559:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = require('./_to-object')
  , $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});
},{"./_object-gpo":525,"./_object-sap":529,"./_to-object":543}],560:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":527,"./_object-sap":529,"./_to-object":543}],561:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});
},{"./_export":496,"./_set-proto":533}],562:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"dup":155}],563:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.2 Set Objects
module.exports = require('./_collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./_collection":487,"./_collection-strong":485}],564:[function(require,module,exports){
'use strict';
var $at  = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":510,"./_string-at":538}],565:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global         = require('./_global')
  , has            = require('./_has')
  , DESCRIPTORS    = require('./_descriptors')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , META           = require('./_meta').KEY
  , $fails         = require('./_fails')
  , shared         = require('./_shared')
  , setToStringTag = require('./_set-to-string-tag')
  , uid            = require('./_uid')
  , wks            = require('./_wks')
  , wksExt         = require('./_wks-ext')
  , wksDefine      = require('./_wks-define')
  , keyOf          = require('./_keyof')
  , enumKeys       = require('./_enum-keys')
  , isArray        = require('./_is-array')
  , anObject       = require('./_an-object')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , createDesc     = require('./_property-desc')
  , _create        = require('./_object-create')
  , gOPNExt        = require('./_object-gopn-ext')
  , $GOPD          = require('./_object-gopd')
  , $DP            = require('./_object-dp')
  , $keys          = require('./_object-keys')
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f  = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./_library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./_an-object":477,"./_descriptors":492,"./_enum-keys":495,"./_export":496,"./_fails":497,"./_global":499,"./_has":500,"./_hide":501,"./_is-array":506,"./_keyof":514,"./_library":515,"./_meta":516,"./_object-create":518,"./_object-dp":519,"./_object-gopd":521,"./_object-gopn":523,"./_object-gopn-ext":522,"./_object-gops":524,"./_object-keys":527,"./_object-pie":528,"./_property-desc":530,"./_redefine":532,"./_set-to-string-tag":535,"./_shared":537,"./_to-iobject":541,"./_to-primitive":544,"./_uid":545,"./_wks":548,"./_wks-define":546,"./_wks-ext":547}],566:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Map', {toJSON: require('./_collection-to-json')('Map')});
},{"./_collection-to-json":486,"./_export":496}],567:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Set', {toJSON: require('./_collection-to-json')('Set')});
},{"./_collection-to-json":486,"./_export":496}],568:[function(require,module,exports){
require('./_wks-define')('asyncIterator');
},{"./_wks-define":546}],569:[function(require,module,exports){
require('./_wks-define')('observable');
},{"./_wks-define":546}],570:[function(require,module,exports){
require('./es6.array.iterator');
var global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , TO_STRING_TAG = require('./_wks')('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}
},{"./_global":499,"./_hide":501,"./_iterators":513,"./_wks":548,"./es6.array.iterator":553}],571:[function(require,module,exports){
(function (global){
// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./runtime":572}],572:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[22])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi9kaXN0L2NvcmUvSGlzdG9yeS5qcyIsIi4uLy4uL2Rpc3QvSGlzdG9yeS5qcyIsIi4uLy4uL2Rpc3QvbW9kdWxlL0hpc3RvcnkuanMiLCIuLi8uLi9kaXN0L3BsYXllci9IaXN0b3J5LmpzIiwiLi4vLi4vZGlzdC91dGlscy9IaXN0b3J5LmpzIiwiZGlzdC9pbmRleC5qcyIsImRpc3QvbWV0YWRhdGEtYmVhdHMuanMiLCJkaXN0L21ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL0BpcmNhbS9iYXNpYy1jb250cm9sbGVycy9kaXN0L2NvbXBvbmVudHMvQmFzZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9AaXJjYW0vYmFzaWMtY29udHJvbGxlcnMvZGlzdC9jb21wb25lbnRzL0RyYWdBbmREcm9wLmpzIiwibm9kZV9tb2R1bGVzL0BpcmNhbS9iYXNpYy1jb250cm9sbGVycy9kaXN0L2NvbXBvbmVudHMvR3JvdXAuanMiLCJub2RlX21vZHVsZXMvQGlyY2FtL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvY29tcG9uZW50cy9OdW1iZXJCb3guanMiLCJub2RlX21vZHVsZXMvQGlyY2FtL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvY29tcG9uZW50cy9TZWxlY3RCdXR0b25zLmpzIiwibm9kZV9tb2R1bGVzL0BpcmNhbS9iYXNpYy1jb250cm9sbGVycy9kaXN0L2NvbXBvbmVudHMvU2VsZWN0TGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9AaXJjYW0vYmFzaWMtY29udHJvbGxlcnMvZGlzdC9jb21wb25lbnRzL1NsaWRlci5qcyIsIm5vZGVfbW9kdWxlcy9AaXJjYW0vYmFzaWMtY29udHJvbGxlcnMvZGlzdC9jb21wb25lbnRzL1RleHQuanMiLCJub2RlX21vZHVsZXMvQGlyY2FtL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvY29tcG9uZW50cy9UaXRsZS5qcyIsIm5vZGVfbW9kdWxlcy9AaXJjYW0vYmFzaWMtY29udHJvbGxlcnMvZGlzdC9jb21wb25lbnRzL1RvZ2dsZS5qcyIsIm5vZGVfbW9kdWxlcy9AaXJjYW0vYmFzaWMtY29udHJvbGxlcnMvZGlzdC9jb21wb25lbnRzL1RyaWdnZXJCdXR0b25zLmpzIiwibm9kZV9tb2R1bGVzL0BpcmNhbS9iYXNpYy1jb250cm9sbGVycy9kaXN0L2ZhY3RvcnkuanMiLCJub2RlX21vZHVsZXMvQGlyY2FtL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGlyY2FtL2Jhc2ljLWNvbnRyb2xsZXJzL2Rpc3QvbWl4aW5zL2NvbnRhaW5lci5qcyIsIm5vZGVfbW9kdWxlcy9AaXJjYW0vYmFzaWMtY29udHJvbGxlcnMvZGlzdC9taXhpbnMvZGlzcGxheS5qcyIsIm5vZGVfbW9kdWxlcy9AaXJjYW0vYmFzaWMtY29udHJvbGxlcnMvZGlzdC91dGlscy9lbGVtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AaXJjYW0vYmFzaWMtY29udHJvbGxlcnMvZGlzdC91dGlscy9zdHlsZXMtZGVjbGFyYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0BpcmNhbS9iYXNpYy1jb250cm9sbGVycy9kaXN0L3V0aWxzL3N0eWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9AaXJjYW0vYmFzaWMtY29udHJvbGxlcnMvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL0BpcmNhbS9ndWktY29tcG9uZW50cy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcGVyZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzLWxvYWRlcnMvZGlzdC9hdWRpby1idWZmZXItbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzLWxvYWRlcnMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93YXZlcy1sb2FkZXJzL2Rpc3QvbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL3dhdmVzLWxvYWRlcnMvZGlzdC9zdXBlci1sb2FkZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGlyY2FtL3BhcmFtZXRlcnMvZGlzdC9wYXJhbWV0ZXJzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BpcmNhbS90aWNrZXIvZGlzdC9UaWNrZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXRoL2xvZzEwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9udW1iZXIvaXMtZmluaXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3dlYWstbWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9tYXRoL2xvZzEwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvaXMtZmluaXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3dlYWstbWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC5mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAub2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0Lm9mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAub2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24tZGVlcC9vYmplY3RBc3NpZ25EZWVwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWF1ZGlvL2Rpc3QvY29yZS9hdWRpby1jb250ZXh0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWF1ZGlvL2Rpc3QvY29yZS9hdWRpby10aW1lLWVuZ2luZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L2NvcmUvcHJpb3JpdHktcXVldWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtYXVkaW8vZGlzdC9jb3JlL3NjaGVkdWxpbmctcXVldWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtYXVkaW8vZGlzdC9jb3JlL3RpbWUtZW5naW5lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWF1ZGlvL2Rpc3QvZW5naW5lcy9ncmFudWxhci1lbmdpbmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtYXVkaW8vZGlzdC9lbmdpbmVzL21ldHJvbm9tZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L2VuZ2luZXMvcGxheWVyLWVuZ2luZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L2VuZ2luZXMvc2VnbWVudC1lbmdpbmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtYXVkaW8vZGlzdC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L21hc3RlcnMvZmFjdG9yaWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWF1ZGlvL2Rpc3QvbWFzdGVycy9wbGF5LWNvbnRyb2wuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtYXVkaW8vZGlzdC9tYXN0ZXJzL3NjaGVkdWxlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L21hc3RlcnMvc2ltcGxlLXNjaGVkdWxlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1hdWRpby9kaXN0L21hc3RlcnMvdHJhbnNwb3J0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9vcGVyYXRvci9CaXF1YWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9vcGVyYXRvci9DbGlwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvRGN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvRGVsdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9vcGVyYXRvci9GZnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9vcGVyYXRvci9NYWduaXR1ZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9vcGVyYXRvci9NZWFuU3RkZGV2LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvTWVsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvTWVyZ2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvTWZjYy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1sZm8vY29tbW9uL29wZXJhdG9yL01pbk1heC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1sZm8vY29tbW9uL29wZXJhdG9yL01vdmluZ0F2ZXJhZ2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9vcGVyYXRvci9Nb3ZpbmdNZWRpYW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9vcGVyYXRvci9NdWx0aXBsaWVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvT25PZmYuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9vcGVyYXRvci9Qb3dlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1sZm8vY29tbW9uL29wZXJhdG9yL1Jtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1sZm8vY29tbW9uL29wZXJhdG9yL1NjYWxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvU2VnbWVudGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvU2VsZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvU2xpY2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvWWluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vb3BlcmF0b3IvX25hbWVzcGFjZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1sZm8vY29tbW9uL3NpbmsvQnJpZGdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vc2luay9EYXRhUmVjb3JkZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9zaW5rL0xvZ2dlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1sZm8vY29tbW9uL3NpbmsvU2lnbmFsUmVjb3JkZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9zaW5rL19uYW1lc3BhY2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi9zb3VyY2UvRGF0YVJlYWRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1sZm8vY29tbW9uL3NvdXJjZS9FdmVudEluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vc291cmNlL19uYW1lc3BhY2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2F2ZXMtbGZvL2NvbW1vbi91dGlscy9fbmFtZXNwYWNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb21tb24vdXRpbHMvd2luZG93cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93YXZlcy1sZm8vY29yZS9CYXNlTGZvLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb3JlL1NvdXJjZU1peGluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dhdmVzLWxmby9jb3JlL2luZGV4LmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9heGlzL0F4aXNMYXllci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvYXhpcy9ncmlkQXhpc0dlbmVyYXRvci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvYXhpcy90aW1lQXhpc0dlbmVyYXRvci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvYmVoYXZpb3JzL0Jhc2VCZWhhdmlvci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvYmVoYXZpb3JzL0JyZWFrcG9pbnRCZWhhdmlvci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvYmVoYXZpb3JzL01hcmtlckJlaGF2aW9yLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9iZWhhdmlvcnMvU2VnbWVudEJlaGF2aW9yLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9iZWhhdmlvcnMvVGltZUNvbnRleHRCZWhhdmlvci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvYmVoYXZpb3JzL1RyYWNlQmVoYXZpb3IuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L2NvcmUvTGF5ZXIuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L2NvcmUvTGF5ZXJUaW1lQ29udGV4dC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvY29yZS9UaW1lbGluZVRpbWVDb250ZXh0LmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9jb3JlL1RyYWNrLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9jb3JlL1RyYWNrQ29sbGVjdGlvbi5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvY29yZS9uYW1lc3BhY2UuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L2NvcmUvVGltZWxpbmUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L2hlbHBlcnMvQnJlYWtwb2ludExheWVyLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9oZWxwZXJzL0N1cnNvckxheWVyLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9oZWxwZXJzL0dyaWRBeGlzTGF5ZXIuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L2hlbHBlcnMvTWFya2VyTGF5ZXIuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L2hlbHBlcnMvU2VnbWVudExheWVyLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9oZWxwZXJzL1RpY2tMYXllci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvaGVscGVycy9UaW1lQXhpc0xheWVyLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9oZWxwZXJzL1RyYWNlTGF5ZXIuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L2hlbHBlcnMvV2F2ZWZvcm1MYXllci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvaW5kZXguanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L2ludGVyYWN0aW9ucy9FdmVudFNvdXJjZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvaW50ZXJhY3Rpb25zL0tleWJvYXJkLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9pbnRlcmFjdGlvbnMvU3VyZmFjZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3QvaW50ZXJhY3Rpb25zL1dhdmVFdmVudC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3Qvc2hhcGVzL0Jhc2VTaGFwZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3Qvc2hhcGVzL0N1cnNvci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3Qvc2hhcGVzL0RvdC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3Qvc2hhcGVzL0xpbmUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L3NoYXBlcy9NYXJrZXIuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L3NoYXBlcy9TZWdtZW50LmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9zaGFwZXMvVGlja3MuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L3NoYXBlcy9UcmFjZURvdHMuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L3NoYXBlcy9UcmFjZVBhdGguanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L3NoYXBlcy9XYXZlZm9ybS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3Qvc3RhdGVzL0Jhc2VTdGF0ZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3Qvc3RhdGVzL0JyZWFrcG9pbnRTdGF0ZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL2Rpc3Qvc3RhdGVzL0JydXNoWm9vbVN0YXRlLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9zdGF0ZXMvQ2VudGVyZWRab29tU3RhdGUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L3N0YXRlcy9Db250ZXh0RWRpdGlvblN0YXRlLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9zdGF0ZXMvRWRpdGlvblN0YXRlLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC9zdGF0ZXMvU2VsZWN0aW9uU3RhdGUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L3N0YXRlcy9TaW1wbGVFZGl0aW9uU3RhdGUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L3V0aWxzL09ydGhvZ29uYWxEYXRhLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvZGlzdC91dGlscy9mb3JtYXQuanMiLCIuLi8uLi8uLi93YXZlcy11aS9kaXN0L3V0aWxzL3NjYWxlcy5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9tYXAuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWFwLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCIuLi8uLi8uLi93YXZlcy11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIi4uLy4uLy4uL3dhdmVzLXVpL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzIiwiLi4vLi4vLi4vd2F2ZXMtdWkvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7SUFZTSxjO0FBQ0osMEJBQVksV0FBWixFQUF5QixPQUF6QixFQUFrQztBQUFBOztBQUNoQyxTQUFLLE1BQUwsR0FBYywwQkFBVyxXQUFYLEVBQXdCLE9BQXhCLENBQWQ7O0FBRUEsU0FBSyxNQUFMLEdBQWMsSUFBZDtBQUNBLFNBQUssT0FBTCxHQUFlLElBQWY7QUFDRDs7Ozs7O0FBa0JEOzs7OEJBR1UsQ0FBRTs7QUFFWjs7Ozs7O2dDQUdZLENBQUU7O0FBRWQ7Ozs7OztBQU1BOzs7QUFHQTs7O0FBR0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7O3NCQTNEVSxLLEVBQU87QUFDZixXQUFLLE1BQUwsR0FBYyxLQUFkO0FBQ0QsSzt3QkFFVztBQUNWLGFBQU8sS0FBSyxNQUFaO0FBQ0Q7OztzQkFFVSxNLEVBQVE7QUFDakIsV0FBSyxPQUFMLEdBQWUsTUFBZjtBQUNELEs7d0JBRVk7QUFDWCxhQUFPLEtBQUssT0FBWjtBQUNEOzs7OztrQkFnRFks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QTlCWSxFQW9DWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXBDWSxFQTBDWjtBQUNELFVBQVEsV0FEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTFDWSxFQWdEWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWhEWSxFQXNEWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXREWSxFQTREWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTVEWSxFQWtFWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWxFWSxFQXdFWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXhFWSxFQThFWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTlFWSxFQW9GWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXBGWSxFQTBGWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTFGWSxFQWdHWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWhHWSxFQXNHWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXRHWSxFQTRHWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTVHWSxFQWtIWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWxIWSxFQXdIWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXhIWSxFQThIWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTlIWSxFQW9JWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXBJWSxFQTBJWjtBQUNELFVBQVEsWUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTFJWSxFQWdKWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWhKWSxFQXNKWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXRKWSxFQTRKWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTVKWSxFQWtLWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWxLWSxFQXdLWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXhLWSxFQThLWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTlLWSxFQW9MWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXBMWSxFQTBMWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTFMWSxFQWdNWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWhNWSxFQXNNWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXRNWSxFQTRNWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTVNWSxFQWtOWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWxOWSxFQXdOWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXhOWSxFQThOWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTlOWSxFQW9PWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXBPWSxFQTBPWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTFPWSxFQWdQWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWhQWSxFQXNQWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXRQWSxFQTRQWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTVQWSxFQWtRWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWxRWSxFQXdRWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXhRWSxFQThRWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTlRWSxFQW9SWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXBSWSxFQTBSWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTFSWSxFQWdTWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWhTWSxFQXNTWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXRTWSxFQTRTWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTVTWSxFQWtUWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWxUWSxFQXdUWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXhUWSxFQThUWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTlUWSxFQW9VWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXBVWSxFQTBVWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTFVWSxFQWdWWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWhWWSxFQXNWWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXRWWSxFQTRWWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTVWWSxFQWtXWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWxXWSxFQXdXWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXhXWSxFQThXWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTlXWSxFQW9YWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXBYWSxFQTBYWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTFYWSxFQWdZWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWhZWSxFQXNZWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXRZWSxFQTRZWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTVZWSxFQWtaWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWxaWSxFQXdaWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXhaWSxFQThaWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTlaWSxFQW9hWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXBhWSxFQTBhWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTFhWSxFQWdiWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWhiWSxFQXNiWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXRiWSxFQTRiWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsSUFIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTViWSxFQWtjWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQWxjWSxFQXdjWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQXhjWSxFQThjWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUsQ0FGVDtBQUdELGFBQVcsS0FIVjtBQUlELGFBQVcsS0FKVjtBQUtELFVBQVE7QUFMUCxDQTljWSxFQW9kWjtBQUNELFVBQVEsYUFEUDtBQUVELFlBQVUs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QTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q1gsYUFBTyxLQUFLLGFBQVo7QUFDRDs7Ozs7O2tCQTRDWSxNOzs7OztBQzFIZjs7OztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOzs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOzs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hKQSxJQUFNLGVBQWUsT0FBTyxZQUFQLElBQXVCLE9BQU8sa0JBQW5EOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSxJQUFJ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QUNBO0FBQ0E7QUFDQTs7QUNIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCJpbXBvcnQgQmxvY2sgZnJvbSAnLi9CbG9jayc7XG5pbXBvcnQgQWJzdHJhY3RQbGF5ZXIgZnJvbSAnLi9BYnN0cmFjdFBsYXllcic7XG5pbXBvcnQgQWJzdHJhY3RNb2R1bGUgZnJvbSAnLi9BYnN0cmFjdE1vZHVsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQmxvY2ssXG4gIEFic3RyYWN0UGxheWVyLFxuICBBYnN0cmFjdE1vZHVsZSxcbn07XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIGNvcmUgfSBmcm9tICcuL2NvcmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtb2R1bGUgfSBmcm9tICcuL21vZHVsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBsYXllciB9IGZyb20gJy4vcGxheWVyJztcbiIsImltcG9ydCBBYnN0cmFjdEFubm90YXRpb24gZnJvbSAnLi9BYnN0cmFjdEFubm90YXRpb24nO1xuaW1wb3J0IEJlYXRHcmlkIGZyb20gJy4vQmVhdEdyaWQnO1xuaW1wb3J0IEJwZiBmcm9tICcuL0JwZic7XG5pbXBvcnQgQ3Vyc29yIGZyb20gJy4vQ3Vyc29yJztcbmltcG9ydCBHcmlkQXhpcyBmcm9tICcuL0dyaWRBeGlzJztcbmltcG9ydCBNYXJrZXIgZnJvbSAnLi9NYXJrZXInO1xuaW1wb3J0IFNlZ21lbnQgZnJvbSAnLi9TZWdtZW50JztcbmltcG9ydCBTaW1wbGVXYXZlZm9ybSBmcm9tICcuL1NpbXBsZVdhdmVmb3JtJztcbmltcG9ydCBUaW1lQXhpcyBmcm9tICcuL1RpbWVBeGlzJztcbmltcG9ydCBXYXZlZm9ybSBmcm9tICcuL1dhdmVmb3JtJztcbmltcG9ydCBab29tIGZyb20gJy4vWm9vbSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQWJzdHJhY3RBbm5vdGF0aW9uLFxuICBCZWF0R3JpZCxcbiAgQnBmLFxuICBDdXJzb3IsXG4gIEdyaWRBeGlzLFxuICBNYXJrZXIsXG4gIFNlZ21lbnQsXG4gIFNpbXBsZVdhdmVmb3JtLFxuICBUaW1lQXhpcyxcbiAgV2F2ZWZvcm0sXG4gIFpvb20sXG59O1xuIiwiaW1wb3J0IERhdGFQbGF5ZXIgZnJvbSAnLi9EYXRhUGxheWVyJztcbmltcG9ydCBTaW1wbGVQbGF5ZXIgZnJvbSAnLi9TaW1wbGVQbGF5ZXInO1xuXG5leHBvcnQgZGVmYXVsdMKge1xuICBEYXRhUGxheWVyLFxuICBTaW1wbGVQbGF5ZXIsXG59O1xuIiwiXG4vKipcbiAqIENvcHkgY3VycmVudCBjb25maWcgdG8gY3JlYXRlIHNuYXBzaG90c1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG5cbi8qKlxuICpcbiAqXG4gKi9cbmNsYXNzIEhpc3Rvcnkge1xuICBjb25zdHJ1Y3Rvcihob3N0LCBhdHRyLCBtYXhTaXplID0gMTApIHtcbiAgICAvLyBnZXQgYSByZWZlcmVuY2UgdG8gaG9zdFthdHRyXVxuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5hdHRyID0gYXR0cjtcblxuICAgIHRoaXMuX3N0YWNrID0gW107XG4gICAgdGhpcy5fcG9pbnRlciA9IC0xO1xuICAgIHRoaXMuX21heFNpemUgPSBtYXhTaXplO1xuICB9XG5cbiAgaGVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fcG9pbnRlcl07XG4gIH1cblxuICBzbmFwKCkge1xuICAgIC8vIGVsaW1pbmF0ZSBwcmV2aW91cyBmdXR1cmVcbiAgICB0aGlzLl9zdGFjayA9IHRoaXMuX3N0YWNrLnNsaWNlKDAsIHRoaXMuX3BvaW50ZXIgKyAxKTtcblxuICAgIGNvbnN0IG1heEluZGV4ID0gdGhpcy5fbWF4U2l6ZSAtIDE7XG4gICAgdGhpcy5fcG9pbnRlciA9IE1hdGgubWluKG1heEluZGV4LCB0aGlzLl9wb2ludGVyICsgMSk7XG5cbiAgICBjb25zdCBzbmFwc2hvdCA9IGNvcHkodGhpcy5ob3N0W3RoaXMuYXR0cl0pO1xuXG4gICAgaWYgKHRoaXMuX3N0YWNrLmxlbmd0aCA9PT0gdGhpcy5fbWF4U2l6ZSlcbiAgICAgIHRoaXMuX3N0YWNrLnNoaWZ0KCk7XG5cbiAgICB0aGlzLl9zdGFja1t0aGlzLl9wb2ludGVyXSA9IHNuYXBzaG90O1xuICAgIC8vIGNvbnNvbGUubG9nKCdzbmFwJywgdGhpcy5fc3RhY2ssIHRoaXMuX3BvaW50ZXIpO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fc3RhY2subGVuZ3RoID0gMDtcbiAgICB0aGlzLl9wb2ludGVyID0gLTE7XG4gIH1cblxuICB1bmRvKCkge1xuICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLl9wb2ludGVyIC0gMTtcblxuICAgIGlmIChwb2ludGVyID49IDApIHtcbiAgICAgIHRoaXMuX3BvaW50ZXIgPSBwb2ludGVyO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmVkbygpIHtcbiAgICBjb25zdCBwb2ludGVyID0gdGhpcy5fcG9pbnRlciArIDE7XG5cbiAgICBpZiAodGhpcy5fc3RhY2tbcG9pbnRlcl0pIHtcbiAgICAgIHRoaXMuX3BvaW50ZXIgPSBwb2ludGVyO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEhpc3Rvcnk7XG4iLCJpbXBvcnQgKiBhcyBibG9ja3MgZnJvbSAnd2F2ZXMtYmxvY2tzJztcbmltcG9ydCAqIGFzIGxvYWRlcnMgZnJvbSAnd2F2ZXMtbG9hZGVycyc7XG5pbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICdAaXJjYW0vYmFzaWMtY29udHJvbGxlcnMnO1xuaW1wb3J0IG1ldGFkYXRhIGZyb20gJy4vbWV0YWRhdGEuanMnO1xuaW1wb3J0IGJlYXRzIGZyb20gJy4vbWV0YWRhdGEtYmVhdHMuanMnO1xuXG5hc3luYyBmdW5jdGlvbiBpbml0KCkge1xuICBjb25zdCBsb2FkZXIgPSBuZXcgbG9hZGVycy5BdWRpb0J1ZmZlckxvYWRlcigpO1xuICBjb25zdCBidWZmZXJzID0gYXdhaXQgbG9hZGVyLmxvYWQobWV0YWRhdGEubWFwKGQgPT4gZC5idWZmZXIpKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFkYXRhLmxlbmd0aDsgaSsrKVxuICAgIG1ldGFkYXRhW2ldLmJlYXRzID0gYmVhdHMuZmlsdGVyKGIgPT4gYi50aW1lIDwgYnVmZmVyc1tpXS5kdXJhdGlvbik7XG5cbiAgY29uc3QgYmxvY2sgPSBuZXcgYmxvY2tzLmNvcmUuQmxvY2soe1xuICAgIHBsYXllcjogYmxvY2tzLnBsYXllci5TaW1wbGVQbGF5ZXIsXG4gICAgY29udGFpbmVyOiAnI2NvbnRhaW5lcicsXG4gICAgc2l6aW5nOiAnbWFudWFsJyxcbiAgICB3aWR0aDogMTAwMCxcbiAgICBoZWlnaHQ6IDEwMCxcbiAgfSk7XG5cbiAgY29uc3Qgd2F2ZWZvcm0gPSBuZXcgYmxvY2tzLm1vZHVsZS5XYXZlZm9ybSh7IGNoYW5uZWxzOiAnYWxsJyB9KTtcbiAgY29uc3Qgc2ltcGxlV2F2ZWZvcm0gPSBuZXcgYmxvY2tzLm1vZHVsZS5TaW1wbGVXYXZlZm9ybSgpO1xuICBjb25zdCBjdXJzb3IgPSBuZXcgYmxvY2tzLm1vZHVsZS5DdXJzb3IoKTtcbiAgY29uc3QgbWFya2VyID0gbmV3IGJsb2Nrcy5tb2R1bGUuTWFya2VyKCk7XG4gIGNvbnN0IHNlZ21lbnQgPSBuZXcgYmxvY2tzLm1vZHVsZS5TZWdtZW50KCk7XG4gIGNvbnN0IGJlYXRHcmlkID0gbmV3IGJsb2Nrcy5tb2R1bGUuQmVhdEdyaWQoKTtcbiAgY29uc3Qgc2ltcGxlWm9vbSA9IG5ldyBibG9ja3MubW9kdWxlLlpvb20oKTtcbiAgY29uc3Qgc2Nyb2xsQmFyWm9vbSA9IG5ldyBibG9ja3MubW9kdWxlLlpvb20oeyBzY3JvbGxCYXJDb250YWluZXI6ICcjc2Nyb2xsLWJhcicgfSk7XG5cbiAgY29uc3QgbW9kdWxlcyA9IHtcbiAgICB3YXZlZm9ybSxcbiAgICBzaW1wbGVXYXZlZm9ybSxcbiAgICBjdXJzb3IsXG4gICAgbWFya2VyLFxuICAgIHNlZ21lbnQsXG4gICAgYmVhdEdyaWQsXG4gICAgc2ltcGxlWm9vbSxcbiAgICBzY3JvbGxCYXJab29tLFxuICB9O1xuXG5cbiAgYmxvY2suYWRkKHdhdmVmb3JtLCAwKTtcbiAgYmxvY2suYWRkKHNpbXBsZVpvb20sIDEpO1xuXG4gIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICBsZXQgY3VycmVudEJ1ZmZlciA9IGJ1ZmZlcnNbY3VycmVudEluZGV4XTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQ09OVFJPTFNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgY29uc3QgJGxhYmVsQ29udHJvbCA9IG5ldyBjb250cm9sbGVycy5UZXh0KHtcbiAgICBjb250YWluZXI6ICcjY29udHJvbGxlcnMnLFxuICAgIGxhYmVsOiAnbGFiZWwnLFxuICAgIGRlZmF1bHQ6IG1ldGFkYXRhW2N1cnJlbnRJbmRleF0udGl0bGUsXG4gICAgcmVhZG9ubHk6IHRydWUsXG4gIH0pO1xuXG4gIGNvbnN0ICR0cmFuc3BvcnRDb250cm9sID0gbmV3IGNvbnRyb2xsZXJzLlNlbGVjdEJ1dHRvbnMoe1xuICAgIGNvbnRhaW5lcjogJyNjb250cm9sbGVycycsXG4gICAgbGFiZWw6ICd0cmFuc3BvcnQnLFxuICAgIG9wdGlvbnM6IFsnc3RhcnQnLCAncGF1c2UnLCAnc3RvcCddLFxuICAgIGRlZmF1bHQ6ICdzdG9wJyxcbiAgICBjYWxsYmFjazogKHN0YXRlKSA9PiBibG9ja1tzdGF0ZV0oKSxcbiAgfSk7XG5cbiAgbmV3IGNvbnRyb2xsZXJzLlNlbGVjdEJ1dHRvbnMoe1xuICAgIGNvbnRhaW5lcjogJyNjb250cm9sbGVycycsXG4gICAgbGFiZWw6ICdjaGFuZ2UgdHJhY2snLFxuICAgIG9wdGlvbnM6IG1ldGFkYXRhLm1hcChkID0+IGQudGl0bGUpLFxuICAgIGRlZmF1bHQ6IG1ldGFkYXRhW2N1cnJlbnRJbmRleF0udGl0bGUsXG4gICAgY2FsbGJhY2s6ICh0aXRsZSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBtZXRhZGF0YS5maW5kSW5kZXgoZCA9PiBkLnRpdGxlID09PSB0aXRsZSk7XG4gICAgICBibG9jay5zZXRUcmFjayhidWZmZXJzW2luZGV4XSwgbWV0YWRhdGFbaW5kZXhdKTtcblxuICAgICAgJGxhYmVsQ29udHJvbC52YWx1ZSA9IG1ldGFkYXRhW2luZGV4XS50aXRsZTtcbiAgICAgIGN1cnJlbnRCdWZmZXIgPSBidWZmZXJzW2luZGV4XTtcbiAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhtb2R1bGVzKTtcblxuICBmb3IgKGxldCBuYW1lIGluIG1vZHVsZXMpIHtcbiAgICBjb25zdCBtb2R1bGUgPSBtb2R1bGVzW25hbWVdO1xuXG4gICAgbmV3IGNvbnRyb2xsZXJzLlRvZ2dsZSh7XG4gICAgICBjb250YWluZXI6ICcjY29udHJvbGxlcnMnLFxuICAgICAgbGFiZWw6IG5hbWUsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGNhbGxiYWNrOiB2YWx1ZSA9PiB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJztcbiAgICAgICAgY29uc3QgekluZGV4ID0gbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgYmxvY2tbbWV0aG9kXShtb2R1bGUsIHpJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBuZXcgY29udHJvbGxlcnMuVHJpZ2dlckJ1dHRvbnMoe1xuICAgIGNvbnRhaW5lcjogJyNjb250cm9sbGVycycsXG4gICAgbGFiZWw6ICdsb2cgbWV0YWRhdGEnLFxuICAgIG9wdGlvbnM6IFsnbm93J10sXG4gICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgIGNvbnN0ICRsb2cgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbG9nLW1ldGFkYXRhJyk7XG4gICAgICAkbG9nLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhW2N1cnJlbnRJbmRleF0sIG51bGwsIDIpO1xuICAgIH0sXG4gIH0pO1xuXG4gIG5ldyBjb250cm9sbGVycy5UcmlnZ2VyQnV0dG9ucyh7XG4gICAgY29udGFpbmVyOiAnI2NvbnRyb2xsZXJzJyxcbiAgICBsYWJlbDogJ2JlYXRHcmlkIHNoaWZ0JyxcbiAgICBvcHRpb25zOiBbLTAuMDEsIDAuMDFdLFxuICAgIGNhbGxiYWNrOiB2YWx1ZSA9PiBiZWF0R3JpZC5zaGlmdCh2YWx1ZSksXG4gIH0pO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBREQgTElTVEVORVJTIEFORCBJTklUSUFMSVpFXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGJsb2NrLmFkZExpc3RlbmVyKGJsb2NrLkVWRU5UUy5TVE9QLCAoKSA9PiAkdHJhbnNwb3J0Q29udHJvbC52YWx1ZSA9ICdzdG9wJyk7XG4gIGJsb2NrLnNldFRyYWNrKGJ1ZmZlcnNbY3VycmVudEluZGV4XSwgbWV0YWRhdGFbY3VycmVudEluZGV4XSk7XG59XG5cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBpbml0KTtcbiIsImV4cG9ydCBkZWZhdWx0IFt7XG4gIFwidGltZVwiOiAwLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMC40MjIzNjgyNTI3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDAuODQwMzI3NDM2NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxLjI3NTcwMTU4NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEuNjkzNjYwNzY5NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyLjExMTYxOTk1MzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMi41MzUzODQxMjU3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIuOTU5MTQ4Mjk4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMy4zODI5MTI0NzA0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMuODA2Njc2NjQyNyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0LjIyNDYzNTgyNjQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0LjY1NDIwNDk4NzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNS4wNzIxNjQxNzExLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDUuNDk1OTI4MzQzNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA1LjkxOTY5MjUxNTcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA2LjM0MzQ1NjY4ODEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNi43NjcyMjA4NjA0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDcuMTg1MTgwMDQ0MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA3LjYwODk0NDIxNjQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA4LjAzMjcwODM4ODgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogOC40NTY0NzI1NjExLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDguODc0NDMxNzQ0OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA5LjI5MjM5MDkyODQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA5LjcxMDM1MDExMjEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTAuMTM0MTE0Mjg0NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMC41NTc4Nzg0NTY4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEwLjk4NzQ0NzYxNzgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMS40MTcwMTY3Nzg4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDExLjg0MDc4MDk1MTEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTIuMjY0NTQ1MTIzNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMi42ODI1MDQzMDcxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTMuMTA2MjY4NDc5NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMy41MzAwMzI2NTE4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEzLjk1Mzc5NjgyNDEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTQuMzc3NTYwOTk2NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE0Ljc5NTUyMDE4MDEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTUuMjEzNDc5MzYzOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNS42MzE0Mzg1NDc1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE2LjA1NTIwMjcxOTgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNi40Nzg5NjY4OTIyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE2Ljg5NjkyNjA3NTgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTcuMzIwNjkwMjQ4MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNy43NDQ0NTQ0MjA1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTguMTY4MjE4NTkyOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxOC42MDM1OTI3NDI1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE5LjAyNzM1NjkxNDgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTkuNDQ1MzE2MDk4NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE5Ljg3NDg4NTI1OTUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjAuMjkyODQ0NDQzMixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMC43MTA4MDM2MjY4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxLjEzNDU2Nzc5OTIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMS41NTgzMzE5NzE1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxLjk3MDQ4NjE2NjUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjIuMzk0MjUwMzM4OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMi44MTgwMTQ1MTEyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjMuMjQxNzc4NjgzNSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMy42NjU1NDI4NTU5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI0LjA4MzUwMjAzOTUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjQuNTA3MjY2MjExOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI0LjkzMTAzMDM4NDIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjUuMzQ4OTg5NTY3OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNS43NzI3NTM3NDAyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjYuMTk2NTE3OTEyNixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNi42MjAyODIwODQ5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI3LjAzODI0MTI2ODYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNy40NjIwMDU0NDA5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI3Ljg3OTk2NDYyNDYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjguMzAzNzI4Nzk2OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI4LjcyNzQ5Mjk2OTIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjkuMTUxMjU3MTQxNixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyOS41NzUwMjEzMTM5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI5Ljk5ODc4NTQ4NjMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMC40MjI1NDk2NTg2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMwLjg0NjMxMzgzMDksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzEuMjcwMDc4MDAzMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMxLjY5Mzg0MjE3NTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzIuMTE3NjA2MzQ3OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMi41NDEzNzA1MjAzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMyLjk1OTMyOTcwMzksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMy4zNzcyODg4ODc2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMzLjgwNjg1ODA0ODYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzQuMjM2NDI3MjA5NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzNC42NjAxOTEzODE5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzUuMDgzOTU1NTU0MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzNS40OTYxMDk3NDkzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDM1LjkxOTg3MzkyMTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzYuMzQzNjM4MDk0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzYuNzY3NDAyMjY2MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzNy4xOTExNjY0Mzg2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDM3LjYwOTEyNTYyMjMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzguMDI3MDg0ODA2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzguNDU2NjUzOTY3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDM4Ljg4MDQxODEzOTMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzkuMjk4Mzc3MzIzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDM5LjcyMjE0MTQ5NTMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0MC4xNDU5MDU2Njc3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDQwLjU2Mzg2NDg1MTMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNDAuOTkzNDM0MDEyMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0MS40MTcxOTgxODQ3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNDEuODM1MTU3MzY4MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0Mi4yNTg5MjE1NDA3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDQyLjY4MjY4NTcxMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0My4xMDA2NDQ4OTY3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNDMuNTI0NDA5MDY5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDQzLjk0ODE3MzI0MTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNDQuMzY2MTMyNDI1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDQ0Ljc4OTg5NjU5NzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0NS4yMDc4NTU3ODEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNDUuNjMxNjE5OTUzNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0Ni4wNTUzODQxMjU3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDQ2LjQ3OTE0ODI5OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDQ2LjkwMjkxMjQ3MDQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNDcuMzI2Njc2NjQyNyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0Ny43NTA0NDA4MTUxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDQ4LjE3NDIwNDk4NzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0OC41OTc5NjkxNTk3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDQ5LjAyMTczMzMzMjEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNDkuNDQ1NDk3NTA0NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA0OS44NjkyNjE2NzY3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNTAuMjkzMDI1ODQ5MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA1MC43MTY3OTAwMjE0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDUxLjE0MDU1NDE5MzcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNTEuNTU4NTEzMzc3NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDUxLjk3NjQ3MjU2MTEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNTIuNDAwMjM2NzMzNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA1Mi44MjQwMDA5MDU4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDUzLjI0MTk2MDA4OTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA1My42NjU3MjQyNjE4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDU0LjA4MzY4MzQ0NTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNTQuNTEzMjUyNjA2NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA1NC45MzEyMTE3OTAxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNTUuMzU0OTc1OTYyNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA1NS43NzI5MzUxNDYxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDU2LjE5NjY5OTMxODUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNTYuNjIwNDYzNDkwOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDU3LjA0NDIyNzY2MzEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNTcuNDY3OTkxODM1NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA1Ny44OTE3NTYwMDc4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDU4LjMwOTcxNTE5MTUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA1OC43MzM0NzkzNjM4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDU5LjE1NzI0MzUzNjEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNTkuNTgxMDA3NzA4NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA1OS45OTg5NjY4OTIyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNjAuNDIyNzMxMDY0NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA2MC44NDA2OTAyNDgyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDYxLjI1ODY0OTQzMTgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNjEuNjg4MjE4NTkyOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDYyLjExMTk4Mjc2NTIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNjIuNTM1NzQ2OTM3NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA2Mi45NTM3MDYxMjEyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDYzLjM3NzQ3MDI5MzUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA2My44MDEyMzQ0NjU4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDY0LjIyNDk5ODYzODIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNjQuNjQyOTU3ODIxOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA2NS4wNjA5MTcwMDU1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNjUuNDg0NjgxMTc3OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA2NS45MDI2NDAzNjE1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDY2LjMyNjQwNDUzMzksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNjYuNzUwMTY4NzA2MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDY3LjE3MzkzMjg3ODUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNjcuNTk3Njk3MDUwOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA2OC4wMzMwNzEyMDA1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDY4LjQ2MjY0MDM2MTUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA2OC44ODY0MDQ1MzM5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDY5LjMxMDE2ODcwNjIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNjkuNzI4MTI3ODg5OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA3MC4xNDYwODcwNzM2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNzAuNTY5ODUxMjQ1OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA3MC45ODc4MTA0Mjk2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDcxLjQwNTc2OTYxMzIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNzEuODI5NTMzNzg1NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDcyLjI0NzQ5Mjk2OTIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNzIuNjc3MDYyMTMwMixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA3My4wOTUwMjEzMTM5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDczLjUxODc4NTQ4NjMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA3My45MzY3NDQ2Njk5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDc0LjM2MDUwODg0MjMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNzQuNzg0MjczMDE0NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA3NS4yMDgwMzcxODY5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNzUuNjMxODAxMzU5MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA3Ni4wNTU1NjU1MzE2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDc2LjQ3OTMyOTcwMzksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNzYuOTAzMDkzODc2MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDc3LjMyNjg1ODA0ODYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNzcuNzUwNjIyMjIwOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA3OC4xNzQzODYzOTMzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDc4LjYwMzk1NTU1NDMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA3OS4wMjE5MTQ3MzgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogNzkuNDQ1Njc4OTEwMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA3OS44Njk0NDMwODI2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDgwLjI5MzIwNzI1NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDgwLjcxMTE2NjQzODYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogODEuMTM0OTMwNjExLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDgxLjU1ODY5NDc4MzMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogODEuOTc2NjUzOTY3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogODIuNDAwNDE4MTM5MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA4Mi44MjQxODIzMTE3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDgzLjI0Nzk0NjQ4NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA4My42NjU5MDU2Njc3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogODQuMDg5NjY5ODQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogODQuNTEzNDM0MDEyMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA4NC45MzEzOTMxOTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogODUuMzQ5MzUyMzc5NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDg1Ljc3MzExNjU1MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA4Ni4xOTEwNzU3MzU3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDg2LjYxNDgzOTkwOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA4Ny4wMzI3OTkwOTE3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogODcuNDU2NTYzMjY0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDg3Ljg4MDMyNzQzNjQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogODguMzA0MDkxNjA4NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA4OC43MzM2NjA3Njk3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogODkuMTU3NDI0OTQyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDg5LjU4MTE4OTExNDQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogODkuOTk5MTQ4Mjk4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDkwLjQyMjkxMjQ3MDQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA5MC44NDY2NzY2NDI3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDkxLjI3MDQ0MDgxNTEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogOTEuNjg4Mzk5OTk4NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA5Mi4xMTIxNjQxNzExLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogOTIuNTMwMTIzMzU0NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA5Mi45NTM4ODc1MjcxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDkzLjM4MzQ1NjY4ODEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogOTMuODAxNDE1ODcxNyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDk0LjIyNTE4MDA0NDEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogOTQuNjQzMTM5MjI3OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA5NS4wNjY5MDM0MDAxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDk1LjQ5MDY2NzU3MjQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA5NS45MTQ0MzE3NDQ4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDk2LjMzMjM5MDkyODQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogOTYuNzU2MTU1MTAwOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA5Ny4xNzk5MTkyNzMxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogOTcuNjAzNjgzNDQ1NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiA5OC4wMjE2NDI2MjkxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDk4LjQ0NTQwNjgwMTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogOTguODYzMzY1OTg1MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDk5LjI4NzEzMDE1NzUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogOTkuNzEwODk0MzI5OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMDAuMTQwNDYzNDkwOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMDAuNTY0MjI3NjYzMSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEwMC45ODIxODY4NDY4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEwMS40MDU5NTEwMTkxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEwMS44Mjk3MTUxOTE1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEwMi4yNTM0NzkzNjM4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTAyLjY3NzI0MzUzNjEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTAzLjEwMTAwNzcwODUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTAzLjUyNDc3MTg4MDgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTAzLjk0MjczMTA2NDUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMDQuMzY2NDk1MjM2OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMDQuNzkwMjU5NDA5MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMDUuMjA4MjE4NTkyOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMDUuNjMxOTgyNzY1MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEwNi4wNTU3NDY5Mzc1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEwNi40NzM3MDYxMjEyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEwNi45MDMyNzUyODIyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEwNy4zMjcwMzk0NTQ1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTA3Ljc0NDk5ODYzODIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTA4LjE2ODc2MjgxMDUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTA4LjU5MjUyNjk4MjksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTA5LjAxMDQ4NjE2NjUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMDkuNDM0MjUwMzM4OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMDkuODUyMjA5NTIyNSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMTAuMjc1OTczNjk0OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMTAuNjk5NzM3ODY3MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDExMS4xMjM1MDIwMzk1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDExMS41NDcyNjYyMTE5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDExMS45ODI2NDAzNjE1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDExMi40MDA1OTk1NDUyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTEyLjgxODU1ODcyODksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTEzLjI0MjMyMjkwMTIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTEzLjY2NjA4NzA3MzYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTE0LjA4OTg1MTI0NTksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMTQuNTEzNjE1NDE4MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMTQuOTMxNTc0NjAxOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMTUuMzU1MzM4Nzc0MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMTUuNzc5MTAyOTQ2NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDExNi4yMDI4NjcxMTg5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDExNi42MjY2MzEyOTEyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDExNy4wNDQ1OTA0NzQ5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDExNy40NjgzNTQ2NDczLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTE3Ljg5MjExODgxOTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTE4LjMxNTg4Mjk5MTksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTE4LjczMzg0MjE3NTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTE5LjE1NzYwNjM0NzksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMTkuNTgxMzcwNTIwMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMTkuOTk5MzI5NzAzOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMjAuNDI4ODk4ODY0OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMjAuODQ2ODU4MDQ4NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyMS4yNzA2MjIyMjA5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyMS42OTQzODYzOTMzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyMi4xMTgxNTA1NjU2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyMi41NDE5MTQ3MzgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMjIuOTU5ODczOTIxNixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMjMuMzgzNjM4MDk0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyMy44MDc0MDIyNjYzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyNC4yMjUzNjE0NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyNC42NDkxMjU2MjIzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyNS4wNzI4ODk3OTQ2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyNS40OTA4NDg5NzgzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyNS45MTQ2MTMxNTA3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTI2LjMzODM3NzMyMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMjYuNzU2MzM2NTA2NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMjcuMTgwMTAwNjc5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyNy42MDM4NjQ4NTEzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTI4LjAyMTgyNDAzNSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMjguNDQ1NTg4MjA3MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMjguODY5MzUyMzc5NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMjkuMjg3MzExNTYzNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEyOS43MTEwNzU3MzU3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEzMC4xNDA2NDQ4OTY3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEzMC41NjQ0MDkwNjksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTMwLjk4MjM2ODI1MjcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMzEuNDA2MTMyNDI1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEzMS44MjQwOTE2MDg3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEzMi4yNDc4NTU3ODEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTMyLjY3MTYxOTk1MzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMzMuMTAxMTg5MTE0NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMzMuNTEzMzQzMzA5NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMzMuOTQyOTEyNDcwNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMzQuMzY2Njc2NjQyNyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEzNC43ODQ2MzU4MjY0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEzNS4yMDgzOTk5OTg3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEzNS42Mzc5NjkxNTk3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEzNi4wNTAxMjMzNTQ3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTM2LjQ3Mzg4NzUyNzEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTM2Ljg5MTg0NjcxMDcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTM3LjMxNTYxMDg4MzEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTM3LjczOTM3NTA1NTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMzguMTU3MzM0MjM5MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMzguNTgxMDk4NDExNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMzkuMDA0ODYyNTgzOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxMzkuNDI4NjI2NzU2MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDEzOS44NTIzOTA5Mjg0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE0MC4yNzAzNTAxMTIxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE0MC42OTQxMTQyODQ0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE0MS4xMTc4Nzg0NTY4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTQxLjU0MTY0MjYyOTEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTQxLjk2NTQwNjgwMTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTQyLjM4OTE3MDk3MzgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTQyLjgxMjkzNTE0NjEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNDMuMjM2Njk5MzE4NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNDMuNjU0NjU4NTAyMSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNDQuMDc4NDIyNjc0NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNDQuNDk2MzgxODU4MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE0NC45MjU5NTEwMTkxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE0NS4zNDk3MTUxOTE1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE0NS43NzM0NzkzNjM4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE0Ni4yMDMwNDg1MjQ4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTQ2LjYyMTAwNzcwODUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTQ3LjA0NDc3MTg4MDgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTQ3LjQ3NDM0MTA0MTgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTQ3Ljg5ODEwNTIxNDEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNDguMzE2MDY0Mzk3OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNDguNzM0MDIzNTgxNSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNDkuMTUxOTgyNzY1MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNDkuNTc1NzQ2OTM3NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE0OS45OTk1MTExMDk4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE1MC40MjMyNzUyODIyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE1MC44NDEyMzQ0NjU4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE1MS4yNjQ5OTg2MzgyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTUxLjY4ODc2MjgxMDUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTUyLjExMjUyNjk4MjksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTUyLjUzMDQ4NjE2NjUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTUyLjk1NDI1MDMzODksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNTMuMzcyMjA5NTIyNSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNTMuNzk1OTczNjk0OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNTQuMjE5NzM3ODY3MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNTQuNjQzNTAyMDM5NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE1NS4wNjcyNjYyMTE5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE1NS40ODUyMjUzOTU2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE1NS45MTQ3OTQ1NTY2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE1Ni4zMzg1NTg3Mjg5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTU2Ljc2ODEyNzg4OTksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTU3LjE4NjA4NzA3MzYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTU3LjYwOTg1MTI0NTksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTU4LjAzMzYxNTQxODIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNTguNDUxNTc0NjAxOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNTguODc1MzM4Nzc0MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNTkuMjkzMjk3OTU3OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNTkuNzE3MDYyMTMwMixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE2MC4xNDA4MjYzMDI2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE2MC41NTg3ODU0ODYzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE2MC45ODI1NDk2NTg2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE2MS40MDYzMTM4MzA5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTYxLjgzMDA3ODAwMzMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTYyLjI1Mzg0MjE3NTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTYyLjY3NzYwNjM0NzksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTYzLjEwMTM3MDUyMDMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNjMuNTI1MTM0NjkyNixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNjMuOTQ4ODk4ODY0OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNjQuMzcyNjYzMDM3MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNjQuNzkwNjIyMjIwOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE2NS4yMDg1ODE0MDQ2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE2NS42MzIzNDU1NzcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTY2LjA1MDMwNDc2MDYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTY2LjQ2ODI2Mzk0NDMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNjYuODkyMDI4MTE2NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNjcuMzE1NzkyMjg5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE2Ny43MzM3NTE0NzI3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE2OC4xNTc1MTU2NDUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNjguNTgxMjc5ODE3MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNjkuMDA1MDQzOTg5NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNjkuNDM0NjEzMTUwNyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNjkuODU4Mzc3MzIzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTcwLjI4MjE0MTQ5NTMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTcwLjcwNTkwNTY2NzcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTcxLjEyOTY2OTg0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE3MS41NTM0MzQwMTIzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTcxLjk3NzE5ODE4NDcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTcyLjM5NTE1NzM2ODMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTcyLjgxODkyMTU0MDcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTczLjIzNjg4MDcyNDQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNzMuNjU0ODM5OTA4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE3NC4wNzg2MDQwODA0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE3NC41MDIzNjgyNTI3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE3NC45MzE5Mzc0MTM3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTc1LjM1NTcwMTU4NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNzUuNzc5NDY1NzU4NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNzYuMjAzMjI5OTMwNyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxNzYuNjIxMTg5MTE0NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE3Ny4wNDQ5NTMyODY3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE3Ny40NjI5MTI0NzA0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE3Ny44ODY2NzY2NDI3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE3OC4zMDQ2MzU4MjY0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTc4LjcyODM5OTk5ODcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTc5LjE0NjM1OTE4MjQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTc5LjU3MDEyMzM1NDcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTc5Ljk5Mzg4NzUyNzEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxODAuNDE3NjUxNjk5NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxODAuODM1NjEwODgzMSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxODEuMjU5Mzc1MDU1NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxODEuNjgzMTM5MjI3OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE4Mi4xMDY5MDM0MDAxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE4Mi41MjQ4NjI1ODM4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE4Mi45NTQ0MzE3NDQ4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE4My4zNzIzOTA5Mjg0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTgzLjgwMTk2MDA4OTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTg0LjIyNTcyNDI2MTgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTg0LjY0MzY4MzQ0NTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTg1LjA2NzQ0NzYxNzgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxODUuNDkxMjExNzkwMSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxODUuOTA5MTcwOTczOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxODYuMzMyOTM1MTQ2MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxODYuNzUwODk0MzI5OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE4Ny4xODA0NjM0OTA4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE4Ny42MDQyMjc2NjMxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE4OC4wMzM3OTY4MjQxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE4OC40NTc1NjA5OTY1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTg4Ljg4MTMyNTE2ODgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTg5LjI5OTI4NDM1MjUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTg5LjcyODg1MzUxMzUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTkwLjE1MjYxNzY4NTgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxOTAuNTc2MzgxODU4MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxOTAuOTk0MzQxMDQxOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxOTEuNDIzOTEwMjAyOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxOTEuODQxODY5Mzg2NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE5Mi4yNjU2MzM1NTg4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE5Mi42Nzc3ODc3NTM4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE5My4xMDczNTY5MTQ4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE5My41MjUzMTYwOTg1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTkzLjk0OTA4MDI3MDgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTk0LjM3Mjg0NDQ0MzIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTk0Ljc5NjYwODYxNTUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTk1LjIxNDU2Nzc5OTIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxOTUuNjM4MzMxOTcxNSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxOTYuMDU2MjkxMTU1MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxOTYuNDg1ODYwMzE2MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAxOTYuOTAzODE5NDk5OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE5Ny4zMzMzODg2NjA5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE5Ny43NTEzNDc4NDQ1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE5OC4xNzUxMTIwMTY5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDE5OC41OTg4NzYxODkyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTk5LjAxNjgzNTM3MjksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTk5LjQzNDc5NDU1NjYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMTk5Ljg2NDM2MzcxNzUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjAwLjI4MjMyMjkwMTIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMDAuNzAwMjgyMDg0OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMDEuMTI0MDQ2MjU3MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMDEuNTQ3ODEwNDI5NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMDEuOTcxNTc0NjAxOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIwMi4zOTUzMzg3NzQyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIwMi44MTkxMDI5NDY2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIwMy4yNDI4NjcxMTg5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIwMy42NjY2MzEyOTEyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjA0LjA5MDM5NTQ2MzYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjA0LjUwODM1NDY0NzMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjA0LjkzMjExODgxOTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjA1LjM1NTg4Mjk5MTksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMDUuNzc5NjQ3MTY0MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMDYuMTk3NjA2MzQ3OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMDYuNjIxMzcwNTIwMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMDcuMDQ1MTM0NjkyNixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIwNy40NjMwOTM4NzYzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIwNy44ODY4NTgwNDg2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIwOC4zMTY0MjcyMDk2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIwOC43MzQzODYzOTMzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjA5LjE1ODE1MDU2NTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjA5LjU4MTkxNDczOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMTAuMDA1Njc4OTEwMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxMC40Mjk0NDMwODI2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxMC44NDc0MDIyNjYzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxMS4yNzExNjY0Mzg2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjExLjY5NDkzMDYxMSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMTIuMTE4Njk0NzgzMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMTIuNTM2NjUzOTY3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxMi45NjA0MTgxMzkzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjEzLjM4NDE4MjMxMTcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjEzLjgwNzk0NjQ4NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMTQuMjMxNzEwNjU2MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxNC42NDM4NjQ4NTEzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxNS4wNjc2MjkwMjM3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxNS40OTEzOTMxOTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjE1LjkwOTM1MjM3OTcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMTYuMzMzMTE2NTUyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxNi43NTY4ODA3MjQ0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxNy4xODA2NDQ4OTY3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjE3LjU5ODYwNDA4MDQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjE4LjAyMjM2ODI1MjcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjE4LjQ0NjEzMjQyNSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMTguODY5ODk2NTk3NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxOS4yOTM2NjA3Njk3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIxOS43MTc0MjQ5NDIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjIwLjE0MTE4OTExNDQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjIwLjU2NDk1MzI4NjcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMjAuOTgyOTEyNDcwNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMjEuNDA2Njc2NjQyNyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMjEuODMwNDQwODE1MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMjIuMjU0MjA0OTg3NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIyMi42Nzc5NjkxNTk3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIyMy4xMDE3MzMzMzIxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIyMy41MjU0OTc1MDQ0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIyMy45NTUwNjY2NjU0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjI0LjM3MzAyNTg0OTEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjI0Ljc5Njc5MDAyMTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjI1LjIyMDU1NDE5MzcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjI1LjYzODUxMzM3NzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMjYuMDYyMjc3NTQ5NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMjYuNDgwMjM2NzMzNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMjYuOTA0MDAwOTA1OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMjcuMzI3NzY1MDc4MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIyNy43NDU3MjQyNjE4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIyOC4xNjk0ODg0MzQxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIyOC41OTMyNTI2MDY0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIyOS4wMTcwMTY3Nzg4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjI5LjQ0MDc4MDk1MTEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjI5Ljg2NDU0NTEyMzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjMwLjI4MjUwNDMwNzEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjMwLjcwNjI2ODQ3OTUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMzEuMTMwMDMyNjUxOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMzEuNTQ3OTkxODM1NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMzEuOTcxNzU2MDA3OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMzIuMzk1NTIwMTgwMSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIzMi44MTkyODQzNTI1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIzMy4yNDMwNDg1MjQ4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIzMy42NzI2MTc2ODU4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIzNC4wOTYzODE4NTgxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjM0LjUyMDE0NjAzMDUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjM0LjkzODEwNTIxNDEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjM1LjM2MTg2OTM4NjUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjM1Ljc3OTgyODU3MDIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMzYuMTk3Nzg3NzUzOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMzYuNjIxNTUxOTI2MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMzcuMDM5NTExMTA5OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyMzcuNDYzMjc1MjgyMixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIzNy44ODcwMzk0NTQ1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIzOC4zMTA4MDM2MjY4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIzOC43MzQ1Njc3OTkyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDIzOS4xNTgzMzE5NzE1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjM5LjU4MjA5NjE0MzksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjQwLjAwNTg2MDMxNjIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjQwLjQyOTYyNDQ4ODUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjQwLjg1MzM4ODY2MDksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNDEuMjc3MTUyODMzMixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNDEuNjk1MTEyMDE2OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNDIuMTE4ODc2MTg5MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNDIuNTM2ODM1MzcyOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI0Mi45NjA1OTk1NDUyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI0My4zNzg1NTg3Mjg5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI0My44MDIzMjI5MDEyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI0NC4yMjAyODIwODQ5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjQ0LjY0NDA0NjI1NzIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjQ1LjA2NzgxMDQyOTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjQ1LjQ5MTU3NDYwMTksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjQ1LjkxNTMzODc3NDIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNDYuMzM5MTAyOTQ2NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNDYuNzU3MDYyMTMwMixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNDcuMTgwODI2MzAyNixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNDcuNjA0NTkwNDc0OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI0OC4wMjgzNTQ2NDczLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI0OC40NDYzMTM4MzA5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI0OC44NjQyNzMwMTQ2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI0OS4yODgwMzcxODY5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjQ5LjcxMTgwMTM1OTMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjUwLjEzNTU2NTUzMTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjUwLjU1OTMyOTcwMzksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjUwLjk4MzA5Mzg3NjMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNTEuNDA2ODU4MDQ4NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNTEuODI0ODE3MjMyMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNTIuMjU0Mzg2MzkzMyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNTIuNjcyMzQ1NTc3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjUzLjA5NjEwOTc0OTMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjUzLjUyNTY3ODkxMDMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjUzLjk0OTQ0MzA4MjYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjU0LjM3MzIwNzI1NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI1NC43OTExNjY0Mzg2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI1NS4yMjA3MzU1OTk2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI1NS42NDQ0OTk3NzIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjU2LjA2MjQ1ODk1NTYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNTYuNDgwNDE4MTM5MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNTYuOTA0MTgyMzExNyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNTcuMzIyMTQxNDk1MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNTcuNzQ1OTA1NjY3NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI1OC4xNjk2Njk4NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNTguNTg3NjI5MDIzNyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNTkuMDExMzkzMTk2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI1OS40MzUxNTczNjgzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjU5Ljg1ODkyMTU0MDcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjYwLjI3Njg4MDcyNDQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjYwLjcwMDY0NDg5NjcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjYxLjEyNDQwOTA2OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI2MS41NDgxNzMyNDE0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI2MS45NjYxMzI0MjUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjYyLjM4OTg5NjU5NzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjYyLjgxMzY2MDc2OTcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNjMuMjMxNjE5OTUzNCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNjMuNjU1Mzg0MTI1NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNjQuMDc5MTQ4Mjk4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI2NC41MDI5MTI0NzA0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjY0LjkyNjY3NjY0MjcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjY1LjM1MDQ0MDgxNTEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjY1Ljc3NDIwNDk4NzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjY2LjE5Nzk2OTE1OTcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNjYuNjIxNzMzMzMyMSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNjcuMDQ1NDk3NTA0NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNjcuNDc1MDY2NjY1NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNjcuODkzMDI1ODQ5MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI2OC4zMTA5ODUwMzI3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI2OC43Mjg5NDQyMTY0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI2OS4xNTI3MDgzODg4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI2OS41NzY0NzI1NjExLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjcwLjAwMDIzNjczMzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjcwLjQyNDAwMDkwNTgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjcwLjg0MTk2MDA4OTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjcxLjI2NTcyNDI2MTgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNzEuNjg5NDg4NDM0MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNzIuMTEzMjUyNjA2NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNzIuNTM3MDE2Nzc4OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNzIuOTY2NTg1OTM5OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI3My4zNzg3NDAxMzQ4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI3My44MDI1MDQzMDcxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI3NC4yMjYyNjg0Nzk1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI3NC42NDQyMjc2NjMxLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjc1LjA2Nzk5MTgzNTUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjc1LjQ5MTc1NjAwNzgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjc1LjkxNTUyMDE4MDEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjc2LjMzOTI4NDM1MjUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNzYuNzYzMDQ4NTI0OCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNzcuMTgxMDA3NzA4NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNzcuNjA0NzcxODgwOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyNzguMDI4NTM2MDUzMSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI3OC40NDY0OTUyMzY4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI3OC44NzAyNTk0MDkyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI3OS4yODgyMTg1OTI4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI3OS43MTc3ODc3NTM4LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjgwLjE0MTU1MTkyNjIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjgwLjU2NTMxNjA5ODUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjgwLjk4OTA4MDI3MDgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjgxLjQxMjg0NDQ0MzIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyODEuODM2NjA4NjE1NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyODIuMjU0NTY3Nzk5MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyODIuNjc4MzMxOTcxNSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyODMuMDk2MjkxMTU1MixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI4My41MjU4NjAzMTYyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI4My45NDM4MTk0OTk5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI4NC4zNjE3Nzg2ODM1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI4NC43ODU1NDI4NTU5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjg1LjIxNTExMjAxNjksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjg1LjYzODg3NjE4OTIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjg2LjA2MjY0MDM2MTUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjg2LjQ4NjQwNDUzMzksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyODYuOTA0MzYzNzE3NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyODcuMzI4MTI3ODg5OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyODcuNzUxODkyMDYyMixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyODguMTc1NjU2MjM0NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI4OC41OTM2MTU0MTgyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI4OS4wMTE1NzQ2MDE5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI4OS40MzUzMzg3NzQyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI4OS44NTkxMDI5NDY2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjkwLjI3NzA2MjEzMDIsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjkwLjcwMDgyNjMwMjYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjkxLjEyNDU5MDQ3NDksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjkxLjU0ODM1NDY0NzMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyOTEuOTcyMTE4ODE5NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyOTIuMzk1ODgyOTkxOSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyOTIuODEzODQyMTc1NixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyOTMuMjM3NjA2MzQ3OSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI5My42NjEzNzA1MjAzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI5NC4wNzkzMjk3MDM5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI5NC41MDMwOTM4NzYzLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI5NC45MjY4NTgwNDg2LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjk1LjM0NDgxNzIzMjMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjk1Ljc1MTE2NjQzODYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjk2LjE2MzMyMDYzMzYsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjk2LjU4MTI3OTgxNzMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyOTcuMDA1MDQzOTg5NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyOTcuNDI4ODA4MTYyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI5Ny44NTgzNzczMjMsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMjk4LjI5Mzc1MTQ3MjcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyOTguNzIzMzIwNjMzNixcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyOTkuMTQxMjc5ODE3MyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAyOTkuNTQxODI0MDM1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDI5OS45NTk3ODMyMTg3LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzAwLjM3Nzc0MjQwMjQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzAwLjgwNzMxMTU2MzQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzAxLjIzNjg4MDcyNDQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzAxLjY1NDgzOTkwOCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMwMi4wNDk1NzkxMzcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzAyLjQ5MDc1ODI3NTQsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzAyLjkxNDUyMjQ0NzcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzAzLjMwOTI2MTY3NjcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMDMuNzQ0NjM1ODI2NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMDQuMTgwMDA5OTc2MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMDQuNjE1Mzg0MTI1NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMDUuMDU2NTYzMjY0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzA1LjQ4NjEzMjQyNSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMDUuOTMzMTE2NTUyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMwNi4zODAxMDA2NzksXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzA2Ljc5ODA1OTg2MjcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMDcuMjEwMjE0MDU3NyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMDcuNjIyMzY4MjUyNyxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMDguMDI4NzE3NDU5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMwOC40MzUwNjY2NjU0LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzA4Ljg0MTQxNTg3MTcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzA5LjI3MDk4NTAzMjcsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzA5LjY4MzEzOTIyNzgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzEwLjEwNjkwMzQwMDEsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiB0cnVlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMTAuNTE5MDU3NTk1MSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMTAuOTY2MDQxNzIyMSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMTEuMzcyMzkwOTI4NCxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IGZhbHNlLFxuICBcInBhdHRlcm5cIjogZmFsc2UsXG4gIFwiYmVhdFwiOiAxXG59LCB7XG4gIFwidGltZVwiOiAzMTEuNzE0ODg1MjU5NSxcbiAgXCJsZW5ndGhcIjogMCxcbiAgXCJtZWFzdXJlXCI6IHRydWUsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMxMi4xMDM4MTk0OTk5LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMxMi41MjE3Nzg2ODM1LFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogZmFsc2UsXG4gIFwicGF0dGVyblwiOiBmYWxzZSxcbiAgXCJiZWF0XCI6IDFcbn0sIHtcbiAgXCJ0aW1lXCI6IDMxMi45Mzk3Mzc4NjcyLFxuICBcImxlbmd0aFwiOiAwLFxuICBcIm1lYXN1cmVcIjogdHJ1ZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzEzLjQwOTk0MTk0ODgsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufSwge1xuICBcInRpbWVcIjogMzEzLjgyNzkwMTEzMjUsXG4gIFwibGVuZ3RoXCI6IDAsXG4gIFwibWVhc3VyZVwiOiBmYWxzZSxcbiAgXCJwYXR0ZXJuXCI6IGZhbHNlLFxuICBcImJlYXRcIjogMVxufV1cbiIsImV4cG9ydCBkZWZhdWx0IFtcbiAge1xuICAgIFwiYnVmZmVyXCI6IFwiLi9hc3NldHMvYXVkaW8vY2hlcm9rZWUud2F2XCIsXG4gICAgXCJ0aXRsZVwiOiBcIldobyBrbm93cz9cIixcbiAgICBcImJwbVwiOiA2MCxcbiAgICBcInNpZ25hdHVyZVwiOiBcIjQvNFwiLFxuICAgIFwibWFya2Vyc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGltZVwiOiAwLjEwNDI0MTkwNDc2MTkwNDc2LFxuICAgICAgICBcImxhYmVsXCI6IFwibGFiZWwgMFwiLFxuICAgICAgICBcImR1cmF0aW9uXCI6IDAuNVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0aW1lXCI6IDEuMTI4MDE0Mjg1NzE0Mjg1NixcbiAgICAgICAgXCJkdXJhdGlvblwiOiAxLFxuICAgICAgICBcImxhYmVsXCI6IFwibGFiZWwgMVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRpbWVcIjogMS43MDU0NDQ3NjE5MDQ3NjE3LFxuICAgICAgICBcImR1cmF0aW9uXCI6IDAuMSxcbiAgICAgICAgXCJsYWJlbFwiOiBcImxhYmVsIDJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwiYnVmZmVyXCI6IFwiLi9hc3NldHMvYXVkaW8vaGVuZHJpeC53YXZcIixcbiAgICBcInRpdGxlXCI6IFwiSHltbmVuXCIsXG4gICAgXCJicG1cIjogMTIwLFxuICAgIFwic2lnbmF0dXJlXCI6IFwiMy80XCIsXG4gICAgXCJtYXJrZXJzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0aW1lXCI6IDMuNzg3Mjg1NDQyMTc2ODcxLFxuICAgICAgICBcImR1cmF0aW9uXCI6IDIuMTg2MTk4OTExNTY0NjI3LFxuICAgICAgICBcImxhYmVsXCI6IFwibGFiZWwgMFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRpbWVcIjogOC4xOTcxOTA0NzYxOTA0NzUsXG4gICAgICAgIFwiZHVyYXRpb25cIjogMSxcbiAgICAgICAgXCJsYWJlbFwiOiBcImxhYmVsIDFcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0aW1lXCI6IDEyLjI5MzgxMzA2MTIyNDQ5MixcbiAgICAgICAgXCJkdXJhdGlvblwiOiAzLjU1NDY1MTQyODU3MTQyOSxcbiAgICAgICAgXCJsYWJlbFwiOiBcImxhYmVsIDJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0aW1lXCI6IDE3LjgyODQ2ODk3OTU5MTgzMyxcbiAgICAgICAgXCJsYWJlbFwiOiBcImxhYmVsXCIsXG4gICAgICAgIFwiZHVyYXRpb25cIjogMlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwiYnVmZmVyXCI6IFwiLi9hc3NldHMvYXVkaW8vaHVtYW4tdm9pY2Uud2F2XCIsXG4gICAgXCJ0aXRsZVwiOiBcIlNwZWVjaFwiLFxuICAgIFwiYnBtXCI6IDE0MCxcbiAgICBcInNpZ25hdHVyZVwiOiBcIjQvNFwiLFxuICAgIFwibWFya2Vyc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGltZVwiOiA4LjU4MzE1MDIwNDA4MTYzNSxcbiAgICAgICAgXCJkdXJhdGlvblwiOiAzLjQzNjE2MzI2NTMwNjEyMjUsXG4gICAgICAgIFwibGFiZWxcIjogXCJsYWJlbCAwXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGltZVwiOiAyNi4zNjg0NTA2MTIyNDQ5LFxuICAgICAgICBcImR1cmF0aW9uXCI6IDEsXG4gICAgICAgIFwibGFiZWxcIjogXCJsYWJlbCAxXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGltZVwiOiA0NC4zNDU4NTc5NTkxODM2OCxcbiAgICAgICAgXCJkdXJhdGlvblwiOiAyLjgwMTI3MDIwNDA4MTYzMixcbiAgICAgICAgXCJsYWJlbFwiOiBcImxhYmVsIDJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0aW1lXCI6IDE1LjkxNDAwNDg5Nzk1OTE4NSxcbiAgICAgICAgXCJsYWJlbFwiOiBcImxhYmVsIDAuMVwiLFxuICAgICAgICBcImR1cmF0aW9uXCI6IDIuMTc2MTY5Nzk1OTE4MzY3NVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0aW1lXCI6IDM3LjE3MTgyNjkzODc3NTUyLFxuICAgICAgICBcImxhYmVsXCI6IFwibGFiZWwgMS4xXCIsXG4gICAgICAgIFwiZHVyYXRpb25cIjogMlxuICAgICAgfVxuICAgIF1cbiAgfSxcbl1cbiIsIi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXIgKi9cblxuY29uc3QgdHlwZUNvdW50ZXJzID0ge307XG5cbi8qKlxuICogQmFzZSBjbGFzcyB0byBjcmVhdGUgbmV3IGNvbnRyb2xsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gU3RyaW5nIGRlc2NyaWJpbmcgdGhlIHR5cGUgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHMgLSBEZWZhdWx0IHBhcmFtZXRlcnMgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gVXNlciBkZWZpbmVkIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqL1xuY2xhc3MgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGRlZmF1bHRzLCBjb25maWcgPSB7fSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgY29uZmlnKTtcblxuICAgIC8vIGhhbmRsZSBpZFxuICAgIGlmICghdHlwZUNvdW50ZXJzW3R5cGVdKVxuICAgICAgdHlwZUNvdW50ZXJzW3R5cGVdID0gMDtcblxuICAgIGlmICghdGhpcy5wYXJhbXMuaWQpIHtcbiAgICAgIHRoaXMuaWQgPSBgJHt0eXBlfS0ke3R5cGVDb3VudGVyc1t0eXBlXX1gO1xuICAgICAgdHlwZUNvdW50ZXJzW3R5cGVdICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnBhcmFtcy5pZDtcbiAgICB9XG5cbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fZ3JvdXBMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyByZWdpc3RlciBjYWxsYmFjayBpZiBnaXZlblxuICAgIGlmICh0aGlzLnBhcmFtcy5jYWxsYmFjaylcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXIodGhpcy5wYXJhbXMuY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIHRoZSBjb250cm9sbGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGJlIGFwcGxpZWQgd2hlbiB0aGUgY29udHJvbGxlclxuICAgKiAgc3RhdGUgY2hhbmdlLlxuICAgKi9cbiAgYWRkTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMuYWRkKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGxpc3RlbmVyIGlzIGFkZGVkIGZyb20gYSBjb250YWluaW5nIGdyb3VwLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZEdyb3VwTGlzdGVuZXIoaWQsIGNhbGxJZCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxJZClcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXIoY2FsbGJhY2spO1xuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fZ3JvdXBMaXN0ZW5lcnMuYWRkKHsgY2FsbElkLCBjYWxsYmFjayB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgbGlzdGVuZXIgZnJvbSB0aGUgY29udHJvbGxlci5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgbGlzdGVuZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdG9kbyAtIHJlZXhwb3NlIHdoZW4gYGNvbnRhaW5lcmAgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kLi4uXG4gICAqL1xuICAvLyByZW1vdmVMaXN0ZW5lcihjYWxsYmFjaykge1xuICAvLyAgIHRoaXMuX2xpc3RlbmVycy5yZW1vdmUoY2FsbGJhY2spO1xuICAvLyB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGV4ZWN1dGVMaXN0ZW5lcnMoLi4udmFsdWVzKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayguLi52YWx1ZXMpKTtcblxuICAgIHRoaXMuX2dyb3VwTGlzdGVuZXJzLmZvckVhY2goKHBheWxvYWQpID0+IHtcbiAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIGNhbGxJZCB9ID0gcGF5bG9hZDtcbiAgICAgIGNhbGxiYWNrKGNhbGxJZCwgLi4udmFsdWVzKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlQ29tcG9uZW50O1xuIiwiaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9CYXNlQ29tcG9uZW50JztcbmltcG9ydCBkaXNwbGF5IGZyb20gJy4uL21peGlucy9kaXNwbGF5JztcblxuY29uc3QgQXVkaW9Db250ZXh0ID0gKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCk7XG5cbi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXJzICovXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBsYWJlbDogJ0RyYWcgYW5kIGRyb3AgYXVkaW8gZmlsZXMnLFxuICBsYWJlbFByb2Nlc3M6ICdwcm9jZXNzLi4uJyxcbiAgYXVkaW9Db250ZXh0OiBudWxsLFxuICBjb250YWluZXI6IG51bGwsXG4gIGNhbGxiYWNrOiBudWxsLFxufTtcblxuLyoqXG4gKiBEcmFnIGFuZCBkcm9wIHpvbmUgZm9yIGF1ZGlvIGZpbGVzIHJldHVybmluZyBgQXVkaW9CdWZmZXJgcyBhbmQvb3IgSlNPTlxuICogZGVzY3JpcHRvciBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5sYWJlbD0nRHJhZyBhbmQgZHJvcCBhdWRpbyBmaWxlcyddIC0gTGFiZWwgb2YgdGhlXG4gKiAgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxhYmVsUHJvY2Vzcz0ncHJvY2Vzcy4uLiddIC0gTGFiZWwgb2YgdGhlIGNvbnRyb2xsZXJcbiAqICB3aGlsZSBhdWRpbyBmaWxlcyBhcmUgZGVjb2RlZC5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBbY29uZmlnLmF1ZGlvQ29udGV4dD1udWxsXSAtIE9wdGlvbm5hbCBhdWRpbyBjb250ZXh0XG4gKiAgdG8gdXNlIGluIG9yZGVyIHRvIGRlY29kZSBhdWRpbyBmaWxlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8YmFzaWMtY29udHJvbGxlcn5Hcm91cH0gW2NvbmZpZy5jb250YWluZXI9bnVsbF0gLVxuICogIENvbnRhaW5lciBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2FsbGJhY2s9bnVsbF0gLSBDYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuIHRoZVxuICogIHZhbHVlIGNoYW5nZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJ2Jhc2ljLWNvbnRyb2xsZXJzJztcbiAqXG4gKiBjb25zdCBkcmFnQW5kRHJvcCA9IG5ldyBjb250cm9sbGVycy5EcmFnQW5kRHJvcCh7XG4gKiAgIGNvbnRhaW5lcjogJyNjb250YWluZXInLFxuICogICBjYWxsYmFjazogKHJlc3VsdHMpID0+IGNvbnNvbGUubG9nKHJlc3VsdHMpLFxuICogfSk7XG4gKi9cbmNsYXNzIERyYWdBbmREcm9wIGV4dGVuZHMgZGlzcGxheShCYXNlQ29tcG9uZW50KSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcignZHJhZy1hbmQtZHJvcCcsIGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcblxuICAgIGlmICghdGhpcy5wYXJhbXMuYXVkaW9Db250ZXh0KVxuICAgICAgdGhpcy5wYXJhbXMuYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCByZXN1bHRzXG4gICAqIEB0eXBlIHtPYmplY3Q8U3RyaW5nLCBBdWRpb0J1ZmZlcnxKU09OPn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwiZHJvcC16b25lXCI+XG4gICAgICAgIDxwIGNsYXNzPVwibGFiZWxcIj4ke2xhYmVsfTwvcD5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG5cbiAgICB0aGlzLiRlbCA9IHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgdGhpcy4kZHJvcFpvbmUgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuZHJvcC16b25lJyk7XG4gICAgdGhpcy4kbGFiZWwgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcubGFiZWwnKTtcblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGRyb3Bab25lLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHRoaXMuJGRyb3Bab25lLmNsYXNzTGlzdC5hZGQoJ2RyYWcnKTtcbiAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdGhpcy4kZHJvcFpvbmUuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHRoaXMuJGRyb3Bab25lLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWcnKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB0aGlzLiRkcm9wWm9uZS5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGNvbnN0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICBjb25zdCBhdWRpb0ZpbGVzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICAgIGlmICgvXmF1ZGlvLy50ZXN0KGZpbGUudHlwZSkpIHtcbiAgICAgICAgICBmaWxlLnNob3J0VHlwZSA9ICdhdWRpbyc7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoL2pzb24kLy50ZXN0KGZpbGUudHlwZSkpIHtcbiAgICAgICAgICBmaWxlLnNob3J0VHlwZSA9ICdqc29uJztcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0ge307XG4gICAgICBsZXQgY291bnRlciA9IDA7XG5cbiAgICAgIHRoaXMuJGxhYmVsLnRleHRDb250ZW50ID0gdGhpcy5wYXJhbXMubGFiZWxQcm9jZXNzO1xuXG4gICAgICBjb25zdCB0ZXN0RW5kID0gKCkgPT4ge1xuICAgICAgICBjb3VudGVyICs9IDE7XG5cbiAgICAgICAgaWYgKGNvdW50ZXIgPT09IGF1ZGlvRmlsZXMubGVuZ3RoKcKge1xuICAgICAgICAgIHRoaXMuX3ZhbHVlID0gcmVzdWx0c1xuICAgICAgICAgIHRoaXMuZXhlY3V0ZUxpc3RlbmVycyhyZXN1bHRzKTtcblxuICAgICAgICAgIHRoaXMuJGRyb3Bab25lLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWcnKTtcbiAgICAgICAgICB0aGlzLiRsYWJlbC50ZXh0Q29udGVudCA9IHRoaXMucGFyYW1zLmxhYmVsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICAgICAgaWYgKGZpbGUuc2hvcnRUeXBlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbZmlsZS5uYW1lXSA9IEpTT04ucGFyc2UoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIHRlc3RFbmQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpbGUuc2hvcnRUeXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5hdWRpb0NvbnRleHRcbiAgICAgICAgICAgICAgLmRlY29kZUF1ZGlvRGF0YShlLnRhcmdldC5yZXN1bHQpXG4gICAgICAgICAgICAgIC50aGVuKChhdWRpb0J1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbZmlsZS5uYW1lXSA9IGF1ZGlvQnVmZmVyO1xuICAgICAgICAgICAgICAgIHRlc3RFbmQoKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2ZpbGUubmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRlc3RFbmQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbGUuc2hvcnRUeXBlID09PSAnanNvbicpXG4gICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICAgIGVsc2UgaWYgKGZpbGUuc2hvcnRUeXBlID09PSAnYXVkaW8nKVxuICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICAgIH0pO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmFnQW5kRHJvcDtcbiIsImltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQgZGlzcGxheSBmcm9tICcuLi9taXhpbnMvZGlzcGxheSc7XG5pbXBvcnQgY29udGFpbmVyIGZyb20gJy4uL21peGlucy9jb250YWluZXInO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi4vdXRpbHMvZWxlbWVudHMnO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgbGVnZW5kOiAnJm5ic3A7JyxcbiAgZGVmYXVsdDogJ29wZW5lZCcsXG4gIGNvbnRhaW5lcjogbnVsbCxcbn07XG5cbi8qKlxuICogR3JvdXAgb2YgY29udHJvbGxlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubGFiZWwgLSBMYWJlbCBvZiB0aGUgZ3JvdXAuXG4gKiBAcGFyYW0geydvcGVuZWQnfCdjbG9zZWQnfSBbY29uZmlnLmRlZmF1bHQ9J29wZW5lZCddIC0gRGVmYXVsdCBzdGF0ZSBvZiB0aGVcbiAqICBncm91cC5cbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8YmFzaWMtY29udHJvbGxlcn5Hcm91cH0gW2NvbmZpZy5jb250YWluZXI9bnVsbF0gLVxuICogIENvbnRhaW5lciBvZiB0aGUgY29udHJvbGxlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgY29udHJvbGxlcnMgZnJvbSAnYmFzaWMtY29udHJvbGxlcnMnO1xuICpcbiAqIC8vIGNyZWF0ZSBhIGdyb3VwXG4gKiBjb25zdCBncm91cCA9IG5ldyBjb250cm9sbGVycy5Hcm91cCh7XG4gKiAgIGxhYmVsOiAnR3JvdXAnLFxuICogICBkZWZhdWx0OiAnb3BlbmVkJyxcbiAqICAgY29udGFpbmVyOiAnI2NvbnRhaW5lcidcbiAqIH0pO1xuICpcbiAqIC8vIGluc2VydCBjb250cm9sbGVycyBpbiB0aGUgZ3JvdXBcbiAqIGNvbnN0IGdyb3VwU2xpZGVyID0gbmV3IGNvbnRyb2xsZXJzLlNsaWRlcih7XG4gKiAgIGxhYmVsOiAnR3JvdXAgU2xpZGVyJyxcbiAqICAgbWluOiAyMCxcbiAqICAgbWF4OiAxMDAwLFxuICogICBzdGVwOiAxLFxuICogICBkZWZhdWx0OiAyMDAsXG4gKiAgIHVuaXQ6ICdIeicsXG4gKiAgIHNpemU6ICdsYXJnZScsXG4gKiAgIGNvbnRhaW5lcjogZ3JvdXAsXG4gKiAgIGNhbGxiYWNrOiAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGdyb3VwVGV4dCA9IG5ldyBjb250cm9sbGVycy5UZXh0KHtcbiAqICAgbGFiZWw6ICdHcm91cCBUZXh0JyxcbiAqICAgZGVmYXVsdDogJ3RleHQgaW5wdXQnLFxuICogICByZWFkb25seTogZmFsc2UsXG4gKiAgIGNvbnRhaW5lcjogZ3JvdXAsXG4gKiAgIGNhbGxiYWNrOiAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlKSxcbiAqIH0pO1xuICovXG5jbGFzcyBHcm91cCBleHRlbmRzIGNvbnRhaW5lcihkaXNwbGF5KEJhc2VDb21wb25lbnQpKSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCdncm91cCcsIGRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgdGhpcy5fc3RhdGVzID0gWydvcGVuZWQnLCAnY2xvc2VkJ107XG5cbiAgICBpZiAodGhpcy5fc3RhdGVzLmluZGV4T2YodGhpcy5wYXJhbXMuZGVmYXVsdCkgPT09IC0xKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlIFwiJHt2YWx1ZX1cImApO1xuXG4gICAgdGhpcy5fc3RhdGUgPSB0aGlzLnBhcmFtcy5kZWZhdWx0O1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRlIG9mIHRoZSBncm91cCAoYCdvcGVuZWQnYCBvciBgJ2Nsb3NlZCdgKS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYHZhbHVlYC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICBzZXQgc3RhdGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc3RhdGVzLmluZGV4T2YodmFsdWUpID09PSAtMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZSBcIiR7dmFsdWV9XCJgKTtcblxuICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fc3RhdGUpO1xuICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5hZGQodmFsdWUpO1xuXG4gICAgdGhpcy5fc3RhdGUgPSB2YWx1ZTtcbiAgfVxuXG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgY29udGVudCA9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJncm91cC1oZWFkZXJcIj5cbiAgICAgICAgJHtlbGVtZW50cy5zbWFsbEFycm93UmlnaHR9XG4gICAgICAgICR7ZWxlbWVudHMuc21hbGxBcnJvd0JvdHRvbX1cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbFwiPiR7dGhpcy5wYXJhbXMubGFiZWx9PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiZ3JvdXAtY29udGVudFwiPjwvZGl2PlxuICAgIGA7XG5cbiAgICB0aGlzLiRlbCA9IHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCh0aGlzLl9zdGF0ZSk7XG5cbiAgICB0aGlzLiRoZWFkZXIgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuZ3JvdXAtaGVhZGVyJyk7XG4gICAgdGhpcy4kY29udGFpbmVyID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmdyb3VwLWNvbnRlbnQnKTtcblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiRoZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlID09PSAnY2xvc2VkJyA/ICdvcGVuZWQnIDogJ2Nsb3NlZCc7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR3JvdXA7XG4iLCJpbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL0Jhc2VDb21wb25lbnQnO1xuaW1wb3J0IGRpc3BsYXkgZnJvbSAnLi4vbWl4aW5zL2Rpc3BsYXknO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi4vdXRpbHMvZWxlbWVudHMnO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgbGFiZWw6ICcmbmJzcDsnLFxuICBtaW46IDAsXG4gIG1heDogMSxcbiAgc3RlcDogMC4wMSxcbiAgZGVmYXVsdDogMCxcbiAgY29udGFpbmVyOiBudWxsLFxuICBjYWxsYmFjazogbnVsbCxcbn07XG5cbi8qKlxuICogTnVtYmVyIEJveCBjb250cm9sbGVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubGFiZWwgLSBMYWJlbCBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm1pbj0wXSAtIE1pbmltdW0gdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5tYXg9MV0gLSBNYXhpbXVtIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3RlcD0wLjAxXSAtIFN0ZXAgYmV0d2VlbiBjb25zZWN1dGl2ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kZWZhdWx0PTBdIC0gRGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8YmFzaWMtY29udHJvbGxlcn5Hcm91cH0gW2NvbmZpZy5jb250YWluZXI9bnVsbF0gLVxuICogIENvbnRhaW5lciBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2FsbGJhY2s9bnVsbF0gLSBDYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuIHRoZVxuICogIHZhbHVlIGNoYW5nZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJ2Jhc2ljLWNvbnRyb2xsZXJzJztcbiAqXG4gKiBjb25zdCBudW1iZXJCb3ggPSBuZXcgY29udHJvbGxlcnMuTnVtYmVyQm94KHtcbiAqICAgbGFiZWw6ICdNeSBOdW1iZXIgQm94JyxcbiAqICAgbWluOiAwLFxuICogICBtYXg6IDEwLFxuICogICBzdGVwOiAwLjEsXG4gKiAgIGRlZmF1bHQ6IDUsXG4gKiAgIGNvbnRhaW5lcjogJyNjb250YWluZXInLFxuICogICBjYWxsYmFjazogKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSksXG4gKiB9KTtcbiAqL1xuY2xhc3MgTnVtYmVyQm94IGV4dGVuZHMgZGlzcGxheShCYXNlQ29tcG9uZW50KSB7XG4gIC8vIGxlZ2VuZCwgbWluID0gMCwgbWF4ID0gMSwgc3RlcCA9IDAuMDEsIGRlZmF1bHRWYWx1ZSA9IDAsICRjb250YWluZXIgPSBudWxsLCBjYWxsYmFjayA9IG51bGxcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoJ251bWJlci1ib3gnLCBkZWZhdWx0cywgY29uZmlnKTtcblxuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5wYXJhbXMuZGVmYXVsdDtcbiAgICB0aGlzLl9pc0ludFN0ZXAgPSAodGhpcy5wYXJhbXMuc3RlcCAlIDEgPT09IDApO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgdmFsdWUgb2YgdGhlIGNvbnRyb2xsZXIuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgLy8gdXNlICRudW1iZXIgZWxlbWVudCBtaW4sIG1heCBhbmQgc3RlcCBzeXN0ZW1cbiAgICB0aGlzLiRudW1iZXIudmFsdWUgPSB2YWx1ZTtcbiAgICB2YWx1ZSA9IHRoaXMuJG51bWJlci52YWx1ZTtcbiAgICB2YWx1ZSA9IHRoaXMuX2lzSW50U3RlcCA/IHBhcnNlSW50KHZhbHVlLCAxMCkgOiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGxhYmVsLCBtaW4sIG1heCwgc3RlcCB9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY29udGVudCA9IGBcbiAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj4ke2xhYmVsfTwvc3Bhbj5cbiAgICAgIDxkaXYgY2xhc3M9XCJpbm5lci13cmFwcGVyXCI+XG4gICAgICAgICR7ZWxlbWVudHMuYXJyb3dMZWZ0fVxuICAgICAgICA8aW5wdXQgY2xhc3M9XCJudW1iZXJcIiB0eXBlPVwibnVtYmVyXCIgbWluPVwiJHttaW59XCIgbWF4PVwiJHttYXh9XCIgc3RlcD1cIiR7c3RlcH1cIiB2YWx1ZT1cIiR7dGhpcy5fdmFsdWV9XCIgLz5cbiAgICAgICAgJHtlbGVtZW50cy5hcnJvd1JpZ2h0fVxuICAgICAgPC9kaXY+XG4gICAgYDtcblxuICAgIHRoaXMuJGVsID0gc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCgnYWxpZ24tc21hbGwnKTtcbiAgICB0aGlzLiRlbC5pbm5lckhUTUwgPSBjb250ZW50O1xuXG4gICAgdGhpcy4kcHJldiA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5hcnJvdy1sZWZ0Jyk7XG4gICAgdGhpcy4kbmV4dCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5hcnJvdy1yaWdodCcpO1xuICAgIHRoaXMuJG51bWJlciA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJudW1iZXJcIl0nKTtcblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiRwcmV2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnBhcmFtcy5zdGVwO1xuICAgICAgY29uc3QgZGVjaW1hbHMgPSBzdGVwLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXTtcbiAgICAgIGNvbnN0IGV4cCA9IGRlY2ltYWxzID8gZGVjaW1hbHMubGVuZ3RoIDogMDtcbiAgICAgIGNvbnN0IG11bHQgPSBNYXRoLnBvdygxMCwgZXhwKTtcblxuICAgICAgY29uc3QgaW50VmFsdWUgPSBNYXRoLmZsb29yKHRoaXMuX3ZhbHVlICogbXVsdCArIDAuNSk7XG4gICAgICBjb25zdCBpbnRTdGVwID0gTWF0aC5mbG9vcihzdGVwICogbXVsdCArIDAuNSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IChpbnRWYWx1ZSAtIGludFN0ZXApIC8gbXVsdDtcblxuICAgICAgdGhpcy5fcHJvcGFnYXRlKHZhbHVlKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB0aGlzLiRuZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnBhcmFtcy5zdGVwO1xuICAgICAgY29uc3QgZGVjaW1hbHMgPSBzdGVwLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXTtcbiAgICAgIGNvbnN0IGV4cCA9IGRlY2ltYWxzID8gZGVjaW1hbHMubGVuZ3RoIDogMDtcbiAgICAgIGNvbnN0IG11bHQgPSBNYXRoLnBvdygxMCwgZXhwKTtcblxuICAgICAgY29uc3QgaW50VmFsdWUgPSBNYXRoLmZsb29yKHRoaXMuX3ZhbHVlICogbXVsdCArIDAuNSk7XG4gICAgICBjb25zdCBpbnRTdGVwID0gTWF0aC5mbG9vcihzdGVwICogbXVsdCArIDAuNSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IChpbnRWYWx1ZSArIGludFN0ZXApIC8gbXVsdDtcblxuICAgICAgdGhpcy5fcHJvcGFnYXRlKHZhbHVlKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB0aGlzLiRudW1iZXIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXMuJG51bWJlci52YWx1ZTtcbiAgICAgIHZhbHVlID0gdGhpcy5faXNJbnRTdGVwID8gcGFyc2VJbnQodmFsdWUsIDEwKSA6IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgdmFsdWUgPSBNYXRoLm1pbih0aGlzLnBhcmFtcy5tYXgsIE1hdGgubWF4KHRoaXMucGFyYW1zLm1pbiwgdmFsdWUpKTtcblxuICAgICAgdGhpcy5fcHJvcGFnYXRlKHZhbHVlKTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3Byb3BhZ2F0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fdmFsdWUpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuJG51bWJlci52YWx1ZSA9IHZhbHVlO1xuXG4gICAgdGhpcy5leGVjdXRlTGlzdGVuZXJzKHRoaXMuX3ZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJCb3g7XG4iLCJpbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL0Jhc2VDb21wb25lbnQnO1xuaW1wb3J0IGRpc3BsYXkgZnJvbSAnLi4vbWl4aW5zL2Rpc3BsYXknO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi4vdXRpbHMvZWxlbWVudHMnO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgbGFiZWw6ICcmbmJzcDsnLFxuICBvcHRpb25zOiBudWxsLFxuICBkZWZhdWx0OiBudWxsLFxuICBjb250YWluZXI6IG51bGwsXG4gIGNhbGxiYWNrOiBudWxsLFxufTtcblxuLyoqXG4gKiBMaXN0IG9mIGJ1dHRvbnMgd2l0aCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5sYWJlbCAtIExhYmVsIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5vcHRpb25zPW51bGxdIC0gVmFsdWVzIG9mIHRoZSBkcm9wIGRvd24gbGlzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRlZmF1bHQ9bnVsbF0gLSBEZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxiYXNpYy1jb250cm9sbGVyfkdyb3VwfSBbY29uZmlnLmNvbnRhaW5lcj1udWxsXSAtXG4gKiAgQ29udGFpbmVyIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5jYWxsYmFjaz1udWxsXSAtIENhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlXG4gKiAgdmFsdWUgY2hhbmdlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgY29udHJvbGxlcnMgZnJvbSAnYmFzaWMtY29udHJvbGxlcnMnO1xuICpcbiAqIGNvbnN0IHNlbGVjdEJ1dHRvbnMgPSBuZXcgY29udHJvbGxlcnMuU2VsZWN0QnV0dG9ucyh7XG4gKiAgIGxhYmVsOiAnU2VsZWN0QnV0dG9ucycsXG4gKiAgIG9wdGlvbnM6IFsnc3RhbmRieScsICdydW4nLCAnZW5kJ10sXG4gKiAgIGRlZmF1bHQ6ICdydW4nLFxuICogICBjb250YWluZXI6ICcjY29udGFpbmVyJyxcbiAqICAgY2FsbGJhY2s6ICh2YWx1ZSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKHZhbHVlLCBpbmRleCksXG4gKiB9KTtcbiAqL1xuY2xhc3MgU2VsZWN0QnV0dG9ucyBleHRlbmRzIGRpc3BsYXkoQmFzZUNvbXBvbmVudCkge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcignc2VsZWN0LWJ1dHRvbnMnLCBkZWZhdWx0cywgY29uZmlnKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnBhcmFtcy5vcHRpb25zKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZ2dlckJ1dHRvbjogSW52YWxpZCBvcHRpb24gXCJvcHRpb25zXCInKTtcblxuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5wYXJhbXMuZGVmYXVsdDtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnBhcmFtcy5vcHRpb25zO1xuICAgIGNvbnN0IGluZGV4ID0gb3B0aW9ucy5pbmRleE9mKHRoaXMuX3ZhbHVlKTtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4ID09PSAtMSA/wqAwIDogaW5kZXg7XG4gICAgdGhpcy5fbWF4SW5kZXggPSBvcHRpb25zLmxlbmd0aCAtIDE7XG5cbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCB2YWx1ZS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucGFyYW1zLm9wdGlvbnMuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgb3B0aW9uIGluZGV4LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGluZGV4KCkge1xuICAgIHRoaXMuX2luZGV4O1xuICB9XG5cbiAgc2V0IGluZGV4KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuX21heEluZGV4KSByZXR1cm47XG5cbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMucGFyYW1zLm9wdGlvbnNbaW5kZXhdO1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5faGlnaGxpZ2h0QnRuKHRoaXMuX2luZGV4KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBvcHRpb25zLCBsYWJlbCB9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY29udGVudCA9IGBcbiAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj4ke2xhYmVsfTwvc3Bhbj5cbiAgICAgIDxkaXYgY2xhc3M9XCJpbm5lci13cmFwcGVyXCI+XG4gICAgICAgICR7ZWxlbWVudHMuYXJyb3dMZWZ0fVxuICAgICAgICAke29wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG5cIiBkYXRhLWluZGV4PVwiJHtpbmRleH1cIiBkYXRhLXZhbHVlPVwiJHtvcHRpb259XCI+XG4gICAgICAgICAgICAgICR7b3B0aW9ufVxuICAgICAgICAgICAgPC9idXR0b24+YDtcbiAgICAgICAgfSkuam9pbignJyl9XG4gICAgICAgICR7ZWxlbWVudHMuYXJyb3dSaWdodH1cbiAgICAgIDwvZGl2PlxuICAgIGA7XG5cbiAgICB0aGlzLiRlbCA9IHN1cGVyLnJlbmRlcih0aGlzLnR5cGUpO1xuICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cbiAgICB0aGlzLiRwcmV2ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmFycm93LWxlZnQnKTtcbiAgICB0aGlzLiRuZXh0ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmFycm93LXJpZ2h0Jyk7XG4gICAgdGhpcy4kYnRucyA9IEFycmF5LmZyb20odGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbCgnLmJ0bicpKTtcblxuICAgIHRoaXMuX2hpZ2hsaWdodEJ0bih0aGlzLl9pbmRleCk7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJHByZXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2luZGV4IC0gMTtcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZShpbmRleCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRuZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICB0aGlzLl9wcm9wYWdhdGUoaW5kZXgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kYnRucy5mb3JFYWNoKCgkYnRuLCBpbmRleCkgPT4ge1xuICAgICAgJGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlKGluZGV4KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9wcm9wYWdhdGUoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5fbWF4SW5kZXgpIHJldHVybjtcblxuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLnBhcmFtcy5vcHRpb25zW2luZGV4XTtcbiAgICB0aGlzLl9oaWdobGlnaHRCdG4odGhpcy5faW5kZXgpO1xuXG4gICAgdGhpcy5leGVjdXRlTGlzdGVuZXJzKHRoaXMuX3ZhbHVlLCB0aGlzLl9pbmRleCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2hpZ2hsaWdodEJ0bihhY3RpdmVJbmRleCkge1xuICAgIHRoaXMuJGJ0bnMuZm9yRWFjaCgoJGJ0biwgaW5kZXgpID0+IHtcbiAgICAgICRidG4uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG5cbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgJGJ0bi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RCdXR0b25zO1xuIiwiaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9CYXNlQ29tcG9uZW50JztcbmltcG9ydCBkaXNwbGF5IGZyb20gJy4uL21peGlucy9kaXNwbGF5JztcbmltcG9ydCAqIGFzIGVsZW1lbnRzIGZyb20gJy4uL3V0aWxzL2VsZW1lbnRzJztcblxuLyoqIEBtb2R1bGUgYmFzaWMtY29udHJvbGxlcnMgKi9cblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGxhYmVsOiAnJm5ic3A7JyxcbiAgb3B0aW9uczogbnVsbCxcbiAgZGVmYXVsdDogbnVsbCxcbiAgY29udGFpbmVyOiBudWxsLFxuICBjYWxsYmFjazogbnVsbCxcbn1cblxuLyoqXG4gKiBEcm9wLWRvd24gbGlzdCBjb250cm9sbGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmxhYmVsIC0gTGFiZWwgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLm9wdGlvbnM9bnVsbF0gLSBWYWx1ZXMgb2YgdGhlIGRyb3AgZG93biBsaXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZGVmYXVsdD1udWxsXSAtIERlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fGJhc2ljLWNvbnRyb2xsZXJ+R3JvdXB9IFtjb25maWcuY29udGFpbmVyPW51bGxdIC1cbiAqICBDb250YWluZXIgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNhbGxiYWNrPW51bGxdIC0gQ2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGVcbiAqICB2YWx1ZSBjaGFuZ2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICdiYXNpYy1jb250cm9sbGVycyc7XG4gKlxuICogY29uc3Qgc2VsZWN0TGlzdCA9IG5ldyBjb250cm9sbGVycy5TZWxlY3RMaXN0KHtcbiAqICAgbGFiZWw6ICdTZWxlY3RMaXN0JyxcbiAqICAgb3B0aW9uczogWydzdGFuZGJ5JywgJ3J1bicsICdlbmQnXSxcbiAqICAgZGVmYXVsdDogJ3J1bicsXG4gKiAgIGNvbnRhaW5lcjogJyNjb250YWluZXInLFxuICogICBjYWxsYmFjazogKHZhbHVlLCBpbmRleCkgPT4gY29uc29sZS5sb2codmFsdWUsIGluZGV4KSxcbiAqIH0pO1xuICovXG5jbGFzcyBTZWxlY3RMaXN0IGV4dGVuZHMgZGlzcGxheShCYXNlQ29tcG9uZW50KSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCdzZWxlY3QtbGlzdCcsIGRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMucGFyYW1zLm9wdGlvbnMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmlnZ2VyQnV0dG9uOiBJbnZhbGlkIG9wdGlvbiBcIm9wdGlvbnNcIicpO1xuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLnBhcmFtcy5kZWZhdWx0O1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucGFyYW1zLm9wdGlvbnM7XG4gICAgY29uc3QgaW5kZXggPSBvcHRpb25zLmluZGV4T2YodGhpcy5fdmFsdWUpO1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXggPT09IC0xID/CoDAgOiBpbmRleDtcbiAgICB0aGlzLl9tYXhJbmRleCA9IG9wdGlvbnMubGVuZ3RoIC0gMTtcblxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHZhbHVlLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuJHNlbGVjdC52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5faW5kZXggPSB0aGlzLnBhcmFtcy5vcHRpb25zLmluZGV4T2YodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgb3B0aW9uIGluZGV4LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgfVxuXG4gIHNldCBpbmRleChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLl9tYXhJbmRleCkgcmV0dXJuO1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLnBhcmFtcy5vcHRpb25zW2luZGV4XTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBsYWJlbCwgb3B0aW9uc8KgfSA9IHRoaXMucGFyYW1zO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBgXG4gICAgICA8c3BhbiBjbGFzcz1cImxhYmVsXCI+JHtsYWJlbH08L3NwYW4+XG4gICAgICA8ZGl2IGNsYXNzPVwiaW5uZXItd3JhcHBlclwiPlxuICAgICAgICAke2VsZW1lbnRzLmFycm93TGVmdH1cbiAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgJHtvcHRpb25zLm1hcCgob3B0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgIHJldHVybiBgPG9wdGlvbiB2YWx1ZT1cIiR7b3B0aW9ufVwiPiR7b3B0aW9ufTwvb3B0aW9uPmA7XG4gICAgICAgIH0pLmpvaW4oJycpfVxuICAgICAgICA8c2VsZWN0PlxuICAgICAgICAke2VsZW1lbnRzLmFycm93UmlnaHR9XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuXG4gICAgdGhpcy4kZWwgPSBzdXBlci5yZW5kZXIodGhpcy50eXBlKTtcbiAgICB0aGlzLiRlbC5jbGFzc0xpc3QuYWRkKCdhbGlnbi1zbWFsbCcpO1xuICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cbiAgICB0aGlzLiRwcmV2ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmFycm93LWxlZnQnKTtcbiAgICB0aGlzLiRuZXh0ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmFycm93LXJpZ2h0Jyk7XG4gICAgdGhpcy4kc2VsZWN0ID0gdGhpcy4kZWwucXVlcnlTZWxlY3Rvcignc2VsZWN0Jyk7XG4gICAgLy8gc2V0IHRvIGRlZmF1bHQgdmFsdWVcbiAgICB0aGlzLiRzZWxlY3QudmFsdWUgPSBvcHRpb25zW3RoaXMuX2luZGV4XTtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgdGhpcy4kcHJldi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faW5kZXggLSAxO1xuICAgICAgdGhpcy5fcHJvcGFnYXRlKGluZGV4KTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB0aGlzLiRuZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICB0aGlzLl9wcm9wYWdhdGUoaW5kZXgpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMuJHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuJHNlbGVjdC52YWx1ZTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYXJhbXMub3B0aW9ucy5pbmRleE9mKHZhbHVlKTtcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZShpbmRleCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3Byb3BhZ2F0ZShpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHzCoGluZGV4ID4gdGhpcy5fbWF4SW5kZXgpIHJldHVybjtcblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wYXJhbXMub3B0aW9uc1tpbmRleF07XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuJHNlbGVjdC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgdGhpcy5leGVjdXRlTGlzdGVuZXJzKHRoaXMuX3ZhbHVlLCB0aGlzLl9pbmRleCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0TGlzdDtcbiIsImltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQgZGlzcGxheSBmcm9tICcuLi9taXhpbnMvZGlzcGxheSc7XG5pbXBvcnQgKiBhcyBndWlDb21wb25lbnRzIGZyb20gJ0BpcmNhbS9ndWktY29tcG9uZW50cyc7XG5cbi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXJzICovXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBsYWJlbDogJyZuYnNwOycsXG4gIG1pbjogMCxcbiAgbWF4OiAxLFxuICBzdGVwOiAwLjAxLFxuICBkZWZhdWx0OiAwLFxuICB1bml0OiAnJyxcbiAgc2l6ZTogJ21lZGl1bScsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgY2FsbGJhY2s6IG51bGwsXG59XG5cbi8qKlxuICogU2xpZGVyIGNvbnRyb2xsZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubGFiZWwgLSBMYWJlbCBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm1pbj0wXSAtIE1pbmltdW0gdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5tYXg9MV0gLSBNYXhpbXVtIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3RlcD0wLjAxXSAtIFN0ZXAgYmV0d2VlbiBjb25zZWN1dGl2ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kZWZhdWx0PTBdIC0gRGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnVuaXQ9JyddIC0gVW5pdCBvZiB0aGUgdmFsdWUuXG4gKiBAcGFyYW0geydzbWFsbCd8J21lZGl1bSd8J2xhcmdlJ30gW2NvbmZpZy5zaXplPSdtZWRpdW0nXSAtIFNpemUgb2YgdGhlXG4gKiAgc2xpZGVyLlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxiYXNpYy1jb250cm9sbGVyfkdyb3VwfSBbY29uZmlnLmNvbnRhaW5lcj1udWxsXSAtXG4gKiAgQ29udGFpbmVyIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5jYWxsYmFjaz1udWxsXSAtIENhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlXG4gKiAgdmFsdWUgY2hhbmdlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgY29udHJvbGxlcnMgZnJvbSAnYmFzaWMtY29udHJvbGxlcnMnO1xuICpcbiAqIGNvbnN0IHNsaWRlciA9IG5ldyBjb250cm9sbGVycy5TbGlkZXIoe1xuICogICBsYWJlbDogJ015IFNsaWRlcicsXG4gKiAgIG1pbjogMjAsXG4gKiAgIG1heDogMTAwMCxcbiAqICAgc3RlcDogMSxcbiAqICAgZGVmYXVsdDogNTM3LFxuICogICB1bml0OiAnSHonLFxuICogICBzaXplOiAnbGFyZ2UnLFxuICogICBjb250YWluZXI6ICcjY29udGFpbmVyJyxcbiAqICAgY2FsbGJhY2s6ICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogfSk7XG4gKi9cbmNsYXNzIFNsaWRlciBleHRlbmRzIGRpc3BsYXkoQmFzZUNvbXBvbmVudCkge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcignc2xpZGVyJywgZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMucGFyYW1zLmRlZmF1bHQ7XG4gICAgdGhpcy5fb25TbGlkZXJDaGFuZ2UgPSB0aGlzLl9vblNsaWRlckNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgdmFsdWUuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKHRoaXMuJG51bWJlciAmJiB0aGlzLiRyYW5nZSkge1xuICAgICAgdGhpcy4kbnVtYmVyLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMuc2xpZGVyLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGxhYmVsLCBtaW4sIG1heCwgc3RlcCwgdW5pdCwgc2l6ZSB9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY29udGVudCA9IGBcbiAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj4ke2xhYmVsfTwvc3Bhbj5cbiAgICAgIDxkaXYgY2xhc3M9XCJpbm5lci13cmFwcGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyYW5nZVwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwibnVtYmVyLXdyYXBwZXJcIj5cbiAgICAgICAgICA8aW5wdXQgdHlwZT1cIm51bWJlclwiIGNsYXNzPVwibnVtYmVyXCIgbWluPVwiJHttaW59XCIgbWF4PVwiJHttYXh9XCIgc3RlcD1cIiR7c3RlcH1cIiB2YWx1ZT1cIiR7dGhpcy5fdmFsdWV9XCIgLz5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInVuaXRcIj4ke3VuaXR9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PmA7XG5cbiAgICB0aGlzLiRlbCA9IHN1cGVyLnJlbmRlcih0aGlzLnR5cGUpO1xuICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZChgc2xpZGVyLSR7c2l6ZX1gKTtcblxuICAgIHRoaXMuJHJhbmdlID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnJhbmdlJyk7XG4gICAgdGhpcy4kbnVtYmVyID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcihgaW5wdXRbdHlwZT1cIm51bWJlclwiXWApO1xuXG4gICAgdGhpcy5zbGlkZXIgPSBuZXcgZ3VpQ29tcG9uZW50cy5TbGlkZXIoe1xuICAgICAgY29udGFpbmVyOiB0aGlzLiRyYW5nZSxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLl9vblNsaWRlckNoYW5nZSxcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXgsXG4gICAgICBzdGVwOiBzdGVwLFxuICAgICAgZGVmYXVsdDogdGhpcy5fdmFsdWUsXG4gICAgICBmb3JlZ3JvdW5kQ29sb3I6ICcjYWJhYmFiJyxcbiAgICB9KTtcblxuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZXNpemUoKSB7XG4gICAgc3VwZXIucmVzaXplKCk7XG5cbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHTCoH0gPSB0aGlzLiRyYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0aGlzLnNsaWRlci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgdGhpcy4kbnVtYmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLiRudW1iZXIudmFsdWUpO1xuICAgICAgLy8gdGhlIHNsaWRlciBwcm9wYWdhdGVzIHRoZSB2YWx1ZVxuICAgICAgdGhpcy5zbGlkZXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICAgIHRoaXMuZXhlY3V0ZUxpc3RlbmVycyh0aGlzLl92YWx1ZSk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9vblNsaWRlckNoYW5nZSh2YWx1ZSkge1xuICAgIHRoaXMuJG51bWJlci52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICB0aGlzLmV4ZWN1dGVMaXN0ZW5lcnModGhpcy5fdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNsaWRlcjtcbiIsImltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQgZGlzcGxheSBmcm9tICcuLi9taXhpbnMvZGlzcGxheSc7XG5cbi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXJzICovXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBsYWJlbDogJyZuYnNwOycsXG4gIGRlZmF1bHQ6ICcnLFxuICByZWFkb25seTogZmFsc2UsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgY2FsbGJhY2s6IG51bGwsXG59XG5cbi8qKlxuICogVGV4dCBjb250cm9sbGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmxhYmVsIC0gTGFiZWwgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRlZmF1bHQ9JyddIC0gRGVmYXVsdCB2YWx1ZSBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcucmVhZG9ubHk9ZmFsc2VdIC0gRGVmaW5lIGlmIHRoZSBjb250cm9sbGVyIGlzIHJlYWRvbmx5LlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxiYXNpYy1jb250cm9sbGVyfkdyb3VwfSBbY29uZmlnLmNvbnRhaW5lcj1udWxsXSAtXG4gKiAgQ29udGFpbmVyIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5jYWxsYmFjaz1udWxsXSAtIENhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlXG4gKiAgdmFsdWUgY2hhbmdlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgY29udHJvbGxlcnMgZnJvbSAnYmFzaWMtY29udG9sbGVycyc7XG4gKlxuICogY29uc3QgdGV4dCA9IG5ldyBjb250cm9sbGVycy5UZXh0KHtcbiAqICAgbGFiZWw6ICdNeSBUZXh0JyxcbiAqICAgZGVmYXVsdDogJ2RlZmF1bHQgdmFsdWUnLFxuICogICByZWFkb25seTogZmFsc2UsXG4gKiAgIGNvbnRhaW5lcjogJyNjb250YWluZXInLFxuICogICBjYWxsYmFjazogKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSksXG4gKiB9KTtcbiAqL1xuY2xhc3MgVGV4dCBleHRlbmRzIGRpc3BsYXkoQmFzZUNvbXBvbmVudCkge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigndGV4dCcsIGRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLnBhcmFtcy5kZWZhdWx0O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgdmFsdWUuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy4kaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCByZWFkb25seSA9IHRoaXMucGFyYW1zLnJlYWRvbmx5ID8gJ3JlYWRvbmx5JyA6ICcnO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBgXG4gICAgICA8c3BhbiBjbGFzcz1cImxhYmVsXCI+JHt0aGlzLnBhcmFtcy5sYWJlbH08L3NwYW4+XG4gICAgICA8ZGl2IGNsYXNzPVwiaW5uZXItd3JhcHBlclwiPlxuICAgICAgICA8aW5wdXQgY2xhc3M9XCJ0ZXh0XCIgdHlwZT1cInRleHRcIiB2YWx1ZT1cIiR7dGhpcy5fdmFsdWV9XCIgJHtyZWFkb25seX0gLz5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG5cbiAgICB0aGlzLiRlbCA9IHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgdGhpcy4kaW5wdXQgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcudGV4dCcpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoKSA9PiB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuJGlucHV0LnZhbHVlO1xuICAgICAgdGhpcy5leGVjdXRlTGlzdGVuZXJzKHRoaXMuX3ZhbHVlKTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dDtcbiIsImltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQgZGlzcGxheSBmcm9tICcuLi9taXhpbnMvZGlzcGxheSc7XG5cbi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXJzICovXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBsYWJlbDogJyZuYnNwOycsXG4gIGNvbnRhaW5lcjogbnVsbCxcbn07XG5cbi8qKlxuICogVGl0bGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubGFiZWwgLSBMYWJlbCBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8YmFzaWMtY29udHJvbGxlcn5Hcm91cH0gW2NvbmZpZy5jb250YWluZXI9bnVsbF0gLVxuICogIENvbnRhaW5lciBvZiB0aGUgY29udHJvbGxlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgY29udHJvbGxlciBmcm9tICdiYXNpYy1jb250cm9sbGVycyc7XG4gKlxuICogY29uc3QgdGl0bGUgPSBuZXcgY29udHJvbGxlcnMuVGl0bGUoe1xuICogICBsYWJlbDogJ015IFRpdGxlJyxcbiAqICAgY29udGFpbmVyOiAnI2NvbnRhaW5lcidcbiAqIH0pO1xuICovXG5jbGFzcyBUaXRsZSBleHRlbmRzIGRpc3BsYXkoQmFzZUNvbXBvbmVudCkge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigndGl0bGUnLCBkZWZhdWx0cywgY29uZmlnKTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBgPHNwYW4gY2xhc3M9XCJsYWJlbFwiPiR7dGhpcy5wYXJhbXMubGFiZWx9PC9zcGFuPmA7XG5cbiAgICB0aGlzLiRlbCA9IHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGl0bGU7XG4iLCJpbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL0Jhc2VDb21wb25lbnQnO1xuaW1wb3J0IGRpc3BsYXkgZnJvbSAnLi4vbWl4aW5zL2Rpc3BsYXknO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi4vdXRpbHMvZWxlbWVudHMnO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgbGFiZWw6ICcmYm5zcDsnLFxuICBhY3RpdmU6IGZhbHNlLFxuICBjb250YWluZXI6IG51bGwsXG4gIGNhbGxiYWNrOiBudWxsLFxufTtcblxuLyoqXG4gKiBPbi9PZmYgY29udHJvbGxlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5sYWJlbCAtIExhYmVsIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5hY3RpdmU9ZmFsc2VdIC0gRGVmYXVsdCBzdGF0ZSBvZiB0aGUgdG9nZ2xlLlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxiYXNpYy1jb250cm9sbGVyfkdyb3VwfSBbY29uZmlnLmNvbnRhaW5lcj1udWxsXSAtXG4gKiAgQ29udGFpbmVyIG9mIHRoZSBjb250cm9sbGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5jYWxsYmFjaz1udWxsXSAtIENhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlXG4gKiAgdmFsdWUgY2hhbmdlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgY29udHJvbGxlcnMgZnJvbSAnYmFzaWMtY29udHJvbGxlcnMnO1xuICpcbiAqIGNvbnN0IHRvZ2dsZSA9IG5ldyBjb250cm9sbGVycy5Ub2dnbGUoe1xuICogICBsYWJlbDogJ015IFRvZ2dsZScsXG4gKiAgIGFjdGl2ZTogZmFsc2UsXG4gKiAgIGNvbnRhaW5lcjogJyNjb250YWluZXInLFxuICogICBjYWxsYmFjazogKGFjdGl2ZSkgPT4gY29uc29sZS5sb2coYWN0aXZlKSxcbiAqIH0pO1xuICovXG5jbGFzcyBUb2dnbGUgZXh0ZW5kcyBkaXNwbGF5KEJhc2VDb21wb25lbnQpIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoJ3RvZ2dsZScsIGRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gdGhpcy5wYXJhbXMuYWN0aXZlO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbHVlIG9mIHRoZSB0b2dnbGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzZXQgdmFsdWUoYm9vbCkge1xuICAgIHRoaXMuYWN0aXZlID0gYm9vbDtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBgdmFsdWVgLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHNldCBhY3RpdmUoYm9vbCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGJvb2w7XG4gICAgdGhpcy5fdXBkYXRlQnRuKCk7XG4gIH1cblxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3VwZGF0ZUJ0bigpIHtcbiAgICB2YXIgbWV0aG9kID0gdGhpcy5hY3RpdmUgPyAnYWRkJyA6ICdyZW1vdmUnO1xuICAgIHRoaXMuJHRvZ2dsZS5jbGFzc0xpc3RbbWV0aG9kXSgnYWN0aXZlJyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVuZGVyKCkge1xuICAgIGxldCBjb250ZW50ID0gYFxuICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbFwiPiR7dGhpcy5wYXJhbXMubGFiZWx9PC9zcGFuPlxuICAgICAgPGRpdiBjbGFzcz1cImlubmVyLXdyYXBwZXJcIj5cbiAgICAgICAgJHtlbGVtZW50cy50b2dnbGV9XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgdGhpcy4kZWwgPSBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLiRlbC5jbGFzc0xpc3QuYWRkKCdhbGlnbi1zbWFsbCcpO1xuICAgIHRoaXMuJGVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cbiAgICB0aGlzLiR0b2dnbGUgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcudG9nZ2xlLWVsZW1lbnQnKTtcbiAgICAvLyBpbml0aWFsaXplIHN0YXRlXG4gICAgdGhpcy5hY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLiR0b2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLmFjdGl2ZSA9ICF0aGlzLmFjdGl2ZTtcbiAgICAgIHRoaXMuZXhlY3V0ZUxpc3RlbmVycyh0aGlzLl9hY3RpdmUpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvZ2dsZTtcbiIsImltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQgZGlzcGxheSBmcm9tICcuLi9taXhpbnMvZGlzcGxheSc7XG5cbi8qKiBAbW9kdWxlIGJhc2ljLWNvbnRyb2xsZXJzICovXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBsYWJlbDogJyZuYnNwOycsXG4gIG9wdGlvbnM6IG51bGwsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgY2FsbGJhY2s6IG51bGwsXG59O1xuXG4vKipcbiAqIExpc3Qgb2YgYnV0dG9ucyB3aXRob3V0IHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmxhYmVsIC0gTGFiZWwgb2YgdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLm9wdGlvbnM9bnVsbF0gLSBPcHRpb25zIGZvciBlYWNoIGJ1dHRvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8YmFzaWMtY29udHJvbGxlcn5Hcm91cH0gW2NvbmZpZy5jb250YWluZXI9bnVsbF0gLVxuICogIENvbnRhaW5lciBvZiB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2FsbGJhY2s9bnVsbF0gLSBDYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuIHRoZVxuICogIHZhbHVlIGNoYW5nZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJ2Jhc2ljLWNvbnRyb2xsZXJzJztcbiAqXG4gKiBjb25zdCB0cmlnZ2VyQnV0dG9ucyA9IG5ldyBjb250cm9sbGVycy5UcmlnZ2VyQnV0dG9ucyh7XG4gKiAgIGxhYmVsOiAnTXkgVHJpZ2dlciBCdXR0b25zJyxcbiAqICAgb3B0aW9uczogWyd2YWx1ZSAxJywgJ3ZhbHVlIDInLCAndmFsdWUgMyddLFxuICogICBjb250YWluZXI6ICcjY29udGFpbmVyJyxcbiAqICAgY2FsbGJhY2s6ICh2YWx1ZSwgaW5kZXgpID0+IGNvbnNvbGUubG9nKHZhbHVlLCBpbmRleCksXG4gKiB9KTtcbiAqL1xuY2xhc3MgVHJpZ2dlckJ1dHRvbnMgZXh0ZW5kcyBkaXNwbGF5KEJhc2VDb21wb25lbnQpIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoJ3RyaWdnZXItYnV0dG9ucycsIGRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMucGFyYW1zLm9wdGlvbnMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmlnZ2VyQnV0dG9uOiBJbnZhbGlkIG9wdGlvbiBcIm9wdGlvbnNcIicpO1xuXG4gICAgdGhpcy5faW5kZXggPSBudWxsO1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcblxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMYXN0IHRyaWdnZXJlZCBidXR0b24gdmFsdWUuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cblxuICAvKipcbiAgICogTGFzdCB0cmlnZ2VyZWQgYnV0dG9uIGluZGV4LlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBpbmRleCgpIHsgcmV0dXJuIHRoaXMuX2luZGV4OyB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGxhYmVsLCBvcHRpb25zIH0gPSB0aGlzLnBhcmFtcztcblxuICAgIGNvbnN0IGNvbnRlbnQgPSBgXG4gICAgICA8c3BhbiBjbGFzcz1cImxhYmVsXCI+JHtsYWJlbH08L3NwYW4+XG4gICAgICA8ZGl2IGNsYXNzPVwiaW5uZXItd3JhcHBlclwiPlxuICAgICAgICAke29wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGA8YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuXCI+JHtvcHRpb259PC9hPmA7XG4gICAgICAgIH0pLmpvaW4oJycpfVxuICAgICAgPC9kaXY+YDtcblxuICAgIHRoaXMuJGVsID0gc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy4kZWwuaW5uZXJIVE1MID0gY29udGVudDtcblxuICAgIHRoaXMuJGJ1dHRvbnMgPSBBcnJheS5mcm9tKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5idG4nKSk7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGJ1dHRvbnMuZm9yRWFjaCgoJGJ0biwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wYXJhbXMub3B0aW9uc1tpbmRleF07XG5cbiAgICAgICRidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcblxuICAgICAgICB0aGlzLmV4ZWN1dGVMaXN0ZW5lcnModmFsdWUsIGluZGV4KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyaWdnZXJCdXR0b25zO1xuIiwiaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnRzL0Jhc2VDb21wb25lbnQnO1xuaW1wb3J0IEdyb3VwIGZyb20gJy4vY29tcG9uZW50cy9Hcm91cCc7XG5pbXBvcnQgTnVtYmVyQm94IGZyb20gJy4vY29tcG9uZW50cy9OdW1iZXJCb3gnO1xuaW1wb3J0IFNlbGVjdEJ1dHRvbnMgZnJvbSAnLi9jb21wb25lbnRzL1NlbGVjdEJ1dHRvbnMnO1xuaW1wb3J0IFNlbGVjdExpc3QgZnJvbSAnLi9jb21wb25lbnRzL1NlbGVjdExpc3QnO1xuaW1wb3J0IFNsaWRlciBmcm9tICcuL2NvbXBvbmVudHMvU2xpZGVyJztcbmltcG9ydCBUZXh0IGZyb20gJy4vY29tcG9uZW50cy9UZXh0JztcbmltcG9ydCBUaXRsZSBmcm9tICcuL2NvbXBvbmVudHMvVGl0bGUnO1xuaW1wb3J0IFRvZ2dsZSBmcm9tICcuL2NvbXBvbmVudHMvVG9nZ2xlJztcbmltcG9ydCBUcmlnZ2VyQnV0dG9ucyBmcm9tICcuL2NvbXBvbmVudHMvVHJpZ2dlckJ1dHRvbnMnO1xuXG5pbXBvcnQgY29udGFpbmVyIGZyb20gJy4vbWl4aW5zL2NvbnRhaW5lcic7XG5cbi8vIG1hcCB0eXBlIG5hbWVzIHRvIGNvbnN0cnVjdG9yc1xuY29uc3QgdHlwZUN0b3JNYXAgPSB7XG4gICdncm91cCc6IEdyb3VwLFxuICAnbnVtYmVyLWJveCc6IE51bWJlckJveCxcbiAgJ3NlbGVjdC1idXR0b25zJzogU2VsZWN0QnV0dG9ucyxcbiAgJ3NlbGVjdC1saXN0JzogU2VsZWN0TGlzdCxcbiAgJ3NsaWRlcic6IFNsaWRlcixcbiAgJ3RleHQnOiBUZXh0LFxuICAndGl0bGUnOiBUaXRsZSxcbiAgJ3RvZ2dsZSc6IFRvZ2dsZSxcbiAgJ3RyaWdnZXItYnV0dG9ucyc6IFRyaWdnZXJCdXR0b25zLFxufTtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGNvbnRhaW5lcjogJ2JvZHknLFxufTtcblxuY2xhc3MgQ29udHJvbCBleHRlbmRzIGNvbnRhaW5lcihCYXNlQ29tcG9uZW50KSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCdjb250cm9sJywgZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICBsZXQgJGNvbnRhaW5lciA9IHRoaXMucGFyYW1zLmNvbnRhaW5lcjtcblxuICAgIGlmICh0eXBlb2YgJGNvbnRhaW5lciA9PT0gJ3N0cmluZycpXG4gICAgICAkY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigkY29udGFpbmVyKTtcblxuICAgIHRoaXMuJGNvbnRhaW5lciA9ICRjb250YWluZXI7XG4gIH1cbn1cblxuLyoqIEBtb2R1bGUgYmFzaWMtY29udHJvbGxlcnMgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSB3aG9sZSBjb250cm9sIHN1cmZhY2UgZnJvbSBhIGpzb24gZGVmaW5pdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBjb250YWluZXIgLSBDb250YWluZXIgb2YgdGhlIGNvbnRyb2xzLlxuICogQHBhcmFtIHtPYmplY3R9IC0gRGVmaW5pdGlvbnMgZm9yIHRoZSBjb250cm9scy5cbiAqIEByZXR1cm4ge09iamVjdH0gLSBBIGBDb250cm9sYCBpbnN0YW5jZSB0aGF0IGJlaGF2ZXMgbGlrZSBhIGdyb3VwIHdpdGhvdXQgZ3JhcGhpYy5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgY29udHJvbGxlcnMgZnJvbSAnYmFzaWMtY29udHJvbGxlcnMnO1xuICpcbiAqIGNvbnN0IGRlZmluaXRpb25zID0gW1xuICogICB7XG4gKiAgICAgaWQ6ICdteS1zbGlkZXInLFxuICogICAgIHR5cGU6ICdzbGlkZXInLFxuICogICAgIGxhYmVsOiAnTXkgU2xpZGVyJyxcbiAqICAgICBzaXplOiAnbGFyZ2UnLFxuICogICAgIG1pbjogMCxcbiAqICAgICBtYXg6IDEwMDAsXG4gKiAgICAgc3RlcDogMSxcbiAqICAgICBkZWZhdWx0OiAyNTMsXG4gKiAgIH0sIHtcbiAqICAgICBpZDogJ215LWdyb3VwJyxcbiAqICAgICB0eXBlOiAnZ3JvdXAnLFxuICogICAgIGxhYmVsOiAnR3JvdXAnLFxuICogICAgIGRlZmF1bHQ6ICdvcGVuZWQnLFxuICogICAgIGVsZW1lbnRzOiBbXG4gKiAgICAgICB7XG4gKiAgICAgICAgIGlkOiAnbXktbnVtYmVyJyxcbiAqICAgICAgICAgdHlwZTogJ251bWJlci1ib3gnLFxuICogICAgICAgICBkZWZhdWx0OiAwLjQsXG4gKiAgICAgICAgIG1pbjogLTEsXG4gKiAgICAgICAgIG1heDogMSxcbiAqICAgICAgICAgc3RlcDogMC4wMSxcbiAqICAgICAgIH1cbiAqICAgICBdLFxuICogICB9XG4gKiBdO1xuICpcbiAqIGNvbnN0IGNvbnRyb2xzID0gY29udHJvbGxlcnMuY3JlYXRlKCcjY29udGFpbmVyJywgZGVmaW5pdGlvbnMpO1xuICpcbiAqIC8vIGFkZCBhIGxpc3RlbmVyIG9uIGFsbCB0aGUgY29tcG9uZW50IGluc2lkZSBgbXktZ3JvdXBgXG4gKiBjb250cm9scy5hZGRMaXN0ZW5lcignbXktZ3JvdXAnLCAoaWQsIHZhbHVlKSA9PiBjb25zb2xlLmxvZyhpZCwgdmFsdWUpKTtcbiAqXG4gKiAvLyByZXRyaWV2ZSB0aGUgaW5zdGFuY2Ugb2YgYG15LW51bWJlcmBcbiAqIGNvbnN0IG15TnVtYmVyID0gY29udHJvbHMuZ2V0Q29tcG9uZW50KCdteS1ncm91cC9teS1udW1iZXInKTtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKGNvbnRhaW5lciwgZGVmaW5pdGlvbnMpIHtcblxuICBmdW5jdGlvbiBfcGFyc2UoY29udGFpbmVyLCBkZWZpbml0aW9ucykge1xuICAgIGRlZmluaXRpb25zLmZvckVhY2goKGRlZiwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSBkZWYudHlwZTtcbiAgICAgIGNvbnN0IGN0b3IgPSB0eXBlQ3Rvck1hcFt0eXBlXTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZik7XG5cbiAgICAgIC8vXG4gICAgICBjb25maWcuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgZGVsZXRlIGNvbmZpZy50eXBlO1xuXG4gICAgICBjb25zdCBjb21wb25lbnQgPSBuZXcgY3Rvcihjb25maWcpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2dyb3VwJylcbiAgICAgICAgX3BhcnNlKGNvbXBvbmVudCwgY29uZmlnLmVsZW1lbnRzKTtcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBfcm9vdCA9IG5ldyBDb250cm9sKHsgY29udGFpbmVyOiBjb250YWluZXIgfSk7XG4gIF9wYXJzZShfcm9vdCwgZGVmaW5pdGlvbnMpO1xuXG4gIHJldHVybiBfcm9vdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlO1xuIiwiaW1wb3J0ICogYXMgX3N0eWxlcyBmcm9tICcuL3V0aWxzL3N0eWxlcyc7XG5leHBvcnQgY29uc3Qgc3R5bGVzID0gX3N0eWxlcztcblxuLyoqIEBtb2R1bGUgYmFzaWMtY29udHJvbGxlcnMgKi9cblxuLy8gZXhwb3NlIGZvciBwbHVnaW5zXG5pbXBvcnQgX0Jhc2VDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnRzL0Jhc2VDb21wb25lbnQnO1xuZXhwb3J0IGNvbnN0IEJhc2VDb21wb25lbnQgPSBfQmFzZUNvbXBvbmVudDtcblxuLy8gY29tcG9uZW50c1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcm91cCB9IGZyb20gJy4vY29tcG9uZW50cy9Hcm91cCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERyYWdBbmREcm9wIH0gZnJvbSAnLi9jb21wb25lbnRzL0RyYWdBbmREcm9wJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTnVtYmVyQm94IH0gZnJvbSAnLi9jb21wb25lbnRzL051bWJlckJveCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlbGVjdEJ1dHRvbnMgfSBmcm9tICcuL2NvbXBvbmVudHMvU2VsZWN0QnV0dG9ucyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlbGVjdExpc3QgfSBmcm9tICcuL2NvbXBvbmVudHMvU2VsZWN0TGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNsaWRlciB9IGZyb20gJy4vY29tcG9uZW50cy9TbGlkZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0IH0gZnJvbSAnLi9jb21wb25lbnRzL1RleHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUaXRsZSB9IGZyb20gJy4vY29tcG9uZW50cy9UaXRsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRvZ2dsZSB9IGZyb20gJy4vY29tcG9uZW50cy9Ub2dnbGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUcmlnZ2VyQnV0dG9ucyB9IGZyb20gJy4vY29tcG9uZW50cy9UcmlnZ2VyQnV0dG9ucyc7XG5cbi8vIGZhY3RvcnlcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3JlYXRlIH0gZnJvbSAnLi9mYWN0b3J5Jztcbi8vIGRpc3BsYXlcbmV4cG9ydCB7IHNldFRoZW1lICB9IGZyb20gJy4vbWl4aW5zL2Rpc3BsYXknO1xuXG4vKipcbiAqIERpc2FibGUgZGVmYXVsdCBzdHlsaW5nIChleHBlY3QgYSBicm9rZW4gdWkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlU3R5bGVzKCkge1xuICBfc3R5bGVzLmRpc2FibGUoKTtcbn07XG4iLCJcbmNvbnN0IHNlcGFyYXRvciA9ICcvJztcblxuZnVuY3Rpb24gZ2V0SGVhZChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnNwbGl0KHNlcGFyYXRvcilbMF07XG59XG5cbmZ1bmN0aW9uIGdldFRhaWwocGF0aCkge1xuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoc2VwYXJhdG9yKTtcbiAgcGFydHMuc2hpZnQoKTtcbiAgcmV0dXJuIHBhcnRzLmpvaW4oc2VwYXJhdG9yKTtcbn1cblxuY29uc3QgY29udGFpbmVyID0gKHN1cGVyY2xhc3MpID0+IGNsYXNzIGV4dGVuZHMgc3VwZXJjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBzdXJlIG9mIHRoYXQgP1xuICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgZGVsZXRlIHRoaXMuX2dyb3VwTGlzdGVuZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBvbmUgb2YgdGhlIGdyb3VwIGNoaWxkcmVuIGFjY29yZGluZyB0byBpdHMgYGlkYCwgYG51bGxgIG90aGVyd2lzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRIZWFkKGlkKSB7XG5cbiAgfVxuXG4gIF9nZXRUYWlsKGlkKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjaGlsZCBvZiB0aGUgZ3JvdXAgcmVjdXJzaXZlbHkgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBgaWRgLFxuICAgKiBgbnVsbGAgb3RoZXJ3aXNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q29tcG9uZW50KGlkKSB7XG4gICAgY29uc3QgaGVhZCA9IGdldEhlYWQoaWQpO1xuXG4gICAgZm9yIChsZXQgY29tcG9uZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIGlmIChoZWFkID09PSBjb21wb25lbnQuaWQpIHtcbiAgICAgICAgaWYgKGhlYWQgPT09IGlkKVxuICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC50eXBlID0gJ2dyb3VwJylcbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50LmdldENvbXBvbmVudChnZXRUYWlsKGlkKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBjb21wb25lbnQgJHtpZH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBjb21wb25lbnQgJHtpZH1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgTGlzdGVuZXIgb24gZWFjaCBjb21wb25lbnRzIG9mIHRoZSBncm91cC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gUGF0aCB0byBjb21wb25lbnQgaWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICovXG4gIGFkZExpc3RlbmVyKGlkLCBjYWxsYmFjaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjYWxsYmFjayA9IGlkO1xuICAgICAgdGhpcy5fYWRkR3JvdXBMaXN0ZW5lcignJywgJycsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkR3JvdXBMaXN0ZW5lcihpZCwgJycsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2FkZEdyb3VwTGlzdGVuZXIoaWQsIGNhbGxJZCwgY2FsbGJhY2spIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudElkID0gZ2V0SGVhZChpZCk7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldENvbXBvbmVudChjb21wb25lbnRJZCk7XG5cbiAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgaWQgPSBnZXRUYWlsKGlkKTtcbiAgICAgICAgY29tcG9uZW50Ll9hZGRHcm91cExpc3RlbmVyKGlkLCBjYWxsSWQsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkIGNvbXBvbmVudCAke3RoaXMucm9vdElkfS8ke2NvbXBvbmVudElkfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICBsZXQgX2NhbGxJZCA9IGNhbGxJZDsgLy8gY3JlYXRlIGEgbmV3IGJyYW5jaGVcbiAgICAgICAgX2NhbGxJZCArPSAoY2FsbElkID09PSAnJykgPyBjb21wb25lbnQuaWQgOiBzZXBhcmF0b3IgKyBjb21wb25lbnQuaWQ7XG4gICAgICAgIGNvbXBvbmVudC5fYWRkR3JvdXBMaXN0ZW5lcihpZCwgX2NhbGxJZCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRhaW5lcjtcbiIsImltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuLi91dGlscy9zdHlsZXMnO1xuXG4vKiogQG1vZHVsZSBiYXNpYy1jb250cm9sbGVycyAqL1xuXG4vLyBkZWZhdWx0IHRoZW1lXG5sZXQgdGhlbWUgPSAnbGlnaHQnO1xuLy8gc2V0IG9mIHRoZSBpbnN0YW5jaWF0ZWQgY29udHJvbGxlcnNcbmNvbnN0IGNvbnRyb2xsZXJzID0gbmV3IFNldCgpO1xuXG5cbi8qKlxuICogQ2hhbmdlIHRoZSB0aGVtZSBvZiB0aGUgY29udHJvbGxlcnMsIGN1cnJlbnRseSAzIHRoZW1lcyBhcmUgYXZhaWxhYmxlOlxuICogIC0gYCdsaWdodCdgIChkZWZhdWx0KVxuICogIC0gYCdncmV5J2BcbiAqICAtIGAnZGFyaydgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRoZW1lIC0gTmFtZSBvZiB0aGUgdGhlbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRUaGVtZSh2YWx1ZSkge1xuICBjb250cm9sbGVycy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiBjb250cm9sbGVyLiRlbC5jbGFzc0xpc3QucmVtb3ZlKHRoZW1lKSk7XG4gIHRoZW1lID0gdmFsdWU7XG4gIGNvbnRyb2xsZXJzLmZvckVhY2goKGNvbnRyb2xsZXIpID0+IGNvbnRyb2xsZXIuJGVsLmNsYXNzTGlzdC5hZGQodGhlbWUpKTtcbn1cblxuLyoqXG4gKiBkaXNwbGF5IG1peGluIC0gY29tcG9uZW50cyB3aXRoIERPTVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZGlzcGxheSA9IChzdXBlcmNsYXNzKSA9PiBjbGFzcyBleHRlbmRzIHN1cGVyY2xhc3Mge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAvLyBpbnNlcnQgc3R5bGVzIHdoZW4gdGhlIGZpcnN0IGNvbnRyb2xsZXIgaXMgY3JlYXRlZFxuICAgIGlmIChjb250cm9sbGVycy5zaXplID09PSAwKVxuICAgICAgc3R5bGVzLmluc2VydFN0eWxlU2hlZXQoKTtcblxuICAgIHRoaXMucmVzaXplID0gdGhpcy5yZXNpemUuYmluZCh0aGlzKTtcblxuICAgIGNvbnRyb2xsZXJzLmFkZCh0aGlzKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgbGV0ICRjb250YWluZXIgPSB0aGlzLnBhcmFtcy5jb250YWluZXI7XG5cbiAgICBpZiAoJGNvbnRhaW5lcikge1xuICAgICAgLy8gY3NzIHNlbGVjdG9yXG4gICAgICBpZiAodHlwZW9mICRjb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICRjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCRjb250YWluZXIpO1xuICAgICAgLy8gZ3JvdXBcbiAgICAgIH0gZWxzZSBpZiAoJGNvbnRhaW5lci4kY29udGFpbmVyKSB7XG4gICAgICAgIC8vIHRoaXMuZ3JvdXAgPSAkY29udGFpbmVyO1xuICAgICAgICAkY29udGFpbmVyLmVsZW1lbnRzLmFkZCh0aGlzKTtcbiAgICAgICAgJGNvbnRhaW5lciA9ICRjb250YWluZXIuJGNvbnRhaW5lcjtcbiAgICAgIH1cblxuICAgICAgJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcigpKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZXNpemUoKSwgMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLiRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5hZGQoc3R5bGVzLm5zLCB0aGVtZSwgdGhpcy50eXBlKTtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZXNpemUoKSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7XG4gICAgICBjb25zdCBib3VuZGluZ1JlY3QgPSB0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gYm91bmRpbmdSZWN0LndpZHRoO1xuICAgICAgY29uc3QgbWV0aG9kID0gd2lkdGggPiA2MDAgPyAncmVtb3ZlJyA6ICdhZGQnO1xuXG4gICAgICB0aGlzLiRlbC5jbGFzc0xpc3RbbWV0aG9kXSgnc21hbGwnKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZGlzcGxheTtcbiIsIlxuZXhwb3J0IGNvbnN0IHRvZ2dsZSA9IGBcbiAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJ0b2dnbGUtZWxlbWVudFwiIHZlcnNpb249XCIxLjFcIiB2aWV3Qm94PVwiMCAwIDUwIDUwXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIj5cbiAgICAgIDxnIGNsYXNzPVwieFwiPlxuICAgICAgICA8bGluZSB4MT1cIjhcIiB5MT1cIjhcIiB4Mj1cIjQyXCIgeTI9XCI0MlwiIHN0cm9rZT1cIndoaXRlXCIgLz5cbiAgICAgICAgPGxpbmUgeDE9XCI4XCIgeTE9XCI0MlwiIHgyPVwiNDJcIiB5Mj1cIjhcIiBzdHJva2U9XCJ3aGl0ZVwiIC8+XG4gICAgICA8L2c+XG4gIDwvc3ZnPlxuYDtcblxuZXhwb3J0IGNvbnN0IGFycm93UmlnaHQgPSBgXG4gIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwiYXJyb3ctcmlnaHRcIiB2ZXJzaW9uPVwiMS4xXCIgdmlld0JveD1cIjAgMCA1MCA1MFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCI+XG4gICAgPGxpbmUgeDE9XCIxMFwiIHkxPVwiMTBcIiB4Mj1cIjQwXCIgeTI9XCIyNVwiIC8+XG4gICAgPGxpbmUgeDE9XCIxMFwiIHkxPVwiNDBcIiB4Mj1cIjQwXCIgeTI9XCIyNVwiIC8+XG4gIDwvc3ZnPlxuYDtcblxuZXhwb3J0IGNvbnN0IGFycm93TGVmdCA9IGBcbiAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJhcnJvdy1sZWZ0XCIgdmVyc2lvbj1cIjEuMVwiIHZpZXdCb3g9XCIwIDAgNTAgNTBcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiPlxuICAgIDxsaW5lIHgxPVwiNDBcIiB5MT1cIjEwXCIgeDI9XCIxMFwiIHkyPVwiMjVcIiAvPlxuICAgIDxsaW5lIHgxPVwiNDBcIiB5MT1cIjQwXCIgeDI9XCIxMFwiIHkyPVwiMjVcIiAvPlxuICA8L3N2Zz5cbmA7XG5cbmV4cG9ydCBjb25zdCBzbWFsbEFycm93UmlnaHQgPSBgXG4gIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwic21hbGwtYXJyb3ctcmlnaHRcIiB2aWV3Qm94PVwiMCAwIDUwIDUwXCI+XG4gICAgPHBhdGggZD1cIk0gMjAgMTUgTCAzNSAyNSBMIDIwIDM1IFpcIiAvPlxuICA8L3N2Zz5cbmA7XG5cbmV4cG9ydCBjb25zdCBzbWFsbEFycm93Qm90dG9tID0gYFxuICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cInNtYWxsLWFycm93LWJvdHRvbVwiIHZpZXdCb3g9XCIwIDAgNTAgNTBcIj5cbiAgICA8cGF0aCBkPVwiTSAxNSAxNyBMIDM1IDE3IEwgMjUgMzIgWlwiIC8+XG4gIDwvc3ZnPlxuYDtcblxuXG5cbiIsIm1vZHVsZS5leHBvcnRzID0gXCIgLmJhc2ljLWNvbnRyb2xsZXJzIHsgfSAuYmFzaWMtY29udHJvbGxlcnMgeyB3aWR0aDogMTAwJTsgbWF4LXdpZHRoOiA4MDBweDsgaGVpZ2h0OiAzNHB4OyBwYWRkaW5nOiAzcHg7IG1hcmdpbjogNHB4IDA7IGJhY2tncm91bmQtY29sb3I6ICNlZmVmZWY7IGJvcmRlcjogMXB4IHNvbGlkICNhYWFhYWE7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IGJvcmRlci1yYWRpdXM6IDJweDsgZGlzcGxheTogYmxvY2s7IGNvbG9yOiAjNDY0NjQ2OyAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7IC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTsgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgLW1zLXVzZXItc2VsZWN0OiBub25lOyB1c2VyLXNlbGVjdDogbm9uZTsgfSAuYmFzaWMtY29udHJvbGxlcnMgLmxhYmVsIHsgZm9udDogaXRhbGljIG5vcm1hbCAxLjJlbSBRdWlja3NhbmQsIGFyaWFsLCBzYW5zLXNlcmlmOyBsaW5lLWhlaWdodDogMjZweDsgb3ZlcmZsb3c6IGhpZGRlbjsgdGV4dC1hbGlnbjogcmlnaHQ7IHBhZGRpbmc6IDAgOHB4IDAgMDsgZGlzcGxheTogYmxvY2s7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IHdpZHRoOiAyNCU7IGZsb2F0OiBsZWZ0OyB3aGl0ZS1zcGFjZTogbm93cmFwOyAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAtbW96LXVzZXItc2VsZWN0OiBub25lOyAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IC1vLXVzZXItc2VsZWN0OiBub25lOyB1c2VyLXNlbGVjdDogbm9uZTsgfSAuYmFzaWMtY29udHJvbGxlcnMgLmlubmVyLXdyYXBwZXIgeyBkaXNwbGF5OiAtd2Via2l0LWlubGluZS1mbGV4OyBkaXNwbGF5OiBpbmxpbmUtZmxleDsgLXdlYmtpdC1mbGV4LXdyYXA6IG5vLXdyYXA7IGZsZXgtd3JhcDogbm8td3JhcDsgd2lkdGg6IDc2JTsgZmxvYXQ6IGxlZnQ7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsIHsgaGVpZ2h0OiA0OHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbDpub3QoLmFsaWduLXNtYWxsKSB7IGhlaWdodDogYXV0bzsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGw6bm90KC5hbGlnbi1zbWFsbCkgLmxhYmVsIHsgd2lkdGg6IDEwMCU7IGZsb2F0OiBub25lOyB0ZXh0LWFsaWduOiBsZWZ0OyBsaW5lLWhlaWdodDogNDBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGw6bm90KC5hbGlnbi1zbWFsbCkgLmlubmVyLXdyYXBwZXIgeyB3aWR0aDogMTAwJTsgZmxvYXQ6IG5vbmU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsLmFsaWduLXNtYWxsIC5sYWJlbCB7IGRpc3BsYXk6IGJsb2NrOyBtYXJnaW4tcmlnaHQ6IDIwcHg7IHRleHQtYWxpZ246IGxlZnQ7IGxpbmUtaGVpZ2h0OiA0MHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbC5hbGlnbi1zbWFsbCAuaW5uZXItd3JhcHBlciB7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IGF1dG87IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5hcnJvdy1yaWdodCwgLmJhc2ljLWNvbnRyb2xsZXJzIC5hcnJvdy1sZWZ0IHsgYm9yZGVyLXJhZGl1czogMnB4OyB3aWR0aDogMTRweDsgaGVpZ2h0OiAyNnB4OyBjdXJzb3I6IHBvaW50ZXI7IGJhY2tncm91bmQtY29sb3I6ICM0NjQ2NDY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5hcnJvdy1yaWdodCBsaW5lLCAuYmFzaWMtY29udHJvbGxlcnMgLmFycm93LWxlZnQgbGluZSB7IHN0cm9rZS13aWR0aDogM3B4OyBzdHJva2U6ICNmZmZmZmY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5hcnJvdy1yaWdodDpob3ZlciwgLmJhc2ljLWNvbnRyb2xsZXJzIC5hcnJvdy1sZWZ0OmhvdmVyIHsgYmFja2dyb3VuZC1jb2xvcjogIzY4Njg2ODsgfSAuYmFzaWMtY29udHJvbGxlcnMgLmFycm93LXJpZ2h0OmFjdGl2ZSwgLmJhc2ljLWNvbnRyb2xsZXJzIC5hcnJvdy1sZWZ0OmFjdGl2ZSB7IGJhY2tncm91bmQtY29sb3I6ICM5MDkwOTA7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5zbWFsbC1hcnJvdy1yaWdodCwgLmJhc2ljLWNvbnRyb2xsZXJzIC5zbWFsbC1hcnJvdy1ib3R0b20geyB3aWR0aDogMjZweDsgaGVpZ2h0OiAyNnB4OyBjdXJzb3I6IHBvaW50ZXI7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5zbWFsbC1hcnJvdy1yaWdodCBwYXRoLCAuYmFzaWMtY29udHJvbGxlcnMgLnNtYWxsLWFycm93LWJvdHRvbSBwYXRoIHsgZmlsbDogIzkwOTA5MDsgfSAuYmFzaWMtY29udHJvbGxlcnMgLnNtYWxsLWFycm93LXJpZ2h0OmhvdmVyIHBhdGgsIC5iYXNpYy1jb250cm9sbGVycyAuc21hbGwtYXJyb3ctYm90dG9tOmhvdmVyIHBhdGggeyBmaWxsOiAjNjg2ODY4OyB9IC5iYXNpYy1jb250cm9sbGVycyAudG9nZ2xlLWVsZW1lbnQgeyB3aWR0aDogMjZweDsgaGVpZ2h0OiAyNnB4OyBib3JkZXItcmFkaXVzOiAycHg7IGJhY2tncm91bmQtY29sb3I6ICM0NjQ2NDY7IGN1cnNvcjogcG9pbnRlcjsgfSAuYmFzaWMtY29udHJvbGxlcnMgLnRvZ2dsZS1lbGVtZW50OmhvdmVyIHsgYmFja2dyb3VuZC1jb2xvcjogIzY4Njg2ODsgfSAuYmFzaWMtY29udHJvbGxlcnMgLnRvZ2dsZS1lbGVtZW50IGxpbmUgeyBzdHJva2Utd2lkdGg6IDNweDsgfSAuYmFzaWMtY29udHJvbGxlcnMgLnRvZ2dsZS1lbGVtZW50IC54IHsgZGlzcGxheTogbm9uZTsgfSAuYmFzaWMtY29udHJvbGxlcnMgLnRvZ2dsZS1lbGVtZW50LmFjdGl2ZSAueCB7IGRpc3BsYXk6IGJsb2NrOyB9IC5iYXNpYy1jb250cm9sbGVycyAuYnRuIHsgZGlzcGxheTogYmxvY2s7IHRleHQtYWxpZ246IGNlbnRlcjsgZm9udDogbm9ybWFsIG5vcm1hbCAxMnB4IGFyaWFsOyB0ZXh0LWRlY29yYXRpb246IG5vbmU7IGhlaWdodDogMjZweDsgbGluZS1oZWlnaHQ6IDI2cHg7IGJhY2tncm91bmQtY29sb3I6ICM0NjQ2NDY7IGJvcmRlcjogbm9uZTsgY29sb3I6ICNmZmZmZmY7IG1hcmdpbjogMCA0cHggMCAwOyBwYWRkaW5nOiAwOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBib3JkZXItcmFkaXVzOiAycHg7IGN1cnNvcjogcG9pbnRlcjsgLXdlYmtpdC1mbGV4LWdyb3c6IDE7IGZsZXgtZ3JvdzogMTsgfSAuYmFzaWMtY29udHJvbGxlcnMgLmJ0bjpsYXN0LWNoaWxkIHsgbWFyZ2luOiAwOyB9IC5iYXNpYy1jb250cm9sbGVycyAuYnRuOmhvdmVyIHsgYmFja2dyb3VuZC1jb2xvcjogIzY4Njg2ODsgfSAuYmFzaWMtY29udHJvbGxlcnMgLmJ0bjphY3RpdmUsIC5iYXNpYy1jb250cm9sbGVycyAuYnRuLmFjdGl2ZSB7IGJhY2tncm91bmQtY29sb3I6ICM5MDkwOTA7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5idG46Zm9jdXMgeyBvdXRsaW5lOiBub25lOyB9IC5iYXNpYy1jb250cm9sbGVycyAubnVtYmVyIHsgaGVpZ2h0OiAyNnB4OyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHBvc2l0aW9uOiByZWxhdGl2ZTsgZm9udDogbm9ybWFsIG5vcm1hbCAxLjJlbSBRdWlja3NhbmQsIGFyaWFsLCBzYW5zLXNlcmlmOyB2ZXJ0aWNhbC1hbGlnbjogdG9wOyBib3JkZXI6IG5vbmU7IGJhY2tncm91bmQ6IG5vbmU7IGNvbG9yOiAjNDY0NjQ2OyBwYWRkaW5nOiAwIDRweDsgbWFyZ2luOiAwOyBiYWNrZ3JvdW5kLWNvbG9yOiAjZjlmOWY5OyBib3JkZXItcmFkaXVzOiAycHg7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH0gLmJhc2ljLWNvbnRyb2xsZXJzIC5udW1iZXI6Zm9jdXMgeyBvdXRsaW5lOiBub25lOyB9IC5iYXNpYy1jb250cm9sbGVycyBzZWxlY3QgeyBoZWlnaHQ6IDI2cHg7IGxpbmUtaGVpZ2h0OiAyNnB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjZjlmOWY5OyBib3JkZXItcmFkaXVzOiAycHg7IGJvcmRlcjogbm9uZTsgdmVydGljYWwtYWxpZ246IHRvcDsgcGFkZGluZzogMDsgbWFyZ2luOiAwOyB9IC5iYXNpYy1jb250cm9sbGVycyBzZWxlY3Q6Zm9jdXMgeyBvdXRsaW5lOiBub25lOyB9IC5iYXNpYy1jb250cm9sbGVycyBpbnB1dFt0eXBlPXRleHRdIHsgd2lkdGg6IDEwMCU7IGhlaWdodDogMjZweDsgbGluZS1oZWlnaHQ6IDI2cHg7IGJvcmRlcjogMDsgcGFkZGluZzogMCA0cHg7IGJhY2tncm91bmQtY29sb3I6ICNmOWY5Zjk7IGJvcmRlci1yYWRpdXM6IDJweDsgY29sb3I6ICM1NjU2NTY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsIC5hcnJvdy1yaWdodCwgLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsIC5hcnJvdy1sZWZ0IHsgd2lkdGg6IDI0cHg7IGhlaWdodDogNDBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGwgLnRvZ2dsZS1lbGVtZW50IHsgd2lkdGg6IDQwcHg7IGhlaWdodDogNDBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGwgLmJ0biB7IGhlaWdodDogNDBweDsgbGluZS1oZWlnaHQ6IDQwcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsIC5udW1iZXIgeyBoZWlnaHQ6IDQwcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsIHNlbGVjdCB7IGhlaWdodDogNDBweDsgbGluZS1oZWlnaHQ6IDQwcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsIGlucHV0W3R5cGU9dGV4dF0geyBoZWlnaHQ6IDQwcHg7IGxpbmUtaGVpZ2h0OiA0MHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy50aXRsZSB7IGJvcmRlcjogbm9uZSAhaW1wb3J0YW50OyBtYXJnaW4tYm90dG9tOiAwOyBtYXJnaW4tdG9wOiA4cHg7IHBhZGRpbmctdG9wOiA4cHg7IHBhZGRpbmctYm90dG9tOiAwOyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50OyBoZWlnaHQ6IDI1cHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnRpdGxlIC5sYWJlbCB7IGZvbnQ6IG5vcm1hbCBib2xkIDEuM2VtIFF1aWNrc2FuZCwgYXJpYWwsIHNhbnMtc2VyaWY7IGhlaWdodDogMTAwJTsgb3ZlcmZsb3c6IGhpZGRlbjsgdGV4dC1hbGlnbjogbGVmdDsgcGFkZGluZzogMDsgd2lkdGg6IDEwMCU7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC13ZWJraXQtZmxleC1ncm93OiAxOyBmbGV4LWdyb3c6IDE7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyb3VwIHsgaGVpZ2h0OiBhdXRvOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JvdXAgLmdyb3VwLWhlYWRlciAubGFiZWwgeyBmb250OiBub3JtYWwgYm9sZCAxLjNlbSBRdWlja3NhbmQsIGFyaWFsLCBzYW5zLXNlcmlmOyBoZWlnaHQ6IDI2cHg7IGxpbmUtaGVpZ2h0OiAyNnB4OyBvdmVyZmxvdzogaGlkZGVuOyB0ZXh0LWFsaWduOiBsZWZ0OyBwYWRkaW5nOiAwIDAgMCAzNnB4OyB3aWR0aDogMTAwJTsgYm94LXNpemluZzogYm9yZGVyLWJveDsgLXdlYmtpdC1mbGV4LWdyb3c6IDE7IGZsZXgtZ3JvdzogMTsgZmxvYXQ6IG5vbmU7IGN1cnNvcjogcG9pbnRlcjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JvdXAgLmdyb3VwLWhlYWRlciAuc21hbGwtYXJyb3ctcmlnaHQgeyB3aWR0aDogMjZweDsgaGVpZ2h0OiAyNnB4OyBwb3NpdGlvbjogYWJzb2x1dGU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyb3VwIC5ncm91cC1oZWFkZXIgLnNtYWxsLWFycm93LWJvdHRvbSB7IHdpZHRoOiAyNnB4OyBoZWlnaHQ6IDI2cHg7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JvdXAgLmdyb3VwLWNvbnRlbnQgeyBvdmVyZmxvdzogaGlkZGVuOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncm91cCAuZ3JvdXAtY29udGVudCA+IGRpdiB7IG1hcmdpbjogNHB4IGF1dG87IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyb3VwIC5ncm91cC1jb250ZW50ID4gZGl2Omxhc3QtY2hpbGQgeyBtYXJnaW4tYm90dG9tOiAwOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncm91cC5vcGVuZWQgLmdyb3VwLWhlYWRlciAuc21hbGwtYXJyb3ctcmlnaHQgeyBkaXNwbGF5OiBub25lOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncm91cC5vcGVuZWQgLmdyb3VwLWhlYWRlciAuc21hbGwtYXJyb3ctYm90dG9tIHsgZGlzcGxheTogYmxvY2s7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyb3VwLm9wZW5lZCAuZ3JvdXAtY29udGVudCB7IGRpc3BsYXk6IGJsb2NrOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncm91cC5jbG9zZWQgLmdyb3VwLWhlYWRlciAuc21hbGwtYXJyb3ctcmlnaHQgeyBkaXNwbGF5OiBibG9jazsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JvdXAuY2xvc2VkIC5ncm91cC1oZWFkZXIgLnNtYWxsLWFycm93LWJvdHRvbSB7IGRpc3BsYXk6IG5vbmU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyb3VwLmNsb3NlZCAuZ3JvdXAtY29udGVudCB7IGRpc3BsYXk6IG5vbmU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNsaWRlciAucmFuZ2UgeyBoZWlnaHQ6IDI2cHg7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgbWFyZ2luOiAwOyAtd2Via2l0LWZsZXgtZ3JvdzogNDsgZmxleC1ncm93OiA0OyBwb3NpdGlvbjogcmVsYXRpdmU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNsaWRlciAucmFuZ2UgY2FudmFzIHsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNsaWRlciAubnVtYmVyLXdyYXBwZXIgeyBkaXNwbGF5OiBpbmxpbmU7IGhlaWdodDogMjZweDsgdGV4dC1hbGlnbjogcmlnaHQ7IC13ZWJraXQtZmxleC1ncm93OiAzOyBmbGV4LWdyb3c6IDM7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNsaWRlciAubnVtYmVyLXdyYXBwZXIgLm51bWJlciB7IGxlZnQ6IDVweDsgd2lkdGg6IDU0cHg7IHRleHQtYWxpZ246IHJpZ2h0OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbGlkZXIgLm51bWJlci13cmFwcGVyIC51bml0IHsgZm9udDogaXRhbGljIG5vcm1hbCAxZW0gUXVpY2tzYW5kLCBhcmlhbCwgc2Fucy1zZXJpZjsgbGluZS1oZWlnaHQ6IDI2cHg7IGhlaWdodDogMjZweDsgd2lkdGg6IDMwcHg7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgcG9zaXRpb246IHJlbGF0aXZlOyBwYWRkaW5nLWxlZnQ6IDVweDsgcGFkZGluZy1yaWdodDogNXB4OyBjb2xvcjogIzU2NTY1NjsgfSAuYmFzaWMtY29udHJvbGxlcnMuc2xpZGVyIC5udW1iZXItd3JhcHBlciAudW5pdCBzdXAgeyBsaW5lLWhlaWdodDogN3B4OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbGlkZXIuc2xpZGVyLWxhcmdlIC5yYW5nZSB7IC13ZWJraXQtZmxleC1ncm93OiA1MDsgZmxleC1ncm93OiA1MDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc2xpZGVyLnNsaWRlci1sYXJnZSAubnVtYmVyLXdyYXBwZXIgeyAtd2Via2l0LWZsZXgtZ3JvdzogMTsgZmxleC1ncm93OiAxOyB9IC5iYXNpYy1jb250cm9sbGVycy5zbGlkZXIuc2xpZGVyLXNtYWxsIC5yYW5nZSB7IC13ZWJraXQtZmxleC1ncm93OiAyOyBmbGV4LWdyb3c6IDI7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNsaWRlci5zbGlkZXItc21hbGwgLm51bWJlci13cmFwcGVyIHsgLXdlYmtpdC1mbGV4LWdyb3c6IDQ7IGZsZXgtZ3JvdzogNDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGwuc2xpZGVyIC5yYW5nZSB7IGhlaWdodDogNDBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGwuc2xpZGVyIC5udW1iZXItd3JhcHBlciB7IGhlaWdodDogNDBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuc21hbGwuc2xpZGVyIC5udW1iZXItd3JhcHBlciAudW5pdCB7IGxpbmUtaGVpZ2h0OiA0MHB4OyBoZWlnaHQ6IDQwcHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLm51bWJlci1ib3ggLm51bWJlciB7IHdpZHRoOiAxMjBweDsgbWFyZ2luOiAwIDEwcHg7IHZlcnRpY2FsLWFsaWduOiB0b3A7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNlbGVjdC1saXN0IHNlbGVjdCB7IG1hcmdpbjogMCAxMHB4OyB3aWR0aDogMTIwcHg7IGZvbnQ6IG5vcm1hbCBub3JtYWwgMS4yZW0gUXVpY2tzYW5kLCBhcmlhbCwgc2Fucy1zZXJpZjsgY29sb3I6ICM0NjQ2NDY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNlbGVjdC1idXR0b25zIC5idG46Zmlyc3Qtb2YtdHlwZSB7IG1hcmdpbi1sZWZ0OiA0cHg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnRleHQgaW5wdXRbdHlwZT10ZXh0XSB7IGZvbnQ6IG5vcm1hbCBub3JtYWwgMS4yZW0gUXVpY2tzYW5kLCBhcmlhbCwgc2Fucy1zZXJpZjsgY29sb3I6ICM0NjQ2NDY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRyYWctYW5kLWRyb3AgeyB3aWR0aDogMTAwJTsgdGV4dC1hbGlnbjogY2VudGVyOyBmb250LXdlaWdodDogYm9sZDsgaGVpZ2h0OiAxMDBweDsgfSAuYmFzaWMtY29udHJvbGxlcnMuZHJhZy1hbmQtZHJvcCAuZHJvcC16b25lIHsgYm9yZGVyOiAxcHggZG90dGVkICNjNGM0YzQ7IGJvcmRlci1yYWRpdXM6IDJweDsgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAyMDBtczsgaGVpZ2h0OiA5MHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy5kcmFnLWFuZC1kcm9wIC5kcm9wLXpvbmUuZHJhZyB7IGJhY2tncm91bmQtY29sb3I6ICNjNGM0YzQ7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRyYWctYW5kLWRyb3AgLmxhYmVsIHsgZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDkwcHg7IGxpbmUtaGVpZ2h0OiA5MHB4OyBtYXJnaW46IDA7IHBhZGRpbmc6IDA7IHRleHQtYWxpZ246IGNlbnRlcjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZHJhZy1hbmQtZHJvcC5wcm9jZXNzIC5sYWJlbCB7IGRpc3BsYXk6IG5vbmU7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLnNtYWxsLmRyYWctYW5kLWRyb3AgeyBoZWlnaHQ6IDEyMHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbC5kcmFnLWFuZC1kcm9wIC5kcm9wLXpvbmUgeyBoZWlnaHQ6IDExMHB4OyB9IC5iYXNpYy1jb250cm9sbGVycy5zbWFsbC5kcmFnLWFuZC1kcm9wIC5sYWJlbCB7IGRpc3BsYXk6IGJsb2NrOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMTBweDsgbGluZS1oZWlnaHQ6IDExMHB4OyBtYXJnaW46IDA7IHBhZGRpbmc6IDA7IHRleHQtYWxpZ246IGNlbnRlcjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSB7IGJhY2tncm91bmQtY29sb3I6ICMzNjM2MzY7IGJvcmRlcjogMXB4IHNvbGlkICM1ODU4NTg7IGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOTUpOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC50b2dnbGUtZWxlbWVudCB7IGJhY2tncm91bmQtY29sb3I6ICNlZmVmZWY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLnRvZ2dsZS1lbGVtZW50IGxpbmUgeyBzdHJva2U6ICMzNjM2MzY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLnRvZ2dsZS1lbGVtZW50OmhvdmVyIHsgYmFja2dyb3VuZC1jb2xvcjogI2NkY2RjZDsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuYXJyb3ctcmlnaHQsIC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC5hcnJvdy1sZWZ0IHsgYmFja2dyb3VuZC1jb2xvcjogI2VmZWZlZjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuYXJyb3ctcmlnaHQgbGluZSwgLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLmFycm93LWxlZnQgbGluZSB7IHN0cm9rZTogIzM2MzYzNjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuYXJyb3ctcmlnaHQ6aG92ZXIsIC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC5hcnJvdy1sZWZ0OmhvdmVyIHsgYmFja2dyb3VuZC1jb2xvcjogI2NkY2RjZDsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuYXJyb3ctcmlnaHQ6YWN0aXZlLCAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuYXJyb3ctbGVmdDphY3RpdmUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjYWJhYmFiOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC5zbWFsbC1hcnJvdy1yaWdodCBwYXRoLCAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuc21hbGwtYXJyb3ctYm90dG9tIHBhdGggeyBmaWxsOiAjYWJhYmFiOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC5zbWFsbC1hcnJvdy1yaWdodDpob3ZlciBwYXRoLCAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuc21hbGwtYXJyb3ctYm90dG9tOmhvdmVyIHBhdGggeyBmaWxsOiAjY2RjZGNkOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC5udW1iZXIsIC5iYXNpYy1jb250cm9sbGVycy5ncmV5IHNlbGVjdCwgLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgaW5wdXRbdHlwZT10ZXh0XSB7IGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOTUpOyBiYWNrZ3JvdW5kLWNvbG9yOiAjNDU0NTQ1OyB9IC5iYXNpYy1jb250cm9sbGVycy5ncmV5IC5idG4geyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZlZmVmOyBjb2xvcjogIzM2MzYzNjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuYnRuOmhvdmVyIHsgYmFja2dyb3VuZC1jb2xvcjogI2NkY2RjZDsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleSAuYnRuOmFjdGl2ZSwgLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkgLmJ0bi5hY3RpdmUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjYWJhYmFiOyB9IC5iYXNpYy1jb250cm9sbGVycy5ncmV5LnNsaWRlciAuaW5uZXItd3JhcHBlciAubnVtYmVyLXdyYXBwZXIgLnVuaXQgeyBjb2xvcjogI2JjYmNiYzsgfSAuYmFzaWMtY29udHJvbGxlcnMuZ3JleS5ncm91cCB7IGJhY2tncm91bmQtY29sb3I6ICM1MDUwNTA7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkuZHJhZy1hbmQtZHJvcCAuZHJvcC16b25lIHsgYm9yZGVyOiAxcHggZG90dGVkICM3MjcyNzI7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmdyZXkuZHJhZy1hbmQtZHJvcCAuZHJvcC16b25lLmRyYWcgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjNzI3MjcyOyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIHsgYmFja2dyb3VuZC1jb2xvcjogIzI0MjQyNDsgYm9yZGVyOiAxcHggc29saWQgIzI4MjgyODsgY29sb3I6ICNmZmZmZmY7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLnRvZ2dsZS1lbGVtZW50IHsgYmFja2dyb3VuZC1jb2xvcjogIzQ2NDY0NjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAudG9nZ2xlLWVsZW1lbnQgbGluZSB7IHN0cm9rZTogI2ZmZmZmZjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAudG9nZ2xlLWVsZW1lbnQ6aG92ZXIgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjNjg2ODY4OyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5hcnJvdy1yaWdodCwgLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLmFycm93LWxlZnQgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjNDY0NjQ2OyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5hcnJvdy1yaWdodCBsaW5lLCAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuYXJyb3ctbGVmdCBsaW5lIHsgc3Ryb2tlOiAjZmZmZmZmOyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5hcnJvdy1yaWdodDpob3ZlciwgLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLmFycm93LWxlZnQ6aG92ZXIgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjNjg2ODY4OyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5hcnJvdy1yaWdodDphY3RpdmUsIC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5hcnJvdy1sZWZ0OmFjdGl2ZSB7IGJhY2tncm91bmQtY29sb3I6ICM5MDkwOTA7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLnNtYWxsLWFycm93LXJpZ2h0IHBhdGgsIC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5zbWFsbC1hcnJvdy1ib3R0b20gcGF0aCB7IGZpbGw6ICM5MDkwOTA7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLnNtYWxsLWFycm93LXJpZ2h0OmhvdmVyIHBhdGgsIC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5zbWFsbC1hcnJvdy1ib3R0b206aG92ZXIgcGF0aCB7IGZpbGw6ICM2ODY4Njg7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLm51bWJlciwgLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgc2VsZWN0LCAuYmFzaWMtY29udHJvbGxlcnMuZGFyayBpbnB1dFt0eXBlPXRleHRdIHsgY29sb3I6ICNmZmZmZmY7IGJhY2tncm91bmQtY29sb3I6ICMzMzMzMzM7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsgLmJ0biB7IGJhY2tncm91bmQtY29sb3I6ICM0NjQ2NDY7IGNvbG9yOiAjZmZmZmZmOyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5idG46aG92ZXIgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjNjg2ODY4OyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrIC5idG46YWN0aXZlLCAuYmFzaWMtY29udHJvbGxlcnMuZGFyayAuYnRuLmFjdGl2ZSB7IGJhY2tncm91bmQtY29sb3I6ICM5MDkwOTA7IH0gLmJhc2ljLWNvbnRyb2xsZXJzLmRhcmsuc2xpZGVyIC5pbm5lci13cmFwcGVyIC5udW1iZXItd3JhcHBlciAudW5pdCB7IGNvbG9yOiAjY2RjZGNkOyB9IC5iYXNpYy1jb250cm9sbGVycy5kYXJrLmdyb3VwIHsgYmFja2dyb3VuZC1jb2xvcjogIzNlM2UzZTsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyay5kcmFnLWFuZC1kcm9wIC5kcm9wLXpvbmUgeyBib3JkZXI6IDFweCBkb3R0ZWQgIzQyNDI0MjsgfSAuYmFzaWMtY29udHJvbGxlcnMuZGFyay5kcmFnLWFuZC1kcm9wIC5kcm9wLXpvbmUuZHJhZyB7IGJhY2tncm91bmQtY29sb3I6ICM0MjQyNDI7IH0gXCI7IiwiaW1wb3J0IHsgbmFtZSB9IGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLWRlY2xhcmF0aW9ucy5qcyc7XG5cbmV4cG9ydCBjb25zdCBucyA9IG5hbWUucmVwbGFjZSgnQGlyY2FtLycsICcnKTtcblxuY29uc3QgbnNDbGFzcyA9IGAuJHtuc31gO1xubGV0IF9kaXNhYmxlZCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgX2Rpc2FibGVkID0gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydFN0eWxlU2hlZXQoKSB7XG4gIGlmIChfZGlzYWJsZWQpIHJldHVybjtcblxuICBjb25zdCAkY3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgJGNzcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZXNwYWNlJywgbnMpO1xuICAkY3NzLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmICgkY3NzLnN0eWxlU2hlZXQpXG4gICAgJGNzcy5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZXM7XG4gIGVsc2VcbiAgICAkY3NzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0eWxlcykpO1xuXG4gIC8vIGluc2VydCBiZWZvcmUgbGluayBvciBzdHlsZXMgaWYgZXhpc3RzXG4gIGNvbnN0ICRsaW5rID0gZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKCdsaW5rJyk7XG4gIGNvbnN0ICRzdHlsZSA9IGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3Rvcignc3R5bGUnKTtcblxuICBpZiAoJGxpbmspXG4gICAgZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUoJGNzcywgJGxpbmspO1xuICBlbHNlIGlmICgkc3R5bGUpXG4gICAgZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUoJGNzcywgJHN0eWxlKTtcbiAgZWxzZVxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJGNzcyk7XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfZnJvbVwiOiBcIkBpcmNhbS9iYXNpYy1jb250cm9sbGVyc1wiLFxuICBcIl9pZFwiOiBcIkBpcmNhbS9iYXNpYy1jb250cm9sbGVyc0AxLjAuNFwiLFxuICBcIl9pbkJ1bmRsZVwiOiBmYWxzZSxcbiAgXCJfaW50ZWdyaXR5XCI6IFwic2hhNTEyLTNjU0F0eGZwWHRnMWEzaHZ5VkpONWdObWZxd2Y1bVNieHV4cTJnOUk2L3JvVXN3dHhPZ0d3WXdXVjE4VUpGV1I3NU1xb3Q1U1NWdmJMZFBQZ3Yxbm9BPT1cIixcbiAgXCJfbG9jYXRpb25cIjogXCIvQGlyY2FtL2Jhc2ljLWNvbnRyb2xsZXJzXCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcInR5cGVcIjogXCJ0YWdcIixcbiAgICBcInJlZ2lzdHJ5XCI6IHRydWUsXG4gICAgXCJyYXdcIjogXCJAaXJjYW0vYmFzaWMtY29udHJvbGxlcnNcIixcbiAgICBcIm5hbWVcIjogXCJAaXJjYW0vYmFzaWMtY29udHJvbGxlcnNcIixcbiAgICBcImVzY2FwZWROYW1lXCI6IFwiQGlyY2FtJTJmYmFzaWMtY29udHJvbGxlcnNcIixcbiAgICBcInNjb3BlXCI6IFwiQGlyY2FtXCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiXCIsXG4gICAgXCJzYXZlU3BlY1wiOiBudWxsLFxuICAgIFwiZmV0Y2hTcGVjXCI6IFwibGF0ZXN0XCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIjVVNFUlwiLFxuICAgIFwiL1wiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvQGlyY2FtL2Jhc2ljLWNvbnRyb2xsZXJzLy0vYmFzaWMtY29udHJvbGxlcnMtMS4wLjQudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcIjJlMjE1MmM2MThiYWU5NDYxMjZiOGViZjQxYmFlYjk1Y2IzYzQwZjhcIixcbiAgXCJfc3BlY1wiOiBcIkBpcmNhbS9iYXNpYy1jb250cm9sbGVyc1wiLFxuICBcIl93aGVyZVwiOiBcIi9Vc2Vycy9tYXR1c3pld3NraS9kZXYvanMvd2F2ZXNqcy9saWIvd2F2ZXMtYmxvY2tzL2V4YW1wbGVzL21vZHVsZS1saXN0XCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vaXJjYW0tanN0b29scy9iYXNpYy1jb250cm9sbGVycy9pc3N1ZXNcIlxuICB9LFxuICBcImJ1bmRsZURlcGVuZGVuY2llc1wiOiBmYWxzZSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGlyY2FtL2d1aS1jb21wb25lbnRzXCI6IFwiXjEuMC4zXCJcbiAgfSxcbiAgXCJkZXByZWNhdGVkXCI6IGZhbHNlLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiU2V0IG9mIHNpbXBsZSBjb250cm9sbGVycyBmb3IgcmFwaWQgcHJvdG90eXBpbmdcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmFiZWwtY29yZVwiOiBcIl42LjI2LjBcIixcbiAgICBcImJhYmVsLXBsdWdpbi10cmFuc2Zvcm0tZXMyMDE1LW1vZHVsZXMtY29tbW9uanNcIjogXCJeNi4yNi4wXCIsXG4gICAgXCJiYWJlbC1wcmVzZXQtZW52XCI6IFwiXjEuNi4xXCIsXG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjE0LjUuMFwiLFxuICAgIFwiY2hhbGtcIjogXCJeMi4zLjBcIixcbiAgICBcImZzLWV4dHJhXCI6IFwiXjQuMC4zXCIsXG4gICAgXCJqc2RvYy10by1tYXJrZG93blwiOiBcIl4zLjAuMFwiLFxuICAgIFwia2xhd1wiOiBcIl4yLjEuMVwiLFxuICAgIFwibm9kZS1zYXNzXCI6IFwiXjQuNy4yXCIsXG4gICAgXCJucFwiOiBcIl4yLjE4LjJcIixcbiAgICBcInRhcGVcIjogXCJeNC44LjBcIixcbiAgICBcInVnbGlmeS1qc1wiOiBcIl4zLjIuMlwiLFxuICAgIFwid2F0Y2hcIjogXCJeMS4wLjJcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2lyY2FtLWpzdG9vbHMvYmFzaWMtY29udHJvbGxlcnMjcmVhZG1lXCIsXG4gIFwibGljZW5zZVwiOiBcIkJTRC0zLUNsYXVzZVwiLFxuICBcIm1haW5cIjogXCJkaXN0L2luZGV4LmpzXCIsXG4gIFwibmFtZVwiOiBcIkBpcmNhbS9iYXNpYy1jb250cm9sbGVyc1wiLFxuICBcInB1Ymxpc2hDb25maWdcIjoge1xuICAgIFwiYWNjZXNzXCI6IFwicHVibGljXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vaXJjYW0tanN0b29scy9iYXNpYy1jb250cm9sbGVycy5naXRcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnVuZGxlXCI6IFwibm9kZSAuL2Jpbi9ydW5uZXIgLS1idW5kbGVcIixcbiAgICBcImRlcGxveVwiOiBcIm5wIC0teW9sb1wiLFxuICAgIFwiZG9jXCI6IFwianNkb2MybWQgLXQgdG1wbC9SRUFETUUuaGJzIHNyYy8qKi8qLmpzID4gUkVBRE1FLm1kXCIsXG4gICAgXCJwcmV3YXRjaFwiOiBcIm5wbSBydW4gdHJhbnNwaWxlXCIsXG4gICAgXCJ0cmFuc3BpbGVcIjogXCJub2RlIC4vYmluL3J1bm5lciAtLXRyYW5zcGlsZVwiLFxuICAgIFwidmVyc2lvblwiOiBcIm5wbSBydW4gdHJhbnNwaWxlICYmIG5wbSBydW4gZG9jICYmIGdpdCBhZGQgUkVBRE1FLm1kXCIsXG4gICAgXCJ3YXRjaFwiOiBcIm5vZGUgLi9iaW4vcnVubmVyIC0td2F0Y2hcIlxuICB9LFxuICBcInN0YW5kYWxvbmVcIjogXCJiYXNpY0NvbnRyb2xsZXJzXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMC40XCJcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBndWktY29tcG9uZW50c1xuICovXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNsaWRlciB9IGZyb20gJy4vU2xpZGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnJlYWtwb2ludCB9IGZyb20gJy4vQnJlYWtwb2ludCc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcHJvbWlzZSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3Byb21pc2VcIik7XG5cbnZhciBfcHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9taXNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIG5ldyBfcHJvbWlzZTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF9wcm9taXNlMi5kZWZhdWx0LnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgc3RlcChcInRocm93XCIsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIpO1xuICAgIH0pO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKTtcblxudmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGRlc2MgPSAoMCwgX2dldE93blByb3BlcnR5RGVzY3JpcHRvcjIuZGVmYXVsdCkob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShvYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0ID8gKDAsIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJyk7XG52YXIgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKSB7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICByZXR1cm4gJE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Qua2V5cztcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjMnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYga2V5IGluIGV4cG9ydHMpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gKCFCVUdHWSAmJiAkbmF0aXZlKSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgU2FmYXJpIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICB9IGVsc2UgaWYgKE9ic2VydmVyICYmICEoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnN0YW5kYWxvbmUpKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG4iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gdHlwZW9mIGNvcmVbS0VZXSA9PSAnZnVuY3Rpb24nID8gY29yZVtLRVldIDogZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mIH0pO1xuIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcbiIsIiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcbiAgaWYgKHByb21pc2UuX24pIHJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS10cnlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdQcm9taXNlJywgeyAndHJ5JzogZnVuY3Rpb24gKGNhbGxiYWNrZm4pIHtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZih0aGlzKTtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oY2FsbGJhY2tmbik7XG4gIChyZXN1bHQuZSA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59IH0pO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcbiIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcbiIsImltcG9ydCBMb2FkZXIgZnJvbSAnLi9sb2FkZXInO1xuXG5cbi8qKlxuICogR2V0cyBjYWxsZWQgaWYgYSBwYXJhbWV0ZXIgaXMgbWlzc2luZyBhbmQgdGhlIGV4cHJlc3Npb25cbiAqIHNwZWNpZnlpbmcgdGhlIGRlZmF1bHQgdmFsdWUgaXMgZXZhbHVhdGVkLlxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZNaXNzaW5nKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcGFyYW1ldGVyJyk7XG59XG5cbmxldCBhdWRpb0NvbnRleHQ7XG5cbndpbmRvdy5BdWRpb0NvbnRleHQgPSAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KTtcblxudHJ5IHtcbiAgYXVkaW9Db250ZXh0ID0gbmV3IHdpbmRvdy5BdWRpb0NvbnRleHQoKTtcbn0gY2F0Y2ggKGUpIHt9XG5cblxuLyoqXG4gKiBBdWRpb0J1ZmZlckxvYWRlclxuICogUHJvbWlzZSBiYXNlZCBpbXBsZW1lbnRhdGlvbiBvZiBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyIGZvciBHRVQgbWV0aG9kIGFuZCBkZWNvZGUgYXVkaW8gZGF0YSBmb3IgYXJyYXlidWZmZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvQnVmZmVyTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcbiAgLyoqXG4gICAqIFNldCB0aGUgcmVzcG9uc2VUeXBlIHRvICdhcnJheWJ1ZmZlcicgYW5kIGluaXRpYWxpemUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiXVxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJykge1xuICAgIHN1cGVyKHJlc3BvbnNlVHlwZSk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgXCJ3cmFwQXJvdW5kRXh0ZW5zaW9uXCI6IDBcbiAgICB9O1xuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IHRvIHNldCB0aGUgYXVkaW8gY29udGV4dCB0aGF0IHNob3VsZCBiZSB1c2VkIGluIG9yZGVyIHRvIGRlY29kZVxuICAgKiB0aGUgZmlsZSBhbmQgY3JlYXRlIHRoZSBBdWRpb0J1ZmZlci5cbiAgICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGF1ZGlvQ29udGV4dFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgcHJvbWlzZSBhdWRpbyBmaWxlIGxvYWRpbmcgYW5kIGRlY29kaW5nLlxuICAgKiBAcGFyYW0geyhzdHJpbmd8c3RyaW5nW10pfSBmaWxlVVJMcyAtIFRoZSBVUkwocykgb2YgdGhlIGF1ZGlvIGZpbGVzIHRvIGxvYWQuIEFjY2VwdHMgYSBVUkwgcG9pbnRpbmcgdG8gdGhlIGZpbGUgbG9jYXRpb24gb3IgYW4gYXJyYXkgb2YgVVJMcy5cbiAgICogQHBhcmFtIHt7d3JhcEFyb3VuZEV4dGVuc2lvbjogbnVtYmVyfX0gW29wdGlvbnNdIC0gT2JqZWN0IHdpdGggYSB3cmFwQXJvdW5kRXh0ZW5zaW9uIGtleSB3aGljaCBzZXQgdGhlIGxlbmd0aCwgaW4gc2Vjb25kcyB0byBiZSBjb3BpZWQgZnJvbSB0aGUgYmVnaW5pbmcgYXQgdGhlIGVuZCBvZiB0aGUgcmV0dXJuZWQgQXVkaW9CdWZmZXJcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBsb2FkKGZpbGVVUkxzID0gdGhyb3dJZk1pc3NpbmcoKSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiA9IHRoaXMub3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uIHx8IDA7XG4gICAgcmV0dXJuIHN1cGVyLmxvYWQoZmlsZVVSTHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYSBzaW5nbGUgYXVkaW8gZmlsZSwgZGVjb2RlIGl0IGluIGFuIEF1ZGlvQnVmZmVyLCByZXR1cm4gYSBQcm9taXNlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlVVJMIC0gVGhlIFVSTCBvZiB0aGUgYXVkaW8gZmlsZSBsb2NhdGlvbiB0byBsb2FkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGxvYWRPbmUoZmlsZVVSTCkge1xuICAgIHJldHVybiBzdXBlci5sb2FkT25lKGZpbGVVUkwpXG4gICAgICAudGhlbihcbiAgICAgICAgdGhpcy5kZWNvZGVBdWRpb0RhdGEuYmluZCh0aGlzKSxcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhbGwgYXVkaW8gZmlsZXMgYXQgb25jZSBpbiBhIHNpbmdsZSBhcnJheSwgZGVjb2RlIHRoZW0gaW4gYW4gYXJyYXkgb2YgQXVkaW9CdWZmZXJzLCBhbmQgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmlsZVVSTHMgLSBUaGUgVVJMcyBhcnJheSBvZiB0aGUgYXVkaW8gZmlsZXMgdG8gbG9hZC5cbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBsb2FkQWxsKGZpbGVVUkxzKSB7XG4gICAgcmV0dXJuIHN1cGVyLmxvYWRBbGwoZmlsZVVSTHMpXG4gICAgICAudGhlbihcbiAgICAgICAgKGFycmF5YnVmZmVycykgPT4ge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChhcnJheWJ1ZmZlcnMubWFwKChhcnJheWJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlQXVkaW9EYXRhLmJpbmQodGhpcykoYXJyYXlidWZmZXIpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFRPRE86IGJldHRlciBlcnJvciBoYW5kbGVyXG4gICAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBBdWRpbyBEYXRhLCByZXR1cm4gYSBQcm9taXNlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7YXJyYXlidWZmZXJ9IC0gVGhlIGFycmF5YnVmZmVyIG9mIHRoZSBsb2FkZWQgYXVkaW8gZmlsZSB0byBiZSBkZWNvZGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGRlY29kZUF1ZGlvRGF0YShhcnJheWJ1ZmZlcikge1xuICAgIGlmIChhcnJheWJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoXG4gICAgICAgICAgYXJyYXlidWZmZXIsIC8vIHJldHVybmVkIGF1ZGlvIGRhdGEgYXJyYXlcbiAgICAgICAgICAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb24gPT09IDApIHJlc29sdmUoYnVmZmVyKTtcbiAgICAgICAgICAgIGVsc2UgcmVzb2x2ZSh0aGlzLl9fd3JhcEFyb3VuZChidWZmZXIpKTtcbiAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJEZWNvZGVBdWRpb0RhdGEgZXJyb3JcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXNvbHZlKGFycmF5YnVmZmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwQXJvdW5kLCBjb3B5IHRoZSBiZWdpbmluZyBpbnB1dCBidWZmZXIgdG8gdGhlIGVuZCBvZiBhbiBvdXRwdXQgYnVmZmVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7YXJyYXlidWZmZXJ9IGluQnVmZmVyIHthcnJheWJ1ZmZlcn0gLSBUaGUgaW5wdXQgYnVmZmVyXG4gICAqIEByZXR1cm5zIHthcnJheWJ1ZmZlcn0gLSBUaGUgcHJvY2Vzc2VkIGJ1ZmZlciAod2l0aCBmcmFtZSBjb3BpZWQgZnJvbSB0aGUgYmVnaW5pbmcgdG8gdGhlIGVuZClcbiAgICovXG4gIF9fd3JhcEFyb3VuZChpbkJ1ZmZlcikge1xuICAgIHZhciBsZW5ndGggPSBpbkJ1ZmZlci5sZW5ndGggKyB0aGlzLm9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiAqIGluQnVmZmVyLnNhbXBsZVJhdGU7XG5cbiAgICB2YXIgb3V0QnVmZmVyID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKGluQnVmZmVyLm51bWJlck9mQ2hhbm5lbHMsIGxlbmd0aCwgaW5CdWZmZXIuc2FtcGxlUmF0ZSk7XG4gICAgdmFyIGFycmF5Q2hEYXRhLCBhcnJheU91dENoRGF0YTtcblxuICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgaW5CdWZmZXIubnVtYmVyT2ZDaGFubmVsczsgY2hhbm5lbCsrKSB7XG4gICAgICBhcnJheUNoRGF0YSA9IGluQnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWwpO1xuICAgICAgYXJyYXlPdXRDaERhdGEgPSBvdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XG5cbiAgICAgIGFycmF5T3V0Q2hEYXRhLmZvckVhY2goZnVuY3Rpb24oc2FtcGxlLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCBpbkJ1ZmZlci5sZW5ndGgpIGFycmF5T3V0Q2hEYXRhW2luZGV4XSA9IGFycmF5Q2hEYXRhW2luZGV4XTtcbiAgICAgICAgZWxzZSBhcnJheU91dENoRGF0YVtpbmRleF0gPSBhcnJheUNoRGF0YVtpbmRleCAtIGluQnVmZmVyLmxlbmd0aF07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0QnVmZmVyO1xuICB9XG59XG4iLCIvKipcbiAqIEBmaWxlIExvYWRlcnM6IEF1ZGlvQnVmZmVyIGxvYWRlciBhbmQgdXRpbGl0aWVzXG4gKiBAYXV0aG9yIFNhbXVlbCBHb2xkc3ptaWR0XG4gKiBAdmVyc2lvbiAwLjEuMVxuICovXG5leHBvcnQgeyBkZWZhdWx0IGFzIExvYWRlciB9IGZyb20gJy4vbG9hZGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXVkaW9CdWZmZXJMb2FkZXIgfSBmcm9tICcuL2F1ZGlvLWJ1ZmZlci1sb2FkZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdXBlckxvYWRlciB9IGZyb20gJy4vc3VwZXItbG9hZGVyJztcbiIsIi8qKlxuICogR2V0cyBjYWxsZWQgaWYgYSBwYXJhbWV0ZXIgaXMgbWlzc2luZyBhbmQgdGhlIGV4cHJlc3Npb25cbiAqIHNwZWNpZnlpbmcgdGhlIGRlZmF1bHQgdmFsdWUgaXMgZXZhbHVhdGVkLlxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZNaXNzaW5nKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcGFyYW1ldGVyJyk7XG59XG5cblxuLyoqXG4gKiBQcm9taXNlIGJhc2VkIGltcGxlbWVudGF0aW9uIG9mIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIgZm9yIEdFVCBtZXRob2QuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvYWRlciB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Jlc3BvbnNlVHlwZT1cIlwiXSAtIHJlc3BvbnNlVHlwZSdzIHZhbHVlLCBcInRleHRcIiAoZXF1YWwgdG8gXCJcIiksIFwiYXJyYXlidWZmZXJcIiwgXCJibG9iXCIsIFwiZG9jdW1lbnRcIiBvciBcImpzb25cIlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzcG9uc2VUeXBlID0gdW5kZWZpbmVkKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAvLyByZW5hbWUgdG8gYG9uUHJvZ3Jlc3NgID9cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5wcm9ncmVzc0NiID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgYSBwcm9taXNlIGJhc2VkIGZpbGUgbG9hZGluZy5cbiAgICogSW50ZXJuYWxseSBzd2l0Y2ggYmV0d2VlbiBsb2FkT25lIGFuZCBsb2FkQWxsLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xzdHJpbmdbXSl9IGZpbGVVUkxzIC0gVGhlIFVSTChzKSBvZiB0aGUgZmlsZXMgdG8gbG9hZC4gQWNjZXB0cyBhIFVSTCBwb2ludGluZyB0byB0aGUgZmlsZSBsb2NhdGlvbiBvciBhbiBhcnJheSBvZiBVUkxzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGxvYWQoZmlsZVVSTHMgPSB0aHJvd0lmTWlzc2luZygpKSB7XG4gICAgaWYgKGZpbGVVUkxzID09PSB1bmRlZmluZWQpIHRocm93IChuZXcgRXJyb3IoJ2xvYWQgbmVlZHMgYXQgbGVhc3QgYSB1cmwgdG8gbG9hZCcpKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWxlVVJMcykpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRBbGwoZmlsZVVSTHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkT25lKGZpbGVVUkxzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIHNpbmdsZSBmaWxlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlVVJMIC0gVGhlIFVSTCBvZiB0aGUgZmlsZSB0byBsb2FkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGxvYWRPbmUoZmlsZVVSTCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVMb2FkaW5nUmVxdWVzdChmaWxlVVJMKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBmaWxlcyBhdCBvbmNlIGluIGEgc2luZ2xlIGFycmF5IGFuZCByZXR1cm4gYSBQcm9taXNlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZpbGVVUkxzIC0gVGhlIFVSTHMgYXJyYXkgb2YgdGhlIGZpbGVzIHRvIGxvYWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgbG9hZEFsbChmaWxlVVJMcykge1xuICAgIHZhciB1cmxzQ291bnQgPSBmaWxlVVJMcy5sZW5ndGgsXG4gICAgICBwcm9taXNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cmxzQ291bnQ7ICsraSkge1xuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmZpbGVMb2FkaW5nUmVxdWVzdChmaWxlVVJMc1tpXSwgaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIGZpbGUgYXN5bmNocm9ub3VzbHksIHJldHVybiBhIFByb21pc2UuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmaWxlIHRvIGxvYWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtpbmRleF0gLSBUaGUgaW5kZXggb2YgdGhlIGZpbGUgaW4gdGhlIGFycmF5IG9mIGZpbGVzIHRvIGxvYWRcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBmaWxlTG9hZGluZ1JlcXVlc3QodXJsLCBpbmRleCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoXG4gICAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5pbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAodGhpcy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdWZmaXggPSAnLmpzb24nO1xuICAgICAgICAgIGlmICh1cmwuaW5kZXhPZihzdWZmaXgsIHRoaXMubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBUZXN0IHJlcXVlc3Quc3RhdHVzIHZhbHVlLCBhcyA0MDQgd2lsbCBhbHNvIGdldCB0aGVyZVxuICAgICAgICAgIC8vIFRlc3QgcmVxdWVzdC5zdGF0dXMgPT09IDAgZm9yIGNvcmRvdmEgaW50ZXJuYWwgYWpheCBjYWxsc1xuICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHJlcXVlc3Quc3RhdHVzID09PSAzMDQgfHzCoHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAvLyBIYWNrIGZvciBpT1MgNywgdG8gcmVtb3ZlIGFzIHNvb24gYXMgcG9zc2libGVcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nICYmIHR5cGVvZihyZXF1ZXN0LnJlc3BvbnNlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCAoZXZ0KSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV2dC5sb2FkZWQgLyBldnQudG90YWwsXG4gICAgICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBldnQubG9hZGVkIC8gZXZ0LnRvdGFsLFxuICAgICAgICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1hbmFnZSBuZXR3b3JrIGVycm9yc1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTmV0d29yayBFcnJvcicpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGdldCB0aGUgcHJvZ3Jlc3Mgb2YgZmlsZSBsb2FkaW5nIHByb2Nlc3MuXG4gICAqIFRoaXMgaXMgb25seSBmb3IgdGhlIGZpbGUgbG9hZGluZyBwcm9ncmVzcyBhcyBkZWNvZGVBdWRpb0RhdGEgZG9lc24ndFxuICAgKiBleHBvc2UgYSBkZWNvZGUgcHJvZ3Jlc3MgdmFsdWUuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICovXG4gIGdldCBwcm9ncmVzc0NhbGxiYWNrKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzQ2I7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBnZXQgdGhlIHByb2dyZXNzIG9mIGZpbGUgbG9hZGluZyBwcm9jZXNzLlxuICAgKiBUaGlzIGlzIG9ubHkgZm9yIHRoZSBmaWxlIGxvYWRpbmcgcHJvZ3Jlc3MgYXMgZGVjb2RlQXVkaW9EYXRhIGRvZXNuJ3RcbiAgICogZXhwb3NlIGEgZGVjb2RlIHByb2dyZXNzIHZhbHVlLlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRoYXQgaGFuZGxlcyB0aGUgcmVzcG9uc2UuXG4gICAqL1xuICBzZXQgcHJvZ3Jlc3NDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIHRoaXMucHJvZ3Jlc3NDYiA9IGNhbGxiYWNrO1xuICB9XG59XG4iLCJpbXBvcnQgQXVkaW9CdWZmZXJMb2FkZXIgZnJvbSAnLi9hdWRpby1idWZmZXItbG9hZGVyJztcblxuXG4vKipcbiAqIFN1cGVyTG9hZGVyXG4gKiBIZWxwZXIgdG8gbG9hZCBtdWx0aXBsZSB0eXBlIG9mIGZpbGVzLCBhbmQgZ2V0IHRoZW0gaW4gdGhlaXIgdXNlZnVsIHR5cGUsIGpzb24gZm9yIGpzb24gZmlsZXMsIEF1ZGlvQnVmZmVyIGZvciBhdWRpbyBmaWxlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3VwZXJMb2FkZXIgZXh0ZW5kcyBBdWRpb0J1ZmZlckxvYWRlciB7XG4gIC8qKlxuICAgKiBVc2UgY29tcG9zaXRpb24gdG8gc2V0dXAgYXBwcm9wcmlhdGUgZmlsZSBsb2FkZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihudWxsKTtcbiAgICAvLyBieXBhc3MgQXVkaW9CdWZmZXJMb2FkZXIgY29uc3RydWN0b3IuIFRoaXMgaXMgYmFkIGJ1dCBpdCB3b3Jrcy5cbiAgfVxufVxuIiwiaW1wb3J0IHBhcmFtVGVtcGxhdGVzIGZyb20gJy4vcGFyYW1UZW1wbGF0ZXMnO1xuXG4vKipcbiAqIEdlbmVyaWMgY2xhc3MgZm9yIHR5cGVkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBkZWZpbml0aW9uVGVtcGxhdGUgLSBMaXN0IG9mIG1hbmRhdG9yeSBrZXlzIGluIHRoZSBwYXJhbVxuICogIGRlZmluaXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlQ2hlY2tGdW5jdGlvbiAtIEZ1bmN0aW9uIHRvIGJlIHVzZWQgaW4gb3JkZXIgdG8gY2hlY2tcbiAqICB0aGUgdmFsdWUgYWdhaW5zdCB0aGUgcGFyYW0gZGVmaW5pdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIC0gRGVmaW5pdGlvbiBvZiB0aGUgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBWYWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUGFyYW0ge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBkZWZpbml0aW9uVGVtcGxhdGUsIHR5cGVDaGVja0Z1bmN0aW9uLCBkZWZpbml0aW9uLCB2YWx1ZSkge1xuICAgIGRlZmluaXRpb25UZW1wbGF0ZS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGRlZmluaXRpb24uaGFzT3duUHJvcGVydHkoa2V5KSA9PT0gZmFsc2UpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZWZpbml0aW9uIGZvciBwYXJhbSBcIiR7bmFtZX1cIiwgJHtrZXl9IGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZSA9IGRlZmluaXRpb24udHlwZTtcbiAgICB0aGlzLmRlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuXG4gICAgaWYgKHRoaXMuZGVmaW5pdGlvbi5udWxsYWJsZSA9PT0gdHJ1ZSAmJiB2YWx1ZSA9PT0gbnVsbClcbiAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIGVsc2VcbiAgICAgIHRoaXMudmFsdWUgPSB0eXBlQ2hlY2tGdW5jdGlvbih2YWx1ZSwgZGVmaW5pdGlvbiwgbmFtZSk7XG4gICAgdGhpcy5fdHlwZUNoZWNrRnVuY3Rpb24gPSB0eXBlQ2hlY2tGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBOZXcgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gLSBgdHJ1ZWAgaWYgdGhlIHBhcmFtIGhhcyBiZWVuIHVwZGF0ZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKiAgKGUuZy4gaWYgdGhlIHBhcmFtZXRlciBhbHJlYWR5IGhhZCB0aGlzIHZhbHVlKS5cbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVmaW5pdGlvbi5jb25zdGFudCA9PT0gdHJ1ZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3NpZ25lbWVudCB0byBjb25zdGFudCBwYXJhbSBcIiR7dGhpcy5uYW1lfVwiYCk7XG5cbiAgICBpZiAoISh0aGlzLmRlZmluaXRpb24ubnVsbGFibGUgPT09IHRydWUgJiYgdmFsdWUgPT09IG51bGwpKVxuICAgICAgdmFsdWUgPSB0aGlzLl90eXBlQ2hlY2tGdW5jdGlvbih2YWx1ZSwgdGhpcy5kZWZpbml0aW9uLCB0aGlzLm5hbWUpO1xuXG4gICAgaWYgKHRoaXMudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuXG4vKipcbiAqIEJhZyBvZiBwYXJhbWV0ZXJzLiBNYWluIGludGVyZmFjZSBvZiB0aGUgbGlicmFyeVxuICovXG5jbGFzcyBQYXJhbWV0ZXJCYWcge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMsIGRlZmluaXRpb25zKSB7XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxTdHJpbmcsIFBhcmFtPn1cbiAgICAgKiBAbmFtZSBfcGFyYW1zXG4gICAgICogQG1lbWJlcm9mIFBhcmFtZXRlckJhZ1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBkZWZpbml0aW9ucyB3aXRoIGluaXQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxTdHJpbmcsIHBhcmFtRGVmaW5pdGlvbj59XG4gICAgICogQG5hbWUgX2RlZmluaXRpb25zXG4gICAgICogQG1lbWJlcm9mIFBhcmFtZXRlckJhZ1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgZ2xvYmFsIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTZXR9XG4gICAgICogQG5hbWUgX2dsb2JhbExpc3RlbmVyc1xuICAgICAqIEBtZW1iZXJvZiBQYXJhbWV0ZXJCYWdcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dsb2JhbExpc3RlbmVycyA9IG5ldyBTZXQoKTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcGFyYW1zIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8U3RyaW5nLCBTZXQ+fVxuICAgICAqIEBuYW1lIF9wYXJhbXNMaXN0ZW5lcnNcbiAgICAgKiBAbWVtYmVyb2YgUGFyYW1ldGVyQmFnXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYXJhbXNMaXN0ZW5lcnMgPSB7fTtcblxuICAgIC8vIGluaXRpYWxpemUgZW1wdHkgU2V0IGZvciBlYWNoIHBhcmFtXG4gICAgZm9yIChsZXQgbmFtZSBpbiBwYXJhbXMpXG4gICAgICB0aGlzLl9wYXJhbXNMaXN0ZW5lcnNbbmFtZV0gPSBuZXcgU2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBnaXZlbiBkZWZpbml0aW9ucyBhbG9uZyB3aXRoIHRoZSBpbml0aWFsaXphdGlvbiB2YWx1ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldERlZmluaXRpb25zKG5hbWUgPSBudWxsKSB7XG4gICAgaWYgKG5hbWUgIT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbnNbbmFtZV07XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEByZXR1cm4ge01peGVkfSAtIFZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqL1xuICBnZXQobmFtZSkge1xuICAgIGlmICghdGhpcy5fcGFyYW1zW25hbWVdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVhZCBwcm9wZXJ0eSB2YWx1ZSBvZiB1bmRlZmluZWQgcGFyYW1ldGVyIFwiJHtuYW1lfVwiYCk7XG5cbiAgICByZXR1cm4gdGhpcy5fcGFyYW1zW25hbWVdLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgb2YgYSBwYXJhbWV0ZXIuIElmIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyIGlzIHVwZGF0ZWRcbiAgICogKGFrYSBpZiBwcmV2aW91cyB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSBuZXcgdmFsdWUpIGFsbCByZWdpc3RlcmVkXG4gICAqIGNhbGxiYWNrcyBhcmUgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHJldHVybiB7TWl4ZWR9IC0gTmV3IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqL1xuICBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBwYXJhbSA9IHRoaXMuX3BhcmFtc1tuYW1lXTtcbiAgICBjb25zdCB1cGRhdGVkID0gcGFyYW0uc2V0VmFsdWUodmFsdWUpO1xuICAgIHZhbHVlID0gcGFyYW0uZ2V0VmFsdWUoKTtcblxuICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICBjb25zdCBtZXRhcyA9IHBhcmFtLmRlZmluaXRpb24ubWV0YXM7XG4gICAgICAvLyB0cmlnZ2VyIGdsb2JhbCBsaXN0ZW5lcnNcbiAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX2dsb2JhbExpc3RlbmVycylcbiAgICAgICAgbGlzdGVuZXIobmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgICAgLy8gdHJpZ2dlciBwYXJhbSBsaXN0ZW5lcnNcbiAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3BhcmFtc0xpc3RlbmVyc1tuYW1lXSlcbiAgICAgICAgbGlzdGVuZXIodmFsdWUsIG1ldGFzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGlmIHRoZSBgbmFtZWAgcGFyYW1ldGVyIGV4aXN0cyBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gKHRoaXMuX3BhcmFtc1tuYW1lXSkgPyB0cnVlIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgYSBwYXJhbWV0ZXIgdG8gaXRzIGluaXQgdmFsdWUuIFJlc2V0IGFsbCBwYXJhbWV0ZXJzIGlmIG5vIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9bnVsbF0gLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIgdG8gcmVzZXQuXG4gICAqL1xuICByZXNldChuYW1lID0gbnVsbCkge1xuICAgIGlmIChuYW1lICE9PSBudWxsKVxuICAgICAgdGhpcy5zZXQobmFtZSwgcGFyYW0uZGVmaW5pdGlvbi5pbml0VmFsdWUpO1xuICAgIGVsc2VcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3BhcmFtcykuZm9yRWFjaCgobmFtZSkgPT4gdGhpcy5yZXNldChuYW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogQGNhbGxiYWNrIFBhcmFtZXRlckJhZ35saXN0ZW5lckNhbGxiYWNrXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gUGFyYW1ldGVyIG5hbWUuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVXBkYXRlZCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW21ldGE9XSAtIEdpdmVuIG1ldGEgZGF0YSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKi9cblxuICAvKipcbiAgICogQWRkIGxpc3RlbmVyIHRvIGFsbCBwYXJhbSB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcmFtZXRlckJhZ35saXN0ZW5lckNhbGxhY2t9IGNhbGxiYWNrIC0gTGlzdGVuZXIgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBhZGRMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIHRoaXMuX2dsb2JhbExpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lciBmcm9tIGFsbCBwYXJhbSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcmFtZXRlckJhZ35saXN0ZW5lckNhbGxhY2t9IGNhbGxiYWNrIC0gTGlzdGVuZXIgdG8gcmVtb3ZlLiBJZlxuICAgKiAgYG51bGxgIHJlbW92ZSBhbGwgbGlzdGVuZXJzLlxuICAgKi9cbiAgcmVtb3ZlTGlzdGVuZXIoY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsKVxuICAgICAgdGhpcy5fZ2xvYmFsTGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5fZ2xvYmFsTGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQGNhbGxiYWNrIFBhcmFtZXRlckJhZ35wYXJhbUxpc3RlbmVyQ2FsbGFja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAtIFVwZGF0ZWQgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IFttZXRhPV0gLSBHaXZlbiBtZXRhIGRhdGEgb2YgdGhlIHBhcmFtZXRlci5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFkZCBsaXN0ZW5lciB0byBhIGdpdmVuIHBhcmFtIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gUGFyYW1ldGVyIG5hbWUuXG4gICAqIEBwYXJhbSB7UGFyYW1ldGVyQmFnfnBhcmFtTGlzdGVuZXJDYWxsYWNrfSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGFwcGx5XG4gICAqICB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyIGNoYW5nZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RyaWdnZXI9ZmFsc2VdIC0gRXhlY3V0ZSB0aGUgY2FsbGJhY2sgaW1tZWRpYXRlbHkgd2l0aFxuICAgKiAgY3VycmVudCBwYXJhbWV0ZXIgdmFsdWUuXG4gICAqL1xuICBhZGRQYXJhbUxpc3RlbmVyKG5hbWUsIGNhbGxiYWNrLCB0cmlnZ2VyID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYXJhbXNMaXN0ZW5lcnNbbmFtZV0uYWRkKGNhbGxiYWNrKTtcblxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHRoaXMuX3BhcmFtc1tuYW1lXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW0uZ2V0VmFsdWUoKTtcbiAgICAgIGNvbnN0IG1ldGFzID0gcGFyYW0uZGVmaW5pdGlvbi5tZXRhcztcbiAgICAgIGNhbGxiYWNrKHZhbHVlLCBtZXRhcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lciBmcm9tIGEgZ2l2ZW4gcGFyYW0gdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBQYXJhbWV0ZXIgbmFtZS5cbiAgICogQHBhcmFtIHtQYXJhbWV0ZXJCYWd+cGFyYW1MaXN0ZW5lckNhbGxhY2t9IGNhbGxiYWNrIC0gTGlzdGVuZXIgdG8gcmVtb3ZlLlxuICAgKiAgSWYgYG51bGxgIHJlbW92ZSBhbGwgbGlzdGVuZXJzLlxuICAgKi9cbiAgcmVtb3ZlUGFyYW1MaXN0ZW5lcihuYW1lLCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwpXG4gICAgICB0aGlzLl9wYXJhbXNMaXN0ZW5lcnNbbmFtZV0uY2xlYXIoKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9wYXJhbXNMaXN0ZW5lcnNbbmFtZV0uZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxufVxuXG4vKipcbiAqIEZhY3RvcnkgZm9yIHRoZSBgUGFyYW1ldGVyQmFnYCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxTdHJpbmcsIHBhcmFtRGVmaW5pdGlvbj59IGRlZmluaXRpb25zIC0gT2JqZWN0IGRlc2NyaWJpbmcgdGhlXG4gKiAgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7T2JqZWN0PFN0cmluZywgTWl4ZWQ+fSB2YWx1ZXMgLSBJbml0aWFsaXphdGlvbiB2YWx1ZXMgZm9yIHRoZVxuICogIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJuIHtQYXJhbWV0ZXJCYWd9XG4gKi9cbmZ1bmN0aW9uIHBhcmFtZXRlcnMoZGVmaW5pdGlvbnMsIHZhbHVlcyA9IHt9KSB7XG4gIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gIGZvciAobGV0IG5hbWUgaW4gdmFsdWVzKSB7XG4gICAgaWYgKGRlZmluaXRpb25zLmhhc093blByb3BlcnR5KG5hbWUpID09PSBmYWxzZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbSBcIiR7bmFtZX1cImApO1xuICB9XG5cbiAgZm9yIChsZXQgbmFtZSBpbiBkZWZpbml0aW9ucykge1xuICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkgPT09IHRydWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7bmFtZX1cIiBhbHJlYWR5IGRlZmluZWRgKTtcblxuICAgIGNvbnN0IGRlZmluaXRpb24gPSBkZWZpbml0aW9uc1tuYW1lXTtcblxuICAgIGlmICghcGFyYW1UZW1wbGF0ZXNbZGVmaW5pdGlvbi50eXBlXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbSB0eXBlIFwiJHtkZWZpbml0aW9uLnR5cGV9XCJgKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGRlZmluaXRpb25UZW1wbGF0ZSxcbiAgICAgIHR5cGVDaGVja0Z1bmN0aW9uXG4gICAgfSA9IHBhcmFtVGVtcGxhdGVzW2RlZmluaXRpb24udHlwZV07XG5cbiAgICBsZXQgdmFsdWU7XG5cbiAgICBpZiAodmFsdWVzLmhhc093blByb3BlcnR5KG5hbWUpID09PSB0cnVlKVxuICAgICAgdmFsdWUgPSB2YWx1ZXNbbmFtZV07XG4gICAgZWxzZVxuICAgICAgdmFsdWUgPSBkZWZpbml0aW9uLmRlZmF1bHQ7XG5cbiAgICAvLyBzdG9yZSBpbml0IHZhbHVlIGluIGRlZmluaXRpb25cbiAgICBkZWZpbml0aW9uLmluaXRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKCF0eXBlQ2hlY2tGdW5jdGlvbiB8fMKgIWRlZmluaXRpb25UZW1wbGF0ZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSB0eXBlIGRlZmluaXRpb24gXCIke2RlZmluaXRpb24udHlwZX1cImApO1xuXG4gICAgcGFyYW1zW25hbWVdID0gbmV3IFBhcmFtKG5hbWUsIGRlZmluaXRpb25UZW1wbGF0ZSwgdHlwZUNoZWNrRnVuY3Rpb24sIGRlZmluaXRpb24sIHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUGFyYW1ldGVyQmFnKHBhcmFtcywgZGVmaW5pdGlvbnMpO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbmV3IHR5cGUgZm9yIHRoZSBgcGFyYW1ldGVyc2AgZmFjdG9yeS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlTmFtZSAtIFZhbHVlIHRoYXQgd2lsbCBiZSBhdmFpbGFibGUgYXMgdGhlIGB0eXBlYCBvZiBhXG4gKiAgcGFyYW0gZGVmaW5pdGlvbi5cbiAqIEBwYXJhbSB7cGFyYW1ldGVyRGVmaW5pdGlvbn0gcGFyYW1ldGVyRGVmaW5pdGlvbiAtIE9iamVjdCBkZXNjcmliaW5nIHRoZVxuICogIHBhcmFtZXRlci5cbiAqL1xucGFyYW1ldGVycy5kZWZpbmVUeXBlID0gZnVuY3Rpb24odHlwZU5hbWUsIHBhcmFtZXRlckRlZmluaXRpb24pIHtcbiAgcGFyYW1UZW1wbGF0ZXNbdHlwZU5hbWVdID0gcGFyYW1ldGVyRGVmaW5pdGlvbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyYW1ldGVycztcbiIsIi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc1NzU3OTAvZW52aXJvbm1lbnQtZGV0ZWN0aW9uLW5vZGUtanMtb3ItYnJvd3NlclxuY29uc3QgaXNOb2RlID0gbmV3IEZ1bmN0aW9uKCd0cnkgeyByZXR1cm4gdGhpcyA9PT0gZ2xvYmFsOyB9IGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlIH0nKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGltZSBpbiBtaWxsaXNlY29uZHMgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50XG4gKiBlbnZpcm9ubmVtZW50IChub2RlIG9yIGJyb3dzZXIpLlxuICogSWYgcnVubmluZyBpbiBub2RlIHRoZSB0aW1lIHJlbHkgb24gYHByb2Nlc3MuaHJ0aW1lYCwgd2hpbGUgaWYgaW4gdGhlIGJyb3dzZXJcbiAqIGl0IGlzIHByb3ZpZGVkIGJ5IHRoZSBgY3VycmVudFRpbWVgIG9mIGFuIGBBdWRpb0NvbnRleHRgLCB0aGlzIGNvbnRleHQgY2FuXG4gKiBvcHRpb25uYWx5IGJlIHByb3ZpZGVkIHRvIGtlZXAgdGltZSBjb25zaXN0ZW5jeSBiZXR3ZWVuIHNldmVyYWwgYEV2ZW50SW5gXG4gKiBub2Rlcy5cbiAqXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gW2F1ZGlvQ29udGV4dD1udWxsXSAtIE9wdGlvbm5hbCBhdWRpbyBjb250ZXh0LlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRUaW1lRnVuY3Rpb24oYXVkaW9Db250ZXh0ID0gbnVsbCkge1xuICBpZiAoaXNOb2RlKCkpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gKHRbMF0gKyB0WzFdICogMWUtOSkgKiAxZTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayBUaWNrZXJDYWxsYmFja1xuICogQHBhcmFtIHtOdW1iZXJ9IGxvZ2ljYWxUaW1lIC0gbG9naWNhbCB0aW1lIHNpbmNlIGBzdGFydGAgaW4gbXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50VGltZSAtIGN1cnJlbnQgdGltZSBhcyByZXR1cm5lZCBieSBgcGVyZm9ybWFuY2Uubm93YFxuICogQHBhcmFtIHtOdW1iZXJ9IGVycm9yIC0gY3VycmVudCBlcnJvclxuICovXG5cbi8qKlxuICogUHJlY2lzZSBwZXJpb2RpYyB0aW1lciAoYmFzZWQgb24gYHNldFRpbWVvdXRgKSB0aGF0IG1vbml0b3IgYW5kIGFkYXB0IGl0c2VsZlxuICogdG8gc3RheSBjbG9zZSB0byB0aGUgZ2l2ZW4gdGhlcmljYWwgcGVyaW9kLiBJbiBwYXJ0aWN1bGFyLCB0cnkgdG8gbWluaW1pemVcbiAqIHRoZSBkcmlmdCBjYXVzZWQgYnkgdGhlIHVzZSBvZiBhIHJhdyBgc2V0VGltZW91dGAuXG4gKiBPYnNlcnZlZCBhdmVyYWdlIGppdHRlciBpcyBhcm91bmQgKy8tIDJtcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kIC0gcGVyaW9kIG9mIHRoZSB0aW1lciBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiAqICAoZmxvb3JlZCBpZiBmbG9hdCBpcyBnaXZlbilcbiAqIEBwYXJhbSB7VGlja2VyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gY2FsbGJhY2sgdG8gZXhlY3V0ZSBvbiBlYWNoIHRpY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWRkaXRpb25uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVycm9yVGhyZXNob2xkXSAtIFRocmVzaG9sZCBlcnJvciB3aGVyZSB0aGUgdGltZXJcbiAqICBjb25zaWRlcnMgaXRzZWxmIGFzIG91dCBvZiBib3VuZHMuIEluY3JlYXNpbmcgdGhpcyB2YWx1ZSB0ZW5kcyB0byBpbmNyZWFzZVxuICogIHRoZSBvdmVyYWxsIGppdHRlci5cbiAqL1xuY2xhc3MgVGlja2VyIHtcbiAgY29uc3RydWN0b3IocGVyaW9kLCBjYWxsYmFjaywgeyBlcnJvclRocmVzaG9sZCA9IDAuNCB9ID0ge30pIHtcbiAgICBwZXJpb2QgPSBNYXRoLmZsb29yKHBlcmlvZCk7XG5cbiAgICB0aGlzLmxvZ2ljYWxQZXJpb2QgPSBwZXJpb2Q7XG4gICAgdGhpcy5jb21wdXRlZFBlcmlvZCA9IHBlcmlvZDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lcnJvclRocmVzaG9sZCA9IGVycm9yVGhyZXNob2xkO1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5nZXRUaW1lID0gZ2V0VGltZUZ1bmN0aW9uKCk7XG5cbiAgICB0aGlzLl90aWNrID0gdGhpcy5fdGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmlvZCBvZiB0aGUgdGltZXIuIE11c3QgYmUgYW4gaW50ZWdlciwgdGhlIGdpdmVuIHZhbHVlIGlzIGZsb29yZWQuXG4gICAqIFdoZW4gdXBkYXRlZCB0aGUgbmV3IHZhbHVlIGlzIGFwcGxpZWQgYXQgdGhlIG5leHQgdGljay5cbiAgICpcbiAgICogQG5hbWUgcGVyaW9kXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWVtYmVyb2YgVGlja2VyXG4gICAqL1xuICBzZXQgcGVyaW9kKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICB0aGlzLmxvZ2ljYWxQZXJpb2QgPSB2YWx1ZTtcbiAgICB0aGlzLmNvbXB1dGVkUGVyaW9kID0gdmFsdWU7XG4gIH1cblxuICBnZXQgcGVyaW9kKCkge1xuICAgIHJldHVybiB0aGlzLmxvZ2ljYWxQZXJpb2Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIHRpY2tlciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmxvZ2ljYWxUaW1lID0gMDtcblxuICAgICAgdGhpcy5fdGljaygpOyAvLyBydW4gbm93XG5cbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgdGlja2VyIGluc3RhbmNlLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3RpY2soKSB7XG4gICAgY29uc3Qgbm93ID0gdGhpcy5nZXRUaW1lKCk7XG4gICAgY29uc3QgdGltZSA9IG5vdyAtIHRoaXMuc3RhcnRUaW1lO1xuICAgIGNvbnN0IGVycm9yID0gdGltZSAtIHRoaXMubG9naWNhbFRpbWU7XG5cbiAgICBpZiAoZXJyb3IgPj0gdGhpcy5lcnJvclRocmVzaG9sZClcbiAgICAgIHRoaXMuY29tcHV0ZWRQZXJpb2QgPSB0aGlzLmNvbXB1dGVkUGVyaW9kIC0gMTtcblxuICAgIGlmIChlcnJvciA8IC10aGlzLmVycm9yVGhyZXNob2xkKVxuICAgICAgdGhpcy5jb21wdXRlZFBlcmlvZCA9IHRoaXMubG9naWNhbFBlcmlvZDtcblxuICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl90aWNrLCB0aGlzLmNvbXB1dGVkUGVyaW9kKTtcblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5sb2dpY2FsVGltZSwgbm93LCBlcnJvcik7XG4gICAgLy8gbmV4dCBjYWxsIHRpbWVcbiAgICB0aGlzLmxvZ2ljYWxUaW1lICs9IHRoaXMubG9naWNhbFBlcmlvZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaWNrZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL21hcFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXRoL2xvZzEwXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1maW5pdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zZXRcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vd2Vhay1tYXBcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpO1xuXG52YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiBzZXQob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gIHZhciBkZXNjID0gKDAsIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IyLmRlZmF1bHQpKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHNldChwYXJlbnQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYyAmJiBkZXNjLndyaXRhYmxlKSB7XG4gICAgZGVzYy52YWx1ZSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzZXR0ZXIgPSBkZXNjLnNldDtcblxuICAgIGlmIChzZXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0dGVyLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59OyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5NYXA7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5NYXRoLmxvZzEwO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuTnVtYmVyLmlzRmluaXRlO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5TZXQ7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuV2Vha01hcDtcbiIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBnbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcbiAgaWYgKCFERVNDUklQVE9SUyB8fCB0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FLCAnX2MnKTtcbiAgICAgIHRhcmdldC5fYyA9IG5ldyBCYXNlKCk7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIGVhY2goJ2FkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTicuc3BsaXQoJywnKSwgZnVuY3Rpb24gKEtFWSkge1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmIChLRVkgaW4gcHJvdG8gJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSkgaGlkZShDLnByb3RvdHlwZSwgS0VZLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsIEtFWSk7XG4gICAgICAgIGlmICghSVNfQURERVIgJiYgSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkpIHJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2NbS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgSVNfV0VBSyB8fCBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Muc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiwgTyk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS4wJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBlbCkge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIga2V5cyA9IGdldEtleXMoTyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBpZiAoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpIHJldHVybiBrZXk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmIChPYnNlcnZlcikge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwidmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcEZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgIEEgPSBbXTtcbiAgICBpZiAobWFwcGluZykge1xuICAgICAgbiA9IDA7XG4gICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgQSA9IEFycmF5KGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSBBW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldCA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE1BUCA9ICdNYXAnO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG4iLCIvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIHNhbWVDb25zdHJ1Y3RvciA9IExJQlJBUlkgPyBmdW5jdGlvbiAoYSwgYikge1xuICAvLyB3aXRoIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgcmV0dXJuIGEgPT09IGIgfHwgYSA9PT0gJFByb21pc2UgJiYgYiA9PT0gV3JhcHBlcjtcbn0gOiBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn07XG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcbiAgaWYgKHByb21pc2UuX24pIHJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9oID09IDEpIHJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZWFjdGlvbjtcbiAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYgKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKSByZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcbiAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3YgfSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgJHJlamVjdC5jYWxsKHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gc2FtZUNvbnN0cnVjdG9yKCRQcm9taXNlLCBDKVxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFByb21pc2U6ICRQcm9taXNlIH0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICAvLyBpbnN0YW5jZW9mIGluc3RlYWQgb2YgaW50ZXJuYWwgc2xvdCBjaGVjayBiZWNhdXNlIHdlIHNob3VsZCBmaXggaXQgd2l0aG91dCByZXBsYWNlbWVudCBuYXRpdmUgUHJvbWlzZSBjb3JlXG4gICAgaWYgKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpIHJldHVybiB4O1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZSh0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNFVCA9ICdTZXQnO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShTRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIFNFVCksIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnLi9fa2V5b2YnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSkge1xuICAgIGlmIChpc1N5bWJvbChrZXkpKSByZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIGlmIChpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYgKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgkcmVwbGFjZXIpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IG1ldGEuZ2V0V2VhaztcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmU7XG52YXIgdG1wID0ge307XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSwga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmIChmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3OyB9KSkge1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgV0VBS19NQVApO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHByb3RvID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmIChpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnTWFwJyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ01hcCcpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdNYXAnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnU2V0Jyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1NldCcpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcbiIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG4gKiBPQkpFQ1QgQVNTSUdOIERFRVBcbiAqIEFsbG93cyBkZWVwIGNsb25pbmcgb2YgcGxhaW4gb2JqZWN0cyB0aGF0IGNvbnRhaW4gcHJpbWl0aXZlcywgbmVzdGVkIHBsYWluIG9iamVjdHMsIG9yIG5lc3RlZCBwbGFpbiBhcnJheXMuXG4gKi9cblxuLypcbiAqIEEgdW5pZmllZCB3YXkgb2YgcmV0dXJuaW5nIGEgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlIG9mIHRoZSBnaXZlbiB2YXJpYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZU9mIChpbnB1dCkge1xuXG5cdGlmIChpbnB1dCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBgbnVsbGA7XG5cdH1cblxuXHRlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09IGB1bmRlZmluZWRgKSB7XG5cdFx0cmV0dXJuIGB1bmRlZmluZWRgO1xuXHR9XG5cblx0ZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBgb2JqZWN0YCkge1xuXHRcdHJldHVybiAoQXJyYXkuaXNBcnJheShpbnB1dCkgPyBgYXJyYXlgIDogYG9iamVjdGApO1xuXHR9XG5cblx0cmV0dXJuIHR5cGVvZiBpbnB1dDtcblxufVxuXG4vKlxuICogQnJhbmNoaW5nIGxvZ2ljIHdoaWNoIGNhbGxzIHRoZSBjb3JyZWN0IGZ1bmN0aW9uIHRvIGNsb25lIHRoZSBnaXZlbiB2YWx1ZSBiYXNlIG9uIGl0cyB0eXBlLlxuICovXG5mdW5jdGlvbiBjbG9uZVZhbHVlICh2YWx1ZSkge1xuXG5cdC8vIFRoZSB2YWx1ZSBpcyBhbiBvYmplY3Qgc28gbGV0cyBjbG9uZSBpdC5cblx0aWYgKGdldFR5cGVPZih2YWx1ZSkgPT09IGBvYmplY3RgKSB7XG5cdFx0cmV0dXJuIHF1aWNrQ2xvbmVPYmplY3QodmFsdWUpO1xuXHR9XG5cblx0Ly8gVGhlIHZhbHVlIGlzIGFuIGFycmF5IHNvIGxldHMgY2xvbmUgaXQuXG5cdGVsc2UgaWYgKGdldFR5cGVPZih2YWx1ZSkgPT09IGBhcnJheWApIHtcblx0XHRyZXR1cm4gcXVpY2tDbG9uZUFycmF5KHZhbHVlKTtcblx0fVxuXG5cdC8vIEFueSBvdGhlciB2YWx1ZSBjYW4ganVzdCBiZSBjb3BpZWQuXG5cdHJldHVybiB2YWx1ZTtcblxufVxuXG4vKlxuICogRW51bWVyYXRlcyB0aGUgZ2l2ZW4gYXJyYXkgYW5kIHJldHVybnMgYSBuZXcgYXJyYXksIHdpdGggZWFjaCBvZiBpdHMgdmFsdWVzIGNsb25lZCAoaS5lLiByZWZlcmVuY2VzIGJyb2tlbikuXG4gKi9cbmZ1bmN0aW9uIHF1aWNrQ2xvbmVBcnJheSAoaW5wdXQpIHtcblx0cmV0dXJuIGlucHV0Lm1hcChjbG9uZVZhbHVlKTtcbn1cblxuLypcbiAqIEVudW1lcmF0ZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCAoaWdub3JpbmcgdGhlIHByb3RvdHlwZSBjaGFpbikgYW5kIHJldHVybnMgYSBuZXcgb2JqZWN0LCB3aXRoIGVhY2ggb2ZcbiAqIGl0cyB2YWx1ZXMgY2xvbmVkIChpLmUuIHJlZmVyZW5jZXMgYnJva2VuKS5cbiAqL1xuZnVuY3Rpb24gcXVpY2tDbG9uZU9iamVjdCAoaW5wdXQpIHtcblxuXHRjb25zdCBvdXRwdXQgPSB7fTtcblxuXHRmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuXHRcdGlmICghaW5wdXQuaGFzT3duUHJvcGVydHkoa2V5KSkgeyBjb250aW51ZTsgfVxuXG5cdFx0b3V0cHV0W2tleV0gPSBjbG9uZVZhbHVlKGlucHV0W2tleV0pO1xuXHR9XG5cblx0cmV0dXJuIG91dHB1dDtcblxufVxuXG4vKlxuICogRG9lcyB0aGUgYWN0dWFsIGRlZXAgbWVyZ2luZy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURlZXBNZXJnZSAodGFyZ2V0LCBfb2JqZWN0cyA9IFtdLCBfb3B0aW9ucyA9IHt9KSB7XG5cblx0Y29uc3Qgb3B0aW9ucyA9IHtcblx0XHRhcnJheUJlaGF2aW91cjogX29wdGlvbnMuYXJyYXlCZWhhdmlvdXIgfHwgYHJlcGxhY2VgLCAgLy8gQ2FuIGJlIFwibWVyZ2VcIiBvciBcInJlcGxhY2VcIi5cblx0fTtcblxuXHQvLyBFbnN1cmUgd2UgaGF2ZSBhY3R1YWwgb2JqZWN0cyBmb3IgZWFjaC5cblx0Y29uc3Qgb2JqZWN0cyA9IF9vYmplY3RzLm1hcChvYmplY3QgPT4gb2JqZWN0IHx8IHt9KTtcblxuXHRjb25zdCBvdXRwdXQgPSB0YXJnZXQgfHwge307XG5cblx0Ly8gRW51bWVyYXRlIHRoZSBvYmplY3RzIGFuZCB0aGVpciBrZXlzLlxuXHRmb3IgKGxldCBvaW5kZXggPSAwOyBvaW5kZXggPCBvYmplY3RzLmxlbmd0aDsgb2luZGV4KyspIHtcblx0XHRjb25zdCBvYmplY3QgPSBvYmplY3RzW29pbmRleF07XG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cblx0XHRmb3IgKGxldCBraW5kZXggPSAwOyBraW5kZXggPCBrZXlzLmxlbmd0aDsga2luZGV4KyspIHtcblx0XHRcdGNvbnN0IGtleSA9IGtleXNba2luZGV4XTtcblx0XHRcdGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG5cdFx0XHRjb25zdCB0eXBlID0gZ2V0VHlwZU9mKHZhbHVlKTtcblx0XHRcdGNvbnN0IGV4aXN0aW5nVmFsdWVUeXBlID0gZ2V0VHlwZU9mKG91dHB1dFtrZXldKTtcblxuXHRcdFx0aWYgKHR5cGUgPT09IGBvYmplY3RgKSB7XG5cdFx0XHRcdGlmIChleGlzdGluZ1ZhbHVlVHlwZSAhPT0gYHVuZGVmaW5lZGApIHtcblx0XHRcdFx0XHRjb25zdCBleGlzdGluZ1ZhbHVlID0gKGV4aXN0aW5nVmFsdWVUeXBlID09PSBgb2JqZWN0YCA/IG91dHB1dFtrZXldIDoge30pO1xuXHRcdFx0XHRcdG91dHB1dFtrZXldID0gZXhlY3V0ZURlZXBNZXJnZSh7fSwgW2V4aXN0aW5nVmFsdWUsIHF1aWNrQ2xvbmVPYmplY3QodmFsdWUpXSwgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0b3V0cHV0W2tleV0gPSBxdWlja0Nsb25lT2JqZWN0KHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRlbHNlIGlmICh0eXBlID09PSBgYXJyYXlgKSB7XG5cdFx0XHRcdGlmIChleGlzdGluZ1ZhbHVlVHlwZSA9PT0gYGFycmF5YCkge1xuXHRcdFx0XHRcdGNvbnN0IG5ld1ZhbHVlID0gcXVpY2tDbG9uZUFycmF5KHZhbHVlKTtcblx0XHRcdFx0XHRvdXRwdXRba2V5XSA9IChvcHRpb25zLmFycmF5QmVoYXZpb3VyID09PSBgbWVyZ2VgID8gb3V0cHV0W2tleV0uY29uY2F0KG5ld1ZhbHVlKSA6IG5ld1ZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvdXRwdXRba2V5XSA9IHF1aWNrQ2xvbmVBcnJheSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG91dHB1dFtrZXldID0gdmFsdWU7XG5cdFx0XHR9XG5cblxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXRwdXQ7XG5cbn1cblxuLypcbiAqIE1lcmdlIGFsbCB0aGUgc3VwcGxpZWQgb2JqZWN0cyBpbnRvIHRoZSB0YXJnZXQgb2JqZWN0LCBicmVha2luZyBhbGwgcmVmZXJlbmNlcywgaW5jbHVkaW5nIHRob3NlIG9mIG5lc3RlZCBvYmplY3RzXG4gKiBhbmQgYXJyYXlzLCBhbmQgZXZlbiBvYmplY3RzIG5lc3RlZCBpbnNpZGUgYXJyYXlzLiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIG5vdCBtdXRhdGVkIHVubGlrZSBPYmplY3QuYXNzaWduKCkuXG4gKiBQcm9wZXJ0aWVzIGluIGxhdGVyIG9iamVjdHMgd2lsbCBhbHdheXMgb3ZlcndyaXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG9iamVjdEFzc2lnbkRlZXAgKHRhcmdldCwgLi4ub2JqZWN0cykge1xuXHRyZXR1cm4gZXhlY3V0ZURlZXBNZXJnZSh0YXJnZXQsIG9iamVjdHMpO1xufTtcblxuLypcbiAqIFNhbWUgYXMgb2JqZWN0QXNzaWduRGVlcCgpIGV4Y2VwdCBpdCBkb2Vzbid0IG11dGF0ZSB0aGUgdGFyZ2V0IG9iamVjdCBhbmQgcmV0dXJucyBhbiBlbnRpcmVseSBuZXcgb2JqZWN0LlxuICovXG5tb2R1bGUuZXhwb3J0cy5ub011dGF0ZSA9IGZ1bmN0aW9uIG9iamVjdEFzc2lnbkRlZXBJbnRvICguLi5vYmplY3RzKSB7XG5cdHJldHVybiBleGVjdXRlRGVlcE1lcmdlKHt9LCBvYmplY3RzKTtcbn07XG5cbi8qXG4gKiBBbGxvd3MgYW4gb3B0aW9ucyBvYmplY3QgdG8gYmUgcGFzc2VkIGluIHRvIGN1c3RvbWlzZSB0aGUgYmVoYXZpb3VyIG9mIHRoZSBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMud2l0aE9wdGlvbnMgPSBmdW5jdGlvbiBvYmplY3RBc3NpZ25EZWVwSW50byAodGFyZ2V0LCBvYmplY3RzLCBvcHRpb25zKSB7XG5cdHJldHVybiBleGVjdXRlRGVlcE1lcmdlKHRhcmdldCwgb2JqZWN0cywgb3B0aW9ucyk7XG59O1xuIiwiY29uc3QgQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xuXG4vKipcbiAqIEV4cG9zZSBhIHVuaXF1ZSBhdWRpbyBjb250ZXh0IHNpbmdsZXRvbiBhcyB0aGUgZGVmYXVsdCBhdWRpb1xuICogY29udGV4dCB1c2VkIGJ5IHRoZSBjb21wb25lbnRzIG9mIHRoZSBXYXZlcyBBdWRpbyBsaWJyYXJ5IGFuZFxuICogYXBwbGljYXRpb25zIHVzaW5nIHRoZSBsaWJyYXJ5LlxuICpcbiAqIEB0eXBlIEF1ZGlvQ29udGV4dFxuICogQG5hbWUgYXVkaW9Db250ZXh0XG4gKiBAY29uc3RhbnRcbiAqIEBnbG9iYWxcbiAqIEBpbnN0YW5jZVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XG4gKiBjb25zdCBhdWRpb0NvbnRleHQgPSBhdWRpby5hdWRpb0NvbnRleHQ7XG4gKi9cbmxldCBhdWRpb0NvbnRleHQgPSBudWxsO1xuXG5pZiAoQXVkaW9Db250ZXh0KSB7XG4gIGF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcblxuICBpZiAoLyhpUGhvbmV8aVBhZCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlIDwgNDQxMDApIHtcbiAgICBjb25zdCBidWZmZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEsIDQ0MTAwKTtcbiAgICBjb25zdCBkdW1teSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICBkdW1teS5idWZmZXIgPSBidWZmZXI7XG4gICAgZHVtbXkuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgIGR1bW15LnN0YXJ0KDApO1xuICAgIGR1bW15LmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhdWRpb0NvbnRleHQ7XG4iLCJpbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuL3RpbWUtZW5naW5lJztcbmltcG9ydCBkZWZhdWx0QXVkaW9Db250ZXh0IGZyb20gJy4vYXVkaW8tY29udGV4dCc7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIGF1ZGlvIHJlbGF0ZWQgdGltZSBlbmdpbmUgY29tcG9uZW50cy4gSXQgaXNcbiAqIHVzZWQgdG8gaGFuZGxlIGF1ZGlvIHJlbGF0ZWQgZXZlbnRzIHN1Y2ggYXMgdGhlIHBsYXliYWNrIG9mIGEgbWVkaWEgc3RyZWFtLlxuICogSXQgZXh0ZW5kcyB0aGUgVGltZUVuZ2luZSBjbGFzcyBieSB0aGUgc3RhbmRhcmQgd2ViIGF1ZGlvIG5vZGUgbWV0aG9kc1xuICogY29ubmVjdCBhbmQgZGlzY29ubmVjdC5cbiAqXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL2F1ZGlvLXRpbWUtZW5naW5lLmh0bWx9XG4gKlxuICogQGV4dGVuZHMgVGltZUVuZ2luZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XG4gKlxuICogY2xhc3MgTXlFbmdpbmUgZXh0ZW5kcyBhdWRpby5BdWRpb1RpbWVFbmdpbmUge1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICBzdXBlcigpO1xuICogICAgIC8vIC4uLlxuICogICB9XG4gKiB9XG4gKi9cbmNsYXNzIEF1ZGlvVGltZUVuZ2luZSBleHRlbmRzIFRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihhdWRpb0NvbnRleHQgPSBkZWZhdWx0QXVkaW9Db250ZXh0KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEF1ZGlvIGNvbnRleHQgdXNlZCBieSB0aGUgVGltZUVuZ2luZSwgZGVmYXVsdCB0byB0aGUgZ2xvYmFsIGF1ZGlvQ29udGV4dFxuICAgICAqXG4gICAgICogQG5hbWUgYXVkaW9Db250ZXh0XG4gICAgICogQHR5cGUgQXVkaW9Db250ZXh0XG4gICAgICogQG1lbWJlcm9mIEF1ZGlvVGltZUVuZ2luZVxuICAgICAqIEBzZWUgYXVkaW9Db250ZXh0XG4gICAgICovXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBPdXRwdXQgYXVkaW8gbm9kZS4gQnkgZGVmYXVsdCB0aGUgY29ubmVjdCBtZXRob2QgY29ubmVjdHMgYSBnaXZlbiBub2RlXG4gICAgICogdG8gdGhpcyBvdXRwdXQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIG91dHB1dE5vZGVcbiAgICAgKiBAdHlwZSBBdWRpb05vZGVcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UaW1lRW5naW5lXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHRoaXMub3V0cHV0Tm9kZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdCB0byBhbiBhdWRpbyBub2RlIChlLmcuIGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbilcbiAgICpcbiAgICogQHBhcmFtIHtBdWRpb05vZGV9IHRhcmdldCAtIFRhcmdldCBhdWRpbyBub2RlXG4gICAqL1xuICBjb25uZWN0KHRhcmdldCkge1xuICAgIHRoaXMub3V0cHV0Tm9kZS5jb25uZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdCBmcm9tIGFuIGF1ZGlvIG5vZGUgKGUuZy4gYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKS4gSWYgdW5kZWZpbmVkXG4gICAqIGRpc2Nvbm5lY3QgZnJvbSBhbGwgdGFyZ2V0IG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvTm9kZX0gdGFyZ2V0IC0gVGFyZ2V0IGF1ZGlvIG5vZGUuXG4gICAqL1xuICBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLm91dHB1dE5vZGUuZGlzY29ubmVjdChjb25uZWN0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdWRpb1RpbWVFbmdpbmU7XG4iLCIvLyB3b3JrcyBieSByZWZlcmVuY2VcbmZ1bmN0aW9uIHN3YXAoYXJyLCBpMSwgaTIpIHtcbiAgY29uc3QgdG1wID0gYXJyW2kxXTtcbiAgYXJyW2kxXSA9IGFycltpMl07XG4gIGFycltpMl0gPSB0bXA7XG59XG5cbi8vIGh0dHBzOi8vanNwZXJmLmNvbS9qcy1mb3ItbG9vcC12cy1hcnJheS1pbmRleG9mLzM0NlxuZnVuY3Rpb24gaW5kZXhPZihhcnIsIGVsKSB7XG4gIGNvbnN0IGwgPSBhcnIubGVuZ3RoO1xuICAvLyBpZ25vcmUgZmlyc3QgZWxlbWVudCBhcyBpdCBjYW4ndCBiZSBhIGVudHJ5XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSA9PT0gZWwpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgaWYgYHRpbWUxYCBzaG91bGQgYmUgbG93ZXIgaW4gdGhlIHRvcG9ncmFwaHkgdGhhbiBgdGltZTJgLlxuICogSXMgZHluYW1pY2FsbHkgYWZmZWN0ZWQgdG8gdGhlIHByaW9yaXR5IHF1ZXVlIGFjY29yZGluZyB0byBoYW5kbGUgYG1pbmAgYW5kIGBtYXhgIGhlYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lMVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBfaXNMb3dlck1heEhlYXAgPSBmdW5jdGlvbih0aW1lMSwgdGltZTIpIHtcbiAgcmV0dXJuIHRpbWUxIDwgdGltZTI7XG59O1xuXG5jb25zdCBfaXNMb3dlck1pbkhlYXAgPSBmdW5jdGlvbih0aW1lMSwgdGltZTIpIHtcbiAgcmV0dXJuIHRpbWUxID4gdGltZTI7XG59O1xuXG4vKipcbiAqIERlZmluZSBpZiBgdGltZTFgIHNob3VsZCBiZSBoaWdoZXIgaW4gdGhlIHRvcG9ncmFwaHkgdGhhbiBgdGltZTJgLlxuICogSXMgZHluYW1pY2FsbHkgYWZmZWN0ZWQgdG8gdGhlIHByaW9yaXR5IHF1ZXVlIGFjY29yZGluZyB0byBoYW5kbGUgYG1pbmAgYW5kIGBtYXhgIGhlYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lMVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBfaXNIaWdoZXJNYXhIZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XG4gIHJldHVybiB0aW1lMSA+IHRpbWUyO1xufTtcblxuY29uc3QgX2lzSGlnaGVyTWluSGVhcCA9IGZ1bmN0aW9uKHRpbWUxLCB0aW1lMikge1xuICByZXR1cm4gdGltZTEgPCB0aW1lMjtcbn07XG5cbmNvbnN0IFBPU0lUSVZFX0lORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4vKipcbiAqIFByaW9yaXR5IHF1ZXVlIGltcGxlbWVudGluZyBhIGJpbmFyeSBoZWFwLlxuICogQWN0cyBhcyBhIG1pbiBoZWFwIGJ5IGRlZmF1bHQsIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkIHRvIGEgbWF4IGhlYXBcbiAqIGJ5IHNldHRpbmcgYHJldmVyc2VgIHRvIHRydWUuXG4gKlxuICogX25vdGVfOiB0aGUgcXVldWUgY3JlYXRlcyBhbmQgbWFpbnRhaW5zIGEgbmV3IHByb3BlcnR5IChpLmUuIGBxdWV1ZVRpbWVgKVxuICogdG8gZWFjaCBvYmplY3QgYWRkZWQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWFwTGVuZ3RoPTEwMF0gLSBEZWZhdWx0IHNpemUgb2YgdGhlIGFycmF5IHVzZWQgdG8gY3JlYXRlIHRoZSBoZWFwLlxuICovXG5jbGFzcyBQcmlvcml0eVF1ZXVlIHtcbiAgY29uc3RydWN0b3IoaGVhcExlbmd0aCA9IDEwMCkge1xuICAgIC8qKlxuICAgICAqIFBvaW50ZXIgdG8gdGhlIGZpcnN0IGVtcHR5IGluZGV4IG9mIHRoZSBoZWFwLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFByaW9yaXR5UXVldWVcbiAgICAgKiBAbmFtZSBfY3VycmVudExlbmd0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY3VycmVudExlbmd0aCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiB0aGUgc29ydGVkIGluZGV4ZXMgb2YgdGhlIGVudHJpZXMsIHRoZSBhY3R1YWwgaGVhcC4gSWdub3JlIHRoZSBpbmRleCAwLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAbWVtYmVyb2YgUHJpb3JpdHlRdWV1ZVxuICAgICAqIEBuYW1lIF9oZWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9oZWFwID0gbmV3IEFycmF5KGhlYXBMZW5ndGggKyAxKTtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgdGhlIHF1ZXVlOiBgbWluYCBoZWFwIGlmIGBmYWxzZWAsIGBtYXhgIGhlYXAgaWYgYHRydWVgXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFByaW9yaXR5UXVldWVcbiAgICAgKiBAbmFtZSBfcmV2ZXJzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmV2ZXJzZSA9IG51bGw7XG5cbiAgICAvLyBpbml0aWFsaXplIGNvbXBhcmUgZnVuY3Rpb25zXG4gICAgdGhpcy5yZXZlcnNlID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGltZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYmluYXJ5IGhlYXAuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgdGltZSgpIHtcbiAgICBpZiAodGhpcy5fY3VycmVudExlbmd0aCA+IDEpXG4gICAgICByZXR1cm4gdGhpcy5faGVhcFsxXS5xdWV1ZVRpbWU7XG5cbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cblxuICAvKipcbiAgICogRmlyc3QgZWxlbWVudCBpbiB0aGUgYmluYXJ5IGhlYXAuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGhlYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYXBbMV07XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgcXVldWUgKG1heCBoZWFwIGlmIHRydWUsIG1pbiBoZWFwIGlmIGZhbHNlKSxcbiAgICogcmVidWlsZCB0aGUgaGVhcCB3aXRoIHRoZSBleGlzdGluZyBlbnRyaWVzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHNldCByZXZlcnNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9yZXZlcnNlKSB7XG4gICAgICB0aGlzLl9yZXZlcnNlID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLl9yZXZlcnNlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2lzTG93ZXIgPSBfaXNMb3dlck1heEhlYXA7XG4gICAgICAgIHRoaXMuX2lzSGlnaGVyID0gX2lzSGlnaGVyTWF4SGVhcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzTG93ZXIgPSBfaXNMb3dlck1pbkhlYXA7XG4gICAgICAgIHRoaXMuX2lzSGlnaGVyID0gX2lzSGlnaGVyTWluSGVhcDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZEhlYXAoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgcmV2ZXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggdGhlIGhlYXAgYnkgbW92aW5nIGFuIGVudHJ5IHRvIGEgbmV3IHVwcGVyIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgZW50cnkgdG8gbW92ZS5cbiAgICovXG4gIF9idWJibGVVcChzdGFydEluZGV4KSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5faGVhcFtzdGFydEluZGV4XTtcblxuICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgbGV0IHBhcmVudEluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDIpO1xuICAgIGxldCBwYXJlbnQgPSB0aGlzLl9oZWFwW3BhcmVudEluZGV4XTtcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgdGhpcy5faXNIaWdoZXIoZW50cnkucXVldWVUaW1lLCBwYXJlbnQucXVldWVUaW1lKSkge1xuICAgICAgc3dhcCh0aGlzLl9oZWFwLCBpbmRleCwgcGFyZW50SW5kZXgpO1xuXG4gICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgcGFyZW50SW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gMik7XG4gICAgICBwYXJlbnQgPSB0aGlzLl9oZWFwW3BhcmVudEluZGV4XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRml4IHRoZSBoZWFwIGJ5IG1vdmluZyBhbiBlbnRyeSB0byBhIG5ldyBsb3dlciBwb3NpdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGVudHJ5IHRvIG1vdmUuXG4gICAqL1xuICBfYnViYmxlRG93bihzdGFydEluZGV4KSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5faGVhcFtzdGFydEluZGV4XTtcblxuICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgbGV0IGMxaW5kZXggPSBpbmRleCAqIDI7XG4gICAgbGV0IGMyaW5kZXggPSBjMWluZGV4ICsgMTtcbiAgICBsZXQgY2hpbGQxID0gdGhpcy5faGVhcFtjMWluZGV4XTtcbiAgICBsZXQgY2hpbGQyID0gdGhpcy5faGVhcFtjMmluZGV4XTtcblxuICAgIHdoaWxlICgoY2hpbGQxICYmIHRoaXMuX2lzTG93ZXIoZW50cnkucXVldWVUaW1lLCBjaGlsZDEucXVldWVUaW1lKSnCoHx8XG4gICAgICAgICAgIChjaGlsZDIgJiYgdGhpcy5faXNMb3dlcihlbnRyeS5xdWV1ZVRpbWUsIGNoaWxkMi5xdWV1ZVRpbWUpKSlcbiAgICB7XG4gICAgICAvLyBzd2FwIHdpdGggdGhlIG1pbmltdW0gY2hpbGRcbiAgICAgIGxldCB0YXJnZXRJbmRleDtcblxuICAgICAgaWYgKGNoaWxkMilcbiAgICAgICAgdGFyZ2V0SW5kZXggPSB0aGlzLl9pc0hpZ2hlcihjaGlsZDEucXVldWVUaW1lLCBjaGlsZDIucXVldWVUaW1lKSA/IGMxaW5kZXggOiBjMmluZGV4O1xuICAgICAgZWxzZVxuICAgICAgICB0YXJnZXRJbmRleCA9IGMxaW5kZXg7XG5cbiAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIHRhcmdldEluZGV4KTtcblxuICAgICAgLy8gdXBkYXRlIHRvIGZpbmQgbmV4dCBjaGlsZHJlblxuICAgICAgaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICAgIGMxaW5kZXggPSBpbmRleCAqIDI7XG4gICAgICBjMmluZGV4ID0gYzFpbmRleCArIDE7XG4gICAgICBjaGlsZDEgPSB0aGlzLl9oZWFwW2MxaW5kZXhdO1xuICAgICAgY2hpbGQyID0gdGhpcy5faGVhcFtjMmluZGV4XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgdGhlIGhlYXAgKGZyb20gYm90dG9tIHVwKS5cbiAgICovXG4gIGJ1aWxkSGVhcCgpIHtcbiAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBpbnRlcm5hbCBub2RlXG4gICAgLy8gQHRvZG8gLSBtYWtlIHN1cmUgdGhhdCdzIHRoZSByaWdodCB3YXkgdG8gZG8uXG4gICAgbGV0IG1heEluZGV4ID0gTWF0aC5mbG9vcigodGhpcy5fY3VycmVudExlbmd0aCAtIDEpIC8gMik7XG5cbiAgICBmb3IgKGxldCBpID0gbWF4SW5kZXg7IGkgPiAwOyBpLS0pXG4gICAgICB0aGlzLl9idWJibGVEb3duKGkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhIG5ldyBvYmplY3QgaW4gdGhlIGJpbmFyeSBoZWFwIGFuZCBzb3J0IGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50cnkgLSBFbnRyeSB0byBpbnNlcnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gVGltZSBhdCB3aGljaCB0aGUgZW50cnkgc2hvdWxkIGJlIG9yZGVyZXIuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGltZSBvZiB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIGhlYXAuXG4gICAqL1xuICBpbnNlcnQoZW50cnksIHRpbWUpIHtcbiAgICBpZiAoTWF0aC5hYnModGltZSkgIT09IFBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICBlbnRyeS5xdWV1ZVRpbWUgPSB0aW1lO1xuICAgICAgLy8gYWRkIHRoZSBuZXcgZW50cnkgYXQgdGhlIGVuZCBvZiB0aGUgaGVhcFxuICAgICAgdGhpcy5faGVhcFt0aGlzLl9jdXJyZW50TGVuZ3RoXSA9IGVudHJ5O1xuICAgICAgLy8gYnViYmxlIGl0IHVwXG4gICAgICB0aGlzLl9idWJibGVVcCh0aGlzLl9jdXJyZW50TGVuZ3RoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRMZW5ndGggKz0gMTtcblxuICAgICAgcmV0dXJuIHRoaXMudGltZTtcbiAgICB9XG5cbiAgICBlbnRyeS5xdWV1ZVRpbWUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlKGVudHJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZ2l2ZW4gZW50cnkgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIEVudHJ5IHRvIG1vdmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gVGltZSBhdCB3aGljaCB0aGUgZW50cnkgc2hvdWxkIGJlIG9yZGVyZXIuXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBUaW1lIG9mIGZpcnN0IGVudHJ5IGluIHRoZSBoZWFwLlxuICAgKi9cbiAgbW92ZShlbnRyeSwgdGltZSkge1xuICAgIGlmIChNYXRoLmFicyh0aW1lKSAhPT0gUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhPZih0aGlzLl9oZWFwLCBlbnRyeSk7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgZW50cnkucXVldWVUaW1lID0gdGltZTtcbiAgICAgICAgLy8gZGVmaW5lIGlmIHRoZSBlbnRyeSBzaG91bGQgYmUgYnViYmxlZCB1cCBvciBkb3duXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2hlYXBbTWF0aC5mbG9vcihpbmRleCAvIDIpXTtcblxuICAgICAgICBpZiAocGFyZW50ICYmIHRoaXMuX2lzSGlnaGVyKHRpbWUsIHBhcmVudC5xdWV1ZVRpbWUpKVxuICAgICAgICAgIHRoaXMuX2J1YmJsZVVwKGluZGV4KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuX2J1YmJsZURvd24oaW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy50aW1lO1xuICAgIH1cblxuICAgIGVudHJ5LnF1ZXVlVGltZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoZW50cnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBlbnRyeSBmcm9tIHRoZSBoZWFwIGFuZCBmaXggdGhlIGhlYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIEVudHJ5IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7TnVtYmVyfSAtIFRpbWUgb2YgZmlyc3QgZW50cnkgaW4gdGhlIGhlYXAuXG4gICAqL1xuICByZW1vdmUoZW50cnkpIHtcbiAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgZW50cnlcbiAgICBjb25zdCBpbmRleCA9IGluZGV4T2YodGhpcy5faGVhcCwgZW50cnkpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5fY3VycmVudExlbmd0aCAtIDE7XG5cbiAgICAgIC8vIGlmIHRoZSBlbnRyeSBpcyB0aGUgbGFzdCBvbmVcbiAgICAgIGlmIChpbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIGhlYXBcbiAgICAgICAgdGhpcy5faGVhcFtsYXN0SW5kZXhdID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB1cGRhdGUgY3VycmVudCBsZW5ndGhcbiAgICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IGxhc3RJbmRleDtcblxuICAgICAgICByZXR1cm4gdGhpcy50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3dhcCB3aXRoIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGhlYXBcbiAgICAgICAgc3dhcCh0aGlzLl9oZWFwLCBpbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gaGVhcFxuICAgICAgICB0aGlzLl9oZWFwW2xhc3RJbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5fYnViYmxlRG93bigxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBidWJibGUgdGhlIChleCBsYXN0KSBlbGVtZW50IHVwIG9yIGRvd24gYWNjb3JkaW5nIHRvIGl0cyBuZXcgY29udGV4dFxuICAgICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5faGVhcFtpbmRleF07XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5faGVhcFtNYXRoLmZsb29yKGluZGV4IC8gMildO1xuXG4gICAgICAgICAgaWYgKHBhcmVudCAmJiB0aGlzLl9pc0hpZ2hlcihlbnRyeS5xdWV1ZVRpbWUsIHBhcmVudC5xdWV1ZVRpbWUpKVxuICAgICAgICAgICAgdGhpcy5fYnViYmxlVXAoaW5kZXgpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX2J1YmJsZURvd24oaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IGxlbmd0aFxuICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IGxhc3RJbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50aW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBxdWV1ZS5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2N1cnJlbnRMZW5ndGggPSAxO1xuICAgIHRoaXMuX2hlYXAgPSBuZXcgQXJyYXkodGhpcy5faGVhcC5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgaWYgdGhlIHF1ZXVlIGNvbnRhaW5zIHRoZSBnaXZlbiBgZW50cnlgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50cnkgLSBFbnRyeSB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBoYXMoZW50cnkpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhcC5pbmRleE9mKGVudHJ5KSAhPT0gLTE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJpb3JpdHlRdWV1ZTtcbiIsIi8qKlxuICogU2NoZWR1bGluZ1F1ZXVlIGJhc2UgY2xhc3NcbiAqIGh0dHA6Ly93YXZlc2pzLmdpdGh1Yi5pby9hdWRpby8jYXVkaW8tc2NoZWR1bGluZy1xdWV1ZVxuICpcbiAqIE5vcmJlcnQuU2NobmVsbEBpcmNhbS5mclxuICogQ29weXJpZ2h0IDIwMTQsIDIwMTUgSVJDQU0g4oCTwqBDZW50cmUgUG9tcGlkb3VcbiAqL1xuXG5pbXBvcnQgUHJpb3JpdHlRdWV1ZSBmcm9tICcuL3ByaW9yaXR5LXF1ZXVlJztcbmltcG9ydCBUaW1lRW5naW5lIGZyb20gJy4vdGltZS1lbmdpbmUnO1xuXG4vKipcbiAqIEBjbGFzcyBTY2hlZHVsaW5nUXVldWVcbiAqIEBleHRlbmRzIFRpbWVFbmdpbmVcbiAqL1xuY2xhc3MgU2NoZWR1bGluZ1F1ZXVlIGV4dGVuZHMgVGltZUVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9fcXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICAgIHRoaXMuX19lbmdpbmVzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgLy8gVGltZUVuZ2luZSAnc2NoZWR1bGVkJyBpbnRlcmZhY2VcbiAgYWR2YW5jZVRpbWUodGltZSkge1xuICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX19xdWV1ZS5oZWFkO1xuICAgIGNvbnN0IG5leHRFbmdpbmVUaW1lID0gZW5naW5lLmFkdmFuY2VUaW1lKHRpbWUpO1xuXG4gICAgaWYgKCFuZXh0RW5naW5lVGltZSkge1xuICAgICAgZW5naW5lLm1hc3RlciA9IG51bGw7XG4gICAgICB0aGlzLl9fZW5naW5lcy5kZWxldGUoZW5naW5lKTtcbiAgICAgIHRoaXMuX19xdWV1ZS5yZW1vdmUoZW5naW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fX3F1ZXVlLm1vdmUoZW5naW5lLCBuZXh0RW5naW5lVGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19xdWV1ZS50aW1lO1xuICB9XG5cbiAgLy8gVGltZUVuZ2luZSBtYXN0ZXIgbWV0aG9kIHRvIGJlIGltcGxlbWVudGVkIGJ5IGRlcml2ZWQgY2xhc3NcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gY2FsbCBhIGZ1bmN0aW9uIGF0IGEgZ2l2ZW4gdGltZVxuICBkZWZlcihmdW4sIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgaWYgKCEoZnVuIGluc3RhbmNlb2YgRnVuY3Rpb24pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBkZWZlcmVkIGJ5IHNjaGVkdWxlclwiKTtcblxuICAgIHRoaXMuYWRkKHtcbiAgICAgIGFkdmFuY2VUaW1lOiBmdW5jdGlvbih0aW1lKSB7IGZ1bih0aW1lKTsgfSwgLy8gbWFrZSBzdXIgdGhhdCB0aGUgYWR2YW5jZVRpbWUgbWV0aG9kIGRvZXMgbm90IHJldHVybSBhbnl0aGluZ1xuICAgIH0sIHRpbWUpO1xuICB9XG5cbiAgLy8gYWRkIGEgdGltZSBlbmdpbmUgdG8gdGhlIHNjaGVkdWxlclxuICBhZGQoZW5naW5lLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xuICAgIGlmICghVGltZUVuZ2luZS5pbXBsZW1lbnRzU2NoZWR1bGVkKGVuZ2luZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgY2Fubm90IGJlIGFkZGVkIHRvIHNjaGVkdWxlclwiKTtcblxuICAgIGlmIChlbmdpbmUubWFzdGVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gYSBtYXN0ZXJcIik7XG5cbiAgICBlbmdpbmUubWFzdGVyID0gdGhpcztcblxuICAgIC8vIGFkZCB0byBlbmdpbmVzIGFuZCBxdWV1ZVxuICAgIHRoaXMuX19lbmdpbmVzLmFkZChlbmdpbmUpO1xuICAgIGNvbnN0IG5leHRUaW1lID0gdGhpcy5fX3F1ZXVlLmluc2VydChlbmdpbmUsIHRpbWUpO1xuXG4gICAgLy8gcmVzY2hlZHVsZSBxdWV1ZVxuICAgIHRoaXMucmVzZXRUaW1lKG5leHRUaW1lKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhIHRpbWUgZW5naW5lIGZyb20gdGhlIHF1ZXVlXG4gIHJlbW92ZShlbmdpbmUpIHtcbiAgICBpZiAoZW5naW5lLm1hc3RlciAhPT0gdGhpcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhpcyBzY2hlZHVsZXJcIik7XG5cbiAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcblxuICAgIC8vIHJlbW92ZSBmcm9tIGFycmF5IGFuZCBxdWV1ZVxuICAgIHRoaXMuX19lbmdpbmVzLmRlbGV0ZShlbmdpbmUpO1xuICAgIGNvbnN0IG5leHRUaW1lID0gdGhpcy5fX3F1ZXVlLnJlbW92ZShlbmdpbmUpO1xuXG4gICAgLy8gcmVzY2hlZHVsZSBxdWV1ZVxuICAgIHRoaXMucmVzZXRUaW1lKG5leHRUaW1lKTtcbiAgfVxuXG4gIC8vIHJlc2V0IG5leHQgZW5naW5lIHRpbWVcbiAgcmVzZXRFbmdpbmVUaW1lKGVuZ2luZSwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcbiAgICBpZiAoZW5naW5lLm1hc3RlciAhPT0gdGhpcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhpcyBzY2hlZHVsZXJcIik7XG5cbiAgICBsZXQgbmV4dFRpbWU7XG5cbiAgICBpZiAodGhpcy5fX3F1ZXVlLmhhcyhlbmdpbmUpKVxuICAgICAgbmV4dFRpbWUgPSB0aGlzLl9fcXVldWUubW92ZShlbmdpbmUsIHRpbWUpO1xuICAgIGVsc2VcbiAgICAgIG5leHRUaW1lID0gdGhpcy5fX3F1ZXVlLmluc2VydChlbmdpbmUsIHRpbWUpO1xuXG4gICAgdGhpcy5yZXNldFRpbWUobmV4dFRpbWUpO1xuICB9XG5cbiAgLy8gY2hlY2sgd2hldGhlciBhIGdpdmVuIGVuZ2luZSBpcyBzY2hlZHVsZWRcbiAgaGFzKGVuZ2luZSkge1xuICAgIHJldHVybiB0aGlzLl9fZW5naW5lcy5oYXMoZW5naW5lKTtcbiAgfVxuXG4gIC8vIGNsZWFyIHF1ZXVlXG4gIGNsZWFyKCkge1xuICAgIGZvcihsZXQgZW5naW5lIG9mIHRoaXMuX19lbmdpbmVzKVxuICAgICAgZW5naW5lLm1hc3RlciA9IG51bGw7XG5cbiAgICB0aGlzLl9fcXVldWUuY2xlYXIoKTtcbiAgICB0aGlzLl9fZW5naW5lcy5jbGVhcigpO1xuICAgIHRoaXMucmVzZXRUaW1lKEluZmluaXR5KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTY2hlZHVsaW5nUXVldWVcbiIsIi8qKlxuICogQmFzZSBjbGFzcyBmb3IgdGltZSBlbmdpbmVzXG4gKlxuICogQSB0aW1lIGVuZ2luZSBnZW5lcmF0ZXMgbW9yZSBvciBsZXNzIHJlZ3VsYXIgZXZlbnRzIGFuZC9vciBwbGF5cyBiYWNrIGFcbiAqIG1lZGlhIHN0cmVhbS4gSXQgaW1wbGVtZW50cyBvbmUgb3IgbXVsdGlwbGUgaW50ZXJmYWNlcyB0byBiZSBkcml2ZW4gYnkgYVxuICogbWFzdGVyIChpLmUuIGEgU2NoZWR1bGVyLCBhIFRyYW5zcG9ydCBvciBhIFBsYXlDb250cm9sKSBpbiBzeW5jaHJvbml6YXRpb25cbiAqIHdpdGggb3RoZXIgZW5naW5lcy4gVGhlIHByb3ZpZGVkIGludGVyZmFjZXMgYXJlIHNjaGVkdWxlZCwgdHJhbnNwb3J0ZWQsXG4gKiBhbmQgcGxheS1jb250cm9sbGVkLlxuICpcbiAqXG4gKiAjIyMjIFRoZSBgc2NoZWR1bGVkYCBpbnRlcmZhY2VcbiAqXG4gKiBUaGUgc2NoZWR1bGVkIGludGVyZmFjZSBhbGxvd3MgZm9yIHN5bmNocm9uaXppbmcgYW4gZW5naW5lIHRvIGEgbW9ub3Rvbm91cyB0aW1lXG4gKiBhcyBpdCBpcyBwcm92aWRlZCBieSB0aGUgU2NoZWR1bGVyIG1hc3Rlci5cbiAqXG4gKiAjIyMjIyMgYGFkdmFuY2VUaW1lKHRpbWUgOk51bWJlcikgLT4ge051bWJlcn1gXG4gKlxuICogVGhlIGBhZHZhbmNlVGltZWAgbWV0aG9kIGhhcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhbiBgVGltZUVuZ2luZWAgYXMgcGFydCBvZiB0aGVcbiAqIHNjaGVkdWxlZCBpbnRlcmZhY2UuIFRoZSBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBtYXN0ZXIgKGUuZy4gdGhlIHNjaGVkdWxlcikuXG4gKiBJdCBnZW5lcmF0ZXMgYW4gZXZlbnQgYW5kIHRvIHJldHVybnMgdGhlIHRpbWUgb2YgdGhlIG5leHQgZXZlbnQgKGkuZS4gdGhlIG5leHRcbiAqIGNhbGwgb2YgYWR2YW5jZVRpbWUpLiBUaGUgcmV0dXJuZWQgdGltZSBoYXMgdG8gYmUgZ3JlYXRlciB0aGFuIHRoZSB0aW1lXG4gKiByZWNlaXZlZCBhcyBhcmd1bWVudCBvZiB0aGUgbWV0aG9kLiBJbiBjYXNlIHRoYXQgYSBUaW1lRW5naW5lIGhhcyB0byBnZW5lcmF0ZVxuICogbXVsdGlwbGUgZXZlbnRzIGF0IHRoZSBzYW1lIHRpbWUsIHRoZSBlbmdpbmUgaGFzIHRvIGltcGxlbWVudCBpdHMgb3duIGxvb3BcbiAqIHdoaWxlKGV2ZW50LnRpbWUgPD0gdGltZSkgYW5kIHJldHVybiB0aGUgdGltZSBvZiB0aGUgbmV4dCBldmVudCAoaWYgYW55KS5cbiAqXG4gKiAjIyMjIyMgYHJlc2V0VGltZSh0aW1lPXVuZGVmaW5lZCA6TnVtYmVyKWBcbiAqXG4gKiBUaGUgYHJlc2V0VGltZWAgbWV0aG9kIGlzIHByb3ZpZGVkIGJ5IHRoZSBgVGltZUVuZ2luZWAgYmFzZSBjbGFzcy4gQW4gZW5naW5lIG1heVxuICogY2FsbCB0aGlzIG1ldGhvZCB0byByZXNldCBpdHMgbmV4dCBldmVudCB0aW1lIChlLmcuIHdoZW4gYSBwYXJhbWV0ZXIgaXNcbiAqIGNoYW5nZWQgdGhhdCBpbmZsdWVuY2VzIHRoZSBlbmdpbmUncyB0ZW1wb3JhbCBiZWhhdmlvcikuIFdoZW4gbm8gYXJndW1lbnRcbiAqIGlzIGdpdmVuLCB0aGUgdGltZSBpcyByZXNldCB0byB0aGUgY3VycmVudCBtYXN0ZXIgdGltZS4gV2hlbiBjYWxsaW5nIHRoZVxuICogbWV0aG9kIHdpdGggSW5maW5pdHkgdGhlIGVuZ2luZSBpcyBzdXNwZW5kZWQgd2l0aG91dCBiZWluZyByZW1vdmVkIGZyb20gdGhlXG4gKiBtYXN0ZXIuXG4gKlxuICpcbiAqICMjIyMgVGhlIGB0cmFuc3BvcnRlZGAgaW50ZXJmYWNlXG4gKlxuICogVGhlIHRyYW5zcG9ydGVkIGludGVyZmFjZSBhbGxvd3MgZm9yIHN5bmNocm9uaXppbmcgYW4gZW5naW5lIHRvIGEgcG9zaXRpb25cbiAqIChpLmUuIG1lZGlhIHBsYXliYWNrIHRpbWUpIHRoYXQgY2FuIHJ1biBmb3J3YXJkIGFuZCBiYWNrd2FyZCBhbmQganVtcCBhcyBpdFxuICogaXMgcHJvdmlkZWQgYnkgdGhlIFRyYW5zcG9ydCBtYXN0ZXIuXG4gKlxuICogIyMjIyMjIGBzeW5jUG9zaXRpb24odGltZSA6TnVtYmVyLCBwb3NpdGlvbiA6TnVtYmVyLCBzcGVlZCA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcbiAqXG4gKiBUaGUgYHN5bmNQb3NpdG9uYCBtZXRob2QgaGFzIHRvIGJlIGltcGxlbWVudGVkIGJ5IGEgYFRpbWVFbmdpbmVgIGFzIHBhcnQgb2YgdGhlXG4gKiB0cmFuc3BvcnRlZCBpbnRlcmZhY2UuIFRoZSBtZXRob2Qgc3luY1Bvc2l0b24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBtYXN0ZXJcbiAqIG9mIGEgdHJhbnNwb3J0ZWQgZW5naW5lIGhhcyB0byAocmUtKXN5bmNocm9uaXplIHRoZSBlbmdpbmUncyBwb3NpdGlvbi4gVGhpc1xuICogaXMgZm9yIGV4YW1wbGUgcmVxdWlyZWQgd2hlbiB0aGUgbWFzdGVyIChyZS0pc3RhcnRzIHBsYXliYWNrLCBqdW1wcyB0byBhblxuICogYXJiaXRyYXJ5IHBvc2l0aW9uLCBhbmQgd2hlbiByZXZlcnNpbmcgcGxheWJhY2sgZGlyZWN0aW9uLiBUaGUgbWV0aG9kIHJldHVybnNcbiAqIHRoZSBuZXh0IHBvc2l0aW9uIG9mIHRoZSBlbmdpbmUgaW4gdGhlIGdpdmVuIHBsYXliYWNrIGRpcmVjdGlvblxuICogKGkuZS4gYHNwZWVkIDwgMGAgb3IgYHNwZWVkID4gMGApLlxuICpcbiAqICMjIyMjIyBgYWR2YW5jZVBvc2l0aW9uKHRpbWUgOk51bWJlciwgcG9zaXRpb24gOk51bWJlciwgc3BlZWQgOk51bWJlcikgLT4ge051bWJlcn1gXG4gKlxuICogVGhlIGBhZHZhbmNlUG9zaXRpb25gIG1ldGhvZCBoYXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBgVGltZUVuZ2luZWAgYXMgcGFydFxuICogb2YgdGhlIHRyYW5zcG9ydGVkIGludGVyZmFjZS4gVGhlIG1hc3RlciBjYWxscyB0aGUgYWR2YW5jZVBvc2l0b24gbWV0aG9kIHdoZW5cbiAqIHRoZSBlbmdpbmUncyBldmVudCBwb3NpdGlvbiBpcyByZWFjaGVkLiBUaGUgbWV0aG9kIGdlbmVyYXRlcyBhbiBldmVudCBhbmRcbiAqIHJldHVybnMgdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIGdpdmVuIHBsYXliYWNrIGRpcmVjdGlvbiAoaS5lLiBzcGVlZCA8IDAgb3JcbiAqIHNwZWVkID4gMCkuIFRoZSByZXR1cm5lZCBwb3NpdGlvbiBoYXMgdG8gYmUgZ3JlYXRlciAoaS5lLiB3aGVuIHNwZWVkID4gMClcbiAqIG9yIGxlc3MgKGkuZS4gd2hlbiBzcGVlZCA8IDApIHRoYW4gdGhlIHBvc2l0aW9uIHJlY2VpdmVkIGFzIGFyZ3VtZW50IG9mIHRoZVxuICogbWV0aG9kLlxuICpcbiAqICMjIyMjIyBgcmVzZXRQb3NpdGlvbihwb3NpdGlvbj11bmRlZmluZWQgOk51bWJlcilgXG4gKlxuICogVGhlIHJlc2V0UG9zaXRpb24gbWV0aG9kIGlzIHByb3ZpZGVkIGJ5IHRoZSBUaW1lRW5naW5lIGJhc2UgY2xhc3MuIEFuIGVuZ2luZVxuICogbWF5IGNhbGwgdGhpcyBtZXRob2QgdG8gcmVzZXQgaXRzIG5leHQgZXZlbnQgcG9zaXRpb24uIFdoZW4gbm8gYXJndW1lbnRcbiAqIGlzIGdpdmVuLCB0aGUgdGltZSBpcyByZXNldCB0byB0aGUgY3VycmVudCBtYXN0ZXIgdGltZS4gV2hlbiBjYWxsaW5nIHRoZVxuICogbWV0aG9kIHdpdGggSW5maW5pdHkgdGhlIGVuZ2luZSBpcyBzdXNwZW5kZWQgd2l0aG91dCBiZWluZyByZW1vdmVkIGZyb21cbiAqIHRoZSBtYXN0ZXIuXG4gKlxuICpcbiAqICMjIyMgVGhlIHNwZWVkLWNvbnRyb2xsZWQgaW50ZXJmYWNlXG4gKlxuICogVGhlIFwic3BlZWQtY29udHJvbGxlZFwiIGludGVyZmFjZSBhbGxvd3MgZm9yIHN5bmNyb25pemluZyBhbiBlbmdpbmUgdGhhdCBpc1xuICogbmVpdGhlciBkcml2ZW4gdGhyb3VnaCB0aGUgc2NoZWR1bGVkIG5vciB0aGUgdHJhbnNwb3J0ZWQgaW50ZXJmYWNlLiBUaGVcbiAqIGludGVyZmFjZSBhbGxvd3MgaW4gcGFydGljdWxhciB0byBzeW5jaHJvbml6ZSBlbmdpbmVzIHRoYXQgYXNzdXJlIHRoZWlyIG93blxuICogc2NoZWR1bGluZyAoaS5lLiBhdWRpbyBwbGF5ZXIgb3IgYW4gb3NjaWxsYXRvcikgdG8gdGhlIGV2ZW50LWJhc2VkIHNjaGVkdWxlZFxuICogYW5kIHRyYW5zcG9ydGVkIGVuZ2luZXMuXG4gKlxuICogIyMjIyMjIGBzeW5jU3BlZWQodGltZSA6TnVtYmVyLCBwb3NpdGlvbiA6TnVtYmVyLCBzcGVlZCA6TnVtYmVyLCBzZWVrPWZhbHNlIDpCb29sZWFuKWBcbiAqXG4gKiBUaGUgc3luY1NwZWVkIG1ldGhvZCBoYXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBUaW1lRW5naW5lIGFzIHBhcnQgb2YgdGhlXG4gKiBzcGVlZC1jb250cm9sbGVkIGludGVyZmFjZS4gVGhlIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1hc3RlciB3aGVuZXZlciB0aGVcbiAqIHBsYXliYWNrIHNwZWVkIGNoYW5nZXMgb3IgdGhlIHBvc2l0aW9uIGp1bXBzIGFyYml0YXJpbHkgKGkuZS4gb24gYSBzZWVrKS5cbiAqXG4gKlxuICogPGhyIC8+XG4gKlxuICogRXhhbXBsZSB0aGF0IHNob3dzIGEgYFRpbWVFbmdpbmVgIHJ1bm5pbmcgaW4gYSBgU2NoZWR1bGVyYCB0aGF0IGNvdW50cyB1cFxuICogYXQgYSBnaXZlbiBmcmVxdWVuY3k6XG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3RpbWUtZW5naW5lLmh0bWx9XG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqXG4gKiBjbGFzcyBNeUVuZ2luZSBleHRlbmRzIGF1ZGlvLlRpbWVFbmdpbmUge1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICBzdXBlcigpO1xuICogICAgIC8vIC4uLlxuICogICB9XG4gKiB9XG4gKlxuICovXG5jbGFzcyBUaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGVuZ2luZSdzIG1hc3Rlci5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNaXhlZH1cbiAgICAgKiBAbmFtZSBtYXN0ZXJcbiAgICAgKiBAbWVtYmVyb2YgVGltZUVuZ2luZVxuICAgICAqL1xuICAgIHRoaXMubWFzdGVyID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGltZSBlbmdpbmUncyBjdXJyZW50IChtYXN0ZXIpIHRpbWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIGlmICh0aGlzLm1hc3RlcilcbiAgICAgIHJldHVybiB0aGlzLm1hc3Rlci5jdXJyZW50VGltZTtcblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWUgZW5naW5lJ3MgY3VycmVudCAobWFzdGVyKSBwb3NpdGlvbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG1lbWJlcm9mIFRpbWVFbmdpbmVcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xuICAgIHZhciBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcblxuICAgIGlmIChtYXN0ZXIgJiYgbWFzdGVyLmN1cnJlbnRQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIG1hc3Rlci5jdXJyZW50UG9zaXRpb247XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlZCBpbnRlcmZhY2VcbiAgICogICAtIGFkdmFuY2VUaW1lKHRpbWUpLCBjYWxsZWQgdG8gZ2VuZXJhdGUgbmV4dCBldmVudCBhdCBnaXZlbiB0aW1lLCByZXR1cm5zIG5leHQgdGltZVxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXG4gICAqL1xuICBzdGF0aWMgaW1wbGVtZW50c1NjaGVkdWxlZChlbmdpbmUpIHtcbiAgICByZXR1cm4gKGVuZ2luZS5hZHZhbmNlVGltZSAmJiBlbmdpbmUuYWR2YW5jZVRpbWUgaW5zdGFuY2VvZiBGdW5jdGlvbik7XG4gIH1cblxuICByZXNldFRpbWUodGltZSA9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLm1hc3RlcilcbiAgICAgIHRoaXMubWFzdGVyLnJlc2V0RW5naW5lVGltZSh0aGlzLCB0aW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc3BvcnRlZCBpbnRlcmZhY2VcbiAgICogICAtIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpLCBjYWxsZWQgdG8gcmVwb3NpdGlvbiBUaW1lRW5naW5lLCByZXR1cm5zIG5leHQgcG9zaXRpb25cbiAgICogICAtIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpLCBjYWxsZWQgdG8gZ2VuZXJhdGUgbmV4dCBldmVudCBhdCBnaXZlbiB0aW1lIGFuZCBwb3NpdGlvbiwgcmV0dXJucyBuZXh0IHBvc2l0aW9uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlcm9mIFRpbWVFbmdpbmVcbiAgICovXG4gIHN0YXRpYyBpbXBsZW1lbnRzVHJhbnNwb3J0ZWQoZW5naW5lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVuZ2luZS5zeW5jUG9zaXRpb24gJiYgZW5naW5lLnN5bmNQb3NpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmXG4gICAgICBlbmdpbmUuYWR2YW5jZVBvc2l0aW9uICYmIGVuZ2luZS5hZHZhbmNlUG9zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICk7XG4gIH1cblxuICByZXNldFBvc2l0aW9uKHBvc2l0aW9uID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMubWFzdGVyKVxuICAgICAgdGhpcy5tYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogU3BlZWQtY29udHJvbGxlZCBpbnRlcmZhY2VcbiAgICogICAtIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsICksIGNhbGxlZCB0b1xuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXG4gICAqL1xuICBzdGF0aWMgaW1wbGVtZW50c1NwZWVkQ29udHJvbGxlZChlbmdpbmUpIHtcbiAgICByZXR1cm4gKGVuZ2luZS5zeW5jU3BlZWQgJiYgZW5naW5lLnN5bmNTcGVlZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lRW5naW5lO1xuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcblxuZnVuY3Rpb24gb3B0T3JEZWYob3B0LCBkZWYpIHtcbiAgaWYgKG9wdCAhPT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBvcHQ7XG5cbiAgcmV0dXJuIGRlZjtcbn1cblxuXG4vKipcbiAqIEdyYW51bGFyIHN5bnRoZXNpcyBUaW1lRW5naW5lIGltcGxlbWVudGluZyB0aGUgc2NoZWR1bGVkIGludGVyZmFjZS5cbiAqIFRoZSBncmFpbiBwb3NpdGlvbiAoZ3JhaW4gb25zZXQgb3IgY2VudGVyIHRpbWUgaW4gdGhlIGF1ZGlvIGJ1ZmZlcikgaXNcbiAqIG9wdGlvbmFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgZW5naW5lJ3MgY3VycmVudFBvc2l0aW9uIGF0dHJpYnV0ZS5cbiAqXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgYSBgR3JhbnVsYXJFbmdpbmVgICh3aXRoIGEgZmV3IHBhcmFtZXRlciBjb250cm9scykgZHJpdmVuXG4gKiBieSBhIGBTY2hlZHVsZXJgIGFuZCBhIGBQbGF5Q29udHJvbGA6XG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL2dyYW51bGFyLWVuZ2luZS5odG1sfVxuICpcbiAqIEBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNjaGVkdWxlcigpO1xuICogY29uc3QgZ3JhbnVsYXJFbmdpbmUgPSBuZXcgYXVkaW8uR3JhbnVsYXJFbmdpbmUoKTtcbiAqXG4gKiBzY2hlZHVsZXIuYWRkKGdyYW51bGFyRW5naW5lKTtcbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnM9e30gLSBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBbb3B0aW9ucy5idWZmZXI9bnVsbF0gLSBBdWRpbyBidWZmZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RBYnM9MC4wMV0gLSBBYnNvbHV0ZSBncmFpbiBwZXJpb2QgaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kUmVsPTBdIC0gR3JhaW4gcGVyaW9kIHJlbGF0aXZlIHRvIGFic29sdXRlXG4gKiAgZHVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gZ3JhaW4gcGVyaW9kXG4gKiAgdmFyaWF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZE1pbj0wLjAwMV0gLSBNaW5pbXVtIGdyYWluIHBlcmlvZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvc2l0aW9uPTBdIC0gR3JhaW4gcG9zaXRpb24gKG9uc2V0IHRpbWUgaW4gYXVkaW9cbiAqICBidWZmZXIpIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvc2l0aW9uVmFyPTAuMDAzXSAtIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBwb3NpdGlvblxuICogIHZhcmlhdGlvbiBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFicz0wLjFdIC0gQWJzb2x1dGUgZ3JhaW4gZHVyYXRpb24gaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25SZWw9MF0gLSBHcmFpbiBkdXJhdGlvbiByZWxhdGl2ZSB0byBncmFpblxuICogIHBlcmlvZCAob3ZlcmxhcClcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hdHRhY2tBYnM9MF0gLSBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hdHRhY2tSZWw9MC41XSAtIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIGdyYWluIGR1cmF0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYXR0YWNrU2hhcGU9J2xpbiddIC0gU2hhcGUgb2YgYXR0YWNrXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVsZWFzZUFicz0wXSAtIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWxlYXNlUmVsPTAuNV0gLSBSZWxlYXNlIHRpbWUgcmVsYXRpdmUgdG8gZ3JhaW4gZHVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWxlYXNlU2hhcGU9J2xpbiddIC0gU2hhcGUgb2YgcmVsZWFzZVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmV4cFJhbXBPZmZzZXQ9MC4wMDAxXSAtIE9mZnNldCAoc3RhcnQvZW5kIHZhbHVlKVxuICogIGZvciBleHBvbmVudGlhbCBhdHRhY2svcmVsZWFzZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc2FtcGxpbmc9MF0gLSBHcmFpbiByZXNhbXBsaW5nIGluIGNlbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNhbXBsaW5nVmFyPTBdIC0gQW1vdXQgb2YgcmFuZG9tIHJlc2FtcGxpbmcgdmFyaWF0aW9uIGluIGNlbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5nYWluPTFdIC0gTGluZWFyIGdhaW4gZmFjdG9yXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNlbnRlcmVkPXRydWVdIC0gV2hldGhlciB0aGUgZ3JhaW4gcG9zaXRpb24gcmVmZXJzXG4gKiAgdG8gdGhlIGNlbnRlciBvZiB0aGUgZ3JhaW4gKG9yIHRoZSBiZWdpbm5pbmcpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmN5Y2xpYz1mYWxzZV0gLSBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIGdyYWluXG4gKiAgcG9zaXRpb24gYXJlIGNvbnNpZGVyZWQgYXMgY3ljbGljXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbj0wXSAtIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGVcbiAqICBhdWRpbyBidWZmZXIgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIGFzc3VyZSBjeWNsaWMgYmVoYXZpb3JcbiAqL1xuY2xhc3MgR3JhbnVsYXJFbmdpbmUgZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zLmF1ZGlvQ29udGV4dCk7XG5cbiAgICAvKipcbiAgICAgKiBBdWRpbyBidWZmZXJcbiAgICAgKlxuICAgICAqIEB0eXBlIHtBdWRpb0J1ZmZlcn1cbiAgICAgKiBAbmFtZSBidWZmZXJcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5idWZmZXIgPSBvcHRPckRlZihvcHRpb25zLmJ1ZmZlciwgbnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSBncmFpbiBwZXJpb2QgaW4gc2VjXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIHBlcmlvZEFic1xuICAgICAqIEBkZWZhdWx0IDAuMDFcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBlcmlvZEFicyA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kQWJzLCAwLjAxKTtcblxuICAgIC8qKlxuICAgICAqIEdyYWluIHBlcmlvZCByZWxhdGl2ZSB0byBhYnNvbHV0ZSBkdXJhdGlvblxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBwZXJpb2RSZWxcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wZXJpb2RSZWwgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZFJlbCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbW91dCBvZiByYW5kb20gZ3JhaW4gcGVyaW9kIHZhcmlhdGlvbiByZWxhdGl2ZSB0byBncmFpbiBwZXJpb2RcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgcGVyaW9kVmFyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucGVyaW9kVmFyID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RWYXIsIDApO1xuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBncmFpbiBwZXJpb2RcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgcGVyaW9kTWluXG4gICAgICogQGRlZmF1bHQgMC4wMDFcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBlcmlvZE1pbiA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kTWluLCAwLjAwMSk7XG5cbiAgICAvKipcbiAgICAgKiBHcmFpbiBwb3NpdGlvbiAob25zZXQgdGltZSBpbiBhdWRpbyBidWZmZXIpIGluIHNlY1xuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBwb3NpdGlvblxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gb3B0T3JEZWYob3B0aW9ucy5wb3NpdGlvbiwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbW91dCBvZiByYW5kb20gZ3JhaW4gcG9zaXRpb24gdmFyaWF0aW9uIGluIHNlY1xuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBwb3NpdGlvblZhclxuICAgICAqIEBkZWZhdWx0IDAuMDAzXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvblZhciA9IG9wdE9yRGVmKG9wdGlvbnMucG9zaXRpb25WYXIsIDAuMDAzKTtcblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIGdyYWluIGR1cmF0aW9uIGluIHNlY1xuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBkdXJhdGlvbkFic1xuICAgICAqIEBkZWZhdWx0IDAuMVxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25BYnMgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uQWJzLCAwLjEpOyAvLyBhYnNvbHV0ZSBncmFpbiBkdXJhdGlvblxuXG4gICAgLyoqXG4gICAgICogR3JhaW4gZHVyYXRpb24gcmVsYXRpdmUgdG8gZ3JhaW4gcGVyaW9kIChvdmVybGFwKVxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBkdXJhdGlvblJlbFxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uUmVsID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvblJlbCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgYXR0YWNrQWJzXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuYXR0YWNrQWJzID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tBYnMsIDApO1xuXG4gICAgLyoqXG4gICAgICogQXR0YWNrIHRpbWUgcmVsYXRpdmUgdG8gZ3JhaW4gZHVyYXRpb25cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgYXR0YWNrUmVsXG4gICAgICogQGRlZmF1bHQgMC41XG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5hdHRhY2tSZWwgPSBvcHRPckRlZihvcHRpb25zLmF0dGFja1JlbCwgMC41KTtcblxuICAgIC8qKlxuICAgICAqIFNoYXBlIG9mIGF0dGFjayAoJ2xpbicgZm9yIGxpbmVhciByYW1wLCAnZXhwJyBmb3IgZXhwb25lbnRpYWwgcmFtcClcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQG5hbWUgYXR0YWNrU2hhcGVcbiAgICAgKiBAZGVmYXVsdCAnbGluJ1xuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuYXR0YWNrU2hhcGUgPSBvcHRPckRlZihvcHRpb25zLmF0dGFja1NoYXBlLCAnbGluJyk7XG5cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSByZWxlYXNlIHRpbWUgaW4gc2VjXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIHJlbGVhc2VBYnNcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5yZWxlYXNlQWJzID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlQWJzLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBncmFpbiBkdXJhdGlvblxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSByZWxlYXNlUmVsXG4gICAgICogQGRlZmF1bHQgMC41XG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5yZWxlYXNlUmVsID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlUmVsLCAwLjUpO1xuXG4gICAgLyoqXG4gICAgICogU2hhcGUgb2YgcmVsZWFzZSAoJ2xpbicgZm9yIGxpbmVhciByYW1wLCAnZXhwJyBmb3IgZXhwb25lbnRpYWwgcmFtcClcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQG5hbWUgcmVsZWFzZVNoYXBlXG4gICAgICogQGRlZmF1bHQgJ2xpbidcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlbGVhc2VTaGFwZSA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZVNoYXBlLCAnbGluJyk7XG5cbiAgICAvKipcbiAgICAgKiBPZmZzZXQgKHN0YXJ0L2VuZCB2YWx1ZSkgZm9yIGV4cG9uZW50aWFsIGF0dGFjay9yZWxlYXNlXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIGV4cFJhbXBPZmZzZXRcbiAgICAgKiBAZGVmYXVsdCAwLjAwMDFcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmV4cFJhbXBPZmZzZXQgPSBvcHRPckRlZihvcHRpb25zLmV4cFJhbXBPZmZzZXQsIDAuMDAwMSk7XG5cbiAgICAvKipcbiAgICAgKiBHcmFpbiByZXNhbXBsaW5nIGluIGNlbnRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1xuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlc2FtcGxpbmcgPSBvcHRPckRlZihvcHRpb25zLnJlc2FtcGxpbmcsIDApO1xuXG4gICAgLyoqXG4gICAgICogQW1vdXQgb2YgcmFuZG9tIHJlc2FtcGxpbmcgdmFyaWF0aW9uIGluIGNlbnRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1ZhclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlc2FtcGxpbmdWYXIgPSBvcHRPckRlZihvcHRpb25zLnJlc2FtcGxpbmdWYXIsIDApO1xuXG4gICAgLyoqXG4gICAgICogTGluZWFyIGdhaW4gZmFjdG9yXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBuYW1lIGdhaW5cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5nYWluID0gb3B0T3JEZWYob3B0aW9ucy5nYWluLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGdyYWluIHBvc2l0aW9uIHJlZmVycyB0byB0aGUgY2VudGVyIG9mIHRoZSBncmFpbiAob3IgdGhlIGJlZ2lubmluZylcbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBuYW1lIGNlbnRlcmVkXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuY2VudGVyZWQgPSBvcHRPckRlZihvcHRpb25zLmNlbnRlcmVkLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGF1ZGlvIGJ1ZmZlciBhbmQgZ3JhaW4gcG9zaXRpb24gYXJlIGNvbnNpZGVyZWQgYXMgY3ljbGljXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAbmFtZSBjeWNsaWNcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuY3ljbGljID0gb3B0T3JEZWYob3B0aW9ucy5jeWNsaWMsIGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gYnVmZmVyIHRoYXQgaGFzIGJlZW4gY29waWVkIGZyb20gdGhlXG4gICAgICogYmVnaW5uaW5nIHRvIGFzc3VyZSBjeWNsaWMgYmVoYXZpb3JcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgd3JhcEFyb3VuZEV4dGVuc2lvblxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLndyYXBBcm91bmRFeHRlbnNpb24gPSBvcHRPckRlZihvcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb24sIDApO1xuXG4gICAgdGhpcy5vdXRwdXROb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBidWZmZXIgZHVyYXRpb24gKGV4Y2x1ZGluZyB3cmFwQXJvdW5kRXh0ZW5zaW9uKVxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbmFtZSBidWZmZXJEdXJhdGlvblxuICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcbiAgICogQGluc3RhbmNlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJ1ZmZlckR1cmF0aW9uKCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb247XG5cbiAgICAgIGlmICh0aGlzLndyYXBBcm91bmRFeHRlbnNpb24pXG4gICAgICAgIGJ1ZmZlckR1cmF0aW9uIC09IHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbjtcblxuICAgICAgcmV0dXJuIGJ1ZmZlckR1cmF0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgcG9zaXRpb25cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgY3VycmVudFBvc2l0aW9uXG4gICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xuICAgIHZhciBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcblxuICAgIGlmIChtYXN0ZXIgJiYgbWFzdGVyLmN1cnJlbnRQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIG1hc3Rlci5jdXJyZW50UG9zaXRpb247XG5cbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbiAgfVxuXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcbiAgICB0aW1lID0gTWF0aC5tYXgodGltZSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUpO1xuICAgIHJldHVybiB0aW1lICsgdGhpcy50cmlnZ2VyKHRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSBncmFpbi4gVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGF0IGFueSB0aW1lICh3aGV0aGVyIHRoZVxuICAgKiBlbmdpbmUgaXMgc2NoZWR1bGVkIG9yIG5vdCkgdG8gZ2VuZXJhdGUgYSBzaW5nbGUgZ3JhaW4gYWNjb3JkaW5nIHRvIHRoZVxuICAgKiBjdXJyZW50IGdyYWluIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gZ3JhaW4gc3ludGhlc2lzIGF1ZGlvIHRpbWVcbiAgICogQHJldHVybiB7TnVtYmVyfSAtIHBlcmlvZCB0byBuZXh0IGdyYWluXG4gICAqL1xuICB0cmlnZ2VyKHRpbWUpIHtcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XG4gICAgdmFyIGdyYWluVGltZSA9IHRpbWUgfHwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHZhciBncmFpblBlcmlvZCA9IHRoaXMucGVyaW9kQWJzO1xuICAgIHZhciBncmFpblBvc2l0aW9uID0gdGhpcy5jdXJyZW50UG9zaXRpb247XG4gICAgdmFyIGdyYWluRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uQWJzO1xuXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICB2YXIgcmVzYW1wbGluZ1JhdGUgPSAxLjA7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSByZXNhbXBsaW5nXG4gICAgICBpZiAodGhpcy5yZXNhbXBsaW5nICE9PSAwIHx8IHRoaXMucmVzYW1wbGluZ1ZhciA+IDApIHtcbiAgICAgICAgdmFyIHJhbmRvbVJlc2FtcGxpbmcgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLjAgKiB0aGlzLnJlc2FtcGxpbmdWYXI7XG4gICAgICAgIHJlc2FtcGxpbmdSYXRlID0gTWF0aC5wb3coMi4wLCAodGhpcy5yZXNhbXBsaW5nICsgcmFuZG9tUmVzYW1wbGluZykgLyAxMjAwLjApO1xuICAgICAgfVxuXG4gICAgICBncmFpblBlcmlvZCArPSB0aGlzLnBlcmlvZFJlbCAqIGdyYWluRHVyYXRpb247XG4gICAgICBncmFpbkR1cmF0aW9uICs9IHRoaXMuZHVyYXRpb25SZWwgKiBncmFpblBlcmlvZDtcblxuICAgICAgLy8gZ3JhaW4gcGVyaW9kIHJhbmRvbiB2YXJpYXRpb25cbiAgICAgIGlmICh0aGlzLnBlcmlvZFZhciA+IDAuMClcbiAgICAgICAgZ3JhaW5QZXJpb2QgKz0gMi4wICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5wZXJpb2RWYXIgKiBncmFpblBlcmlvZDtcblxuICAgICAgLy8gY2VudGVyIGdyYWluXG4gICAgICBpZiAodGhpcy5jZW50ZXJlZClcbiAgICAgICAgZ3JhaW5Qb3NpdGlvbiAtPSAwLjUgKiBncmFpbkR1cmF0aW9uO1xuXG4gICAgICAvLyByYW5kb21pemUgZ3JhaW4gcG9zaXRpb25cbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uVmFyID4gMClcbiAgICAgICAgZ3JhaW5Qb3NpdGlvbiArPSAoMi4wICogTWF0aC5yYW5kb20oKSAtIDEpICogdGhpcy5wb3NpdGlvblZhcjtcblxuICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXJEdXJhdGlvbjtcblxuICAgICAgLy8gd3JhcCBvciBjbGlwIGdyYWluIHBvc2l0aW9uIGFuZCBkdXJhdGlvbiBpbnRvIGJ1ZmZlciBkdXJhdGlvblxuICAgICAgaWYgKGdyYWluUG9zaXRpb24gPCAwIHx8IGdyYWluUG9zaXRpb24gPj0gYnVmZmVyRHVyYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuY3ljbGljKSB7XG4gICAgICAgICAgdmFyIGN5Y2xlcyA9IGdyYWluUG9zaXRpb24gLyBidWZmZXJEdXJhdGlvbjtcbiAgICAgICAgICBncmFpblBvc2l0aW9uID0gKGN5Y2xlcyAtIE1hdGguZmxvb3IoY3ljbGVzKSkgKiBidWZmZXJEdXJhdGlvbjtcblxuICAgICAgICAgIGlmIChncmFpblBvc2l0aW9uICsgZ3JhaW5EdXJhdGlvbiA+IHRoaXMuYnVmZmVyLmR1cmF0aW9uKVxuICAgICAgICAgICAgZ3JhaW5EdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uIC0gZ3JhaW5Qb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZ3JhaW5Qb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIGdyYWluVGltZSAtPSBncmFpblBvc2l0aW9uO1xuICAgICAgICAgICAgZ3JhaW5EdXJhdGlvbiArPSBncmFpblBvc2l0aW9uO1xuICAgICAgICAgICAgZ3JhaW5Qb3NpdGlvbiA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGdyYWluUG9zaXRpb24gKyBncmFpbkR1cmF0aW9uID4gYnVmZmVyRHVyYXRpb24pXG4gICAgICAgICAgICBncmFpbkR1cmF0aW9uID0gYnVmZmVyRHVyYXRpb24gLSBncmFpblBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2UgZ3JhaW5cbiAgICAgIGlmICh0aGlzLmdhaW4gPiAwICYmIGdyYWluRHVyYXRpb24gPj0gMC4wMDEpIHtcbiAgICAgICAgLy8gbWFrZSBncmFpbiBlbnZlbG9wZVxuICAgICAgICB2YXIgZW52ZWxvcGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICB2YXIgYXR0YWNrID0gdGhpcy5hdHRhY2tBYnMgKyB0aGlzLmF0dGFja1JlbCAqIGdyYWluRHVyYXRpb247XG4gICAgICAgIHZhciByZWxlYXNlID0gdGhpcy5yZWxlYXNlQWJzICsgdGhpcy5yZWxlYXNlUmVsICogZ3JhaW5EdXJhdGlvbjtcblxuICAgICAgICBpZiAoYXR0YWNrICsgcmVsZWFzZSA+IGdyYWluRHVyYXRpb24pIHtcbiAgICAgICAgICB2YXIgZmFjdG9yID0gZ3JhaW5EdXJhdGlvbiAvIChhdHRhY2sgKyByZWxlYXNlKTtcbiAgICAgICAgICBhdHRhY2sgKj0gZmFjdG9yO1xuICAgICAgICAgIHJlbGVhc2UgKj0gZmFjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dGFja0VuZFRpbWUgPSBncmFpblRpbWUgKyBhdHRhY2s7XG4gICAgICAgIHZhciBncmFpbkVuZFRpbWUgPSBncmFpblRpbWUgKyBncmFpbkR1cmF0aW9uIC8gcmVzYW1wbGluZ1JhdGU7XG4gICAgICAgIHZhciByZWxlYXNlU3RhcnRUaW1lID0gZ3JhaW5FbmRUaW1lIC0gcmVsZWFzZTtcblxuICAgICAgICBlbnZlbG9wZS5nYWluLnZhbHVlID0gMDtcblxuICAgICAgICBpZiAodGhpcy5hdHRhY2tTaGFwZSA9PT0gJ2xpbicpIHtcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKDAuMCwgZ3JhaW5UaW1lKTtcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh0aGlzLmV4cFJhbXBPZmZzZXQsIGdyYWluVGltZSk7XG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVsZWFzZVN0YXJ0VGltZSA+IGF0dGFja0VuZFRpbWUpXG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh0aGlzLmdhaW4sIHJlbGVhc2VTdGFydFRpbWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnJlbGVhc2VTaGFwZSA9PT0gJ2xpbicpIHtcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAuMCwgZ3JhaW5FbmRUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5leHBSYW1wT2Zmc2V0LCBncmFpbkVuZFRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW52ZWxvcGUuY29ubmVjdCh0aGlzLm91dHB1dE5vZGUpO1xuXG4gICAgICAgIC8vIG1ha2Ugc291cmNlXG4gICAgICAgIHZhciBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmVzYW1wbGluZ1JhdGU7XG4gICAgICAgIHNvdXJjZS5jb25uZWN0KGVudmVsb3BlKTtcblxuICAgICAgICBzb3VyY2Uuc3RhcnQoZ3JhaW5UaW1lLCBncmFpblBvc2l0aW9uKTtcbiAgICAgICAgc291cmNlLnN0b3AoZ3JhaW5FbmRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5wZXJpb2RNaW4sIGdyYWluUGVyaW9kKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHcmFudWxhckVuZ2luZTtcbiIsImltcG9ydCBBdWRpb1RpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS9hdWRpby10aW1lLWVuZ2luZSc7XG5cbmZ1bmN0aW9uIG9wdE9yRGVmKG9wdCwgZGVmKSB7XG4gIGlmKG9wdCAhPT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBvcHQ7XG5cbiAgcmV0dXJuIGRlZjtcbn1cblxuLyoqXG4gKiBNZXRyb25vbWUgYXVkaW8gZW5naW5lLiBJdCBleHRlbmRzIFRpbWUgRW5naW5lIGFzIGEgdHJhbnNwb3J0ZWQgaW50ZXJmYWNlLlxuICogW2V4YW1wbGVde0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9tZXRyb25vbWUuaHRtbH1cbiAqXG4gKiBAZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XG4gKiBjb25zdCBzY2hlZHVsZXIgPSBhdWRpby5nZXRTY2hlZHVsZXIoKTtcbiAqIGNvbnN0IG1ldHJvbm9tZSA9IG5ldyBhdWRpby5NZXRyb25vbWUoe3BlcmlvZDogMC4zMzN9KTtcbiAqXG4gKiBzY2hlZHVsZXIuYWRkKG1ldHJvbm9tZSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIERlZmF1bHQgb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZD0xXSAtIE1ldHJvbm9tZSBwZXJpb2RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jbGlja0ZyZXE9NjAwXSAtIE1ldHJvbm9tZSBjbGljayBmcmVxdWVuY3lcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jbGlja0F0dGFjaz0wLjAwMl0gLSBNZXRyb25vbWUgY2xpY2sgYXR0YWNrIHRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jbGlja1JlbGVhc2U9MC4wOThdIC0gTWV0cm9ub21lIGNsaWNrIHJlbGVhc2UgdGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhaW49MV0gLSBHYWluXG4gKi9cbmNsYXNzIE1ldHJvbm9tZSBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcblxuICAgIC8qKlxuICAgICAqIE1ldHJvbm9tZSBwZXJpb2RcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fX3BlcmlvZCA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kLCAxKTtcblxuICAgIC8qKlxuICAgICAqIE1ldHJvbm9tZSBjbGljayBmcmVxdWVuY3lcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxuICAgICAqIEBuYW1lIGNsaWNrRnJlcVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuY2xpY2tGcmVxID0gb3B0T3JEZWYob3B0aW9ucy5jbGlja0ZyZXEsIDYwMCk7XG5cbiAgICAvKipcbiAgICAgKiBNZXRyb25vbWUgY2xpY2sgYXR0YWNrIHRpbWVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxuICAgICAqIEBuYW1lIGNsaWNrQXR0YWNrXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5jbGlja0F0dGFjayA9IG9wdE9yRGVmKG9wdGlvbnMuY2xpY2tBdHRhY2ssIDAuMDAyKTtcblxuICAgIC8qKlxuICAgICAqIE1ldHJvbm9tZSBjbGljayByZWxlYXNlIHRpbWVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxuICAgICAqIEBuYW1lIGNsaWNrUmVsZWFzZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuY2xpY2tSZWxlYXNlID0gb3B0T3JEZWYob3B0aW9ucy5jbGlja1JlbGVhc2UsIDAuMDk4KTtcblxuICAgIHRoaXMuX19sYXN0VGltZSA9IDA7XG4gICAgdGhpcy5fX3BoYXNlID0gMDtcblxuICAgIHRoaXMuX19nYWluTm9kZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLl9fZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IG9wdE9yRGVmKG9wdGlvbnMuZ2FpbiwgMSk7XG5cbiAgICB0aGlzLm91dHB1dE5vZGUgPSB0aGlzLl9fZ2Fpbk5vZGU7XG4gIH1cblxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAoc2NoZWR1bGVkIGludGVyZmFjZSlcbiAgYWR2YW5jZVRpbWUodGltZSkge1xuICAgIHRoaXMudHJpZ2dlcih0aW1lKTtcbiAgICB0aGlzLl9fbGFzdFRpbWUgPSB0aW1lO1xuICAgIHJldHVybiB0aW1lICsgdGhpcy5fX3BlcmlvZDtcbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBpZiAodGhpcy5fX3BlcmlvZCA+IDApIHtcbiAgICAgIHZhciBuZXh0UG9zaXRpb24gPSAoTWF0aC5mbG9vcihwb3NpdGlvbiAvIHRoaXMuX19wZXJpb2QpICsgdGhpcy5fX3BoYXNlKSAqIHRoaXMuX19wZXJpb2Q7XG5cbiAgICAgIGlmIChzcGVlZCA+IDAgJiYgbmV4dFBvc2l0aW9uIDwgcG9zaXRpb24pXG4gICAgICAgIG5leHRQb3NpdGlvbiArPSB0aGlzLl9fcGVyaW9kO1xuICAgICAgZWxzZSBpZiAoc3BlZWQgPCAwICYmIG5leHRQb3NpdGlvbiA+IHBvc2l0aW9uKVxuICAgICAgICBuZXh0UG9zaXRpb24gLT0gdGhpcy5fX3BlcmlvZDtcblxuICAgICAgcmV0dXJuIG5leHRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDtcbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXG4gIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICB0aGlzLnRyaWdnZXIodGltZSk7XG5cbiAgICBpZiAoc3BlZWQgPCAwKVxuICAgICAgcmV0dXJuIHBvc2l0aW9uIC0gdGhpcy5fX3BlcmlvZDtcblxuICAgIHJldHVybiBwb3NpdGlvbiArIHRoaXMuX19wZXJpb2Q7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBtZXRyb25vbWUgY2xpY2tcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgbWV0cm9ub21lIGNsaWNrIHN5bnRoZXNpcyBhdWRpbyB0aW1lXG4gICAqL1xuICB0cmlnZ2VyKHRpbWUpIHtcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcbiAgICBjb25zdCBjbGlja0F0dGFjayA9IHRoaXMuY2xpY2tBdHRhY2s7XG4gICAgY29uc3QgY2xpY2tSZWxlYXNlID0gdGhpcy5jbGlja1JlbGVhc2U7XG5cbiAgICBjb25zdCBlbnYgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIGVudi5nYWluLnZhbHVlID0gMC4wO1xuICAgIGVudi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xuICAgIGVudi5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDEuMCwgdGltZSArIGNsaWNrQXR0YWNrKTtcbiAgICBlbnYuZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKDAuMDAwMDAwMSwgdGltZSArIGNsaWNrQXR0YWNrICsgY2xpY2tSZWxlYXNlKTtcbiAgICBlbnYuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcbiAgICBlbnYuY29ubmVjdCh0aGlzLm91dHB1dE5vZGUpO1xuXG4gICAgY29uc3Qgb3NjID0gYXVkaW9Db250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICBvc2MuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5jbGlja0ZyZXE7XG4gICAgb3NjLnN0YXJ0KHRpbWUpO1xuICAgIG9zYy5zdG9wKHRpbWUgKyBjbGlja0F0dGFjayArIGNsaWNrUmVsZWFzZSk7XG4gICAgb3NjLmNvbm5lY3QoZW52KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBsaW5lYXIgZ2FpbiBmYWN0b3JcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgZ2FpblxuICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgc2V0IGdhaW4odmFsdWUpIHtcbiAgICB0aGlzLl9fZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGdhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIG1ldHJvbm9tZSBwZXJpb2RcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgcGVyaW9kXG4gICAqIEBtZW1iZXJvZiBNZXRyb25vbWVcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICBzZXQgcGVyaW9kKHBlcmlvZCkge1xuICAgIHRoaXMuX19wZXJpb2QgPSBwZXJpb2Q7XG5cbiAgICBjb25zdCBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcblxuICAgIGlmIChtYXN0ZXIpIHtcbiAgICAgIGlmIChtYXN0ZXIucmVzZXRFbmdpbmVUaW1lKVxuICAgICAgICBtYXN0ZXIucmVzZXRFbmdpbmVUaW1lKHRoaXMsIHRoaXMuX19sYXN0VGltZSArIHBlcmlvZCk7XG4gICAgICBlbHNlIGlmIChtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbilcbiAgICAgICAgbWFzdGVyLnJlc2V0RW5naW5lUG9zaXRpb24odGhpcyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3BlcmlvZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcGhhc2UgcGFyYW1ldGVyIChhdmFpbGFibGUgb25seSB3aGVuICd0cmFuc3BvcnRlZCcpLCBzaG91bGQgYmVcbiAgICogYmV0d2VlbiBbMCwgMVtcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgcGhhc2VcbiAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIHNldCBwaGFzZShwaGFzZSkge1xuICAgIHRoaXMuX19waGFzZSA9IHBoYXNlIC0gTWF0aC5mbG9vcihwaGFzZSk7XG5cbiAgICBjb25zdCBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcblxuICAgIGlmIChtYXN0ZXIgJiYgbWFzdGVyLnJlc2V0RW5naW5lUG9zaXRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgIG1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMpO1xuICB9XG5cbiAgZ2V0IHBoYXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9fcGhhc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWV0cm9ub21lO1xuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcblxuZnVuY3Rpb24gb3B0T3JEZWYob3B0LCBkZWYpIHtcbiAgaWYob3B0ICE9PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIG9wdDtcblxuICByZXR1cm4gZGVmO1xufVxuXG4vKipcbiAqIFVzZWQgd2l0aCBhIGJ1ZmZlciB0byBzZXJ2ZSBhdWRpbyBmaWxlcy5cbiAqXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3BsYXllci1lbmdpbmUuaHRtbH1cbiAqXG4gKiBAZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XG4gKiBjb25zdCBwbGF5ZXJFbmdpbmUgPSBhdWRpby5QbGF5ZXJFbmdpbmUoKTtcbiAqIGNvbnN0IHBsYXlDb250cm9sID0gbmV3IGF1ZGlvLlBsYXlDb250cm9sKHBsYXllckVuZ2luZSk7XG4gKlxuICogcGxheUNvbnRyb2wuc3RhcnQoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVmZmVyPTFdIC0gQXVkaW8gYnVmZmVyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmFkZVRpbWU9NjAwXSAtIEZhZGUgdGltZSBmb3IgY2hhaW5pbmcgc2VnbWVudHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jeWNsaWM9ZmFsc2VdIC0gTG9vcCBtb2RlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ2Fpbj0xXSAtIEdhaW5cbiAqL1xuY2xhc3MgUGxheWVyRW5naW5lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucy5hdWRpb0NvbnRleHQpO1xuXG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsOyAvLyBzZXQgd2hlbiBhZGRlZCB0byB0cmFuc3BvcnRlclxuXG4gICAgLyoqXG4gICAgICogQXVkaW8gYnVmZmVyXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXVkaW9CdWZmZXJ9XG4gICAgICogQG5hbWUgYnVmZmVyXG4gICAgICogQG1lbWJlcm9mIFBsYXllckVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlciA9IG9wdE9yRGVmKG9wdGlvbnMuYnVmZmVyLCBudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEZhZGUgdGltZSBmb3IgY2hhaW5pbmcgc2VnbWVudHMgKGUuZy4gaW4gc3RhcnQsIHN0b3AsIGFuZCBzZWVrKVxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBmYWRlVGltZVxuICAgICAqIEBtZW1iZXJvZiBQbGF5ZXJFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxuICAgICAqL1xuICAgIHRoaXMuZmFkZVRpbWUgPSBvcHRPckRlZihvcHRpb25zLmZhZGVUaW1lLCAwLjAwNSk7XG5cbiAgICB0aGlzLl9fdGltZSA9IDA7XG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbiAgICB0aGlzLl9fc3BlZWQgPSAwO1xuXG4gICAgdGhpcy5fX2J1ZmZlclNvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fX2Vudk5vZGUgPSBudWxsO1xuXG4gICAgdGhpcy5fX2dhaW5Ob2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlID0gb3B0T3JEZWYob3B0aW9ucy5nYWluLCAxKTtcblxuICAgIHRoaXMuX19jeWNsaWMgPSBvcHRPckRlZihvcHRpb25zLmN5Y2xpYywgZmFsc2UpO1xuXG4gICAgdGhpcy5vdXRwdXROb2RlID0gdGhpcy5fX2dhaW5Ob2RlO1xuICB9XG5cbiAgX19zdGFydCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XG5cbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xuXG4gICAgICBpZiAodGhpcy5fX2N5Y2xpYyAmJiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IGJ1ZmZlckR1cmF0aW9uKSkge1xuICAgICAgICB2YXIgcGhhc2UgPSBwb3NpdGlvbiAvIGJ1ZmZlckR1cmF0aW9uO1xuICAgICAgICBwb3NpdGlvbiA9IChwaGFzZSAtIE1hdGguZmxvb3IocGhhc2UpKSAqIGJ1ZmZlckR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zaXRpb24gPj0gMCAmJiBwb3NpdGlvbiA8IGJ1ZmZlckR1cmF0aW9uICYmIHNwZWVkID4gMCkge1xuICAgICAgICB0aGlzLl9fZW52Tm9kZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgIHRoaXMuX19lbnZOb2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGltZSk7XG4gICAgICAgIHRoaXMuX19lbnZOb2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMSwgdGltZSArIHRoaXMuZmFkZVRpbWUpO1xuICAgICAgICB0aGlzLl9fZW52Tm9kZS5jb25uZWN0KHRoaXMuX19nYWluTm9kZSk7XG5cbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSBzcGVlZDtcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5sb29wID0gdGhpcy5fX2N5Y2xpYztcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5sb29wU3RhcnQgPSAwO1xuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLmxvb3BFbmQgPSBidWZmZXJEdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5zdGFydCh0aW1lLCBwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UuY29ubmVjdCh0aGlzLl9fZW52Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX19oYWx0KHRpbWUpIHtcbiAgICBpZiAodGhpcy5fX2J1ZmZlclNvdXJjZSkge1xuICAgICAgdGhpcy5fX2Vudk5vZGUuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGltZSk7XG4gICAgICB0aGlzLl9fZW52Tm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuX19lbnZOb2RlLmdhaW4udmFsdWUsIHRpbWUpO1xuICAgICAgdGhpcy5fX2Vudk5vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aW1lICsgdGhpcy5mYWRlVGltZSk7XG4gICAgICB0aGlzLl9fYnVmZmVyU291cmNlLnN0b3AodGltZSArIHRoaXMuZmFkZVRpbWUpO1xuXG4gICAgICB0aGlzLl9fYnVmZmVyU291cmNlID0gbnVsbDtcbiAgICAgIHRoaXMuX19lbnZOb2RlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAoc3BlZWQtY29udHJvbGxlZCBpbnRlcmZhY2UpXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWsgPSBmYWxzZSkge1xuICAgIHZhciBsYXN0U3BlZWQgPSB0aGlzLl9fc3BlZWQ7XG5cbiAgICBpZiAoc3BlZWQgIT09IGxhc3RTcGVlZCB8fCBzZWVrKSB7XG4gICAgICBpZiAoc2VlayB8fCBsYXN0U3BlZWQgKiBzcGVlZCA8IDApIHtcbiAgICAgICAgdGhpcy5fX2hhbHQodGltZSk7XG4gICAgICAgIHRoaXMuX19zdGFydCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICAgICAgfSBlbHNlIGlmIChsYXN0U3BlZWQgPT09IDAgfHwgc2Vlaykge1xuICAgICAgICB0aGlzLl9fc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgdGhpcy5fX2hhbHQodGltZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX19idWZmZXJTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUoc3BlZWQsIHRpbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9fc3BlZWQgPSBzcGVlZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdGhlIGF1ZGlvIGJ1ZmZlciBpcyBjb25zaWRlcmVkIGFzIGN5Y2xpY1xuICAgKiBAdHlwZSB7Qm9vbH1cbiAgICogQG5hbWUgY3ljbGljXG4gICAqIEBtZW1iZXJvZiBQbGF5ZXJFbmdpbmVcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICBzZXQgY3ljbGljKGN5Y2xpYykge1xuICAgIGlmIChjeWNsaWMgIT09IHRoaXMuX19jeWNsaWMpIHtcbiAgICAgIHZhciB0aW1lID0gdGhpcy5jdXJyZW50VGltZTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuY3VycmVudG9zaXRpb247XG5cbiAgICAgIHRoaXMuX19oYWx0KHRpbWUpO1xuICAgICAgdGhpcy5fX2N5Y2xpYyA9IGN5Y2xpYztcblxuICAgICAgaWYgKHRoaXMuX19zcGVlZCAhPT0gMClcbiAgICAgICAgdGhpcy5fX3N0YXJ0KHRpbWUsIHBvc2l0aW9uLCB0aGlzLl9fc3BlZWQpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBjeWNsaWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19jeWNsaWM7XG4gIH1cblxuICAvKipcbiAgICogTGluZWFyIGdhaW4gZmFjdG9yXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBuYW1lIGdhaW5cbiAgICogQG1lbWJlcm9mIFBsYXllckVuZ2luZVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIHNldCBnYWluKHZhbHVlKSB7XG4gICAgdmFyIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgIHRoaXMuX19nYWluTm9kZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGltZSk7XG4gICAgdGhpcy5fX2dhaW5Ob2RlLnNldFZhbHVlQXRUaW1lKHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlLCB0aW1lKTtcbiAgICB0aGlzLl9fZ2Fpbk5vZGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgdGltZSArIHRoaXMuZmFkZVRpbWUpO1xuICB9XG5cbiAgZ2V0IGdhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBidWZmZXIgZHVyYXRpb25cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgYnVmZmVyRHVyYXRpb25cbiAgICogQG1lbWJlcm9mIFBsYXllckVuZ2luZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYnVmZmVyRHVyYXRpb24oKSB7XG4gICAgaWYodGhpcy5idWZmZXIpXG4gICAgICByZXR1cm4gdGhpcy5idWZmZXIuZHVyYXRpb247XG5cbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGF5ZXJFbmdpbmU7XG4iLCJpbXBvcnQgQXVkaW9UaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvYXVkaW8tdGltZS1lbmdpbmUnO1xuXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xuICBpZiAob3B0ICE9PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIG9wdDtcblxuICByZXR1cm4gZGVmO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50T3JQcmV2aW91c0luZGV4KHNvcnRlZEFycmF5LCB2YWx1ZSwgaW5kZXggPSAtMSkge1xuICB2YXIgc2l6ZSA9IHNvcnRlZEFycmF5Lmxlbmd0aDtcblxuICBpZiAoc2l6ZSA+IDApIHtcbiAgICB2YXIgZmlyc3RWYWwgPSBzb3J0ZWRBcnJheVswXTtcbiAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcblxuICAgIGlmICh2YWx1ZSA8IGZpcnN0VmFsKVxuICAgICAgaW5kZXggPSAtMTtcbiAgICBlbHNlIGlmICh2YWx1ZSA+PSBsYXN0VmFsKVxuICAgICAgaW5kZXggPSBzaXplIC0gMTtcbiAgICBlbHNlIHtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2l6ZSlcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChzaXplIC0gMSkgKiAodmFsdWUgLSBmaXJzdFZhbCkgLyAobGFzdFZhbCAtIGZpcnN0VmFsKSk7XG5cbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleF0gPiB2YWx1ZSlcbiAgICAgICAgaW5kZXgtLTtcblxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4ICsgMV0gPD0gdmFsdWUpXG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50T3JOZXh0SW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XG4gIHZhciBzaXplID0gc29ydGVkQXJyYXkubGVuZ3RoO1xuXG4gIGlmIChzaXplID4gMCkge1xuICAgIHZhciBmaXJzdFZhbCA9IHNvcnRlZEFycmF5WzBdO1xuICAgIHZhciBsYXN0VmFsID0gc29ydGVkQXJyYXlbc2l6ZSAtIDFdO1xuXG4gICAgaWYgKHZhbHVlIDw9IGZpcnN0VmFsKVxuICAgICAgaW5kZXggPSAwO1xuICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXG4gICAgICBpbmRleCA9IHNpemU7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNpemUpXG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoc2l6ZSAtIDEpICogKHZhbHVlIC0gZmlyc3RWYWwpIC8gKGxhc3RWYWwgLSBmaXJzdFZhbCkpO1xuXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXhdIDwgdmFsdWUpXG4gICAgICAgIGluZGV4Kys7XG5cbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleCAtIDFdID49IHZhbHVlKVxuICAgICAgICBpbmRleC0tO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cblxuLyoqXG4gKiBVc2VkIHdpdGggYSBidWZmZXIgdG8gc2VydmUgYXVkaW8gZmlsZXMgdmlhIGdyYW51bGFyIHN5bnRoZXNpcy5cbiAqXG4gKiBUaGUgZW5naW5lIGltcGxlbWVudHMgdGhlIFwic2NoZWR1bGVkXCIgYW5kIFwidHJhbnNwb3J0ZWRcIiBpbnRlcmZhY2VzLlxuICogV2hlbiBcInNjaGVkdWxlZFwiLCB0aGUgZW5naW5lICBnZW5lcmF0ZXMgc2VnbWVudHMgbW9yZSBvciBsZXNzwqBwZXJpb2RpY2FsbHlcbiAqIChjb250cm9sbGVkIGJ5IHRoZSBwZXJpb2RBYnMsIHBlcmlvZFJlbCwgYW5kIHBlcmlvVmFyIGF0dHJpYnV0ZXMpLlxuICogV2hlbiBcInRyYW5zcG9ydGVkXCIsIHRoZSBlbmdpbmUgZ2VuZXJhdGVzIHNlZ21lbnRzIGF0IHRoZSBwb3NpdGlvbiBvZiB0aGVpciBvbnNldCB0aW1lLlxuICpcbiAqIEV4YW1wbGUgdGhhdCBzaG93cyBhIGBTZWdtZW50RW5naW5lYCB3aXRoIGEgZmV3IHBhcmFtZXRlciBjb250cm9scyBydW5uaW5nIGluIGEgYFNjaGVkdWxlcmAuXG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3NlZ21lbnQtZW5naW5lLmh0bWx9XG4gKlxuICogQGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XG4gKiBjb25zdCBzZWdtZW50RW5naW5lID0gbmV3IGF1ZGlvLlNlZ21lbnRFbmdpbmUoKTtcbiAqXG4gKiBzY2hlZHVsZXIuYWRkKHNlZ21lbnRFbmdpbmUpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBEZWZhdWx0IG9wdGlvbnNcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IFtvcHRpb25zLmJ1ZmZlcj1udWxsXSAtIEF1ZGlvIGJ1ZmZlclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZEFicz0wXSAtIEFic29sdXRlIHNlZ21lbnQgcGVyaW9kIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZFJlbD0xXSAtIFNlZ21lbnQgcGVyaW9kIHJlbGF0aXZlIHRvIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlXG4gKiAgdG8gc2VnbWVudCBwZXJpb2RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RNaW49MC4wMDFdIC0gTWluaW11bSBzZWdtZW50IHBlcmlvZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvc2l0aW9uQXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBwb3NpdGlvbnMgKG9uc2V0IHRpbWVzXG4gKiAgaW4gYXVkaW8gYnVmZmVyKSBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3NpdGlvblZhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBvc2l0aW9uIHZhcmlhdGlvbiBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFycmF5PVswLjBdXSAtIEFycmF5IG9mIHNlZ21lbnQgZHVyYXRpb25zIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uQWJzPTBdIC0gQWJzb2x1dGUgc2VnbWVudCBkdXJhdGlvbiBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvblJlbD0xXSAtIFNlZ21lbnQgZHVyYXRpb24gcmVsYXRpdmUgdG8gZ2l2ZW4gc2VnbWVudFxuICogIGR1cmF0aW9uIG9yIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm9mZnNldEFycmF5PVswLjBdXSAtIEFycmF5IG9mIHNlZ21lbnQgb2Zmc2V0cyBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRBYnM9LTAuMDA1XSAtIEFic29sdXRlIHNlZ21lbnQgb2Zmc2V0IGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFJlbD0wXSAtIFNlZ21lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kZWxheT0wLjAwNV0gLSBUaW1lIGJ5IHdoaWNoIGFsbCBzZWdtZW50cyBhcmUgZGVsYXllZCAoZXNwZWNpYWxseVxuICogIHRvIHJlYWxpemUgc2VnbWVudCBvZmZzZXRzKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja0Ficz0wLjAwNV0gLSBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hdHRhY2tSZWw9MF0gLSBBdHRhY2sgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVsZWFzZUFicz0wLjAwNV0gLSBBYnNvbHV0ZSByZWxlYXNlIHRpbWUgaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVsZWFzZVJlbD0wXSAtIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZz0wXSAtIFNlZ21lbnQgcmVzYW1wbGluZyBpbiBjZW50XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZ1Zhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ2Fpbj0xXSAtIExpbmVhciBnYWluIGZhY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFib3J0VGltZT0wLjAwNV0gLSBmYWRlLW91dCB0aW1lIHdoZW4gYWJvcnRlZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNlZ21lbnRJbmRleD0wXSAtIEluZGV4IG9mIHRoZSBzZWdtZW50IHRvIHN5bnRoZXNpemUgKGkuZS4gb2ZcbiAqICB0aGlzLnBvc2l0aW9uQXJyYXkvZHVyYXRpb25BcnJheS9vZmZzZXRBcnJheSlcbiAqIEBwYXJhbSB7Qm9vbH0gW29wdGlvbnMuY3ljbGljPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGF1ZGlvIGJ1ZmZlciBhbmQgc2VnbWVudCBpbmRpY2VzIGFyZVxuICogIGNvbnNpZGVyZWQgYXMgY3ljbGljXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbj0wXSAtIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gYnVmZmVyXG4gKiAgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIGFzc3VyZSBjeWNsaWMgYmVoYXZpb3JcbiAqL1xuY2xhc3MgU2VnbWVudEVuZ2luZSBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcblxuICAgIC8qKlxuICAgICAqIEF1ZGlvIGJ1ZmZlclxuICAgICAqIEBuYW1lIGJ1ZmZlclxuICAgICAqIEB0eXBlIHtBdWRpb0J1ZmZlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlciA9IG9wdE9yRGVmKG9wdGlvbnMuYnVmZmVyLCBudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIHNlZ21lbnQgcGVyaW9kIGluIHNlY1xuICAgICAqIEBuYW1lIHBlcmlvZEFic1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wZXJpb2RBYnMgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZEFicywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBTZWdtZW50IHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlci1zZWdtZW50IGRpc3RhbmNlXG4gICAgICogQG5hbWUgcGVyaW9kUmVsXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBlcmlvZFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kUmVsLCAxKTtcblxuICAgIC8qKlxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBlcmlvZCB2YXJpYXRpb24gcmVsYXRpdmUgdG8gc2VnbWVudCBwZXJpb2RcbiAgICAgKiBAbmFtZSBwZXJpb2RWYXJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucGVyaW9kVmFyID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RWYXIsIDApO1xuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBzZWdtZW50IHBlcmlvZFxuICAgICAqIEBuYW1lIHBlcmlvZE1pblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4wMDFcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucGVyaW9kTWluID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RNaW4sIDAuMDAxKTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgcG9zaXRpb25zIChvbnNldCB0aW1lcyBpbiBhdWRpbyBidWZmZXIpIGluIHNlY1xuICAgICAqIEBuYW1lIHBvc2l0aW9uQXJyYXlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFswLjBdXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uQXJyYXkgPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uQXJyYXksIFswLjBdKTtcblxuICAgIC8qKlxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBvc2l0aW9uIHZhcmlhdGlvbiBpbiBzZWNcbiAgICAgKiBAbmFtZSBwb3NpdGlvblZhclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvblZhciA9IG9wdE9yRGVmKG9wdGlvbnMucG9zaXRpb25WYXIsIDApO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2Ygc2VnbWVudCBkdXJhdGlvbnMgaW4gc2VjXG4gICAgICogQG5hbWUgZHVyYXRpb25BcnJheVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgWzAuMF1cbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25BcnJheSA9IG9wdE9yRGVmKG9wdGlvbnMuZHVyYXRpb25BcnJheSwgWzAuMF0pO1xuXG4gICAgLyoqXG4gICAgICogQWJzb2x1dGUgc2VnbWVudCBkdXJhdGlvbiBpbiBzZWNcbiAgICAgKiBAbmFtZSBkdXJhdGlvbkFic1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbkFicyA9IG9wdE9yRGVmKG9wdGlvbnMuZHVyYXRpb25BYnMsIDApO1xuXG4gICAgLyoqXG4gICAgICogU2VnbWVudCBkdXJhdGlvbiByZWxhdGl2ZSB0byBnaXZlbiBzZWdtZW50IGR1cmF0aW9uIG9yIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcbiAgICAgKiBAbmFtZSBkdXJhdGlvblJlbFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvblJlbCA9IG9wdE9yRGVmKG9wdGlvbnMuZHVyYXRpb25SZWwsIDEpO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2Ygc2VnbWVudCBvZmZzZXRzIGluIHNlY1xuICAgICAqXG4gICAgICogb2Zmc2V0ID4gMDogdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb25cbiAgICAgKiBvZmZzZXQgPCAwOiB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvbiBpcyB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvblxuICAgICAqIGFuZCB0aGUgZHVyYXRpb24gaGFzIHRvIGJlIGNvcnJlY3RlZCBieSB0aGUgb2Zmc2V0XG4gICAgICpcbiAgICAgKiBAbmFtZSBvZmZzZXRBcnJheVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAZGVmYXVsdCBbMC4wXVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRBcnJheSA9IG9wdE9yRGVmKG9wdGlvbnMub2Zmc2V0QXJyYXksIFswLjBdKTtcblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIHNlZ21lbnQgb2Zmc2V0IGluIHNlY1xuICAgICAqIEBuYW1lIG9mZnNldEFic1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTAuMDA1XG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldEFicyA9IG9wdE9yRGVmKG9wdGlvbnMub2Zmc2V0QWJzLCAtMC4wMDUpO1xuXG4gICAgLyoqXG4gICAgICogU2VnbWVudCBvZmZzZXQgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxuICAgICAqIEBuYW1lIG9mZnNldFJlbFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRSZWwgPSBvcHRPckRlZihvcHRpb25zLm9mZnNldFJlbCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaW1lIGJ5IHdoaWNoIGFsbCBzZWdtZW50cyBhcmUgZGVsYXllZCAoZXNwZWNpYWxseSB0byByZWFsaXplIHNlZ21lbnQgb2Zmc2V0cylcbiAgICAgKiBAbmFtZSBkZWxheVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4wMDVcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuZGVsYXkgPSBvcHRPckRlZihvcHRpb25zLmRlbGF5LCAwLjAwNSk7XG5cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcbiAgICAgKiBAbmFtZSBhdHRhY2tBYnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMDA1XG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmF0dGFja0FicyA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrQWJzLCAwLjAwNSk7XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2sgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXG4gICAgICogQG5hbWUgYXR0YWNrUmVsXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmF0dGFja1JlbCA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrUmVsLCAwKTtcblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcbiAgICAgKiBAbmFtZSByZWxlYXNlQWJzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5yZWxlYXNlQWJzID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlQWJzLCAwLjAwNSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRpbWUgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxuICAgICAqIEBuYW1lIHJlbGVhc2VSZWxcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucmVsZWFzZVJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZVJlbCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBTZWdtZW50IHJlc2FtcGxpbmcgaW4gY2VudFxuICAgICAqIEBuYW1lIHJlc2FtcGxpbmdcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucmVzYW1wbGluZyA9IG9wdE9yRGVmKG9wdGlvbnMucmVzYW1wbGluZywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbW91dCBvZiByYW5kb20gcmVzYW1wbGluZyB2YXJpYXRpb24gaW4gY2VudFxuICAgICAqIEBuYW1lIHJlc2FtcGxpbmdWYXJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucmVzYW1wbGluZ1ZhciA9IG9wdE9yRGVmKG9wdGlvbnMucmVzYW1wbGluZ1ZhciwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBMaW5lYXIgZ2FpbiBmYWN0b3JcbiAgICAgKiBAbmFtZSBnYWluXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmdhaW4gPSBvcHRPckRlZihvcHRpb25zLmdhaW4sIDEpO1xuXG4gICAgLyoqXG4gICAgICogSW5kZXggb2YgdGhlIHNlZ21lbnQgdG8gc3ludGhlc2l6ZSAoaS5lLiBvZiB0aGlzLnBvc2l0aW9uQXJyYXkvZHVyYXRpb25BcnJheS9vZmZzZXRBcnJheSlcbiAgICAgKiBAbmFtZSBzZWdtZW50SW5kZXhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuc2VnbWVudEluZGV4ID0gb3B0T3JEZWYob3B0aW9ucy5zZWdtZW50SW5kZXgsIDApO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYXVkaW8gYnVmZmVyIGFuZCBzZWdtZW50IGluZGljZXMgYXJlIGNvbnNpZGVyZWQgYXMgY3ljbGljXG4gICAgICogQG5hbWUgY3ljbGljXG4gICAgICogQHR5cGUge0Jvb2x9XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuY3ljbGljID0gb3B0T3JEZWYob3B0aW9ucy5jeWNsaWMsIGZhbHNlKTtcbiAgICB0aGlzLl9fY3ljbGljT2Zmc2V0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGxhc3Qgc2VnbWVudCBpcyBhYm9ydGVkIHdoZW4gdHJpZ2dlcmluZyB0aGUgbmV4dFxuICAgICAqIEBuYW1lIG1vbm9waG9uaWNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLm1vbm9waG9uaWMgPSBvcHRPckRlZihvcHRpb25zLm1vbm9waG9uaWMsIGZhbHNlKTtcbiAgICB0aGlzLl9fY3VycmVudFNyYyA9IG51bGw7XG4gICAgdGhpcy5fX2N1cnJlbnRFbnYgPSBudWxsO1xuICAgIHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLl9fY3VycmVudEdhaW4gPSAwO1xuICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBGYWRlLW91dCB0aW1lICh3aGVuIGFib3J0ZWQpXG4gICAgICogQG5hbWUgYWJvcnRUaW1lXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5hYm9ydFRpbWUgPSBvcHRPckRlZihvcHRpb25zLmFib3J0VGltZSwgMC4wMDUpO1xuXG4gICAgLyoqXG4gICAgICogUG9ydGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBidWZmZXIgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIGFzc3VyZSBjeWNsaWMgYmVoYXZpb3JcbiAgICAgKiBAbmFtZSB3cmFwQXJvdW5kRXh0ZW5zaW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLndyYXBBcm91bmRFeHRlbnNpb24gPSBvcHRPckRlZihvcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb24sIDApO1xuXG4gICAgdGhpcy5vdXRwdXROb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBidWZmZXIgZHVyYXRpb24gKGV4Y2x1ZGluZyB3cmFwQXJvdW5kRXh0ZW5zaW9uKVxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IGJ1ZmZlckR1cmF0aW9uKCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb247XG5cbiAgICAgIGlmICh0aGlzLndyYXBBcm91bmRFeHRlbnNpb24pXG4gICAgICAgIGJ1ZmZlckR1cmF0aW9uIC09IHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbjtcblxuICAgICAgcmV0dXJuIGJ1ZmZlckR1cmF0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcbiAgYWR2YW5jZVRpbWUodGltZSkge1xuICAgIHRpbWUgPSBNYXRoLm1heCh0aW1lLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgcmV0dXJuIHRpbWUgKyB0aGlzLnRyaWdnZXIodGltZSk7XG4gIH1cblxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAodHJhbnNwb3J0ZWQgaW50ZXJmYWNlKVxuICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXg7XG4gICAgdmFyIGN5Y2xpY09mZnNldCA9IDA7XG4gICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXJEdXJhdGlvbjtcblxuICAgIGlmICh0aGlzLmN5Y2xpYykge1xuICAgICAgdmFyIGN5Y2xlcyA9IHBvc2l0aW9uIC8gYnVmZmVyRHVyYXRpb247XG5cbiAgICAgIGN5Y2xpY09mZnNldCA9IE1hdGguZmxvb3IoY3ljbGVzKSAqIGJ1ZmZlckR1cmF0aW9uO1xuICAgICAgcG9zaXRpb24gLT0gY3ljbGljT2Zmc2V0O1xuICAgIH1cblxuICAgIGlmIChzcGVlZCA+IDApIHtcbiAgICAgIGluZGV4ID0gZ2V0Q3VycmVudE9yTmV4dEluZGV4KHRoaXMucG9zaXRpb25BcnJheSwgcG9zaXRpb24pO1xuXG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGN5Y2xpY09mZnNldCArPSBidWZmZXJEdXJhdGlvbjtcblxuICAgICAgICBpZiAoIXRoaXMuY3ljbGljKVxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNwZWVkIDwgMCkge1xuICAgICAgaW5kZXggPSBnZXRDdXJyZW50T3JQcmV2aW91c0luZGV4KHRoaXMucG9zaXRpb25BcnJheSwgcG9zaXRpb24pO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGN5Y2xpY09mZnNldCAtPSBidWZmZXJEdXJhdGlvbjtcblxuICAgICAgICBpZiAoIXRoaXMuY3ljbGljKVxuICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG5cbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX19jeWNsaWNPZmZzZXQgPSBjeWNsaWNPZmZzZXQ7XG5cbiAgICByZXR1cm4gY3ljbGljT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbkFycmF5W2luZGV4XTtcbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXG4gIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleDtcbiAgICB2YXIgY3ljbGljT2Zmc2V0ID0gdGhpcy5fX2N5Y2xpY09mZnNldDtcblxuICAgIHRoaXMudHJpZ2dlcih0aW1lKTtcblxuICAgIGlmIChzcGVlZCA+IDApIHtcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGlmIChpbmRleCA+PSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgY3ljbGljT2Zmc2V0ICs9IHRoaXMuYnVmZmVyRHVyYXRpb247XG5cbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4LS07XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoIC0gMTtcbiAgICAgICAgY3ljbGljT2Zmc2V0IC09IHRoaXMuYnVmZmVyRHVyYXRpb247XG5cbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcbiAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2VnbWVudEluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IGN5Y2xpY09mZnNldDtcblxuICAgIHJldHVybiBjeWNsaWNPZmZzZXQgKyB0aGlzLnBvc2l0aW9uQXJyYXlbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSBzZWdtZW50LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgYXQgYW55IHRpbWUgKHdoZXRoZXIgdGhlIGVuZ2luZSBpcyBzY2hlZHVsZWQvdHJhbnNwb3J0ZWQgb3Igbm90KVxuICAgKiB0byBnZW5lcmF0ZSBhIHNpbmdsZSBzZWdtZW50IGFjY29yZGluZyB0byB0aGUgY3VycmVudCBzZWdtZW50IHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIHNlZ21lbnQgc3ludGhlc2lzIGF1ZGlvIHRpbWVcbiAgICogQHJldHVybiB7TnVtYmVyfSBwZXJpb2QgdG8gbmV4dCBzZWdtZW50XG4gICAqL1xuICB0cmlnZ2VyKHRpbWUpIHtcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XG4gICAgdmFyIHNlZ21lbnRUaW1lID0gKHRpbWUgfHwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKSArIHRoaXMuZGVsYXk7XG4gICAgdmFyIHNlZ21lbnRQZXJpb2QgPSB0aGlzLnBlcmlvZEFicztcbiAgICB2YXIgc2VnbWVudEluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXg7XG5cbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHZhciBzZWdtZW50UG9zaXRpb24gPSAwLjA7XG4gICAgICB2YXIgc2VnbWVudER1cmF0aW9uID0gMC4wO1xuICAgICAgdmFyIHNlZ21lbnRPZmZzZXQgPSAwLjA7XG4gICAgICB2YXIgcmVzYW1wbGluZ1JhdGUgPSAxLjA7XG4gICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xuXG4gICAgICBpZiAodGhpcy5jeWNsaWMpXG4gICAgICAgIHNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleCAlIHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGg7XG4gICAgICBlbHNlXG4gICAgICAgIHNlZ21lbnRJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNlZ21lbnRJbmRleCwgdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCAtIDEpKTtcblxuICAgICAgaWYgKHRoaXMucG9zaXRpb25BcnJheSlcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcblxuICAgICAgaWYgKHRoaXMuZHVyYXRpb25BcnJheSlcbiAgICAgICAgc2VnbWVudER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbkFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcblxuICAgICAgaWYgKHRoaXMub2Zmc2V0QXJyYXkpXG4gICAgICAgIHNlZ21lbnRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcblxuICAgICAgLy8gY2FsY3VsYXRlIHJlc2FtcGxpbmdcbiAgICAgIGlmICh0aGlzLnJlc2FtcGxpbmcgIT09IDAgfHwgdGhpcy5yZXNhbXBsaW5nVmFyID4gMCkge1xuICAgICAgICB2YXIgcmFuZG9tUmVzYW1wbGluZyA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIuMCAqIHRoaXMucmVzYW1wbGluZ1ZhcjtcbiAgICAgICAgcmVzYW1wbGluZ1JhdGUgPSBNYXRoLnBvdygyLjAsICh0aGlzLnJlc2FtcGxpbmcgKyByYW5kb21SZXNhbXBsaW5nKSAvIDEyMDAuMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBpbnRlci1zZWdtZW50IGRpc3RhbmNlXG4gICAgICBpZiAoc2VnbWVudER1cmF0aW9uID09PSAwIHx8IHRoaXMucGVyaW9kUmVsID4gMCkge1xuICAgICAgICB2YXIgbmV4dFNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleCArIDE7XG4gICAgICAgIHZhciBuZXh0UG9zaXRpb24sIG5leHRPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG5leHRTZWdtZW50SW5kZXggPT09IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAodGhpcy5jeWNsaWMpIHtcbiAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVswXSArIGJ1ZmZlckR1cmF0aW9uO1xuICAgICAgICAgICAgbmV4dE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IGJ1ZmZlckR1cmF0aW9uO1xuICAgICAgICAgICAgbmV4dE9mZnNldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVtuZXh0U2VnbWVudEluZGV4XTtcbiAgICAgICAgICBuZXh0T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVtuZXh0U2VnbWVudEluZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnRlclNlZ21lbnREaXN0YW5jZSA9IG5leHRQb3NpdGlvbiAtIHNlZ21lbnRQb3NpdGlvbjtcblxuICAgICAgICAvLyBjb3JyZWN0IGludGVyLXNlZ21lbnQgZGlzdGFuY2UgYnkgb2Zmc2V0c1xuICAgICAgICAvLyAgIG9mZnNldCA+IDA6IHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGlzIGFmdGVyIHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uXG4gICAgICAgIGlmIChzZWdtZW50T2Zmc2V0ID4gMClcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSAtPSBzZWdtZW50T2Zmc2V0O1xuXG4gICAgICAgIGlmIChuZXh0T2Zmc2V0ID4gMClcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSArPSBuZXh0T2Zmc2V0O1xuXG4gICAgICAgIGlmIChpbnRlclNlZ21lbnREaXN0YW5jZSA8IDApXG4gICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgPSAwO1xuXG4gICAgICAgIC8vIHVzZSBpbnRlci1zZWdtZW50IGRpc3RhbmNlIGluc3RlYWQgb2Ygc2VnbWVudCBkdXJhdGlvblxuICAgICAgICBpZiAoc2VnbWVudER1cmF0aW9uID09PSAwKVxuICAgICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IGludGVyU2VnbWVudERpc3RhbmNlO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwZXJpb2QgcmVsYXRpdmUgdG8gaW50ZXIgbWFya2VyIGRpc3RhbmNlXG4gICAgICAgIHNlZ21lbnRQZXJpb2QgKz0gdGhpcy5wZXJpb2RSZWwgKiBpbnRlclNlZ21lbnREaXN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uXG4gICAgICBzZWdtZW50RHVyYXRpb24gKj0gdGhpcy5kdXJhdGlvblJlbDtcbiAgICAgIHNlZ21lbnREdXJhdGlvbiArPSB0aGlzLmR1cmF0aW9uQWJzO1xuXG4gICAgICAvLyBhZGQgcmVsYXRpdmUgYW5kIGFic29sdXRlIHNlZ21lbnQgb2Zmc2V0XG4gICAgICBzZWdtZW50T2Zmc2V0ICo9IHRoaXMub2Zmc2V0UmVsO1xuICAgICAgc2VnbWVudE9mZnNldCArPSB0aGlzLm9mZnNldEFicztcblxuICAgICAgLy8gYXBwbHkgc2VnbWVudCBvZmZzZXRcbiAgICAgIC8vICAgb2Zmc2V0ID4gMDogdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb25cbiAgICAgIC8vICAgb2Zmc2V0IDwgMDogdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb24gaXMgdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gYW5kIHRoZSBkdXJhdGlvbiBoYXMgdG8gYmUgY29ycmVjdGVkIGJ5IHRoZSBvZmZzZXRcbiAgICAgIGlmIChzZWdtZW50T2Zmc2V0IDwgMCkge1xuICAgICAgICBzZWdtZW50RHVyYXRpb24gLT0gc2VnbWVudE9mZnNldDtcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IHNlZ21lbnRPZmZzZXQ7XG4gICAgICAgIHNlZ21lbnRUaW1lICs9IChzZWdtZW50T2Zmc2V0IC8gcmVzYW1wbGluZ1JhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VnbWVudFRpbWUgLT0gKHNlZ21lbnRPZmZzZXQgLyByZXNhbXBsaW5nUmF0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJhbmRvbWl6ZSBzZWdtZW50IHBvc2l0aW9uXG4gICAgICBpZiAodGhpcy5wb3NpdGlvblZhciA+IDApXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiArPSAyLjAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLnBvc2l0aW9uVmFyO1xuXG4gICAgICAvLyBzaG9ydGVuIGR1cmF0aW9uIG9mIHNlZ21lbnRzIG92ZXIgdGhlIGVkZ2VzIG9mIHRoZSBidWZmZXJcbiAgICAgIGlmIChzZWdtZW50UG9zaXRpb24gPCAwKSB7XG4gICAgICAgIC8vc2VnbWVudFRpbWUgLT0gZ3JhaW5Qb3NpdGlvbjsgaG0sIG5vdCBzdXJlIGlmIHdlIHdhbnQgdG8gZG8gdGhpc1xuICAgICAgICBzZWdtZW50RHVyYXRpb24gKz0gc2VnbWVudFBvc2l0aW9uO1xuICAgICAgICBzZWdtZW50UG9zaXRpb24gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VnbWVudFBvc2l0aW9uICsgc2VnbWVudER1cmF0aW9uID4gdGhpcy5idWZmZXIuZHVyYXRpb24pXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uIC0gc2VnbWVudFBvc2l0aW9uO1xuXG4gICAgICBzZWdtZW50RHVyYXRpb24gLz0gcmVzYW1wbGluZ1JhdGU7XG5cbiAgICAgIGlmICh0aGlzLm1vbm9waG9uaWMpXG4gICAgICAgIHRoaXMuYWJvcnQoc2VnbWVudFRpbWUpO1xuXG4gICAgICAvLyBtYWtlIHNlZ21lbnRcbiAgICAgIGlmICh0aGlzLmdhaW4gPiAwICYmIHNlZ21lbnREdXJhdGlvbiA+IDApIHtcbiAgICAgICAgLy8gbWFrZSBzZWdtZW50IGVudmVsb3BlXG4gICAgICAgIHZhciBlbnZlbG9wZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgIHZhciBhdHRhY2sgPSB0aGlzLmF0dGFja0FicyArIHRoaXMuYXR0YWNrUmVsICogc2VnbWVudER1cmF0aW9uO1xuICAgICAgICB2YXIgcmVsZWFzZSA9IHRoaXMucmVsZWFzZUFicyArIHRoaXMucmVsZWFzZVJlbCAqIHNlZ21lbnREdXJhdGlvbjtcblxuICAgICAgICBpZiAoYXR0YWNrICsgcmVsZWFzZSA+IHNlZ21lbnREdXJhdGlvbikge1xuICAgICAgICAgIHZhciBmYWN0b3IgPSBzZWdtZW50RHVyYXRpb24gLyAoYXR0YWNrICsgcmVsZWFzZSk7XG4gICAgICAgICAgYXR0YWNrICo9IGZhY3RvcjtcbiAgICAgICAgICByZWxlYXNlICo9IGZhY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRhY2tFbmRUaW1lID0gc2VnbWVudFRpbWUgKyBhdHRhY2s7XG4gICAgICAgIHZhciBzZWdtZW50RW5kVGltZSA9IHNlZ21lbnRUaW1lICsgc2VnbWVudER1cmF0aW9uO1xuICAgICAgICB2YXIgcmVsZWFzZVN0YXJ0VGltZSA9IHNlZ21lbnRFbmRUaW1lIC0gcmVsZWFzZTtcblxuICAgICAgICBlbnZlbG9wZS5nYWluLnZhbHVlID0gMDtcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLjAsIHNlZ21lbnRUaW1lKTtcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmdhaW4sIGF0dGFja0VuZFRpbWUpO1xuXG4gICAgICAgIGlmIChyZWxlYXNlU3RhcnRUaW1lID4gYXR0YWNrRW5kVGltZSlcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgcmVsZWFzZVN0YXJ0VGltZSk7XG5cbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLjAsIHNlZ21lbnRFbmRUaW1lKTtcbiAgICAgICAgZW52ZWxvcGUuY29ubmVjdCh0aGlzLm91dHB1dE5vZGUpO1xuXG4gICAgICAgIHRoaXMuX19jdXJyZW50RW52ID0gZW52ZWxvcGU7XG5cbiAgICAgICAgLy8gbWFrZSBzb3VyY2VcbiAgICAgICAgdmFyIHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblxuICAgICAgICBzb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSByZXNhbXBsaW5nUmF0ZTtcbiAgICAgICAgc291cmNlLmNvbm5lY3QoZW52ZWxvcGUpO1xuXG4gICAgICAgIHNvdXJjZS5zdGFydChzZWdtZW50VGltZSwgc2VnbWVudFBvc2l0aW9uKTtcbiAgICAgICAgc291cmNlLnN0b3Aoc2VnbWVudFRpbWUgKyBzZWdtZW50RHVyYXRpb24pO1xuXG4gICAgICAgIHRoaXMuX19jdXJyZW50U3JjID0gc291cmNlO1xuICAgICAgICB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSA9IHJlbGVhc2VTdGFydFRpbWU7XG4gICAgICAgIHRoaXMuX19jdXJyZW50R2FpbiA9IHRoaXMuZ2FpbjtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbmRUaW1lID0gc2VnbWVudEVuZFRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ3JhaW4gcGVyaW9kIHJhbmRvbiB2YXJpYXRpb25cbiAgICBpZiAodGhpcy5wZXJpb2RWYXIgPiAwLjApXG4gICAgICBzZWdtZW50UGVyaW9kICs9IDIuMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMucGVyaW9kVmFyICogZ3JhaW5QZXJpb2Q7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5wZXJpb2RNaW4sIHNlZ21lbnRQZXJpb2QpO1xuICB9XG5cbiAgYWJvcnQodGltZSkge1xuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xuICAgIGNvbnN0IGVuZFRpbWUgPSB0aGlzLl9fY3VycmVudEVuZFRpbWU7XG4gICAgY29uc3QgYWJvcnRUaW1lID0gdGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XG5cbiAgICBpZiAoYWJvcnRUaW1lIDwgZW5kVGltZSkge1xuICAgICAgY29uc3Qgc2VnbWVudEVuZFRpbWUgPSBNYXRoLm1pbihhYm9ydFRpbWUgKyB0aGlzLmFib3J0VGltZSwgZW5kVGltZSk7XG4gICAgICBjb25zdCBlbnZlbG9wZSA9IHRoaXMuX19jdXJyZW50RW52O1xuICAgICAgbGV0IGN1cnJlbnRHYWluVmFsdWUgPSB0aGlzLl9fY3VycmVudEdhaW47XG5cbiAgICAgIGlmIChhYm9ydFRpbWUgPiB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSkge1xuICAgICAgICBjb25zdCByZWxlYXNlU3RhcnQgPSB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZTtcbiAgICAgICAgY3VycmVudEdhaW5WYWx1ZSAqPSAoYWJvcnRUaW1lIC0gcmVsZWFzZVN0YXJ0KSAvIChlbmRUaW1lIC0gcmVsZWFzZVN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgZW52ZWxvcGUuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoYWJvcnRUaW1lKTtcbiAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUoY3VycmVudEdhaW5WYWx1ZSwgYWJvcnRUaW1lKTtcbiAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgc2VnbWVudEVuZFRpbWUpO1xuXG4gICAgICB0aGlzLl9fY3VycmVudFNyYyA9IG51bGw7XG4gICAgICB0aGlzLl9fY3VycmVudEVudiA9IG51bGw7XG4gICAgICB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSA9IDA7XG4gICAgICB0aGlzLl9fY3VycmVudEdhaW4gPSAwO1xuICAgICAgdGhpcy5fX2N1cnJlbnRFbmRUaW1lID0gMDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VnbWVudEVuZ2luZTtcbiIsIi8vIGNvcmVcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXVkaW9Db250ZXh0IH0gZnJvbSAnLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUaW1lRW5naW5lIH0gZnJvbSAnLi9jb3JlL3RpbWUtZW5naW5lJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXVkaW9UaW1lRW5naW5lIH0gZnJvbSAnLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHJpb3JpdHlRdWV1ZSB9IGZyb20gJy4vY29yZS9wcmlvcml0eS1xdWV1ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNjaGVkdWxpbmdRdWV1ZSB9IGZyb20gJy4vY29yZS9zY2hlZHVsaW5nLXF1ZXVlJztcblxuLy8gZW5naW5lc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcmFudWxhckVuZ2luZSB9IGZyb20gJy4vZW5naW5lcy9ncmFudWxhci1lbmdpbmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNZXRyb25vbWUgfSBmcm9tICcuL2VuZ2luZXMvbWV0cm9ub21lJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGxheWVyRW5naW5lIH0gZnJvbSAnLi9lbmdpbmVzL3BsYXllci1lbmdpbmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWdtZW50RW5naW5lIH0gZnJvbSAnLi9lbmdpbmVzL3NlZ21lbnQtZW5naW5lJztcblxuLy8gbWFzdGVyc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQbGF5Q29udHJvbCB9IGZyb20gJy4vbWFzdGVycy9wbGF5LWNvbnRyb2wnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUcmFuc3BvcnQgfSBmcm9tICcuL21hc3RlcnMvdHJhbnNwb3J0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2NoZWR1bGVyIH0gZnJvbSAnLi9tYXN0ZXJzL3NjaGVkdWxlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpbXBsZVNjaGVkdWxlciB9IGZyb20gJy4vbWFzdGVycy9zaW1wbGUtc2NoZWR1bGVyJztcblxuLy8gZmFjdG9yaWVzXG5leHBvcnQgeyBnZXRTY2hlZHVsZXIgfSBmcm9tICcuL21hc3RlcnMvZmFjdG9yaWVzJztcbmV4cG9ydCB7IGdldFNpbXBsZVNjaGVkdWxlciB9IGZyb20gJy4vbWFzdGVycy9mYWN0b3JpZXMnO1xuIiwiLy8gc2NoZWR1bGVycyBzaG91bGQgYmUgc2luZ2xldG9uc1xuaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi4vY29yZS9hdWRpby1jb250ZXh0JztcbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnLi9zY2hlZHVsZXInO1xuaW1wb3J0IFNpbXBsZVNjaGVkdWxlciBmcm9tICcuL3NpbXBsZS1zY2hlZHVsZXInO1xuXG5jb25zdCBzY2hlZHVsZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2ltcGxlU2NoZWR1bGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgdW5pcXVlIGluc3RhbmNlIG9mIGBTY2hlZHVsZXJgXG4gKlxuICogQGdsb2JhbFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7U2NoZWR1bGVyfVxuICogQHNlZSBTY2hlZHVsZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNjaGVkdWxlciA9IGZ1bmN0aW9uKGF1ZGlvQ29udGV4dCA9IGRlZmF1bHRBdWRpb0NvbnRleHQpIHtcbiAgbGV0IHNjaGVkdWxlciA9IHNjaGVkdWxlck1hcC5nZXQoYXVkaW9Db250ZXh0KTtcblxuICBpZiAoIXNjaGVkdWxlcikge1xuICAgIHNjaGVkdWxlciA9IG5ldyBTY2hlZHVsZXIoeyBhdWRpb0NvbnRleHQ6IGF1ZGlvQ29udGV4dCB9KTtcbiAgICBzY2hlZHVsZXJNYXAuc2V0KGF1ZGlvQ29udGV4dCwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIHJldHVybiBzY2hlZHVsZXI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSB1bmlxdWUgaW5zdGFuY2Ugb2YgYFNpbXBsZVNjaGVkdWxlcmBcbiAqXG4gKiBAZ2xvYmFsXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtTaW1wbGVTY2hlZHVsZXJ9XG4gKiBAc2VlIFNpbXBsZVNjaGVkdWxlclxuICovXG5leHBvcnQgY29uc3QgZ2V0U2ltcGxlU2NoZWR1bGVyID0gZnVuY3Rpb24oYXVkaW9Db250ZXh0ID0gZGVmYXVsdEF1ZGlvQ29udGV4dCkge1xuICBsZXQgc2ltcGxlU2NoZWR1bGVyID0gc2ltcGxlU2NoZWR1bGVyTWFwLmdldChhdWRpb0NvbnRleHQpO1xuXG4gIGlmICghc2ltcGxlU2NoZWR1bGVyKSB7XG4gICAgc2ltcGxlU2NoZWR1bGVyID0gbmV3IFNpbXBsZVNjaGVkdWxlcih7IGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0IH0pO1xuICAgIHNpbXBsZVNjaGVkdWxlck1hcC5zZXQoYXVkaW9Db250ZXh0LCBzaW1wbGVTY2hlZHVsZXIpO1xuICB9XG5cbiAgcmV0dXJuIHNpbXBsZVNjaGVkdWxlcjtcbn07XG4iLCJpbXBvcnQgZGVmYXVsdEF1ZGlvQ29udGV4dCBmcm9tICcuLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xuaW1wb3J0IFNjaGVkdWxpbmdRdWV1ZSBmcm9tICcuLi9jb3JlL3NjaGVkdWxpbmctcXVldWUnO1xuaW1wb3J0IFRpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS90aW1lLWVuZ2luZSc7XG5pbXBvcnQgeyBnZXRTY2hlZHVsZXIgfSBmcm9tICcuL2ZhY3Rvcmllcyc7XG5cbmNvbnN0IEVQU0lMT04gPSAxZS04O1xuXG5jbGFzcyBMb29wQ29udHJvbCBleHRlbmRzIFRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBwbGF5Q29udHJvbDtcbiAgICB0aGlzLnNwZWVkID0gMTtcbiAgICB0aGlzLmxvd2VyID0gLUluZmluaXR5O1xuICAgIHRoaXMudXBwZXIgPSBJbmZpbml0eTtcbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzY2hlZHVsZWQgaW50ZXJmYWNlKVxuICBhZHZhbmNlVGltZSh0aW1lKSB7XG4gICAgY29uc3QgcGxheUNvbnRyb2wgPSB0aGlzLl9fcGxheUNvbnRyb2w7XG4gICAgY29uc3Qgc3BlZWQgPSB0aGlzLnNwZWVkO1xuICAgIGNvbnN0IGxvd2VyID0gdGhpcy5sb3dlcjtcbiAgICBjb25zdCB1cHBlciA9IHRoaXMudXBwZXI7XG5cbiAgICBpZiAoc3BlZWQgPiAwKVxuICAgICAgdGltZSArPSBFUFNJTE9OO1xuICAgIGVsc2VcbiAgICAgIHRpbWUgLT0gRVBTSUxPTjtcblxuICAgIGlmIChzcGVlZCA+IDApIHtcbiAgICAgIHBsYXlDb250cm9sLnN5bmNTcGVlZCh0aW1lLCBsb3dlciwgc3BlZWQsIHRydWUpO1xuICAgICAgcmV0dXJuIHBsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24odXBwZXIpIC0gRVBTSUxPTjtcbiAgICB9IGVsc2UgaWYgKHNwZWVkIDwgMCkge1xuICAgICAgcGxheUNvbnRyb2wuc3luY1NwZWVkKHRpbWUsIHVwcGVyLCBzcGVlZCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcGxheUNvbnRyb2wuX19nZXRUaW1lQXRQb3NpdGlvbihsb3dlcikgKyBFUFNJTE9OO1xuICAgIH1cblxuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuXG4gIHJlc2NoZWR1bGUoc3BlZWQpIHtcbiAgICBjb25zdCBwbGF5Q29udHJvbCA9IHRoaXMuX19wbGF5Q29udHJvbDtcbiAgICBjb25zdCBsb3dlciA9IE1hdGgubWluKHBsYXlDb250cm9sLl9fbG9vcFN0YXJ0LCBwbGF5Q29udHJvbC5fX2xvb3BFbmQpO1xuICAgIGNvbnN0IHVwcGVyID0gTWF0aC5tYXgocGxheUNvbnRyb2wuX19sb29wU3RhcnQsIHBsYXlDb250cm9sLl9fbG9vcEVuZCk7XG5cbiAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgdGhpcy5sb3dlciA9IGxvd2VyO1xuICAgIHRoaXMudXBwZXIgPSB1cHBlcjtcblxuICAgIGlmIChsb3dlciA9PT0gdXBwZXIpXG4gICAgICBzcGVlZCA9IDA7XG5cbiAgICBpZiAoc3BlZWQgPiAwKVxuICAgICAgdGhpcy5yZXNldFRpbWUocGxheUNvbnRyb2wuX19nZXRUaW1lQXRQb3NpdGlvbih1cHBlcikgLSBFUFNJTE9OKTtcbiAgICBlbHNlIGlmIChzcGVlZCA8IDApXG4gICAgICB0aGlzLnJlc2V0VGltZShwbGF5Q29udHJvbC5fX2dldFRpbWVBdFBvc2l0aW9uKGxvd2VyKSArIEVQU0lMT04pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMucmVzZXRUaW1lKEluZmluaXR5KTtcbiAgfVxuXG4gIGFwcGx5TG9vcEJvdW5kYXJpZXMocG9zaXRpb24sIHNwZWVkKSB7XG4gICAgY29uc3QgbG93ZXIgPSB0aGlzLmxvd2VyO1xuICAgIGNvbnN0IHVwcGVyID0gdGhpcy51cHBlcjtcblxuICAgIGlmIChzcGVlZCA+IDAgJiYgcG9zaXRpb24gPj0gdXBwZXIpXG4gICAgICByZXR1cm4gbG93ZXIgKyAocG9zaXRpb24gLSBsb3dlcikgJSAodXBwZXIgLSBsb3dlcik7XG4gICAgZWxzZSBpZiAoc3BlZWQgPCAwICYmIHBvc2l0aW9uIDwgbG93ZXIpXG4gICAgICByZXR1cm4gdXBwZXIgLSAodXBwZXIgLSBwb3NpdGlvbikgJSAodXBwZXIgLSBsb3dlcik7XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cbn1cblxuLy8gcGxheSBjb250cm9sbGVkIGJhc2UgY2xhc3NcbmNsYXNzIFBsYXlDb250cm9sbGVkIHtcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IHBsYXlDb250cm9sO1xuXG4gICAgZW5naW5lLm1hc3RlciA9IHRoaXM7XG4gICAgdGhpcy5fX2VuZ2luZSA9IGVuZ2luZTtcbiAgfVxuXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWssIGxhc3RTcGVlZCkge1xuICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2Vlayk7XG4gIH1cblxuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50VGltZTtcbiAgfVxuXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50UG9zaXRpb247XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IG51bGw7XG5cbiAgICB0aGlzLl9fZW5naW5lLm1hc3RlciA9IG51bGw7XG4gICAgdGhpcy5fX2VuZ2luZSA9IG51bGw7XG4gIH1cbn1cblxuLy8gcGxheSBjb250cm9sIGZvciBlbmdpbmVzIGltcGxlbWVudGluZyB0aGUgKnNwZWVkLWNvbnRyb2xsZWQqIGludGVyZmFjZVxuY2xhc3MgUGxheUNvbnRyb2xsZWRTcGVlZENvbnRyb2xsZWQgZXh0ZW5kcyBQbGF5Q29udHJvbGxlZCB7XG4gIGNvbnN0cnVjdG9yKHBsYXlDb250cm9sLCBlbmdpbmUpIHtcbiAgICBzdXBlcihwbGF5Q29udHJvbCwgZW5naW5lKTtcbiAgfVxufVxuXG4vLyBwbGF5IGNvbnRyb2wgZm9yIGVuZ2luZXMgaW1wbG1lbnRpbmcgdGhlICp0cmFuc3BvcnRlZCogaW50ZXJmYWNlXG5jbGFzcyBQbGF5Q29udHJvbGxlZFRyYW5zcG9ydGVkIGV4dGVuZHMgUGxheUNvbnRyb2xsZWQge1xuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XG4gICAgc3VwZXIocGxheUNvbnRyb2wsIGVuZ2luZSk7XG5cbiAgICB0aGlzLl9fc2NoZWR1bGVySG9vayA9IG5ldyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlckhvb2socGxheUNvbnRyb2wsIGVuZ2luZSk7XG4gIH1cblxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrLCBsYXN0U3BlZWQpIHtcbiAgICBpZiAoc3BlZWQgIT09IGxhc3RTcGVlZCB8fCAoc2VlayAmJiBzcGVlZCAhPT0gMCkpIHtcbiAgICAgIHZhciBuZXh0UG9zaXRpb247XG5cbiAgICAgIC8vIHJlc3luYyB0cmFuc3BvcnRlZCBlbmdpbmVzXG4gICAgICBpZiAoc2VlayB8fCBzcGVlZCAqIGxhc3RTcGVlZCA8IDApIHtcbiAgICAgICAgLy8gc2VlayBvciByZXZlcnNlIGRpcmVjdGlvblxuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICAgICAgfSBlbHNlIGlmIChsYXN0U3BlZWQgPT09IDApIHtcbiAgICAgICAgLy8gc3RhcnRcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5fX2VuZ2luZS5zeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgLy8gc3RvcFxuICAgICAgICBuZXh0UG9zaXRpb24gPSBJbmZpbml0eTtcblxuICAgICAgICBpZiAodGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQpXG4gICAgICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIDApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCkge1xuICAgICAgICAvLyBjaGFuZ2Ugc3BlZWQgd2l0aG91dCByZXZlcnNpbmcgZGlyZWN0aW9uXG4gICAgICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLnJlc2V0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICByZXNldEVuZ2luZVBvc2l0aW9uKGVuZ2luZSwgcG9zaXRpb24gPSB1bmRlZmluZWQpIHtcbiAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHBsYXlDb250cm9sID0gdGhpcy5fX3BsYXlDb250cm9sO1xuICAgICAgdmFyIHRpbWUgPSBwbGF5Q29udHJvbC5fX3N5bmMoKTtcblxuICAgICAgcG9zaXRpb24gPSB0aGlzLl9fZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCBwbGF5Q29udHJvbC5fX3Bvc2l0aW9uLCBwbGF5Q29udHJvbC5fX3NwZWVkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9fc2NoZWR1bGVySG9vay5yZXNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fX3NjaGVkdWxlckhvb2suZGVzdHJveSgpO1xuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rID0gbnVsbDtcblxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuXG4vLyBwbGF5IGNvbnRyb2wgZm9yIHRpbWUgZW5naW5lcyBpbXBsZW1lbnRpbmcgdGhlICpzY2hlZHVsZWQqIGludGVyZmFjZVxuY2xhc3MgUGxheUNvbnRyb2xsZWRTY2hlZHVsZWQgZXh0ZW5kcyBQbGF5Q29udHJvbGxlZCB7XG4gIGNvbnN0cnVjdG9yKHBsYXlDb250cm9sLCBlbmdpbmUpIHtcbiAgICBzdXBlcihwbGF5Q29udHJvbCwgZW5naW5lKTtcblxuICAgIC8vIHNjaGVkdWxpbmcgcXVldWUgYmVjb21lcyBtYXN0ZXIgb2YgZW5naW5lXG4gICAgZW5naW5lLm1hc3RlciA9IG51bGw7XG4gICAgdGhpcy5fX3NjaGVkdWxpbmdRdWV1ZSA9IG5ldyBQbGF5Q29udHJvbGxlZFNjaGVkdWxpbmdRdWV1ZShwbGF5Q29udHJvbCwgZW5naW5lKTtcbiAgfVxuXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWssIGxhc3RTcGVlZCkge1xuICAgIGlmIChsYXN0U3BlZWQgPT09IDAgJiYgc3BlZWQgIT09IDApIC8vIHN0YXJ0IG9yIHNlZWtcbiAgICAgIHRoaXMuX19lbmdpbmUucmVzZXRUaW1lKCk7XG4gICAgZWxzZSBpZiAobGFzdFNwZWVkICE9PSAwICYmIHNwZWVkID09PSAwKSAvLyBzdG9wXG4gICAgICB0aGlzLl9fZW5naW5lLnJlc2V0VGltZShJbmZpbml0eSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX19zY2hlZHVsaW5nUXVldWUuZGVzdHJveSgpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuXG4vLyB0cmFuc2xhdGVzIHRyYW5zcG9ydGVkIGVuZ2luZSBhZHZhbmNlUG9zaXRpb24gaW50byBnbG9iYWwgc2NoZWR1bGVyIHRpbWVzXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlckhvb2sgZXh0ZW5kcyBUaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBwbGF5Q29udHJvbDtcbiAgICB0aGlzLl9fZW5naW5lID0gZW5naW5lO1xuXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IEluZmluaXR5O1xuICAgIHBsYXlDb250cm9sLl9fc2NoZWR1bGVyLmFkZCh0aGlzLCBJbmZpbml0eSk7XG4gIH1cblxuICBhZHZhbmNlVGltZSh0aW1lKSB7XG4gICAgdmFyIHBsYXlDb250cm9sID0gdGhpcy5fX3BsYXlDb250cm9sO1xuICAgIHZhciBlbmdpbmUgPSB0aGlzLl9fZW5naW5lO1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX19uZXh0UG9zaXRpb247XG4gICAgdmFyIG5leHRQb3NpdGlvbiA9IGVuZ2luZS5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHBsYXlDb250cm9sLl9fc3BlZWQpO1xuICAgIHZhciBuZXh0VGltZSA9IHBsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcblxuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBuZXh0UG9zaXRpb247XG4gICAgcmV0dXJuIG5leHRUaW1lO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9fcGxheUNvbnRyb2wuY3VycmVudFRpbWU7XG4gIH1cblxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fcGxheUNvbnRyb2wuY3VycmVudFBvc2l0aW9uO1xuICB9XG5cbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbiA9IHRoaXMuX19uZXh0UG9zaXRpb24pIHtcbiAgICB2YXIgdGltZSA9IHRoaXMuX19wbGF5Q29udHJvbC5fX2dldFRpbWVBdFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5yZXNldFRpbWUodGltZSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX19wbGF5Q29udHJvbC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5fX3BsYXlDb250cm9sID0gbnVsbDtcbiAgICB0aGlzLl9fZW5naW5lID0gbnVsbDtcbiAgfVxufVxuXG4vLyBpbnRlcm5hbCBzY2hlZHVsaW5nIHF1ZXVlIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBwb3NpdGlvbiAoYW5kIHRpbWUpIG9mIHRoZSBwbGF5IGNvbnRyb2xcbmNsYXNzIFBsYXlDb250cm9sbGVkU2NoZWR1bGluZ1F1ZXVlIGV4dGVuZHMgU2NoZWR1bGluZ1F1ZXVlIHtcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3BsYXlDb250cm9sID0gcGxheUNvbnRyb2w7XG4gICAgdGhpcy5fX2VuZ2luZSA9IGVuZ2luZTtcblxuICAgIHRoaXMuYWRkKGVuZ2luZSwgSW5maW5pdHkpO1xuICAgIHBsYXlDb250cm9sLl9fc2NoZWR1bGVyLmFkZCh0aGlzLCBJbmZpbml0eSk7XG4gIH1cblxuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50VGltZTtcbiAgfVxuXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50UG9zaXRpb247XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX19wbGF5Q29udHJvbC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5yZW1vdmUodGhpcy5fX2VuZ2luZSk7XG5cbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBudWxsO1xuICAgIHRoaXMuX19lbmdpbmUgPSBudWxsO1xuICB9XG59XG5cblxuLyoqXG4gKiBFeHRlbmRzIFRpbWUgRW5naW5lIHRvIHByb3ZpZGUgcGxheWJhY2sgY29udHJvbCBvZiBhIFRpbWUgRW5naW5lIGluc3RhbmNlLlxuICpcbiAqIFtleGFtcGxlXXtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvcGxheS1jb250cm9sLmh0bWx9XG4gKlxuICogQGV4dGVuZHMgVGltZUVuZ2luZVxuICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBlbmdpbmUgdG8gY29udHJvbFxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XG4gKiBjb25zdCBwbGF5ZXJFbmdpbmUgPSBhdWRpby5QbGF5ZXJFbmdpbmUoKTtcbiAqIGNvbnN0IHBsYXlDb250cm9sID0gbmV3IGF1ZGlvLlBsYXlDb250cm9sKHBsYXllckVuZ2luZSk7XG4gKlxuICogcGxheUNvbnRyb2wuc3RhcnQoKTtcbiAqL1xuY2xhc3MgUGxheUNvbnRyb2wgZXh0ZW5kcyBUaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3IoZW5naW5lLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBvcHRpb25zLmF1ZGlvQ29udGV4dCB8fCBkZWZhdWx0QXVkaW9Db250ZXh0O1xuICAgIHRoaXMuX19zY2hlZHVsZXIgPSBnZXRTY2hlZHVsZXIodGhpcy5hdWRpb0NvbnRleHQpO1xuXG4gICAgdGhpcy5fX3BsYXlDb250cm9sbGVkID0gbnVsbDtcblxuICAgIHRoaXMuX19sb29wQ29udHJvbCA9IG51bGw7XG4gICAgdGhpcy5fX2xvb3BTdGFydCA9IDA7XG4gICAgdGhpcy5fX2xvb3BFbmQgPSAxO1xuXG4gICAgLy8gc3luY2hyb25pemVkIHRpZSwgcG9zaXRpb24sIGFuZCBzcGVlZFxuICAgIHRoaXMuX190aW1lID0gMDtcbiAgICB0aGlzLl9fcG9zaXRpb24gPSAwO1xuICAgIHRoaXMuX19zcGVlZCA9IDA7XG5cbiAgICAvLyBub24temVybyBcInVzZXJcIiBzcGVlZFxuICAgIHRoaXMuX19wbGF5aW5nU3BlZWQgPSAxO1xuXG4gICAgaWYgKGVuZ2luZSlcbiAgICAgIHRoaXMuX19zZXRFbmdpbmUoZW5naW5lKTtcbiAgfVxuXG4gIF9fc2V0RW5naW5lKGVuZ2luZSkge1xuICAgIGlmIChlbmdpbmUubWFzdGVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gYSBtYXN0ZXJcIik7XG5cbiAgICBpZiAoVGltZUVuZ2luZS5pbXBsZW1lbnRzU3BlZWRDb250cm9sbGVkKGVuZ2luZSkpXG4gICAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQgPSBuZXcgUGxheUNvbnRyb2xsZWRTcGVlZENvbnRyb2xsZWQodGhpcywgZW5naW5lKTtcbiAgICBlbHNlIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNUcmFuc3BvcnRlZChlbmdpbmUpKVxuICAgICAgdGhpcy5fX3BsYXlDb250cm9sbGVkID0gbmV3IFBsYXlDb250cm9sbGVkVHJhbnNwb3J0ZWQodGhpcywgZW5naW5lKTtcbiAgICBlbHNlIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSlcbiAgICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZCA9IG5ldyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlZCh0aGlzLCBlbmdpbmUpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgYWRkZWQgdG8gcGxheSBjb250cm9sXCIpO1xuICB9XG5cbiAgX19yZXNldEVuZ2luZSgpIHtcbiAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQuZGVzdHJveSgpO1xuICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlL2V4dHJhcG9sYXRlIHBsYXlpbmcgdGltZSBmb3IgZ2l2ZW4gcG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge051bWJlcn0gZXh0cmFwb2xhdGVkIHRpbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fX3RpbWUgKyAocG9zaXRpb24gLSB0aGlzLl9fcG9zaXRpb24pIC8gdGhpcy5fX3NwZWVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZS9leHRyYXBvbGF0ZSBwbGF5aW5nIHBvc2l0aW9uIGZvciBnaXZlbiB0aW1lXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIHRpbWVcbiAgICogQHJldHVybiB7TnVtYmVyfSBleHRyYXBvbGF0ZWQgcG9zaXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fZ2V0UG9zaXRpb25BdFRpbWUodGltZSkge1xuICAgIHJldHVybiB0aGlzLl9fcG9zaXRpb24gKyAodGltZSAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcbiAgfVxuXG4gIF9fc3luYygpIHtcbiAgICBjb25zdCBub3cgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSAobm93IC0gdGhpcy5fX3RpbWUpICogdGhpcy5fX3NwZWVkO1xuICAgIHRoaXMuX190aW1lID0gbm93O1xuICAgIHJldHVybiBub3c7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgbWFzdGVyIHRpbWUuXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZXBsYWNlZCB3aGVuIHRoZSBwbGF5LWNvbnRyb2wgaXMgYWRkZWQgdG8gYSBtYXN0ZXIuXG4gICAqXG4gICAqIEBuYW1lIGN1cnJlbnRUaW1lXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBQbGF5Q29udHJvbFxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19zY2hlZHVsZXIuY3VycmVudFRpbWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgbWFzdGVyIHBvc2l0aW9uLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVwbGFjZWQgd2hlbiB0aGUgcGxheS1jb250cm9sIGlzIGFkZGVkIHRvIGEgbWFzdGVyLlxuICAgKlxuICAgKiBAbmFtZSBjdXJyZW50UG9zaXRpb25cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiArICh0aGlzLl9fc2NoZWR1bGVyLmN1cnJlbnRUaW1lIC0gdGhpcy5fX3RpbWUpICogdGhpcy5fX3NwZWVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIHBsYXkgY29udHJvbCBpcyBydW5uaW4gZy5cbiAgICpcbiAgICogQG5hbWUgcnVubmluZ1xuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBydW5uaW5nKCkge1xuICAgIHJldHVybiAhKHRoaXMuX19zcGVlZCA9PT0gMCk7XG4gIH1cblxuICBzZXQoZW5naW5lID0gbnVsbCkge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xuICAgIGNvbnN0IHNwZWVkID0gdGhpcy5fX3NwZWVkO1xuXG4gICAgaWYgKHRoaXMuX19wbGF5Q29udHJvbGxlZCAhPT0gbnVsbCAmJiB0aGlzLl9fcGxheUNvbnRyb2xsZWQuX19lbmdpbmUgIT09IGVuZ2luZSkge1xuXG4gICAgICB0aGlzLnN5bmNTcGVlZCh0aW1lLCB0aGlzLl9fcG9zaXRpb24sIDApO1xuXG4gICAgICBpZiAodGhpcy5fX3BsYXlDb250cm9sbGVkKVxuICAgICAgICB0aGlzLl9fcmVzZXRFbmdpbmUoKTtcblxuXG4gICAgICBpZiAodGhpcy5fX3BsYXlDb250cm9sbGVkID09PSBudWxsICYmIGVuZ2luZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9fc2V0RW5naW5lKGVuZ2luZSk7XG5cbiAgICAgICAgaWYgKHNwZWVkICE9PSAwKVxuICAgICAgICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHRoaXMuX19wb3NpdGlvbiwgc3BlZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwbGF5IGNvbnRyb2wgbG9vcCBiZWhhdmlvci5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBuYW1lIGxvb3BcbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgc2V0IGxvb3AoZW5hYmxlKSB7XG4gICAgaWYgKGVuYWJsZSAmJiB0aGlzLl9fbG9vcFN0YXJ0ID4gLUluZmluaXR5ICYmIHRoaXMuX19sb29wRW5kIDwgSW5maW5pdHkpIHtcbiAgICAgIGlmICghdGhpcy5fX2xvb3BDb250cm9sKSB7XG4gICAgICAgIHRoaXMuX19sb29wQ29udHJvbCA9IG5ldyBMb29wQ29udHJvbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fX3NjaGVkdWxlci5hZGQodGhpcy5fX2xvb3BDb250cm9sLCBJbmZpbml0eSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9fc3BlZWQgIT09IDApIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmN1cnJlbnRQb3NpdGlvbjtcbiAgICAgICAgY29uc3QgbG93ZXIgPSBNYXRoLm1pbih0aGlzLl9fbG9vcFN0YXJ0LCB0aGlzLl9fbG9vcEVuZCk7XG4gICAgICAgIGNvbnN0IHVwcGVyID0gTWF0aC5tYXgodGhpcy5fX2xvb3BTdGFydCwgdGhpcy5fX2xvb3BFbmQpO1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3BlZWQgPiAwICYmIHBvc2l0aW9uID4gdXBwZXIpXG4gICAgICAgICAgdGhpcy5zZWVrKHVwcGVyKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fX3NwZWVkIDwgMCAmJiBwb3NpdGlvbiA8IGxvd2VyKVxuICAgICAgICAgIHRoaXMuc2Vlayhsb3dlcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLl9fbG9vcENvbnRyb2wucmVzY2hlZHVsZSh0aGlzLl9fc3BlZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fX2xvb3BDb250cm9sKSB7XG4gICAgICB0aGlzLl9fc2NoZWR1bGVyLnJlbW92ZSh0aGlzLl9fbG9vcENvbnRyb2wpO1xuICAgICAgdGhpcy5fX2xvb3BDb250cm9sID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBnZXQgbG9vcCgpIHtcbiAgICByZXR1cm4gKCEhdGhpcy5fX2xvb3BDb250cm9sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGxvb3Agc3RhcnQgYW5kIGVuZCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbG9vcFN0YXJ0IC0gbG9vcCBzdGFydCB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxvb3BFbmQgLSBsb29wIGVuZCB2YWx1ZS5cbiAgICovXG4gIHNldExvb3BCb3VuZGFyaWVzKGxvb3BTdGFydCwgbG9vcEVuZCkge1xuICAgIHRoaXMuX19sb29wU3RhcnQgPSBsb29wU3RhcnQ7XG4gICAgdGhpcy5fX2xvb3BFbmQgPSBsb29wRW5kO1xuXG4gICAgdGhpcy5sb29wID0gdGhpcy5sb29wO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbG9vcCBzdGFydCB2YWx1ZVxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbmFtZSBsb29wU3RhcnRcbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgc2V0IGxvb3BTdGFydChsb29wU3RhcnQpIHtcbiAgICB0aGlzLnNldExvb3BCb3VuZGFyaWVzKGxvb3BTdGFydCwgdGhpcy5fX2xvb3BFbmQpO1xuICB9XG5cbiAgZ2V0IGxvb3BTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2xvb3BTdGFydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGxvb3AgZW5kIHZhbHVlXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBuYW1lIGxvb3BFbmRcbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgc2V0IGxvb3BFbmQobG9vcEVuZCkge1xuICAgIHRoaXMuc2V0TG9vcEJvdW5kYXJpZXModGhpcy5fX2xvb3BTdGFydCwgbG9vcEVuZCk7XG4gIH1cblxuICBnZXQgbG9vcEVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2xvb3BFbmQ7XG4gIH1cblxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAoc3BlZWQtY29udHJvbGxlZCBpbnRlcmZhY2UpXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWsgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxhc3RTcGVlZCA9IHRoaXMuX19zcGVlZDtcblxuICAgIGlmIChzcGVlZCAhPT0gbGFzdFNwZWVkIHx8IHNlZWspIHtcbiAgICAgIGlmICgoc2VlayB8fCBsYXN0U3BlZWQgPT09IDApICYmIHRoaXMuX19sb29wQ29udHJvbClcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9fbG9vcENvbnRyb2wuYXBwbHlMb29wQm91bmRhcmllcyhwb3NpdGlvbiwgc3BlZWQpO1xuXG4gICAgICB0aGlzLl9fdGltZSA9IHRpbWU7XG4gICAgICB0aGlzLl9fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgIHRoaXMuX19zcGVlZCA9IHNwZWVkO1xuXG4gICAgICBpZiAodGhpcy5fX3BsYXlDb250cm9sbGVkKVxuICAgICAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlaywgbGFzdFNwZWVkKTtcblxuICAgICAgaWYgKHRoaXMuX19sb29wQ29udHJvbClcbiAgICAgICAgdGhpcy5fX2xvb3BDb250cm9sLnJlc2NoZWR1bGUoc3BlZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgcGxheWJhY2tcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xuICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHRoaXMuX19wb3NpdGlvbiwgdGhpcy5fX3BsYXlpbmdTcGVlZCk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2VzIHBsYXliYWNrIGFuZCBzdGF5cyBhdCB0aGUgc2FtZSBwb3NpdGlvbi5cbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xuICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHRoaXMuX19wb3NpdGlvbiwgMCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgcGxheWJhY2sgYW5kIHNlZWtzIHRvIGluaXRpYWwgKDApIHBvc2l0aW9uLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBjb25zdCB0aW1lID0gdGhpcy5fX3N5bmMoKTtcbiAgICB0aGlzLnN5bmNTcGVlZCh0aW1lLCAwLCAwLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBzcGVlZCBpZiBwcm92aWRlZCwgc2V0cyB0aGUgcGxheWJhY2sgc3BlZWQuIFRoZSBzcGVlZCB2YWx1ZSBzaG91bGRcbiAgICogYmUgbm9uLXplcm8gYmV0d2VlbiAtMTYgYW5kIC0xLzE2IG9yIGJldHdlZW4gMS8xNiBhbmQgMTYuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBuYW1lIHNwZWVkXG4gICAqIEBtZW1iZXJvZiBQbGF5Q29udHJvbFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIHNldCBzcGVlZChzcGVlZCkge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xuXG4gICAgaWYgKHNwZWVkID49IDApIHtcbiAgICAgIGlmIChzcGVlZCA8IDAuMDEpXG4gICAgICAgIHNwZWVkID0gMC4wMTtcbiAgICAgIGVsc2UgaWYgKHNwZWVkID4gMTAwKVxuICAgICAgICBzcGVlZCA9IDEwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNwZWVkIDwgLTEwMClcbiAgICAgICAgc3BlZWQgPSAtMTAwO1xuICAgICAgZWxzZSBpZiAoc3BlZWQgPiAtMC4wMSlcbiAgICAgICAgc3BlZWQgPSAtMC4wMTtcbiAgICB9XG5cbiAgICB0aGlzLl9fcGxheWluZ1NwZWVkID0gc3BlZWQ7XG5cbiAgICBpZiAoIXRoaXMubWFzdGVyICYmIHRoaXMuX19zcGVlZCAhPT0gMClcbiAgICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHRoaXMuX19wb3NpdGlvbiwgc3BlZWQpO1xuICB9XG5cbiAgZ2V0IHNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9fcGxheWluZ1NwZWVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCAoanVtcCB0bykgcGxheWluZyBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIHRhcmdldCBwb3NpdGlvblxuICAgKi9cbiAgc2Vlayhwb3NpdGlvbikge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xuICAgIHRoaXMuX19wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCB0aGlzLl9fc3BlZWQsIHRydWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBsYXlDb250cm9sO1xuIiwiaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBkZWZhdWx0QXVkaW9Db250ZXh0IGZyb20gJy4uL2NvcmUvYXVkaW8tY29udGV4dCc7XG5pbXBvcnQgU2NoZWR1bGluZ1F1ZXVlIGZyb20gJy4uL2NvcmUvc2NoZWR1bGluZy1xdWV1ZSc7XG5cbmNvbnN0IGxvZyA9IGRlYnVnKCd3YXZlc2pzOmF1ZGlvJyk7XG5cbi8qKlxuICogVGhlIGBTY2hlZHVsZXJgIGNsYXNzIGltcGxlbWVudHMgYSBtYXN0ZXIgZm9yIGBUaW1lRW5naW5lYCBvciBgQXVkaW9UaW1lRW5naW5lYFxuICogaW5zdGFuY2VzIHRoYXQgaW1wbGVtZW50IHRoZSAqc2NoZWR1bGVkKiBpbnRlcmZhY2Ugc3VjaCBhcyB0aGUgYE1ldHJvbm9tZWBcbiAqIGBHcmFudWxhckVuZ2luZWAuXG4gKlxuICogQSBgU2NoZWR1bGVyYCBjYW4gYWxzbyBzY2hlZHVsZSBzaW1wbGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogVGhlIGNsYXNzIGlzIGJhc2VkIG9uIHJlY3Vyc2l2ZSBjYWxscyB0byBgc2V0VGltZU91dGAgYW5kIHVzZXMgdGhlXG4gKiBgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lYCBhcyBsb2dpY2FsIHBhc3NlZCB0byB0aGUgYGFkdmFuY2VUaW1lYCBtZXRob2RzXG4gKiBvZiB0aGUgc2NoZWR1bGVkIGVuZ2luZXMgb3IgdG8gdGhlIHNjaGVkdWxlZCBjYWxsYmFjayBmdW5jdGlvbnMuXG4gKiBJdCBleHRlbmRzIHRoZSBgU2NoZWR1bGluZ1F1ZXVlYCBjbGFzcyB0aGF0IGl0c2VsZiBpbmNsdWRlcyBhIGBQcmlvcml0eVF1ZXVlYFxuICogdG8gYXNzdXJlIHRoZSBvcmRlciBvZiB0aGUgc2NoZWR1bGVkIGVuZ2luZXMgKHNlZSBgU2ltcGxlU2NoZWR1bGVyYCBmb3IgYVxuICogc2ltcGxpZmllZCBzY2hlZHVsZXIgaW1wbGVtZW50YXRpb24gd2l0aG91dCBgUHJpb3JpdHlRdWV1ZWApLlxuICpcbiAqIFRvIGdldCBhIHVuaXF1ZSBpbnN0YW5jZSBvZiBgU2NoZWR1bGVyYCBhcyB0aGUgZ2xvYmFsIHNjaGVkdWxlciBvZiBhblxuICogYXBwbGljYXRpb24sIHRoZSBgZ2V0U2NoZWR1bGVyYCBmYWN0b3J5IGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkLiBUaGVcbiAqIGZ1bmN0aW9uIGFjY2VwdHMgYW4gYXVkaW8gY29udGV4dCBhcyBvcHRpb25hbCBhcmd1bWVudCBhbmQgdXNlcyB0aGUgV2F2ZXNcbiAqIGRlZmF1bHQgYXVkaW8gY29udGV4dCAoc2VlIGBhdWRpb0NvbnRleHRgKSBhc1xuICogZGVmYXVsdC4gVGhlIGZhY3RvcnkgY3JlYXRlcyBhIHNpbmdsZSBzY2hlZHVsZXIgZm9yIGVhY2ggYXVkaW8gY29udGV4dC5cbiAqXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgdGhyZWUgTWV0cm9ub21lIGVuZ2luZXMgcnVubmluZyBpbiBhIFNjaGVkdWxlcjpcbiAqIHtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvc2NoZWR1bGVyLmh0bWx9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIGRlZmF1bHQgb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZD0wLjAyNV0gLSBwZXJpb2Qgb2YgdGhlIHNjaGVkdWxlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sb29rYWhlYWQ9MC4xXSAtIGxvb2thaGVhZCBvZiB0aGUgc2NoZWR1bGVyLlxuICpcbiAqIEBzZWUgVGltZUVuZ2luZVxuICogQHNlZSBBdWRpb1RpbWVFbmdpbmVcbiAqIEBzZWUgZ2V0U2NoZWR1bGVyXG4gKiBAc2VlIFNpbXBsZVNjaGVkdWxlclxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XG4gKiBjb25zdCBzY2hlZHVsZXIgPSBhdWRpby5nZXRTY2hlZHVsZXIoKTtcbiAqXG4gKiBzY2hlZHVsZXIuYWRkKG15RW5naW5lKTtcbiAqL1xuY2xhc3MgU2NoZWR1bGVyIGV4dGVuZHMgU2NoZWR1bGluZ1F1ZXVlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gb3B0aW9ucy5hdWRpb0NvbnRleHQgfHwgwqBkZWZhdWx0QXVkaW9Db250ZXh0O1xuXG4gICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLl9fbmV4dFRpbWUgPSBJbmZpbml0eTtcbiAgICB0aGlzLl9fdGltZW91dCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBzY2hlZHVsZXIgKHNldFRpbWVvdXQpIHBlcmlvZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgcGVyaW9kXG4gICAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucGVyaW9kID0gb3B0aW9ucy5wZXJpb2QgfHwgwqAwLjAyNTtcblxuICAgIC8qKlxuICAgICAqIHNjaGVkdWxlciBsb29rYWhlYWQgdGltZSAoPiBwZXJpb2QpXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBsb29rYWhlYWRcbiAgICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5sb29rYWhlYWQgPSBvcHRpb25zLmxvb2thaGVhZCB8fCDCoDAuMTtcbiAgfVxuXG4gIC8vIHNldFRpbWVvdXQgc2NoZWR1bGluZyBsb29wXG4gIF9fdGljaygpIHtcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcbiAgICBsZXQgdGltZSA9IHRoaXMuX19uZXh0VGltZTtcblxuICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0aW1lIDw9IGN1cnJlbnRUaW1lICsgdGhpcy5sb29rYWhlYWQpIHtcbiAgICAgIHRoaXMuX19jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgICB0aW1lID0gdGhpcy5hZHZhbmNlVGltZSh0aW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLl9fY3VycmVudFRpbWUgPSBudWxsO1xuICAgIHRoaXMucmVzZXRUaW1lKHRpbWUpO1xuICB9XG5cbiAgcmVzZXRUaW1lKHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgaWYgKHRoaXMubWFzdGVyKSB7XG4gICAgICB0aGlzLm1hc3Rlci5yZXNldCh0aGlzLCB0aW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX190aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9fdGltZW91dCk7XG4gICAgICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWUgIT09IEluZmluaXR5KSB7XG4gICAgICAgIGlmICh0aGlzLl9fbmV4dFRpbWUgPT09IEluZmluaXR5KVxuICAgICAgICAgIGxvZygnU2NoZWR1bGVyIFN0YXJ0Jyk7XG5cbiAgICAgICAgY29uc3QgdGltZU91dERlbGF5ID0gTWF0aC5tYXgoKHRpbWUgLSB0aGlzLmxvb2thaGVhZCAtIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKSwgdGhpcy5wZXJpb2QpO1xuXG4gICAgICAgIHRoaXMuX190aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fX3RpY2soKTtcbiAgICAgICAgfSwgTWF0aC5jZWlsKHRpbWVPdXREZWxheSAqIDEwMDApKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX25leHRUaW1lICE9PSBJbmZpbml0eSkge1xuICAgICAgICBsb2coJ1NjaGVkdWxlciBTdG9wJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX19uZXh0VGltZSA9IHRpbWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlciBjdXJyZW50IGxvZ2ljYWwgdGltZS5cbiAgICpcbiAgICogQG5hbWUgY3VycmVudFRpbWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICBpZiAodGhpcy5tYXN0ZXIpXG4gICAgICByZXR1cm4gdGhpcy5tYXN0ZXIuY3VycmVudFRpbWU7XG5cbiAgICByZXR1cm4gdGhpcy5fX2N1cnJlbnRUaW1lIHx8IHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy5sb29rYWhlYWQ7XG4gIH1cblxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xuXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gbWFzdGVyLmN1cnJlbnRQb3NpdGlvbjtcblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBpbmhlcml0ZWQgZnJvbSBzY2hlZHVsaW5nIHF1ZXVlXG4gIC8qKlxuICAgKiBBZGQgYSBUaW1lRW5naW5lIG9yIGEgc2ltcGxlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHRoZSBzY2hlZHVsZXIgYXQgYW5cbiAgICogb3B0aW9uYWxseSBnaXZlbiB0aW1lLiBXaGV0aGVyIHRoZSBhZGQgbWV0aG9kIGlzIGNhbGxlZCB3aXRoIGEgVGltZUVuZ2luZVxuICAgKiBvciBhIGNhbGxiYWNrIGZ1bmN0aW9uIGl0IHJldHVybnMgYSBUaW1lRW5naW5lIHRoYXQgY2FuIGJlIHVzZWQgYXMgYXJndW1lbnRcbiAgICogb2YgdGhlIG1ldGhvZHMgcmVtb3ZlIGFuZCByZXNldEVuZ2luZVRpbWUuIEEgVGltZUVuZ2luZSBhZGRlZCB0byBhIHNjaGVkdWxlclxuICAgKiBoYXMgdG8gaW1wbGVtZW50IHRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gYWRkZWQgdG8gYVxuICAgKiBzY2hlZHVsZXIgd2lsbCBiZSBjYWxsZWQgYXQgdGhlIGdpdmVuIHRpbWUgYW5kIHdpdGggdGhlIGdpdmVuIHRpbWUgYXNcbiAgICogYXJndW1lbnQuIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIGEgbmV3IHNjaGVkdWxpbmcgdGltZSAoaS5lLiB0aGUgbmV4dFxuICAgKiB0aW1lIHdoZW4gaXQgd2lsbCBiZSBjYWxsZWQpIG9yIGl0IGNhbiByZXR1cm4gSW5maW5pdHkgdG8gc3VzcGVuZCBzY2hlZHVsaW5nXG4gICAqIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIGZyb20gdGhlIHNjaGVkdWxlci4gQSBmdW5jdGlvbiB0aGF0IGRvZXNcbiAgICogbm90IHJldHVybiBhIHZhbHVlIChvciByZXR1cm5zIG51bGwgb3IgMCkgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzY2hlZHVsZXJcbiAgICogYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGFyZ3VtZW50IG9mIHRoZSBtZXRob2RzIHJlbW92ZSBhbmQgcmVzZXRFbmdpbmVUaW1lXG4gICAqIGFueW1vcmUuXG4gICAqXG4gICAqIEBuYW1lIGFkZFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfEZ1bmN0aW9ufSBlbmdpbmUgLSBFbmdpbmUgdG8gYWRkIHRvIHRoZSBzY2hlZHVsZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPXRoaXMuY3VycmVudFRpbWVdIC0gU2NoZWR1bGUgdGltZVxuICAgKi9cbiAgLyoqXG4gICAqIFJlbW92ZSBhIFRpbWVFbmdpbmUgZnJvbSB0aGUgc2NoZWR1bGVyIHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlXG4gICAqIHNjaGVkdWxlciB1c2luZyB0aGUgYWRkIG1ldGhvZC5cbiAgICpcbiAgICogQG5hbWUgYWRkXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIEVuZ2luZSB0byByZW1vdmUgZnJvbSB0aGUgc2NoZWR1bGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZT10aGlzLmN1cnJlbnRUaW1lXSAtIFNjaGVkdWxlIHRpbWVcbiAgICovXG4gIC8qKlxuICAgKiBSZXNjaGVkdWxlIGEgc2NoZWR1bGVkIHRpbWUgZW5naW5lIGF0IGEgZ2l2ZW4gdGltZS5cbiAgICpcbiAgICogQG5hbWUgcmVzZXRFbmdpbmVUaW1lXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIEVuZ2luZSB0byByZXNjaGVkdWxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gU2NoZWR1bGUgdGltZVxuICAgKi9cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgc2NoZWR1bGVkIGNhbGxiYWNrcyBhbmQgZW5naW5lcyBmcm9tIHRoZSBzY2hlZHVsZXIuXG4gICAqXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTY2hlZHVsZXI7XG4iLCJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi4vY29yZS9hdWRpby1jb250ZXh0JztcbmltcG9ydCBUaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvdGltZS1lbmdpbmUnO1xuXG5jb25zdCBsb2cgPSBkZWJ1Zygnd2F2ZXNqczphdWRpbycpO1xuXG4vKipcbiAqXG4gKlxuICpcbiAqIFRoZSBTaW1wbGVTY2hlZHVsZXIgY2xhc3MgaW1wbGVtZW50cyBhIHNpbXBsaWZpZWQgbWFzdGVyIGZvciB0aW1lIGVuZ2luZXNcbiAqIChzZWUgVGltZUVuZ2luZSBvciBBdWRpb1RpbWVFbmdpbmUpIHRoYXQgaW1wbGVtZW50IHRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlXG4gKiBzdWNoIGFzIHRoZSBNZXRyb25vbWUgYW5kIHRoZSBHcmFudWxhckVuZ2luZS4gVGhlIEFQSSBhbmQgZnVudGlvbmFsaXRpZXMgb2ZcbiAqIHRoZSBTaW1wbGVTY2hlZHVsZXIgY2xhc3MgYXJlIGlkZW50aWNhbCB0byB0aGUgU2NoZWR1bGVyIGNsYXNzLiBCdXQsIG90aGVyXG4gKiB0aGFuIHRoZSBTY2hlZHVsZXIsIHRoZSBTaW1wbGVTY2hlZHVsZXIgY2xhc3MgZG9lcyBub3QgZ3VhcmFudGVlIHRoZSBvcmRlclxuICogb2YgZXZlbnRzIChpLmUuIGNhbGxzIHRvIHRoZSBhZHZhbmNlVGltZSBtZXRob2Qgb2Ygc2NoZWR1bGVkIHRpbWUgZW5naW5lc1xuICogYW5kIHRvIHNjaGVkdWxlZCBjYWxsYmFjayBmdW5jdGlvbnMpIHdpdGhpbiBhIHNjaGVkdWxpbmcgcGVyaW9kIChzZWUgcGVyaW9kXG4gKiBhdHRyaWJ1dGUpLlxuICpcbiAqIFRvIGdldCBhIHVuaXF1ZSBpbnN0YW5jZSBvZiBTaW1wbGVTY2hlZHVsZXIgYXMgdGhlIGdsb2JhbCBzY2hlZHVsZXIgb2YgYW5cbiAqIGFwcGxpY2F0aW9uLCB0aGUgZ2V0U2ltcGxlU2NoZWR1bGVyIGZhY3RvcnkgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQuIFRoZVxuICogZnVuY3Rpb24gYWNjZXB0cyBhbiBhdWRpbyBjb250ZXh0IGFzIG9wdGlvbmFsIGFyZ3VtZW50IGFuZCB1c2VzIHRoZSBXYXZlc1xuICogZGVmYXVsdCBhdWRpbyBjb250ZXh0IChzZWUgQXVkaW8gQ29udGV4dCkgYXMgZGVmYXVsdC4gVGhlIGZhY3RvcnkgY3JlYXRlc1xuICogYSBzaW5nbGUgKHNpbXBsZSkgc2NoZWR1bGVyIGZvciBlYWNoIGF1ZGlvIGNvbnRleHQuXG4gKlxuICogRXhhbXBsZSB0aGF0IHNob3dzIHRocmVlIE1ldHJvbm9tZSBlbmdpbmVzIHJ1bm5pbmcgaW4gYSBTaW1wbGVTY2hlZHVsZXI6XG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3NpbXBsZS1zY2hlZHVsZXIuaHRtbH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gZGVmYXVsdCBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kPTAuMDI1XSAtIHBlcmlvZCBvZiB0aGUgc2NoZWR1bGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxvb2thaGVhZD0wLjFdIC0gbG9va2FoZWFkIG9mIHRoZSBzY2hlZHVsZXIuXG4gKlxuICogQHNlZSBUaW1lRW5naW5lXG4gKiBAc2VlIEF1ZGlvVGltZUVuZ2luZVxuICogQHNlZSBnZXRTaW1wbGVTY2hlZHVsZXJcbiAqIEBzZWUgU2NoZWR1bGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNpbXBsZVNjaGVkdWxlcigpO1xuICpcbiAqIHNjaGVkdWxlci5hZGQobXlFbmdpbmUpO1xuICovXG5jbGFzcyBTaW1wbGVTY2hlZHVsZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IG9wdGlvbnMuYXVkaW9Db250ZXh0IHx8IMKgZGVmYXVsdEF1ZGlvQ29udGV4dDtcblxuICAgIHRoaXMuX19lbmdpbmVzID0gbmV3IFNldCgpO1xuXG4gICAgdGhpcy5fX3NjaGVkRW5naW5lcyA9IFtdO1xuICAgIHRoaXMuX19zY2hlZFRpbWVzID0gW107XG5cbiAgICB0aGlzLl9fY3VycmVudFRpbWUgPSBudWxsO1xuICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIHNjaGVkdWxlciAoc2V0VGltZW91dCkgcGVyaW9kXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBwZXJpb2RcbiAgICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wZXJpb2QgPSBvcHRpb25zLnBlcmlvZCB8fCAwLjAyNTtcblxuICAgIC8qKlxuICAgICAqIHNjaGVkdWxlciBsb29rYWhlYWQgdGltZSAoPiBwZXJpb2QpXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAbmFtZSBsb29rYWhlYWRcbiAgICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5sb29rYWhlYWQgPSBvcHRpb25zLmxvb2thaGVhZCB8fCAwLjE7XG4gIH1cblxuICBfX3NjaGVkdWxlRW5naW5lKGVuZ2luZSwgdGltZSkge1xuICAgIHRoaXMuX19zY2hlZEVuZ2luZXMucHVzaChlbmdpbmUpO1xuICAgIHRoaXMuX19zY2hlZFRpbWVzLnB1c2godGltZSk7XG4gIH1cblxuICBfX3Jlc2NoZWR1bGVFbmdpbmUoZW5naW5lLCB0aW1lKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fX3NjaGVkRW5naW5lcy5pbmRleE9mKGVuZ2luZSk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgaWYgKHRpbWUgIT09IEluZmluaXR5KSB7XG4gICAgICAgIHRoaXMuX19zY2hlZFRpbWVzW2luZGV4XSA9IHRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fc2NoZWRFbmdpbmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuX19zY2hlZFRpbWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aW1lIDwgSW5maW5pdHkpIHtcbiAgICAgIHRoaXMuX19zY2hlZEVuZ2luZXMucHVzaChlbmdpbmUpO1xuICAgICAgdGhpcy5fX3NjaGVkVGltZXMucHVzaCh0aW1lKTtcbiAgICB9XG4gIH1cblxuICBfX3Vuc2NoZWR1bGVFbmdpbmUoZW5naW5lKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fX3NjaGVkRW5naW5lcy5pbmRleE9mKGVuZ2luZSk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5fX3NjaGVkRW5naW5lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5fX3NjaGVkVGltZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICBfX3Jlc2V0VGljaygpIHtcbiAgICBpZiAodGhpcy5fX3NjaGVkRW5naW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoIXRoaXMuX190aW1lb3V0KSB7XG4gICAgICAgIGxvZygnU2ltcGxlU2NoZWR1bGVyIFN0YXJ0Jyk7XG4gICAgICAgIHRoaXMuX190aWNrKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9fdGltZW91dCkge1xuICAgICAgbG9nKCdTaW1wbGVTY2hlZHVsZXIgU3RvcCcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX190aW1lb3V0KTtcbiAgICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfX3RpY2soKSB7XG4gICAgdmFyIGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xuICAgIHZhciBjdXJyZW50VGltZSA9IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHRoaXMuX19zY2hlZEVuZ2luZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgZW5naW5lID0gdGhpcy5fX3NjaGVkRW5naW5lc1tpXTtcbiAgICAgIHZhciB0aW1lID0gdGhpcy5fX3NjaGVkVGltZXNbaV07XG5cbiAgICAgIHdoaWxlICh0aW1lICYmIHRpbWUgPD0gY3VycmVudFRpbWUgKyB0aGlzLmxvb2thaGVhZCkge1xuICAgICAgICB0aW1lID0gTWF0aC5tYXgodGltZSwgY3VycmVudFRpbWUpO1xuICAgICAgICB0aGlzLl9fY3VycmVudFRpbWUgPSB0aW1lO1xuICAgICAgICB0aW1lID0gZW5naW5lLmFkdmFuY2VUaW1lKHRpbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZSAmJiB0aW1lIDwgSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5fX3NjaGVkVGltZXNbaSsrXSA9IHRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fdW5zY2hlZHVsZUVuZ2luZShlbmdpbmUpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBlbmdpbmUgZnJvbSBzY2hlZHVsZXJcbiAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgZW5naW5lLm1hc3RlciA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fX2VuZ2luZXMuZGVsZXRlKGVuZ2luZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9fY3VycmVudFRpbWUgPSBudWxsO1xuICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl9fc2NoZWRFbmdpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX190aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX190aWNrKCk7XG4gICAgICB9LCB0aGlzLnBlcmlvZCAqIDEwMDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXIgY3VycmVudCBsb2dpY2FsIHRpbWUuXG4gICAqXG4gICAqIEBuYW1lIGN1cnJlbnRUaW1lXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19jdXJyZW50VGltZSB8fCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMubG9va2FoZWFkO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gY2FsbCBhIGZ1bmN0aW9uIGF0IGEgZ2l2ZW4gdGltZVxuICAvKipcbiAgICogRGVmZXIgdGhlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uIGF0IGEgZ2l2ZW4gdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuIC0gRnVuY3Rpb24gdG8gZGVmZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPXRoaXMuY3VycmVudFRpbWVdIC0gU2NoZWR1bGUgdGltZVxuICAgKi9cbiAgZGVmZXIoZnVuLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xuICAgIGlmICghKGZ1biBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgZGVmZXJlZCBieSBzY2hlZHVsZXJcIik7XG5cbiAgICB0aGlzLmFkZCh7XG4gICAgICBhZHZhbmNlVGltZTogZnVuY3Rpb24odGltZSkgeyBmdW4odGltZSk7IH0sIC8vIG1ha2Ugc3VyIHRoYXQgdGhlIGFkdmFuY2VUaW1lIG1ldGhvZCBkb2VzIG5vdCByZXR1cm0gYW55dGhpbmdcbiAgICB9LCB0aW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBUaW1lRW5naW5lIGZ1bmN0aW9uIHRvIHRoZSBzY2hlZHVsZXIgYXQgYW4gb3B0aW9uYWxseSBnaXZlbiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIEVuZ2luZSB0byBhZGQgdG8gdGhlIHNjaGVkdWxlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9dGhpcy5jdXJyZW50VGltZV0gLSBTY2hlZHVsZSB0aW1lXG4gICAqL1xuICBhZGQoZW5naW5lLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xuICAgIGlmICghVGltZUVuZ2luZS5pbXBsZW1lbnRzU2NoZWR1bGVkKGVuZ2luZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgY2Fubm90IGJlIGFkZGVkIHRvIHNjaGVkdWxlclwiKTtcblxuICAgIGlmIChlbmdpbmUubWFzdGVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gYSBtYXN0ZXJcIik7XG5cbiAgICAvLyBzZXQgbWFzdGVyIGFuZCBhZGQgdG8gYXJyYXlcbiAgICBlbmdpbmUubWFzdGVyID0gdGhpcztcbiAgICB0aGlzLl9fZW5naW5lcy5hZGQoZW5naW5lKTtcblxuICAgIC8vIHNjaGVkdWxlIGVuZ2luZVxuICAgIHRoaXMuX19zY2hlZHVsZUVuZ2luZShlbmdpbmUsIHRpbWUpO1xuICAgIHRoaXMuX19yZXNldFRpY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBUaW1lRW5naW5lIGZyb20gdGhlIHNjaGVkdWxlciB0aGF0IGhhcyBiZWVuIGFkZGVkIHRvIHRoZVxuICAgKiBzY2hlZHVsZXIgdXNpbmcgdGhlIGFkZCBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIHJlbW92ZSBmcm9tIHRoZSBzY2hlZHVsZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPXRoaXMuY3VycmVudFRpbWVdIC0gU2NoZWR1bGUgdGltZVxuICAgKi9cbiAgcmVtb3ZlKGVuZ2luZSkge1xuICAgIGlmICghZW5naW5lLm1hc3RlciB8fCBlbmdpbmUubWFzdGVyICE9PSB0aGlzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW5naW5lIGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGlzIHNjaGVkdWxlclwiKTtcblxuICAgIC8vIHJlc2V0IG1hc3RlciBhbmQgcmVtb3ZlIGZyb20gYXJyYXlcbiAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcbiAgICB0aGlzLl9fZW5naW5lcy5kZWxldGUoZW5naW5lKTtcblxuICAgIC8vIHVuc2NoZWR1bGUgZW5naW5lXG4gICAgdGhpcy5fX3Vuc2NoZWR1bGVFbmdpbmUoZW5naW5lKTtcbiAgICB0aGlzLl9fcmVzZXRUaWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzY2hlZHVsZSBhIHNjaGVkdWxlZCB0aW1lIGVuZ2luZSBhdCBhIGdpdmVuIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIHJlc2NoZWR1bGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBTY2hlZHVsZSB0aW1lXG4gICAqL1xuICByZXNldEVuZ2luZVRpbWUoZW5naW5lLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xuICAgIHRoaXMuX19yZXNjaGVkdWxlRW5naW5lKGVuZ2luZSwgdGltZSk7XG4gICAgdGhpcy5fX3Jlc2V0VGljaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiBlbmdpbmUgaXMgc2NoZWR1bGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIEVuZ2luZSB0byBjaGVja1xuICAgKi9cbiAgaGFzKGVuZ2luZSkge1xuICAgIHJldHVybiB0aGlzLl9fZW5naW5lcy5oYXMoZW5naW5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGVuZ2luZXMgZnJvbSB0aGUgc2NoZWR1bGVyLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgaWYgKHRoaXMuX190aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fX3RpbWVvdXQpO1xuICAgICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX19zY2hlZEVuZ2luZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9fc2NoZWRUaW1lcy5sZW5ndGggPSAwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpbXBsZVNjaGVkdWxlcjtcbiIsImltcG9ydCBkZWZhdWx0QXVkaW9Db250ZXh0IGZyb20gJy4uL2NvcmUvYXVkaW8tY29udGV4dCc7XG5pbXBvcnQgUHJpb3JpdHlRdWV1ZSBmcm9tICcuLi9jb3JlL3ByaW9yaXR5LXF1ZXVlJztcbmltcG9ydCBTY2hlZHVsaW5nUXVldWUgZnJvbSAnLi4vY29yZS9zY2hlZHVsaW5nLXF1ZXVlJztcbmltcG9ydCBUaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvdGltZS1lbmdpbmUnO1xuaW1wb3J0IHsgZ2V0U2NoZWR1bGVyIH0gZnJvbSAnLi9mYWN0b3JpZXMnO1xuXG5cbmZ1bmN0aW9uIGFkZER1cGxldChmaXJzdEFycmF5LCBzZWNvbmRBcnJheSwgZmlyc3RFbGVtZW50LCBzZWNvbmRFbGVtZW50KSB7XG4gIGZpcnN0QXJyYXkucHVzaChmaXJzdEVsZW1lbnQpO1xuICBzZWNvbmRBcnJheS5wdXNoKHNlY29uZEVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBsZXQoZmlyc3RBcnJheSwgc2Vjb25kQXJyYXksIGZpcnN0RWxlbWVudCkge1xuICBjb25zdCBpbmRleCA9IGZpcnN0QXJyYXkuaW5kZXhPZihmaXJzdEVsZW1lbnQpO1xuXG4gIGlmIChpbmRleCA+PSAwKSB7XG4gICAgY29uc3Qgc2Vjb25kRWxlbWVudCA9IHNlY29uZEFycmF5W2luZGV4XTtcblxuICAgIGZpcnN0QXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBzZWNvbmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgcmV0dXJuIHNlY29uZEVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVGhlIFRyYW5zcG9ydGVkIGNhbGwgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgdGhlIGFkYXB0ZXJzIGJldHdlZW5cbi8vIGRpZmZlcmVudCB0eXBlcyBvZiBlbmdpbmVzIChpLmUuIHRyYW5zcG9ydGVkLCBzY2hlZHVsZWQsIHBsYXktY29udHJvbGxlZClcbi8vIFRoZSBhZGFwdGVycyBhcmUgYXQgdGhlIHNhbWUgdGltZSBtYXN0ZXJzIGZvciB0aGUgZW5naW5lcyBhZGRlZCB0byB0aGUgdHJhbnNwb3J0XG4vLyBhbmQgdHJhbnNwb3J0ZWQgVGltZUVuZ2luZXMgaW5zZXJ0ZWQgaW50byB0aGUgdHJhbnNwb3J0J3MgcG9zaXRpb24tYmFzZWQgcHJpdG9yaXR5IHF1ZXVlLlxuY2xhc3MgVHJhbnNwb3J0ZWQgZXh0ZW5kcyBUaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0LCBkdXJhdGlvbiwgb2Zmc2V0LCBzdHJldGNoID0gMSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tYXN0ZXIgPSB0cmFuc3BvcnQ7XG5cbiAgICB0aGlzLl9fZW5naW5lID0gZW5naW5lO1xuICAgIGVuZ2luZS5tYXN0ZXIgPSB0aGlzO1xuXG4gICAgdGhpcy5fX3N0YXJ0UG9zaXRpb24gPSBzdGFydDtcbiAgICB0aGlzLl9fZW5kUG9zaXRpb24gPSAhaXNGaW5pdGUoZHVyYXRpb24pID8gSW5maW5pdHkgOiBzdGFydCArIGR1cmF0aW9uO1xuICAgIHRoaXMuX19vZmZzZXRQb3NpdGlvbiA9IHN0YXJ0ICsgb2Zmc2V0O1xuICAgIHRoaXMuX19zdHJldGNoUG9zaXRpb24gPSBzdHJldGNoO1xuICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHNldEJvdW5kYXJpZXMoc3RhcnQsIGR1cmF0aW9uLCBvZmZzZXQgPSAwLCBzdHJldGNoID0gMSkge1xuICAgIHRoaXMuX19zdGFydFBvc2l0aW9uID0gc3RhcnQ7XG4gICAgdGhpcy5fX2VuZFBvc2l0aW9uID0gc3RhcnQgKyBkdXJhdGlvbjtcbiAgICB0aGlzLl9fb2Zmc2V0UG9zaXRpb24gPSBzdGFydCArIG9mZnNldDtcbiAgICB0aGlzLl9fc3RyZXRjaFBvc2l0aW9uID0gc3RyZXRjaDtcbiAgICB0aGlzLnJlc2V0UG9zaXRpb24oKTtcbiAgfVxuXG4gIHN0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge31cbiAgc3RvcCh0aW1lLCBwb3NpdGlvbikge31cblxuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFzdGVyLmN1cnJlbnRUaW1lO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXN0ZXIuY3VycmVudFBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uO1xuICB9XG5cbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgcG9zaXRpb24gKz0gdGhpcy5fX29mZnNldFBvc2l0aW9uO1xuXG4gICAgdGhpcy5tYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG4gIH1cblxuICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgaWYgKHNwZWVkID4gMCkge1xuICAgICAgaWYgKHBvc2l0aW9uIDwgdGhpcy5fX3N0YXJ0UG9zaXRpb24pIHtcblxuICAgICAgICBpZiAodGhpcy5fX2lzUnVubmluZylcbiAgICAgICAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGFydFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IHRoaXMuX19lbmRQb3NpdGlvbikge1xuICAgICAgICB0aGlzLnN0YXJ0KHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XG5cbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZW5kUG9zaXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMuX19lbmRQb3NpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fX2lzUnVubmluZykgLy8gaWYgZW5naW5lIGlzIHJ1bm5pbmdcbiAgICAgICAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbmRQb3NpdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPiB0aGlzLl9fc3RhcnRQb3NpdGlvbikge1xuICAgICAgICB0aGlzLnN0YXJ0KHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XG5cbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX2lzUnVubmluZykgLy8gaWYgZW5naW5lIGlzIHJ1bm5pbmdcbiAgICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbik7XG5cbiAgICB0aGlzLl9faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIEluZmluaXR5ICogc3BlZWQ7XG4gIH1cblxuICBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgaWYgKCF0aGlzLl9faXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLnN0YXJ0KHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICB0aGlzLl9faXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHNwZWVkID4gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbmRQb3NpdGlvbjtcblxuICAgICAgcmV0dXJuIHRoaXMuX19zdGFydFBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIHN0b3AgZW5naW5lXG4gICAgdGhpcy5zdG9wKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uKTtcblxuICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDtcbiAgfVxuXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBpZiAoc3BlZWQgPT09IDApIC8vIHN0b3BcbiAgICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbik7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubWFzdGVyID0gbnVsbDtcblxuICAgIHRoaXMuX19lbmdpbmUubWFzdGVyID0gbnVsbDtcbiAgICB0aGlzLl9fZW5naW5lID0gbnVsbDtcbiAgfVxufVxuXG4vLyBUcmFuc3BvcnRlZFRyYW5zcG9ydGVkXG4vLyBoYXMgdG8gc3dpdGNoIG9uIGFuZCBvZmYgdGhlIHNjaGVkdWxlZCBlbmdpbmVzIHdoZW4gdGhlIHRyYW5zcG9ydCBoaXRzIHRoZSBlbmdpbmUncyBzdGFydCBhbmQgZW5kIHBvc2l0aW9uXG5jbGFzcyBUcmFuc3BvcnRlZFRyYW5zcG9ydGVkIGV4dGVuZHMgVHJhbnNwb3J0ZWQge1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKSB7XG4gICAgc3VwZXIodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XG4gIH1cblxuICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgaWYgKHNwZWVkID4gMCAmJiBwb3NpdGlvbiA8IHRoaXMuX19lbmRQb3NpdGlvbilcbiAgICAgIHBvc2l0aW9uID0gTWF0aC5tYXgocG9zaXRpb24sIHRoaXMuX19zdGFydFBvc2l0aW9uKTtcbiAgICBlbHNlIGlmIChzcGVlZCA8IDAgJiYgcG9zaXRpb24gPj0gdGhpcy5fX3N0YXJ0UG9zaXRpb24pXG4gICAgICBwb3NpdGlvbiA9IE1hdGgubWluKHBvc2l0aW9uLCB0aGlzLl9fZW5kUG9zaXRpb24pO1xuXG4gICAgcmV0dXJuIHRoaXMuX19vZmZzZXRQb3NpdGlvbiArIHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XG4gIH1cblxuICBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgcG9zaXRpb24gPSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24gKyB0aGlzLl9fZW5naW5lLmFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbiwgc3BlZWQpO1xuXG4gICAgaWYgKHNwZWVkID4gMCAmJiBwb3NpdGlvbiA8IHRoaXMuX19lbmRQb3NpdGlvbiB8fCBzcGVlZCA8IDAgJiYgcG9zaXRpb24gPj0gdGhpcy5fX3N0YXJ0UG9zaXRpb24pXG4gICAgICByZXR1cm4gcG9zaXRpb247XG5cbiAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDtcbiAgfVxuXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBpZiAodGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQpXG4gICAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICB9XG5cbiAgcmVzZXRFbmdpbmVQb3NpdGlvbihlbmdpbmUsIHBvc2l0aW9uID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICBwb3NpdGlvbiArPSB0aGlzLl9fb2Zmc2V0UG9zaXRpb247XG5cbiAgICB0aGlzLnJlc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICB9XG59XG5cbi8vIFRyYW5zcG9ydGVkU3BlZWRDb250cm9sbGVkXG4vLyBoYXMgdG8gc3RhcnQgYW5kIHN0b3AgdGhlIHNwZWVkLWNvbnRyb2xsZWQgZW5naW5lcyB3aGVuIHRoZSB0cmFuc3BvcnQgaGl0cyB0aGUgZW5naW5lJ3Mgc3RhcnQgYW5kIGVuZCBwb3NpdGlvblxuY2xhc3MgVHJhbnNwb3J0ZWRTcGVlZENvbnRyb2xsZWQgZXh0ZW5kcyBUcmFuc3BvcnRlZCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pIHtcbiAgICBzdXBlcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcbiAgfVxuXG4gIHN0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgdHJ1ZSk7XG4gIH1cblxuICBzdG9wKHRpbWUsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIDApO1xuICB9XG5cbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIGlmICh0aGlzLl9faXNSdW5uaW5nKVxuICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGhpcy5tYXN0ZXIuY3VycmVudFRpbWUsIHRoaXMubWFzdGVyLmN1cnJlbnRQb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbiwgMCk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG59XG5cbi8vIFRyYW5zcG9ydGVkU2NoZWR1bGVkXG4vLyBoYXMgdG8gc3dpdGNoIG9uIGFuZCBvZmYgdGhlIHNjaGVkdWxlZCBlbmdpbmVzIHdoZW4gdGhlIHRyYW5zcG9ydCBoaXRzIHRoZSBlbmdpbmUncyBzdGFydCBhbmQgZW5kIHBvc2l0aW9uXG5jbGFzcyBUcmFuc3BvcnRlZFNjaGVkdWxlZCBleHRlbmRzIFRyYW5zcG9ydGVkIHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbikge1xuICAgIHN1cGVyKHRyYW5zcG9ydCwgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pO1xuXG4gICAgLy8gc2NoZWR1bGluZyBxdWV1ZSBiZWNvbWVzIG1hc3RlciBvZiBlbmdpbmVcbiAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcbiAgICB0cmFuc3BvcnQuX19zY2hlZHVsaW5nUXVldWUuYWRkKGVuZ2luZSwgSW5maW5pdHkpO1xuICB9XG5cbiAgc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgdGhpcy5tYXN0ZXIuX19zY2hlZHVsaW5nUXVldWUucmVzZXRFbmdpbmVUaW1lKHRoaXMuX19lbmdpbmUsIHRpbWUpO1xuICB9XG5cbiAgc3RvcCh0aW1lLCBwb3NpdGlvbikge1xuICAgIHRoaXMubWFzdGVyLl9fc2NoZWR1bGluZ1F1ZXVlLnJlc2V0RW5naW5lVGltZSh0aGlzLl9fZW5naW5lLCBJbmZpbml0eSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubWFzdGVyLl9fc2NoZWR1bGluZ1F1ZXVlLnJlbW92ZSh0aGlzLl9fZW5naW5lKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuLy8gdHJhbnNsYXRlcyBhZHZhbmNlUG9zaXRpb24gb2YgKnRyYW5zcG9ydGVkKiBlbmdpbmVzIGludG8gZ2xvYmFsIHNjaGVkdWxlciB0aW1lc1xuY2xhc3MgVHJhbnNwb3J0U2NoZWR1bGVySG9vayBleHRlbmRzIFRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBJbmZpbml0eTtcbiAgICB0aGlzLl9fbmV4dFRpbWUgPSBJbmZpbml0eTtcbiAgICB0cmFuc3BvcnQuX19zY2hlZHVsZXIuYWRkKHRoaXMsIEluZmluaXR5KTtcbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzY2hlZHVsZWQgaW50ZXJmYWNlKVxuICBhZHZhbmNlVGltZSh0aW1lKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5fX3RyYW5zcG9ydDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX19uZXh0UG9zaXRpb247XG4gICAgY29uc3Qgc3BlZWQgPSB0cmFuc3BvcnQuX19zcGVlZDtcbiAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB0cmFuc3BvcnQuYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgY29uc3QgbmV4dFRpbWUgPSB0cmFuc3BvcnQuX19nZXRUaW1lQXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xuXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IG5leHRQb3NpdGlvbjtcbiAgICB0aGlzLl9fbmV4dFRpbWUgPSBuZXh0VGltZTtcblxuICAgIHJldHVybiBuZXh0VGltZTtcbiAgfVxuXG4gIHJlc2V0UG9zaXRpb24ocG9zaXRpb24gPSB0aGlzLl9fbmV4dFBvc2l0aW9uKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5fX3RyYW5zcG9ydDtcbiAgICBjb25zdCB0aW1lID0gdHJhbnNwb3J0Ll9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pO1xuXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHRoaXMuX19uZXh0VGltZSA9IHRpbWU7XG5cbiAgICB0aGlzLnJlc2V0VGltZSh0aW1lKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fX3RyYW5zcG9ydC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5fX3RyYW5zcG9ydCA9IG51bGw7XG4gIH1cbn1cblxuLy8gaW50ZXJuYWwgc2NoZWR1bGluZyBxdWV1ZSB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgcG9zaXRpb24gKGFuZCB0aW1lKSBvZiB0aGUgcGxheSBjb250cm9sXG5jbGFzcyBUcmFuc3BvcnRTY2hlZHVsaW5nUXVldWUgZXh0ZW5kcyBTY2hlZHVsaW5nUXVldWUge1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0cmFuc3BvcnQuX19zY2hlZHVsZXIuYWRkKHRoaXMsIEluZmluaXR5KTtcbiAgfVxuXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RyYW5zcG9ydC5jdXJyZW50VGltZTtcbiAgfVxuXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX190cmFuc3BvcnQuY3VycmVudFBvc2l0aW9uO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9fdHJhbnNwb3J0Ll9fc2NoZWR1bGVyLnJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFByb3ZpZGVzIHN5bmNocm9uaXplZCBzY2hlZHVsaW5nIG9mIFRpbWUgRW5naW5lIGluc3RhbmNlcy5cbiAqXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3RyYW5zcG9ydC5odG1sfVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XG4gKiBjb25zdCB0cmFuc3BvcnQgPSBhdWRpby5UcmFuc3BvcnQoKTtcbiAqIGNvbnN0IHBsYXlDb250cm9sID0gbmV3IGF1ZGlvLlBsYXlDb250cm9sKHRyYW5zcG9ydCk7XG4gKiBjb25zdCBteUVuZ2luZSA9IG5ldyBNeUVuZ2luZSgpO1xuICogY29uc3QgeW91ckVuZ2luZSA9IG5ldyB5b3VyRW5naW5lKCk7XG4gKlxuICogdHJhbnNwb3J0LmFkZChteUVuZ2luZSk7XG4gKiB0cmFuc3BvcnQuYWRkKHlvdXJFbmdpbmUpO1xuICpcbiAqIHBsYXlDb250cm9sLnN0YXJ0KCk7XG4gKi9cbmNsYXNzIFRyYW5zcG9ydCBleHRlbmRzIFRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBvcHRpb25zLmF1ZGlvQ29udGV4dCB8fCBkZWZhdWx0QXVkaW9Db250ZXh0O1xuXG4gICAgdGhpcy5fX2VuZ2luZXMgPSBbXTtcbiAgICB0aGlzLl9fdHJhbnNwb3J0ZWQgPSBbXTtcblxuICAgIHRoaXMuX19zY2hlZHVsZXIgPSBnZXRTY2hlZHVsZXIodGhpcy5hdWRpb0NvbnRleHQpO1xuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rID0gbmV3IFRyYW5zcG9ydFNjaGVkdWxlckhvb2sodGhpcyk7XG4gICAgdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICAgIHRoaXMuX19zY2hlZHVsaW5nUXVldWUgPSBuZXcgVHJhbnNwb3J0U2NoZWR1bGluZ1F1ZXVlKHRoaXMpO1xuXG4gICAgLy8gc3luY3Jvbml6ZWQgdGltZSwgcG9zaXRpb24sIGFuZCBzcGVlZFxuICAgIHRoaXMuX190aW1lID0gMDtcbiAgICB0aGlzLl9fcG9zaXRpb24gPSAwO1xuICAgIHRoaXMuX19zcGVlZCA9IDA7XG4gIH1cblxuICBfX2dldFRpbWVBdFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX190aW1lICsgKHBvc2l0aW9uIC0gdGhpcy5fX3Bvc2l0aW9uKSAvIHRoaXMuX19zcGVlZDtcbiAgfVxuXG4gIF9fZ2V0UG9zaXRpb25BdFRpbWUodGltZSkge1xuICAgIHJldHVybiB0aGlzLl9fcG9zaXRpb24gKyAodGltZSAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcbiAgfVxuXG4gIF9fc3luY1RyYW5zcG9ydGVkUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgY29uc3QgbnVtVHJhbnNwb3J0ZWRFbmdpbmVzID0gdGhpcy5fX3RyYW5zcG9ydGVkLmxlbmd0aDtcbiAgICBsZXQgbmV4dFBvc2l0aW9uID0gSW5maW5pdHkgKiBzcGVlZDtcblxuICAgIGlmIChudW1UcmFuc3BvcnRlZEVuZ2luZXMgPiAwKSB7XG4gICAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5jbGVhcigpO1xuICAgICAgdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUucmV2ZXJzZSA9IChzcGVlZCA8IDApO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRyYW5zcG9ydGVkRW5naW5lczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX190cmFuc3BvcnRlZFtpXTtcbiAgICAgICAgY29uc3QgbmV4dEVuZ2luZVBvc2l0aW9uID0gZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICAgICAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5pbnNlcnQoZW5naW5lLCBuZXh0RW5naW5lUG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS50aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0UG9zaXRpb247XG4gIH1cblxuICBfX3N5bmNUcmFuc3BvcnRlZFNwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIGZvciAobGV0IHRyYW5zcG9ydGVkIG9mIHRoaXMuX190cmFuc3BvcnRlZClcbiAgICAgIHRyYW5zcG9ydGVkLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IG1hc3RlciB0aW1lLiBUaGlzIGdldHRlciB3aWxsIGJlIHJlcGxhY2VkIHdoZW4gdGhlIHRyYW5zcG9ydFxuICAgKiBpcyBhZGRlZCB0byBhIG1hc3RlciAoaS5lLiB0cmFuc3BvcnQgb3IgcGxheS1jb250cm9sKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgY3VycmVudFRpbWVcbiAgICogQG1lbWJlcm9mIFRyYW5zcG9ydFxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19zY2hlZHVsZXIuY3VycmVudFRpbWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgbWFzdGVyIHBvc2l0aW9uLiBUaGlzIGdldHRlciB3aWxsIGJlIHJlcGxhY2VkIHdoZW4gdGhlIHRyYW5zcG9ydFxuICAgKiBpcyBhZGRlZCB0byBhIG1hc3RlciAoaS5lLiB0cmFuc3BvcnQgb3IgcGxheS1jb250cm9sKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgY3VycmVudFBvc2l0aW9uXG4gICAqIEBtZW1iZXJvZiBUcmFuc3BvcnRcbiAgICogQGluc3RhbmNlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICBjb25zdCBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcblxuICAgIGlmIChtYXN0ZXIgJiYgbWFzdGVyLmN1cnJlbnRQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIG1hc3Rlci5jdXJyZW50UG9zaXRpb247XG5cbiAgICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uICsgKHRoaXMuX19zY2hlZHVsZXIuY3VycmVudFRpbWUgLSB0aGlzLl9fdGltZSkgKiB0aGlzLl9fc3BlZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgbmV4dCB0cmFuc3BvcnQgcG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5leHQgLSB0cmFuc3BvcnQgcG9zaXRpb25cbiAgICovXG4gIHJlc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBjb25zdCBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcblxuICAgIGlmIChtYXN0ZXIgJiYgbWFzdGVyLnJlc2V0RW5naW5lUG9zaXRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgIG1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9fc2NoZWR1bGVySG9vay5yZXNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgdHJhbnNwb3J0ZWQgdGltZSBlbmdpbmUgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkXG4gICAqL1xuICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgdGhpcy5fX3RpbWUgPSB0aW1lO1xuICAgIHRoaXMuX19wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHRoaXMuX19zcGVlZCA9IHNwZWVkO1xuXG4gICAgcmV0dXJuIHRoaXMuX19zeW5jVHJhbnNwb3J0ZWRQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSB0cmFuc3BvcnRlZCB0aW1lIGVuZ2luZSBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gc3BlZWRcbiAgICovXG4gIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5oZWFkO1xuICAgIGNvbnN0IG5leHRFbmdpbmVQb3NpdGlvbiA9IGVuZ2luZS5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgICByZXR1cm4gdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUubW92ZShlbmdpbmUsIG5leHRFbmdpbmVQb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIHRyYW5zcG9ydGVkIHRpbWUgZW5naW5lIGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzZWVrPWZhbHNlXVxuICAgKi9cbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlayA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGFzdFNwZWVkID0gdGhpcy5fX3NwZWVkO1xuXG4gICAgdGhpcy5fX3RpbWUgPSB0aW1lO1xuICAgIHRoaXMuX19wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHRoaXMuX19zcGVlZCA9IHNwZWVkO1xuXG4gICAgaWYgKHNwZWVkICE9PSBsYXN0U3BlZWQgfHwgKHNlZWsgJiYgc3BlZWQgIT09IDApKSB7XG4gICAgICBsZXQgbmV4dFBvc2l0aW9uO1xuXG4gICAgICAvLyByZXN5bmMgdHJhbnNwb3J0ZWQgZW5naW5lc1xuICAgICAgaWYgKHNlZWsgfHwgc3BlZWQgKiBsYXN0U3BlZWQgPCAwKSB7XG4gICAgICAgIC8vIHNlZWsgb3IgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RTcGVlZCA9PT0gMCkge1xuICAgICAgICAvLyBzdGFydFxuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fc3luY1RyYW5zcG9ydGVkUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgLy8gc3RvcFxuICAgICAgICBuZXh0UG9zaXRpb24gPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFNwZWVkKHRpbWUsIHBvc2l0aW9uLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNoYW5nZSBzcGVlZCB3aXRob3V0IHJldmVyc2luZyBkaXJlY3Rpb25cbiAgICAgICAgdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFNwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0aW1lIGVuZ2luZSB0byB0aGUgdHJhbnNwb3J0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW5naW5lIC0gZW5naW5lIHRvIGJlIGFkZGVkIHRvIHRoZSB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gc3RhcnQgcG9zaXRpb25cbiAgICovXG4gIGFkZChlbmdpbmUsIHN0YXJ0UG9zaXRpb24gPSAwLCBlbmRQb3NpdGlvbiA9IEluZmluaXR5LCBvZmZzZXRQb3NpdGlvbiA9IDApIHtcbiAgICBsZXQgdHJhbnNwb3J0ZWQgPSBudWxsO1xuXG4gICAgaWYgKG9mZnNldFBvc2l0aW9uID09PSAtSW5maW5pdHkpXG4gICAgICBvZmZzZXRQb3NpdGlvbiA9IDA7XG5cbiAgICBpZiAoZW5naW5lLm1hc3RlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIGEgbWFzdGVyXCIpO1xuXG4gICAgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1RyYW5zcG9ydGVkKGVuZ2luZSkpXG4gICAgICB0cmFuc3BvcnRlZCA9IG5ldyBUcmFuc3BvcnRlZFRyYW5zcG9ydGVkKHRoaXMsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcbiAgICBlbHNlIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNTcGVlZENvbnRyb2xsZWQoZW5naW5lKSlcbiAgICAgIHRyYW5zcG9ydGVkID0gbmV3IFRyYW5zcG9ydGVkU3BlZWRDb250cm9sbGVkKHRoaXMsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcbiAgICBlbHNlIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSlcbiAgICAgIHRyYW5zcG9ydGVkID0gbmV3IFRyYW5zcG9ydGVkU2NoZWR1bGVkKHRoaXMsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgY2Fubm90IGJlIGFkZGVkIHRvIGEgdHJhbnNwb3J0XCIpO1xuXG4gICAgaWYgKHRyYW5zcG9ydGVkKSB7XG4gICAgICBjb25zdCBzcGVlZCA9IHRoaXMuX19zcGVlZDtcblxuICAgICAgYWRkRHVwbGV0KHRoaXMuX19lbmdpbmVzLCB0aGlzLl9fdHJhbnNwb3J0ZWQsIGVuZ2luZSwgdHJhbnNwb3J0ZWQpO1xuXG4gICAgICBpZiAoc3BlZWQgIT09IDApIHtcbiAgICAgICAgLy8gc3luYyBhbmQgc3RhcnRcbiAgICAgICAgY29uc3QgbmV4dEVuZ2luZVBvc2l0aW9uID0gdHJhbnNwb3J0ZWQuc3luY1Bvc2l0aW9uKHRoaXMuY3VycmVudFRpbWUsIHRoaXMuY3VycmVudFBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLmluc2VydCh0cmFuc3BvcnRlZCwgbmV4dEVuZ2luZVBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLnJlc2V0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNwb3J0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdGltZSBlbmdpbmUgZnJvbSB0aGUgdHJhbnNwb3J0LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZW5naW5lT3JUcmFuc3BvcnRlZCAtIGVuZ2luZSBvciB0cmFuc3BvcnRlZCB0byBiZSByZW1vdmVkIGZyb20gdGhlIHRyYW5zcG9ydFxuICAgKi9cbiAgcmVtb3ZlKGVuZ2luZU9yVHJhbnNwb3J0ZWQpIHtcbiAgICBsZXQgZW5naW5lID0gZW5naW5lT3JUcmFuc3BvcnRlZDtcbiAgICBsZXQgdHJhbnNwb3J0ZWQgPSByZW1vdmVEdXBsZXQodGhpcy5fX2VuZ2luZXMsIHRoaXMuX190cmFuc3BvcnRlZCwgZW5naW5lT3JUcmFuc3BvcnRlZCk7XG5cbiAgICBpZiAoIXRyYW5zcG9ydGVkKSB7XG4gICAgICBlbmdpbmUgPSByZW1vdmVEdXBsZXQodGhpcy5fX3RyYW5zcG9ydGVkLCB0aGlzLl9fZW5naW5lcywgZW5naW5lT3JUcmFuc3BvcnRlZCk7XG4gICAgICB0cmFuc3BvcnRlZCA9IGVuZ2luZU9yVHJhbnNwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKGVuZ2luZSAmJiB0cmFuc3BvcnRlZCkge1xuICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUucmVtb3ZlKHRyYW5zcG9ydGVkKTtcblxuICAgICAgdHJhbnNwb3J0ZWQuZGVzdHJveSgpO1xuXG4gICAgICBpZiAodGhpcy5fX3NwZWVkICE9PSAwKVxuICAgICAgICB0aGlzLnJlc2V0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGlzIHRyYW5zcG9ydFwiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGVuZ2luZS5cbiAgICpcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfSB0cmFuc3BvcnRlZCAtIEVuZ2luZSB0byByZXNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBOZXcgcG9zaXRpb25cbiAgICovXG4gIHJlc2V0RW5naW5lUG9zaXRpb24odHJhbnNwb3J0ZWQsIHBvc2l0aW9uID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgc3BlZWQgPSB0aGlzLl9fc3BlZWQ7XG5cbiAgICBpZiAoc3BlZWQgIT09IDApIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBwb3NpdGlvbiA9IHRyYW5zcG9ydGVkLnN5bmNQb3NpdGlvbih0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmN1cnJlbnRQb3NpdGlvbiwgc3BlZWQpO1xuXG4gICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5tb3ZlKHRyYW5zcG9ydGVkLCBwb3NpdGlvbik7XG4gICAgICB0aGlzLnJlc2V0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0aW1lIGVuZ2luZXMgZnJvbSB0aGUgdHJhbnNwb3J0LlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5zeW5jU3BlZWQodGhpcy5jdXJyZW50VGltZSwgdGhpcy5jdXJyZW50UG9zaXRpb24sIDApO1xuXG4gICAgZm9yIChsZXQgdHJhbnNwb3J0ZWQgb2YgdGhpcy5fX3RyYW5zcG9ydGVkKVxuICAgICAgdHJhbnNwb3J0ZWQuZGVzdHJveSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zcG9ydDtcbiIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJyV2ZXJzaW9uJSc7XG5cbmltcG9ydCAqIGFzIF9jb3JlIGZyb20gJy4uL2NvcmUnO1xuZXhwb3J0IGNvbnN0IGNvcmUgPSBfY29yZTtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBvcGVyYXRvciB9IGZyb20gJy4vb3BlcmF0b3IvX25hbWVzcGFjZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNpbmsgfSBmcm9tICcuL3NpbmsvX25hbWVzcGFjZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNvdXJjZSB9IGZyb20gJy4vc291cmNlL19uYW1lc3BhY2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB1dGlscyB9IGZyb20gJy4vdXRpbHMvX25hbWVzcGFjZSc7XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5jb25zdCBzaW4gPSBNYXRoLnNpbjtcbmNvbnN0IGNvcyA9IE1hdGguY29zO1xuY29uc3Qgc3FydCA9IE1hdGguc3FydDtcbmNvbnN0IHBvdyA9IE1hdGgucG93O1xuY29uc3QgXzJQSSA9IE1hdGguUEkgKiAyO1xuXG4vLyBwbG90IChmcm9tIGh0dHA6Ly93d3cuZWFybGV2ZWwuY29tL3NjcmlwdHMvd2lkZ2V0cy8yMDEzMTAxMy9iaXF1YWRzMi5qcylcbi8vIHZhciBsZW4gPSA1MTI7XG4vLyB2YXIgbWFnUGxvdCA9IFtdO1xuLy8gZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuOyBpZHgrKykge1xuLy8gICB2YXIgdztcbi8vICAgaWYgKHBsb3RUeXBlID09IFwibGluZWFyXCIpXG4vLyAgICAgdyA9IGlkeCAvIChsZW4gLSAxKSAqIE1hdGguUEk7ICAvLyAwIHRvIHBpLCBsaW5lYXIgc2NhbGVcbi8vICAgZWxzZVxuLy8gICAgIHcgPSBNYXRoLmV4cChNYXRoLmxvZygxIC8gMC4wMDEpICogaWR4IC8gKGxlbiAtIDEpKSAqIDAuMDAxICogTWF0aC5QSTsgIC8vIDAuMDAxIHRvIDEsIHRpbWVzIHBpLCBsb2cgc2NhbGVcblxuLy8gICB2YXIgcGhpID0gTWF0aC5wb3coTWF0aC5zaW4ody8yKSwgMik7XG4vLyAgIHZhciB5ID0gTWF0aC5sb2coTWF0aC5wb3coYTArYTErYTIsIDIpIC0gNCooYTAqYTEgKyA0KmEwKmEyICsgYTEqYTIpKnBoaSArIDE2KmEwKmEyKnBoaSpwaGkpIC0gTWF0aC5sb2coTWF0aC5wb3coMStiMStiMiwgMikgLSA0KihiMSArIDQqYjIgKyBiMSpiMikqcGhpICsgMTYqYjIqcGhpKnBoaSk7XG4vLyAgIHkgPSB5ICogMTAgLyBNYXRoLkxOMTBcbi8vICAgaWYgKHkgPT0gLUluZmluaXR5KVxuLy8gICAgIHkgPSAtMjAwO1xuXG4vLyAgIGlmIChwbG90VHlwZSA9PSBcImxpbmVhclwiKVxuLy8gICAgIG1hZ1Bsb3QucHVzaChbaWR4IC8gKGxlbiAtIDEpICogRnMgLyAyLCB5XSk7XG4vLyAgIGVsc2Vcbi8vICAgICBtYWdQbG90LnB1c2goW2lkeCAvIChsZW4gLSAxKSAvIDIsIHldKTtcblxuLy8gICBpZiAoaWR4ID09IDApXG4vLyAgICAgbWluVmFsID0gbWF4VmFsID0geTtcbi8vICAgZWxzZSBpZiAoeSA8IG1pblZhbClcbi8vICAgICBtaW5WYWwgPSB5O1xuLy8gICBlbHNlIGlmICh5ID4gbWF4VmFsKVxuLy8gICAgIG1heFZhbCA9IHk7XG4vLyB9XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICB0eXBlOiB7XG4gICAgdHlwZTogJ2VudW0nLFxuICAgIGRlZmF1bHQ6ICdsb3dwYXNzJyxcbiAgICBsaXN0OiBbXG4gICAgICAnbG93cGFzcycsXG4gICAgICAnaGlnaHBhc3MnLFxuICAgICAgJ2JhbmRwYXNzX2NvbnN0YW50X3NraXJ0JyxcbiAgICAgICdiYW5kcGFzcycsXG4gICAgICAnYmFuZHBhc3NfY29uc3RhbnRfcGVhaycsXG4gICAgICAnbm90Y2gnLFxuICAgICAgJ2FsbHBhc3MnLFxuICAgICAgJ3BlYWtpbmcnLFxuICAgICAgJ2xvd3NoZWxmJyxcbiAgICAgICdoaWdoc2hlbGYnLFxuICAgIF0sXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH0sXG4gIH0sXG4gIGYwOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9LFxuICB9LFxuICBnYWluOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbjogMCxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfSxcbiAgfSxcbiAgcToge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtaW46IDAuMDAxLCAvLyBQSVBPX0JJUVVBRF9NSU5fUVxuICAgIC8vIG1heDogMSxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfSxcbiAgfSxcbiAgLy8gYmFuZHdpZHRoOiB7XG4gIC8vICAgdHlwZTogJ2Zsb2F0JyxcbiAgLy8gICBkZWZhdWx0OiBudWxsLFxuICAvLyAgIG51bGxhYmxlOiB0cnVlLFxuICAvLyAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9LFxuICAvLyB9LFxufVxuXG5cbi8qKlxuICogQmlxdWFkIGZpbHRlciAoRGlyZWN0IGZvcm0gSSkuIElmIGlucHV0IGlzIG9mIHR5cGUgYHZlY3RvcmAgdGhlIGZpbHRlciBpc1xuICogYXBwbGllZCBvbiBlYWNoIGRpbWVuc2lvbiBpIHBhcmFsbGVsLlxuICpcbiAqIEJhc2VkIG9uIHRoZSBbXCJDb29rYm9vayBmb3JtdWxhZSBmb3IgYXVkaW8gRVEgYmlxdWFkIGZpbHRlciBjb2VmZmljaWVudHNcIl0oaHR0cDovL3d3dy5tdXNpY2RzcC5vcmcvZmlsZXMvQXVkaW8tRVEtQ29va2Jvb2sudHh0KVxuICogYnkgUm9iZXJ0IEJyaXN0b3ctSm9obnNvbi5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHlwZT0nbG93cGFzcyddIC0gVHlwZSBvZiB0aGUgZmlsdGVyLiBBdmFpbGFibGVcbiAqICBmaWx0ZXJzOiAnbG93cGFzcycsICdoaWdocGFzcycsICdiYW5kcGFzc19jb25zdGFudF9za2lydCcsICdiYW5kcGFzc19jb25zdGFudF9wZWFrJ1xuICogIChhbGlhcyAnYmFuZHBhc3MnKSwgJ25vdGNoJywgJ2FsbHBhc3MnLCAncGVha2luZycsICdsb3dzaGVsZicsICdoaWdoc2hlbGYnLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmYwPTFdIC0gQ3V0b2ZmIG9yIGNlbnRlciBmcmVxdWVuY3kgb2YgdGhlIGZpbHRlclxuICogIGFjY29yZGluZyB0byBpdHMgdHlwZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5nYWluPTFdIC0gR2FpbiBvZiB0aGUgZmlsdGVyIChpbiBkQikuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucT0xXSAtIFF1YWxpdHkgZmFjdG9yIG9mIHRoZSBmaWx0ZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAqXG4gKiBjb25zdCBhdWRpb0luQnVmZmVyID0gbmV3IGxmby5zb3VyY2UuQXVkaW9JbkJ1ZmZlcih7XG4gKiAgIGF1ZGlvQnVmZmVyOiBidWZmZXIsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBiaXF1YWQgPSBuZXcgbGZvLm9wZXJhdG9yLkJpcXVhZCh7XG4gKiAgIHR5cGU6ICdsb3dwYXNzJyxcbiAqICAgZjA6IDIwMDAsXG4gKiAgIGdhaW46IDMsXG4gKiAgIHE6IDEyLFxuICogfSk7XG4gKlxuICogY29uc3Qgc3BlY3RydW1EaXNwbGF5ID0gbmV3IGxmby5zaW5rLlNwZWN0cnVtRGlzcGxheSh7XG4gKiAgIGNhbnZhczogJyNzcGVjdHJ1bScsXG4gKiB9KTtcbiAqXG4gKiBhdWRpb0luQnVmZmVyLmNvbm5lY3QoYmlxdWFkKTtcbiAqIGJpcXVhZC5jb25uZWN0KHNwZWN0cnVtRGlzcGxheSk7XG4gKlxuICogYXVkaW9JbkJ1ZmZlci5zdGFydCgpO1xuICovXG5jbGFzcyBCaXF1YWQgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoZGVmaW5pdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgb25QYXJhbVVwZGF0ZShuYW1lLCB2YWx1ZSwgbWV0YXMpIHtcbiAgICB0aGlzLl9jYWxjdWxhdGVDb2VmcygpO1xuICB9XG5cbiAgX2NhbGN1bGF0ZUNvZWZzKCkge1xuICAgIGNvbnN0IHNhbXBsZVJhdGUgPSB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlO1xuICAgIGNvbnN0IGZyYW1lVHlwZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZTtcbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5wYXJhbXMuZ2V0KCd0eXBlJyk7XG4gICAgY29uc3QgZjAgPSB0aGlzLnBhcmFtcy5nZXQoJ2YwJyk7XG4gICAgY29uc3QgZ2FpbiA9IHRoaXMucGFyYW1zLmdldCgnZ2FpbicpO1xuICAgIGNvbnN0IHEgPSB0aGlzLnBhcmFtcy5nZXQoJ3EnKTtcbiAgICAvLyBjb25zdCBiYW5kd2lkdGggPSB0aGlzLnBhcmFtcy5nZXQoJ2JhbmR3aWR0aCcpO1xuICAgIGNvbnN0IGJhbmR3aWR0aCA9IG51bGw7XG5cbiAgICBsZXQgYjAgPSAwLCBiMSA9IDAsIGIyID0gMCwgYTAgPSAwLCBhMSA9IDAsIGEyID0gMDtcblxuICAgIGNvbnN0IEEgPSBwb3coMTAsIGdhaW4gLyA0MCk7XG4gICAgY29uc3QgdzAgPSBfMlBJICogZjAgLyBzYW1wbGVSYXRlO1xuICAgIGNvbnN0IGNvc1cwID0gY29zKHcwKTtcbiAgICBjb25zdCBzaW5XMCA9IHNpbih3MCk7XG4gICAgbGV0IGFscGhhOyAvLyBkZXBlbmQgb2YgdGhlIGZpbHRlciB0eXBlXG4gICAgbGV0IF8yUm9vdEFBbHBoYTsgLy8gaW50ZXJtZWRpYXRlIHZhbHVlIGZvciBsb3dzaGVsZiBhbmQgaGlnaHNoZWxmXG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIC8vIEgocykgPSAxIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICBjYXNlICdsb3dwYXNzJzpcbiAgICAgICAgYWxwaGEgPSBzaW5XMCAvICgyICogcSk7XG4gICAgICAgIGIwID0gKDEgLSBjb3NXMCkgLyAyO1xuICAgICAgICBiMSA9IDEgLSBjb3NXMDtcbiAgICAgICAgYjIgPSBiMDtcbiAgICAgICAgYTAgPSAxICsgYWxwaGE7XG4gICAgICAgIGExID0gLTIgKiBjb3NXMDtcbiAgICAgICAgYTIgPSAxIC1hbHBoYTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBIKHMpID0gc14yIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICBjYXNlICdoaWdocGFzcyc6XG4gICAgICAgIGFscGhhID0gc2luVzAgLyAoMiAqIHEpO1xuICAgICAgICBiMCA9ICgxICsgY29zVzApIC8gMjtcbiAgICAgICAgYjEgPSAtICgxICsgY29zVzApXG4gICAgICAgIGIyID0gYjA7XG4gICAgICAgIGEwID0gMSArIGFscGhhO1xuICAgICAgICBhMSA9IC0yICogY29zVzA7XG4gICAgICAgIGEyID0gMSAtIGFscGhhO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIEgocykgPSBzIC8gKHNeMiArIHMvUSArIDEpICAoY29uc3RhbnQgc2tpcnQgZ2FpbiwgcGVhayBnYWluID0gUSlcbiAgICAgIGNhc2UgJ2JhbmRwYXNzX2NvbnN0YW50X3NraXJ0JzpcbiAgICAgICAgaWYgKGJhbmR3aWR0aCkge1xuICAgICAgICAgIC8vIHNpbih3MCkqc2luaCggbG4oMikvMiAqIEJXICogdzAvc2luKHcwKSApICAgICAgICAgICAoY2FzZTogQlcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxwaGEgPSBzaW5XMCAvICgyICogcSk7XG4gICAgICAgIH1cblxuICAgICAgICBiMCA9IHNpblcwIC8gMjtcbiAgICAgICAgYjEgPSAwO1xuICAgICAgICBiMiA9IC1iMDtcbiAgICAgICAgYTAgPSAxICsgYWxwaGE7XG4gICAgICAgIGExID0gLTIgKiBjb3NXMDtcbiAgICAgICAgYTIgPSAxIC0gYWxwaGE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gSChzKSA9IChzL1EpIC8gKHNeMiArIHMvUSArIDEpICAgICAgKGNvbnN0YW50IDAgZEIgcGVhayBnYWluKVxuICAgICAgY2FzZSAnYmFuZHBhc3MnOiAvLyBsb29rcyBsaWtlIHdoYXQgaXMgZ25lcmFsbHkgY29uc2lkZXJlZCBhcyBhIGJhbmRwYXNzXG4gICAgICBjYXNlICdiYW5kcGFzc19jb25zdGFudF9wZWFrJzpcbiAgICAgICAgaWYgKGJhbmR3aWR0aCkge1xuICAgICAgICAgIC8vIHNpbih3MCkqc2luaCggbG4oMikvMiAqIEJXICogdzAvc2luKHcwKSApICAgICAgICAgICAoY2FzZTogQlcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxwaGEgPSBzaW5XMCAvICgyICogcSk7XG4gICAgICAgIH1cblxuICAgICAgICBiMCA9IGFscGhhO1xuICAgICAgICBiMSA9IDA7XG4gICAgICAgIGIyID0gLWFscGhhO1xuICAgICAgICBhMCA9IDEgKyBhbHBoYTtcbiAgICAgICAgYTEgPSAtMiAqIGNvc1cwO1xuICAgICAgICBhMiA9IDEgLSBhbHBoYTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBIKHMpID0gKHNeMiArIDEpIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICBjYXNlICdub3RjaCc6XG4gICAgICAgIGFscGhhID0gc2luVzAgLyAoMiAqIHEpO1xuICAgICAgICBiMCA9IDE7XG4gICAgICAgIGIxID0gLTIgKiBjb3NXMDtcbiAgICAgICAgYjIgPSAxO1xuICAgICAgICBhMCA9IDEgKyBhbHBoYTtcbiAgICAgICAgYTEgPSBiMTtcbiAgICAgICAgYTIgPSAxIC0gYWxwaGE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gSChzKSA9IChzXjIgLSBzL1EgKyAxKSAvIChzXjIgKyBzL1EgKyAxKVxuICAgICAgY2FzZSAnYWxscGFzcyc6XG4gICAgICAgIGFscGhhID0gc2luVzAgLyAoMiAqIHEpO1xuICAgICAgICBiMCA9IDEgLSBhbHBoYTtcbiAgICAgICAgYjEgPSAtMiAqIGNvc1cwO1xuICAgICAgICBiMiA9IDEgKyBhbHBoYTtcbiAgICAgICAgYTAgPSBiMjtcbiAgICAgICAgYTEgPSBiMTtcbiAgICAgICAgYTIgPSBiMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBIKHMpID0gKHNeMiArIHMqKEEvUSkgKyAxKSAvIChzXjIgKyBzLyhBKlEpICsgMSlcbiAgICAgIGNhc2UgJ3BlYWtpbmcnOlxuICAgICAgICBpZiAoYmFuZHdpZHRoKSB7XG4gICAgICAgICAgLy8gc2luKHcwKSpzaW5oKCBsbigyKS8yICogQlcgKiB3MC9zaW4odzApICkgICAgICAgICAgIChjYXNlOiBCVylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHBoYSA9IHNpblcwIC8gKDIgKiBxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGIwID0gMSArIGFscGhhICogQTtcbiAgICAgICAgYjEgPSAtMiAqIGNvc1cwO1xuICAgICAgICBiMiA9IDEgLSBhbHBoYSAqIEE7XG4gICAgICAgIGEwID0gMSArIGFscGhhIC8gQTtcbiAgICAgICAgYTEgPSBiMTtcbiAgICAgICAgYTIgPSAxIC0gYWxwaGEgLyBBO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIEgocykgPSBBICogKHNeMiArIChzcXJ0KEEpL1EpKnMgKyBBKS8oQSpzXjIgKyAoc3FydChBKS9RKSpzICsgMSlcbiAgICAgIGNhc2UgJ2xvd3NoZWxmJzpcbiAgICAgICAgYWxwaGEgPSBzaW5XMCAvICgyICogcSk7XG4gICAgICAgIF8yUm9vdEFBbHBoYSA9IDIgKiBzcXJ0KEEpICogYWxwaGE7XG5cbiAgICAgICAgYjAgPSAgICAgQSAqICgoQSArIDEpIC0gKEEgLSAxKSAqIGNvc1cwICsgXzJSb290QUFscGhhKTtcbiAgICAgICAgYjEgPSAyICogQSAqICgoQSAtIDEpIC0gKEEgKyAxKSAqIGNvc1cwKTtcbiAgICAgICAgYjIgPSAgICAgQSAqICgoQSArIDEpIC0gKEEgLSAxKSAqIGNvc1cwIC0gXzJSb290QUFscGhhKTtcbiAgICAgICAgYTAgPSAgICAgICAgICAoQSArIDEpICsgKEEgLSAxKSAqIGNvc1cwICsgXzJSb290QUFscGhhO1xuICAgICAgICBhMSA9ICAgIC0yICogKChBIC0gMSkgKyAoQSArIDEpICogY29zVzApO1xuICAgICAgICBhMiA9ICAgICAgICAgIChBICsgMSkgKyAoQSAtIDEpICogY29zVzAgLSBfMlJvb3RBQWxwaGE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gSChzKSA9IEEgKiAoQSpzXjIgKyAoc3FydChBKS9RKSpzICsgMSkvKHNeMiArIChzcXJ0KEEpL1EpKnMgKyBBKVxuICAgICAgY2FzZSAnaGlnaHNoZWxmJzpcbiAgICAgICAgYWxwaGEgPSBzaW5XMCAvICgyICogcSk7XG4gICAgICAgIF8yUm9vdEFBbHBoYSA9IDIgKiBzcXJ0KEEpICogYWxwaGE7XG5cbiAgICAgICAgYjAgPSAgICAgIEEgKiAoKEEgKyAxKSArIChBIC0gMSkgKiBjb3NXMCArIF8yUm9vdEFBbHBoYSk7XG4gICAgICAgIGIxID0gLTIgKiBBICogKChBIC0gMSkgKyAoQSArIDEpICogY29zVzApO1xuICAgICAgICBiMiA9ICAgICAgQSAqICgoQSArIDEpICsgKEEgLSAxKSAqIGNvc1cwIC0gXzJSb290QUFscGhhKTtcbiAgICAgICAgYTAgPSAgICAgICAgICAgKEEgKyAxKSAtIChBIC0gMSkgKiBjb3NXMCArIF8yUm9vdEFBbHBoYTtcbiAgICAgICAgYTEgPSAgICAgIDIgKiAoKEEgLSAxKSAtIChBICsgMSkgKiBjb3NXMCk7XG4gICAgICAgIGEyID0gICAgICAgICAgIChBICsgMSkgLSAoQSAtIDEpICogY29zVzAgLSBfMlJvb3RBQWxwaGE7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5jb2VmcyA9IHtcbiAgICAgIGIwOiBiMCAvIGEwLFxuICAgICAgYjE6IGIxIC8gYTAsXG4gICAgICBiMjogYjIgLyBhMCxcbiAgICAgIGExOiBhMSAvIGEwLFxuICAgICAgYTI6IGEyIC8gYTAsXG4gICAgfTtcblxuICAgIC8vIHJlc2V0IHN0YXRlXG4gICAgaWYgKGZyYW1lVHlwZSA9PT0gJ3NpZ25hbCcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7IHgxOiAwLCB4MjogMCwgeTE6IDAsIHkyOiAwIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIHgxOiBuZXcgRmxvYXQzMkFycmF5KGZyYW1lU2l6ZSksXG4gICAgICAgIHgyOiBuZXcgRmxvYXQzMkFycmF5KGZyYW1lU2l6ZSksXG4gICAgICAgIHkxOiBuZXcgRmxvYXQzMkFycmF5KGZyYW1lU2l6ZSksXG4gICAgICAgIHkyOiBuZXcgRmxvYXQzMkFycmF5KGZyYW1lU2l6ZSksXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAvLyBpZiBubyBgc2FtcGxlUmF0ZWAgb3IgYHNhbXBsZVJhdGVgIGlzIDAgd2Ugc2hhbGwgaGFsdCFcbiAgICBjb25zdCBzYW1wbGVSYXRlID0gdGhpcy5zdHJlYW1QYXJhbXMuc291cmNlU2FtcGxlUmF0ZTtcblxuICAgIGlmICghc2FtcGxlUmF0ZSB8fCBzYW1wbGVSYXRlIDw9IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2FtcGxlUmF0ZSB2YWx1ZSAoMCkgZm9yIGJpcXVhZCcpO1xuXG4gICAgdGhpcy5fY2FsY3VsYXRlQ29lZnMoKTtcbiAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NWZWN0b3IoZnJhbWUpIHtcbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgY29uc3Qgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICBjb25zdCBpbkRhdGEgPSBmcmFtZS5kYXRhO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb2VmcyA9IHRoaXMuY29lZnM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaW5EYXRhW2ldO1xuICAgICAgY29uc3QgeSA9IGNvZWZzLmIwICogeFxuICAgICAgICAgICAgICArIGNvZWZzLmIxICogc3RhdGUueDFbaV0gKyBjb2Vmcy5iMiAqIHN0YXRlLngyW2ldXG4gICAgICAgICAgICAgIC0gY29lZnMuYTEgKiBzdGF0ZS55MVtpXSAtIGNvZWZzLmEyICogc3RhdGUueTJbaV07XG5cbiAgICAgIG91dERhdGFbaV0gPSB5O1xuXG4gICAgICAvLyB1cGRhdGUgc3RhdGVzXG4gICAgICBzdGF0ZS54MltpXSA9IHN0YXRlLngxW2ldO1xuICAgICAgc3RhdGUueDFbaV0gPSB4O1xuICAgICAgc3RhdGUueTJbaV0gPSBzdGF0ZS55MVtpXTtcbiAgICAgIHN0YXRlLnkxW2ldID0geTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1NpZ25hbChmcmFtZSkge1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgIGNvbnN0IGluRGF0YSA9IGZyYW1lLmRhdGE7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvZWZzID0gdGhpcy5jb2VmcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpbkRhdGFbaV07XG4gICAgICBjb25zdCB5ID0gY29lZnMuYjAgKiB4XG4gICAgICAgICAgICAgICsgY29lZnMuYjEgKiBzdGF0ZS54MSArIGNvZWZzLmIyICogc3RhdGUueDJcbiAgICAgICAgICAgICAgLSBjb2Vmcy5hMSAqIHN0YXRlLnkxIC0gY29lZnMuYTIgKiBzdGF0ZS55MjtcblxuICAgICAgb3V0RGF0YVtpXSA9IHk7XG5cbiAgICAgIC8vIHVwZGF0ZSBzdGF0ZXNcbiAgICAgIHN0YXRlLngyID0gc3RhdGUueDE7XG4gICAgICBzdGF0ZS54MSA9IHg7XG4gICAgICBzdGF0ZS55MiA9IHN0YXRlLnkxO1xuICAgICAgc3RhdGUueTEgPSB5O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCaXF1YWQ7XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgbWluOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1pbjogLUluZmluaXR5LFxuICAgIG1heDogK0luZmluaXR5LFxuICB9LFxuICBtYXg6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluOiAtSW5maW5pdHksXG4gICAgbWF4OiArSW5maW5pdHksXG4gIH0sXG59O1xuXG4vKipcbiAqIENsaXAgaW5jb21taW5nIGFjY29yZGluZyB0byBnaXZlbiBgbWluYCBhbmQgYG1heGAgcGFyYW1ldGVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbXRlcnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW49MF0gLSBNaW5pbXVtIHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4PTFdIC0gTWF4aW11bSB2YWx1ZVxuICovXG5jbGFzcyBDbGlwIGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxuICBpbnB1dFZlY3RvcihkYXRhKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5wYXJhbXMuZ2V0KCdtaW4nKTtcbiAgICBjb25zdCBtYXggPSB0aGlzLnBhcmFtcy5nZXQoJ21heCcpO1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuXG4gICAgLy8gQHRvZG8gLSBjb3VsZCBoYW5kbGUgdmVjdG9yIGFzIG1pbiBhbmQgbWF4XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKylcbiAgICAgIG91dERhdGFbaV0gPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgZGF0YVtpXSkpO1xuXG4gICAgcmV0dXJuIG91dERhdGE7XG4gIH1cblxuICBwcm9jZXNzVmVjdG9yKGZyYW1lKSB7XG4gICAgdGhpcy5mcmFtZS5kYXRhID0gdGhpcy5pbnB1dFZlY3RvcihmcmFtZS5kYXRhKTtcbiAgfVxuXG4gIGlucHV0U2lnbmFsKGRhdGEpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLnBhcmFtcy5nZXQoJ21pbicpO1xuICAgIGNvbnN0IG1heCA9IHRoaXMucGFyYW1zLmdldCgnbWF4Jyk7XG4gICAgY29uc3QgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgIGNvbnN0IG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKVxuICAgICAgb3V0RGF0YVtpXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCBkYXRhW2ldKSk7XG5cbiAgICByZXR1cm4gb3V0RGF0YTtcbiAgfVxuXG4gIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICB0aGlzLmZyYW1lLmRhdGEgPSB0aGlzLmlucHV0U2lnbmFsKGZyYW1lLmRhdGEpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENsaXA7XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5jb25zdCBzcXJ0ID0gTWF0aC5zcXJ0O1xuY29uc3QgY29zID0gTWF0aC5jb3M7XG5jb25zdCBQSSA9IE1hdGguUEk7XG5cbi8vIERjdCBUeXBlIDIgLSBvcnRob2dvbmFsIG1hdHJpeCBzY2FsaW5nXG5mdW5jdGlvbiBnZXREY3RXZWlnaHRzKG9yZGVyLCBOLCB0eXBlID0gJ2h0aycpIHtcbiAgY29uc3Qgd2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkoTiAqIG9yZGVyKTtcbiAgY29uc3QgcGlPdmVyTiA9IFBJIC8gTjtcbiAgY29uc3Qgc2NhbGUwID0gMSAvIHNxcnQoMik7XG4gIGNvbnN0IHNjYWxlID0gc3FydCgyIC8gTik7XG5cbiAgZm9yIChsZXQgayA9IDA7IGsgPCBvcmRlcjsgaysrKSB7XG4gICAgY29uc3QgcyA9IChrID09PSAwKSA/IChzY2FsZTAgKiBzY2FsZSkgOiBzY2FsZTtcbiAgICAvLyBjb25zdCBzID0gc2NhbGU7IC8vIHJ0YSBkb2Vzbid0IGFwcGx5IGs9MCBzY2FsaW5nXG5cbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IE47IG4rKylcbiAgICAgIHdlaWdodHNbayAqIE4gKyBuXSA9IHMgKiBjb3MoayAqIChuICsgMC41KSAqIHBpT3Zlck4pO1xuICB9XG5cbiAgcmV0dXJuIHdlaWdodHM7XG59XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICBvcmRlcjoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAxMixcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9LFxufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBEaXNjcmV0ZSBDb3NpbmUgVHJhbnNmb3JtIG9mIGFuIGlucHV0IGBzaWduYWxgIG9yIGB2ZWN0b3JgLlxuICogKEhUSyBzdHlsZSB3ZWlnaHRpbmcpLlxuICpcbiAqIF9zdXBwb3J0IGBzdGFuZGFsb25lYCB1c2FnZV9cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9yZGVyPTEyXSAtIE51bWJlciBvZiBjb21wdXRlZCBiaW5zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogLy8gYXNzdW1pbmcgc29tZSBhdWRpbyBidWZmZXJcbiAqIGNvbnN0IHNvdXJjZSA9IG5ldyBBdWRpb0luQnVmZmVyKHtcbiAqICAgYXVkaW9CdWZmZXI6IGF1ZGlvQnVmZmVyLFxuICogICB1c2VXb3JrZXI6IGZhbHNlLFxuICogfSk7XG4gKlxuICogY29uc3Qgc2xpY2VyID0gbmV3IFNsaWNlcih7XG4gKiAgIGZyYW1lU2l6ZTogNTEyLFxuICogICBob3BTaXplOiA1MTIsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBkY3QgPSBuZXcgRGN0KHtcbiAqICAgb3JkZXI6IDEyLFxuICogfSk7XG4gKlxuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogc291cmNlLmNvbm5lY3Qoc2xpY2VyKTtcbiAqIHNsaWNlci5jb25uZWN0KGRjdCk7XG4gKiBkY3QuY29ubmVjdChsb2dnZXIpO1xuICpcbiAqIHNvdXJjZS5zdGFydCgpO1xuICovXG5jbGFzcyBEY3QgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoZGVmaW5pdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgIGNvbnN0IG9yZGVyID0gdGhpcy5wYXJhbXMuZ2V0KCdvcmRlcicpO1xuICAgIGNvbnN0IGluRnJhbWVTaXplID0gcHJldlN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG5cbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPSBvcmRlcjtcbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVR5cGUgPSAndmVjdG9yJztcbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5kZXNjcmlwdGlvbiA9IFtdO1xuXG4gICAgdGhpcy53ZWlnaHRNYXRyaXggPSBnZXREY3RXZWlnaHRzKG9yZGVyLCBpbkZyYW1lU2l6ZSk7XG5cbiAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGUgYERjdGAgb3BlcmF0b3IgaW4gYHN0YW5kYWxvbmVgIG1vZGUgKGkuZS4gb3V0c2lkZSBvZiBhIGdyYXBoKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gSW5wdXQgdmFsdWVzLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBEY3Qgb2YgdGhlIGlucHV0IGFycmF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkY3QgPSBuZXcgbGZvLm9wZXJhdG9yLkRjdCh7IG9yZGVyOiAxMiB9KTtcbiAgICogLy8gbWFuZGF0b3J5IGZvciB1c2UgaW4gc3RhbmRhbG9uZSBtb2RlXG4gICAqIGRjdC5pbml0U3RyZWFtKHsgZnJhbWVTaXplOiA1MTIsIGZyYW1lVHlwZTogJ3NpZ25hbCcgfSk7XG4gICAqIGRjdC5pbnB1dFNpZ25hbChkYXRhKTtcbiAgICovXG4gIGlucHV0U2lnbmFsKHZhbHVlcykge1xuICAgIGNvbnN0IG9yZGVyID0gdGhpcy5wYXJhbXMuZ2V0KCdvcmRlcicpO1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0RnJhbWUgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IHRoaXMud2VpZ2h0TWF0cml4O1xuXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBvcmRlcjsgaysrKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBrICogZnJhbWVTaXplO1xuICAgICAgb3V0RnJhbWVba10gPSAwO1xuXG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGZyYW1lU2l6ZTsgbisrKVxuICAgICAgICBvdXRGcmFtZVtrXSArPSB2YWx1ZXNbbl0gKiB3ZWlnaHRzW29mZnNldCArIG5dO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRGcmFtZTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgdGhpcy5pbnB1dFNpZ25hbChmcmFtZS5kYXRhKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzVmVjdG9yKGZyYW1lKSB7XG4gICAgdGhpcy5pbnB1dFNpZ25hbChmcmFtZS5kYXRhKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEY3Q7XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5cbmZ1bmN0aW9uIHNpbXBsZUxpbmVhclJlZ3Jlc3Npb24odmFsdWVzLCBkdCkge1xuICAvLyBtZWFuc1xuICBsZXQgeFN1bSA9IDA7XG4gIGxldCB5U3VtID0gMDtcbiAgY29uc3QgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgeFN1bSArPSBpICogZHQ7XG4gICAgeVN1bSArPSB2YWx1ZXNbaV07XG4gIH1cblxuICBjb25zdCB4TWVhbiA9IHhTdW0gLyBsZW5ndGg7XG4gIGNvbnN0IHlNZWFuID0geVN1bSAvIGxlbmd0aDtcblxuICBsZXQgc3VtRGlmZlhNZWFuU3F1YXJlZCA9IDA7IC8vIHN1bVsgcG93KCh4IC0geE1lYW4pLCAyKSBdXG4gIGxldCBzdW1EaWZmWU1lYW5TcXVhcmVkID0gMDsgLy8gc3VtWyBwb3coKHkgLSB5TWVhbiksIDIpIF1cbiAgbGV0IHN1bURpZmZYWU1lYW4gPSAwOyAgICAgICAvLyBzdW1bICh4IC0geE1lYW4pKHkgLSB5TWVhbikgXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaWZmWE1lYW4gPSBkdCAqIGkgLSB4TWVhbjtcbiAgICBjb25zdCBkaWZmWU1lYW4gPSB2YWx1ZXNbaV0gLSB5TWVhbjtcblxuICAgIGNvbnN0IGRpZmZYTWVhblNxdWFyZWQgPSBkaWZmWE1lYW4gKiBkaWZmWE1lYW47XG4gICAgY29uc3QgZGlmZllNZWFuU3F1YXJlZCA9IGRpZmZZTWVhbiAqIGRpZmZZTWVhbjtcbiAgICBjb25zdCBkaWZmWFlNZWFuID0gZGlmZlhNZWFuICogZGlmZllNZWFuO1xuXG4gICAgc3VtRGlmZlhNZWFuU3F1YXJlZCArPSBkaWZmWE1lYW5TcXVhcmVkO1xuICAgIHN1bURpZmZZTWVhblNxdWFyZWQgKz0gZGlmZllNZWFuU3F1YXJlZDtcbiAgICBzdW1EaWZmWFlNZWFuICs9IGRpZmZYWU1lYW47XG4gIH1cblxuICAvLyBob3Jpem9udGFsIGxpbmUsIGFsbCB5IG9uIHNhbWUgbGluZVxuICBpZiAoc3VtRGlmZllNZWFuU3F1YXJlZCA9PT0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBQZWFyc29uIGNvcnJlbGF0aW9uIGNvZWZmaWNpZW50OlxuICAvLyBjZi4gaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0yU0NnOEt1aDB0RVxuICAvL1xuICAvLyAgICAgICAgICAgICAgICAg4oiRIFsgKHggLSB4TWVhbikoeSAtIHlNZWFuKSBdXG4gIC8vIHIgPSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gICAgIHNxcnQoIOKIkcKgWyBwb3coKHggLSB4TWVhbiksIDIpLCBwb3coKHkgLSB5TWVhbiksIDIpIF0gKVxuICAvL1xuICAvL1xuICBjb25zdCByID0gc3VtRGlmZlhZTWVhbiAvIE1hdGguc3FydChzdW1EaWZmWE1lYW5TcXVhcmVkICogc3VtRGlmZllNZWFuU3F1YXJlZCk7XG5cbiAgLy8gdGhlbiB3ZSBoYXZlOlxuICAvLyBjZi4gaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1HaHJ4Z2JRbkVFVVxuICAvL1xuICAvLyB5ID0gYSArIGJ4XG4gIC8vIHdoZXJlOlxuICAvLyAgICAgICAgIFN5XG4gIC8vIGIgPSByICogLS1cbiAgLy8gICAgICAgICBTeFxuICAvL1xuICAvLyBhID0geU1lYW4gLSBiICogeE1lYW5cbiAgLy9cbiAgLy8gUyBmb3Igc3RhbmRhcmQgZGV2aWF0aW9uXG4gIC8vICAgICAgICAgICAg4oiRIFsgcG93KCh4IC0geE1lYW4pLCAyKSBdXG4gIC8vIFN4ID0gc3FydCggLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgKVxuICAvLyAgICAgICAgICAgICAgICAgICAgICBOIC0gMVxuICBjb25zdCBTeCA9IE1hdGguc3FydChzdW1EaWZmWE1lYW5TcXVhcmVkIC8gKGxlbmd0aCAtIDEpKTtcbiAgY29uc3QgU3kgPSBNYXRoLnNxcnQoc3VtRGlmZllNZWFuU3F1YXJlZCAvIChsZW5ndGggLSAxKSk7XG4gIGNvbnN0IGIgPSByICogKFN5IC8gU3gpO1xuXG4gIHJldHVybiBiO1xufVxuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgc2l6ZToge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBtaW46IDIsXG4gICAgbWF4OiArSW5maW5pdHksXG4gICAgZGVmYXVsdDogMyxcbiAgfSxcbiAgdXNlRnJhbWVSYXRlOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIG1pbjogMCxcbiAgICBtYXg6ICtJbmZpbml0eSxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIG51bGxhYmxlOiB0cnVlLFxuICB9LFxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzaW1wbGUgZGVyaXZhdGl2ZSBvZiBzdWNjZXNzaXZlIHZhbHVlIHVzaW5nXG4gKiBzaW1wbGUgbGluZWFyIHJlZ3Jlc3Npb24uXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIGEgZml4ZWQgYGZyYW1lUmF0ZWAgKGBmcmFtZS50aW1lYCBpcyBpZ25vcmVkKVxuICpcbiAqIEJlZm9yZSB0aGUgbW9kdWxlIGlzIGZpbGxlZCwgaXQgb3V0cHV0cyBhIHZhbHVlIG9mIDAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zaXplPTNdIC0gU2l6ZSBvZiB0aGUgd2luZG93XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudXNlRnJhbWVSYXRlPW51bGxdIC0gT3ZlcnJpZGUgc3RyZWFtIGZyYW1lIHJhdGUgZm9yXG4gKiAgdGhlIHJlZ3Jlc3Npb25cbiAqL1xuY2xhc3MgRGVsdGEgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9wqB7fSkge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcblxuICAgIHRoaXMuYnVmZmVycyA9IG51bGw7XG4gICAgdGhpcy5yaW5nSW5kZXggPSAwO1xuICAgIHRoaXMuZnJhbWVSYXRlID0gbnVsbDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnc2l6ZScpO1xuICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBmcmFtZVNpemUgKiBzaXplO1xuXG4gICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgLy8gY291bnRlciBiZWZvcmUgdGhlIG9wZXJhdG9yIHN0YXJ0cyBvdXRwdXRpbmcgZnJhbWVzXG4gICAgdGhpcy5yaW5nSW5kZXggPSAwO1xuICAgIHRoaXMuZnJhbWVSYXRlID0gdGhpcy5wYXJhbXMuZ2V0KCd1c2VGcmFtZVJhdGUnKSA9PT0gbnVsbCA/XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVJhdGUgOlxuICAgICAgdGhpcy5wYXJhbXMuZ2V0KCd1c2VGcmFtZVJhdGUnKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlcnNbaV0gPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZXNldFN0cmVhbSgpIHtcbiAgICBzdXBlci5yZXNldFN0cmVhbSgpO1xuXG4gICAgY29uc3QgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnBhcmFtcy5nZXQoJ3NpemUnKTtcbiAgICBjb25zdCBidWZmZXJzID0gdGhpcy5idWZmZXJzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplOyBqKyspXG4gICAgICAgIGJ1ZmZlcnNbaV1bal0gPSAwO1xuICAgIH1cblxuICAgIHRoaXMucmluZ0luZGV4ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3N1bWUgYSBzdHJlYW0gb2YgdmVjdG9yIGF0IGEgZml4ZWQgYGZyYW1lUmF0ZWAuXG4gICAqL1xuICBpbnB1dFZlY3RvcihkYXRhKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnc2l6ZScpO1xuICAgIGNvbnN0IG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgY29uc3QgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgIC8vIGNvbnN0IGZyYW1lUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lUmF0ZTtcbiAgICBjb25zdCBidWZmZXJzID0gdGhpcy5idWZmZXJzO1xuICAgIGNvbnN0IGR0ID0gMSAvIHRoaXMuZnJhbWVSYXRlO1xuXG4gICAgLy8gY29uc29sZS5sb2coZHQpO1xuXG4gICAgaWYgKHRoaXMucmluZ0luZGV4IDwgc2l6ZSlcbiAgICAgIHRoaXMucmluZ0luZGV4ICs9IDE7XG5cbiAgICAvLyBjb3B5IGluY29tbWluZyBkYXRhIGludG8gYnVmZmVyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tpXTtcblxuICAgICAgLy8gd2UgbmVlZCB0byBrZWVwIHRoZSBvcmRlciBvZiB0aGUgaW5jb21taW5nIGZyYW1lc1xuICAgICAgLy8gc28gd2UgaGF2ZSB0byBzaGlmdCBhbGwgdGhlIHZhbHVlcyBpbiB0aGUgYnVmZmVyc1xuICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBzaXplOyBqKyspXG4gICAgICAgIGJ1ZmZlcltqIC0gMV0gPSBidWZmZXJbal07XG5cbiAgICAgIGJ1ZmZlcltzaXplIC0gMV0gPSBkYXRhW2ldO1xuXG4gICAgICBpZiAodGhpcy5yaW5nSW5kZXggPj0gc2l6ZSlcbiAgICAgICAgb3V0RGF0YVtpXSA9IHNpbXBsZUxpbmVhclJlZ3Jlc3Npb24oYnVmZmVyLCBkdCk7XG4gICAgICBlbHNlXG4gICAgICAgIG91dERhdGFbaV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBvdXREYXRhO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NWZWN0b3IoZnJhbWUpIHtcbiAgICB0aGlzLmZyYW1lLmRhdGEgPSB0aGlzLmlucHV0VmVjdG9yKGZyYW1lLmRhdGEpO1xuICAgIC8vIGNlbnRlciB0aW1lIGFjY29yZGluZyB0byBkZWx0YSBzaXplXG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnc2l6ZScpO1xuICAgIGNvbnN0IGZyYW1lUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lUmF0ZTtcbiAgICB0aGlzLmZyYW1lLnRpbWUgLT0gMC41ICogKHNpemUgLSAxKSAvIGZyYW1lUmF0ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZWx0YTtcblxuXG5cblxuXG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuaW1wb3J0IGluaXRXaW5kb3cgZnJvbSAnLi4vdXRpbHMvd2luZG93cyc7XG5cbi8vIGh0dHBzOi8vY29kZS5zb3VuZHNvZnR3YXJlLmFjLnVrL3Byb2plY3RzL2pzLWRzcC10ZXN0L3JlcG9zaXRvcnkvZW50cnkvZmZ0L25heXVraS1vYmovZmZ0LmpzXG4vKlxuICogRnJlZSBGZnQgYW5kIGNvbnZvbHV0aW9uIChKYXZhU2NyaXB0KVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBQcm9qZWN0IE5heXVraVxuICogaHR0cDovL3d3dy5uYXl1a2kuaW8vcGFnZS9mcmVlLXNtYWxsLWZmdC1pbi1tdWx0aXBsZS1sYW5ndWFnZXNcbiAqXG4gKiAoTUlUIExpY2Vuc2UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZlxuICogdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiAtIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiAgIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogLSBUaGUgU29mdHdhcmUgaXMgcHJvdmlkZWQgXCJhcyBpc1wiLCB3aXRob3V0IHdhcnJhbnR5IG9mIGFueSBraW5kLCBleHByZXNzIG9yXG4gKiAgIGltcGxpZWQsIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gdGhlIHdhcnJhbnRpZXMgb2YgbWVyY2hhbnRhYmlsaXR5LFxuICogICBmaXRuZXNzIGZvciBhIHBhcnRpY3VsYXIgcHVycG9zZSBhbmQgbm9uaW5mcmluZ2VtZW50LiBJbiBubyBldmVudCBzaGFsbCB0aGVcbiAqICAgYXV0aG9ycyBvciBjb3B5cmlnaHQgaG9sZGVycyBiZSBsaWFibGUgZm9yIGFueSBjbGFpbSwgZGFtYWdlcyBvciBvdGhlclxuICogICBsaWFiaWxpdHksIHdoZXRoZXIgaW4gYW4gYWN0aW9uIG9mIGNvbnRyYWN0LCB0b3J0IG9yIG90aGVyd2lzZSwgYXJpc2luZyBmcm9tLFxuICogICBvdXQgb2Ygb3IgaW4gY29ubmVjdGlvbiB3aXRoIHRoZSBTb2Z0d2FyZSBvciB0aGUgdXNlIG9yIG90aGVyIGRlYWxpbmdzIGluIHRoZVxuICogICBTb2Z0d2FyZS5cbiAqXG4gKiBTbGlnaHRseSByZXN0cnVjdHVyZWQgYnkgQ2hyaXMgQ2FubmFtLCBjYW5uYW1AYWxsLWRheS1icmVha2Zhc3QuY29tXG4gKlxuICogQHByaXZhdGVcbiAqL1xuLypcbiAqIENvbnN0cnVjdCBhbiBvYmplY3QgZm9yIGNhbGN1bGF0aW5nIHRoZSBkaXNjcmV0ZSBGb3VyaWVyIHRyYW5zZm9ybSAoREZUKSBvZlxuICogc2l6ZSBuLCB3aGVyZSBuIGlzIGEgcG93ZXIgb2YgMi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBGZnROYXl1a2kobikge1xuXG4gIHRoaXMubiA9IG47XG4gIHRoaXMubGV2ZWxzID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKDEgPDwgaSA9PSBuKSB7XG4gICAgICB0aGlzLmxldmVscyA9IGk7ICAvLyBFcXVhbCB0byBsb2cyKG4pXG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMubGV2ZWxzID09IC0xKSB7XG4gICAgdGhyb3cgXCJMZW5ndGggaXMgbm90IGEgcG93ZXIgb2YgMlwiO1xuICB9XG5cbiAgdGhpcy5jb3NUYWJsZSA9IG5ldyBBcnJheShuIC8gMik7XG4gIHRoaXMuc2luVGFibGUgPSBuZXcgQXJyYXkobiAvIDIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbiAvIDI7IGkrKykge1xuICAgIHRoaXMuY29zVGFibGVbaV0gPSBNYXRoLmNvcygyICogTWF0aC5QSSAqIGkgLyBuKTtcbiAgICB0aGlzLnNpblRhYmxlW2ldID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgKiBpIC8gbik7XG4gIH1cblxuICAvKlxuICAgKiBDb21wdXRlcyB0aGUgZGlzY3JldGUgRm91cmllciB0cmFuc2Zvcm0gKERGVCkgb2YgdGhlIGdpdmVuIGNvbXBsZXggdmVjdG9yLFxuICAgKiBzdG9yaW5nIHRoZSByZXN1bHQgYmFjayBpbnRvIHRoZSB2ZWN0b3IuXG4gICAqIFRoZSB2ZWN0b3IncyBsZW5ndGggbXVzdCBiZSBlcXVhbCB0byB0aGUgc2l6ZSBuIHRoYXQgd2FzIHBhc3NlZCB0byB0aGVcbiAgICogb2JqZWN0IGNvbnN0cnVjdG9yLCBhbmQgdGhpcyBtdXN0IGJlIGEgcG93ZXIgb2YgMi4gVXNlcyB0aGUgQ29vbGV5LVR1a2V5XG4gICAqIGRlY2ltYXRpb24taW4tdGltZSByYWRpeC0yIGFsZ29yaXRobS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZm9yd2FyZCA9IGZ1bmN0aW9uKHJlYWwsIGltYWcpIHtcbiAgICB2YXIgbiA9IHRoaXMubjtcblxuICAgIC8vIEJpdC1yZXZlcnNlZCBhZGRyZXNzaW5nIHBlcm11dGF0aW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBqID0gcmV2ZXJzZUJpdHMoaSwgdGhpcy5sZXZlbHMpO1xuXG4gICAgICBpZiAoaiA+IGkpIHtcbiAgICAgICAgdmFyIHRlbXAgPSByZWFsW2ldO1xuICAgICAgICByZWFsW2ldID0gcmVhbFtqXTtcbiAgICAgICAgcmVhbFtqXSA9IHRlbXA7XG4gICAgICAgIHRlbXAgPSBpbWFnW2ldO1xuICAgICAgICBpbWFnW2ldID0gaW1hZ1tqXTtcbiAgICAgICAgaW1hZ1tqXSA9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29vbGV5LVR1a2V5IGRlY2ltYXRpb24taW4tdGltZSByYWRpeC0yIEZmdFxuICAgIGZvciAodmFyIHNpemUgPSAyOyBzaXplIDw9IG47IHNpemUgKj0gMikge1xuICAgICAgdmFyIGhhbGZzaXplID0gc2l6ZSAvIDI7XG4gICAgICB2YXIgdGFibGVzdGVwID0gbiAvIHNpemU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSArPSBzaXplKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpLCBrID0gMDsgaiA8IGkgKyBoYWxmc2l6ZTsgaisrLCBrICs9IHRhYmxlc3RlcCkge1xuICAgICAgICAgIHZhciB0cHJlID0gIHJlYWxbaitoYWxmc2l6ZV0gKiB0aGlzLmNvc1RhYmxlW2tdICtcbiAgICAgICAgICAgICAgICAgICAgICBpbWFnW2oraGFsZnNpemVdICogdGhpcy5zaW5UYWJsZVtrXTtcbiAgICAgICAgICB2YXIgdHBpbSA9IC1yZWFsW2oraGFsZnNpemVdICogdGhpcy5zaW5UYWJsZVtrXSArXG4gICAgICAgICAgICAgICAgICAgICAgaW1hZ1tqK2hhbGZzaXplXSAqIHRoaXMuY29zVGFibGVba107XG4gICAgICAgICAgcmVhbFtqICsgaGFsZnNpemVdID0gcmVhbFtqXSAtIHRwcmU7XG4gICAgICAgICAgaW1hZ1tqICsgaGFsZnNpemVdID0gaW1hZ1tqXSAtIHRwaW07XG4gICAgICAgICAgcmVhbFtqXSArPSB0cHJlO1xuICAgICAgICAgIGltYWdbal0gKz0gdHBpbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIGludGVnZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHJldmVyc2Ugb2YgdGhlIGxvd2VzdCAnYml0cydcbiAgICAvLyBiaXRzIG9mIHRoZSBpbnRlZ2VyICd4Jy5cbiAgICBmdW5jdGlvbiByZXZlcnNlQml0cyh4LCBiaXRzKSB7XG4gICAgICB2YXIgeSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYml0czsgaSsrKSB7XG4gICAgICAgIHkgPSAoeSA8PCAxKSB8ICh4ICYgMSk7XG4gICAgICAgIHggPj4+PSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBDb21wdXRlcyB0aGUgaW52ZXJzZSBkaXNjcmV0ZSBGb3VyaWVyIHRyYW5zZm9ybSAoSURGVCkgb2YgdGhlIGdpdmVuIGNvbXBsZXhcbiAgICogdmVjdG9yLCBzdG9yaW5nIHRoZSByZXN1bHQgYmFjayBpbnRvIHRoZSB2ZWN0b3IuXG4gICAqIFRoZSB2ZWN0b3IncyBsZW5ndGggbXVzdCBiZSBlcXVhbCB0byB0aGUgc2l6ZSBuIHRoYXQgd2FzIHBhc3NlZCB0byB0aGVcbiAgICogb2JqZWN0IGNvbnN0cnVjdG9yLCBhbmQgdGhpcyBtdXN0IGJlIGEgcG93ZXIgb2YgMi4gVGhpcyBpcyBhIHdyYXBwZXJcbiAgICogZnVuY3Rpb24uIFRoaXMgdHJhbnNmb3JtIGRvZXMgbm90IHBlcmZvcm0gc2NhbGluZywgc28gdGhlIGludmVyc2UgaXMgbm90XG4gICAqIGEgdHJ1ZSBpbnZlcnNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pbnZlcnNlID0gZnVuY3Rpb24ocmVhbCwgaW1hZykge1xuICAgIGZvcndhcmQoaW1hZywgcmVhbCk7XG4gIH1cbn1cblxuXG5jb25zdCBzcXJ0ID0gTWF0aC5zcXJ0O1xuXG5jb25zdCBpc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbihudW1iZXIpIHtcbiAgd2hpbGUgKChudW1iZXIgJSAyID09PSAwKSAmJiBudW1iZXIgPiAxKVxuICAgIG51bWJlciA9IG51bWJlciAvIDI7XG5cbiAgcmV0dXJuIG51bWJlciA9PT0gMTtcbn1cblxuY29uc3QgZGVmaW5pdGlvbnMgPSB7XG4gIHNpemU6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogMTAyNCxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9LFxuICB3aW5kb3c6IHtcbiAgICB0eXBlOiAnZW51bScsXG4gICAgbGlzdDogWydub25lJywgJ2hhbm4nLCAnaGFubmluZycsICdoYW1taW5nJywgJ2JsYWNrbWFuJywgJ2JsYWNrbWFuaGFycmlzJywgJ3NpbmUnLCAncmVjdGFuZ2xlJ10sXG4gICAgZGVmYXVsdDogJ25vbmUnLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH0sXG4gIH0sXG4gIG1vZGU6IHtcbiAgICB0eXBlOiAnZW51bScsXG4gICAgbGlzdDogWydtYWduaXR1ZGUnLCAncG93ZXInXSwgLy8gYWRkIGNvbXBsZXggb3V0cHV0XG4gICAgZGVmYXVsdDogJ21hZ25pdHVkZScsXG4gIH0sXG4gIG5vcm06IHtcbiAgICB0eXBlOiAnZW51bScsXG4gICAgZGVmYXVsdDogJ2F1dG8nLFxuICAgIGxpc3Q6IFsnYXV0bycsICdub25lJywgJ2xpbmVhcicsICdwb3dlciddLFxuICB9LFxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIEZhc3QgRm91cmllciBUcmFuc2Zvcm0gb2YgYW4gaW5jb21taW5nIGBzaWduYWxgLlxuICpcbiAqIEZmdCBpbXBsZW1lbnRhdGlvbiBieSBbTmF5dWtpXShodHRwczovL2NvZGUuc291bmRzb2Z0d2FyZS5hYy51ay9wcm9qZWN0cy9qcy1kc3AtdGVzdC9yZXBvc2l0b3J5L2VudHJ5L2ZmdC9uYXl1a2ktb2JqL2ZmdC5qcykuXG4gKlxuICogX3N1cHBvcnQgYHN0YW5kYWxvbmVgIHVzYWdlX1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2l6ZT0xMDI0XSAtIFNpemUgb2YgdGhlIGZmdCwgc2hvdWxkIGJlIGEgcG93ZXIgb2YgMi5cbiAqICBJZiB0aGUgZnJhbWUgc2l6ZSBvZiB0aGUgaW5jb21taW5nIHNpZ25hbCBpcyBsb3dlciB0aGFuIHRoaXMgdmFsdWUsXG4gKiAgaXQgaXMgemVybyBwYWRkZWQgdG8gbWF0Y2ggdGhlIGZmdCBzaXplLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndpbmRvdz0nbm9uZSddIC0gTmFtZSBvZiB0aGUgd2luZG93IGFwcGxpZWQgb24gdGhlXG4gKiAgaW5jb21taW5nIHNpZ25hbC4gQXZhaWxhYmxlIHdpbmRvd3MgYXJlOiAnbm9uZScsICdoYW5uJywgJ2hhbm5pbmcnLFxuICogICdoYW1taW5nJywgJ2JsYWNrbWFuJywgJ2JsYWNrbWFuaGFycmlzJywgJ3NpbmUnLCAncmVjdGFuZ2xlJy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RlPSdtYWduaXR1ZGUnXSAtIFR5cGUgb2YgdGhlIG91dHB1dCAoYG1hZ25pdHVkZWBcbiAqICBvciBgcG93ZXJgKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm5vcm09J2F1dG8nXSAtIFR5cGUgb2Ygbm9ybWFsaXphdGlvbiBhcHBsaWVkIG9uIHRoZVxuICogIG91dHB1dC4gUG9zc2libGUgdmFsdWVzIGFyZSAnYXV0bycsICdub25lJywgJ2xpbmVhcicsICdwb3dlcicuIFdoZW4gc2V0IHRvXG4gKiAgYGF1dG9gLCBhIGBsaW5lYXJgIG5vcm1hbGl6YXRpb24gaXMgYXBwbGllZCBvbiB0aGUgbWFnbml0dWRlIHNwZWN0cnVtLCB3aGlsZVxuICogIGEgYHBvd2VyYCBub3JtYWxpemF0aW9uIGlzIGFwcGxpZWQgb24gdGhlIHBvd2VyIHNwZWN0cnVtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogLy8gYXNzdW1pbmcgYW4gYGF1ZGlvQnVmZmVyYCBleGlzdHNcbiAqIGNvbnN0IHNvdXJjZSA9IG5ldyBsZm8uc291cmNlLkF1ZGlvSW5CdWZmZXIoeyBhdWRpb0J1ZmZlciB9KTtcbiAqXG4gKiBjb25zdCBzbGljZXIgPSBuZXcgbGZvLm9wZXJhdG9yLlNsaWNlcih7XG4gKiAgIGZyYW1lU2l6ZTogMjU2LFxuICogfSk7XG4gKlxuICogY29uc3QgZmZ0ID0gbmV3IGxmby5vcGVyYXRvci5GZnQoe1xuICogICBtb2RlOiAncG93ZXInLFxuICogICB3aW5kb3c6ICdoYW5uJyxcbiAqICAgbm9ybTogJ3Bvd2VyJyxcbiAqICAgc2l6ZTogMjU2LFxuICogfSk7XG4gKlxuICogc291cmNlLmNvbm5lY3Qoc2xpY2VyKTtcbiAqIHNsaWNlci5jb25uZWN0KGZmdCk7XG4gKiBzb3VyY2Uuc3RhcnQoKTtcbiAqXG4gKiAvLyA+IG91dHB1dHMgMTI5IGJpbnMgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIHRoZSBwb3dlciBzcGVjdHJ1bSAoaW5jbHVkaW5nXG4gKiAvLyA+IERDIGFuZCBOeXVpc3QgZnJlcXVlbmNpZXMpLlxuICpcbiAqIEB0b2RvIC0gY2hlY2sgaWYgJ3JlY3RhbmdsZScgYW5kICdub25lJyB3aW5kb3dzIGFyZSBub3QgcmVkb25kYW50LlxuICogQHRvZG8gLSBjaGVjayBkZWZhdWx0IHZhbHVlcyBmb3IgYWxsIHBhcmFtcy5cbiAqL1xuY2xhc3MgRmZ0IGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcblxuICAgIHRoaXMud2luZG93U2l6ZSA9IG51bGw7XG4gICAgdGhpcy5ub3JtYWxpemVDb2VmcyA9IG51bGw7XG4gICAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAgIHRoaXMucmVhbCA9IG51bGw7XG4gICAgdGhpcy5pbWFnID0gbnVsbDtcbiAgICB0aGlzLmZmdCA9IG51bGw7XG5cbiAgICBpZiAoIWlzUG93ZXJPZlR3byh0aGlzLnBhcmFtcy5nZXQoJ3NpemUnKSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZmdFNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3bycpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcbiAgICAvLyBzZXQgdGhlIG91dHB1dCBmcmFtZSBzaXplXG4gICAgY29uc3QgaW5GcmFtZVNpemUgPSBwcmV2U3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBmZnRTaXplID0gdGhpcy5wYXJhbXMuZ2V0KCdzaXplJyk7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMucGFyYW1zLmdldCgnbW9kZScpO1xuICAgIGNvbnN0IG5vcm0gPSB0aGlzLnBhcmFtcy5nZXQoJ25vcm0nKTtcbiAgICBsZXQgd2luZG93TmFtZSA9IHRoaXMucGFyYW1zLmdldCgnd2luZG93Jyk7XG4gICAgLy8gd2luZG93IGBub25lYCBhbmQgYHJlY3RhbmdsZWAgYXJlIGFsaWFzZXNcbiAgICBpZiAod2luZG93TmFtZSA9PT0gJ25vbmUnKVxuICAgICAgd2luZG93TmFtZSA9ICdyZWN0YW5nbGUnO1xuXG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gZmZ0U2l6ZSAvIDIgKyAxO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICd2ZWN0b3InO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmRlc2NyaXB0aW9uID0gW107XG4gICAgLy8gc2l6ZSBvZiB0aGUgd2luZG93IHRvIGFwcGx5IG9uIHRoZSBpbnB1dCBmcmFtZVxuICAgIHRoaXMud2luZG93U2l6ZSA9IChpbkZyYW1lU2l6ZSA8IGZmdFNpemUpID8gaW5GcmFtZVNpemUgOiBmZnRTaXplO1xuXG4gICAgLy8gcmVmZXJlbmNlcyB0byBwb3B1bGF0ZSBpbiB0aGUgd2luZG93IGZ1bmN0aW9ucyAoY2YuIGBpbml0V2luZG93YClcbiAgICB0aGlzLm5vcm1hbGl6ZUNvZWZzID0geyBsaW5lYXI6IDAsIHBvd2VyOiAwIH07XG4gICAgdGhpcy53aW5kb3cgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMud2luZG93U2l6ZSk7XG5cbiAgICBpbml0V2luZG93KFxuICAgICAgd2luZG93TmFtZSwgICAgICAgICAvLyBuYW1lIG9mIHRoZSB3aW5kb3dcbiAgICAgIHRoaXMud2luZG93LCAgICAgICAgLy8gYnVmZmVyIHBvcHVsYXRlZCB3aXRoIHRoZSB3aW5kb3cgc2lnbmFsXG4gICAgICB0aGlzLndpbmRvd1NpemUsICAgIC8vIHNpemUgb2YgdGhlIHdpbmRvd1xuICAgICAgdGhpcy5ub3JtYWxpemVDb2VmcyAvLyBvYmplY3QgcG9wdWxhdGVkIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gY29lZnNcbiAgICApO1xuXG4gICAgY29uc3QgeyBsaW5lYXIsIHBvd2VyIH0gPSB0aGlzLm5vcm1hbGl6ZUNvZWZzO1xuXG4gICAgc3dpdGNoIChub3JtKSB7XG4gICAgICBjYXNlICdub25lJzpcbiAgICAgICAgdGhpcy53aW5kb3dOb3JtID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICAgIHRoaXMud2luZG93Tm9ybSA9IGxpbmVhcjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3Bvd2VyJzpcbiAgICAgICAgdGhpcy53aW5kb3dOb3JtID0gcG93ZXI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgaWYgKG1vZGUgPT09ICdtYWduaXR1ZGUnKVxuICAgICAgICAgIHRoaXMud2luZG93Tm9ybSA9IGxpbmVhcjtcbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ3Bvd2VyJylcbiAgICAgICAgICB0aGlzLndpbmRvd05vcm0gPSBwb3dlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5yZWFsID0gbmV3IEZsb2F0MzJBcnJheShmZnRTaXplKTtcbiAgICB0aGlzLmltYWcgPSBuZXcgRmxvYXQzMkFycmF5KGZmdFNpemUpO1xuICAgIHRoaXMuZmZ0ID0gbmV3IEZmdE5heXVraShmZnRTaXplKTtcblxuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBgRmZ0YCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGEgZ3JhcGgpLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBzaWduYWwgLSBJbnB1dCB2YWx1ZXMuXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIEZmdCBvZiB0aGUgaW5wdXQgc2lnbmFsLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBmZnQgPSBuZXcgbGZvLm9wZXJhdG9yLkZmdCh7IHNpemU6IDUxMiwgd2luZG93OiAnaGFubicgfSk7XG4gICAqIC8vIG1hbmRhdG9yeSBmb3IgdXNlIGluIHN0YW5kYWxvbmUgbW9kZVxuICAgKiBmZnQuaW5pdFN0cmVhbSh7IGZyYW1lU2l6ZTogMjU2LCBmcmFtZVR5cGU6ICdzaWduYWwnIH0pO1xuICAgKiBmZnQuaW5wdXRTaWduYWwoc2lnbmFsKTtcbiAgICovXG4gIGlucHV0U2lnbmFsKHNpZ25hbCkge1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLnBhcmFtcy5nZXQoJ21vZGUnKTtcbiAgICBjb25zdCB3aW5kb3dTaXplID0gdGhpcy53aW5kb3dTaXplO1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBmZnRTaXplID0gdGhpcy5wYXJhbXMuZ2V0KCdzaXplJyk7XG4gICAgY29uc3Qgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcblxuICAgIC8vIGFwcGx5IHdpbmRvdyBvbiB0aGUgaW5wdXQgc2lnbmFsIGFuZCByZXNldCBpbWFnIGJ1ZmZlclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICB0aGlzLnJlYWxbaV0gPSBzaWduYWxbaV0gKiB0aGlzLndpbmRvd1tpXSAqIHRoaXMud2luZG93Tm9ybTtcbiAgICAgIHRoaXMuaW1hZ1tpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gaWYgcmVhbCBpcyBiaWdnZXIgdGhhbiBpbnB1dCBzaWduYWwsIGZpbGwgd2l0aCB6ZXJvc1xuICAgIGZvciAobGV0IGkgPSB3aW5kb3dTaXplOyBpIDwgZmZ0U2l6ZTsgaSsrKSB7XG4gICAgICB0aGlzLnJlYWxbaV0gPSAwO1xuICAgICAgdGhpcy5pbWFnW2ldID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmZmdC5mb3J3YXJkKHRoaXMucmVhbCwgdGhpcy5pbWFnKTtcblxuICAgIGlmIChtb2RlID09PSAnbWFnbml0dWRlJykge1xuICAgICAgY29uc3Qgbm9ybSA9IDEgLyBmZnRTaXplO1xuXG4gICAgICAvLyBEQyBpbmRleFxuICAgICAgY29uc3QgcmVhbERjID0gdGhpcy5yZWFsWzBdO1xuICAgICAgY29uc3QgaW1hZ0RjID0gdGhpcy5pbWFnWzBdO1xuICAgICAgb3V0RGF0YVswXSA9IHNxcnQocmVhbERjICogcmVhbERjICsgaW1hZ0RjICogaW1hZ0RjKSAqIG5vcm07XG5cbiAgICAgIC8vIE5xdXlzdCBpbmRleFxuICAgICAgY29uc3QgcmVhbE55ID0gdGhpcy5yZWFsW2ZmdFNpemUgLyAyXTtcbiAgICAgIGNvbnN0IGltYWdOeSA9IHRoaXMuaW1hZ1tmZnRTaXplIC8gMl07XG4gICAgICBvdXREYXRhW2ZmdFNpemUgLyAyXSA9IHNxcnQocmVhbE55ICogcmVhbE55ICsgaW1hZ055ICogaW1hZ055KSAqIG5vcm07XG5cbiAgICAgIC8vIHBvd2VyIHNwZWN0cnVtXG4gICAgICBmb3IgKGxldCBpID0gMSwgaiA9IGZmdFNpemUgLSAxOyBpIDwgZmZ0U2l6ZSAvIDI7IGkrKywgai0tKSB7XG4gICAgICAgIGNvbnN0IHJlYWwgPSAwLjUgKiAodGhpcy5yZWFsW2ldICsgdGhpcy5yZWFsW2pdKTtcbiAgICAgICAgY29uc3QgaW1hZyA9IDAuNSAqICh0aGlzLmltYWdbaV0gLSB0aGlzLmltYWdbal0pO1xuXG4gICAgICAgIG91dERhdGFbaV0gPSAyICogc3FydChyZWFsICogcmVhbCArIGltYWcgKiBpbWFnKSAqIG5vcm07XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdwb3dlcicpIHtcbiAgICAgIGNvbnN0IG5vcm0gPSAxIC8gKGZmdFNpemUgKiBmZnRTaXplKTtcblxuICAgICAgLy8gREMgaW5kZXhcbiAgICAgIGNvbnN0IHJlYWxEYyA9IHRoaXMucmVhbFswXTtcbiAgICAgIGNvbnN0IGltYWdEYyA9IHRoaXMuaW1hZ1swXTtcbiAgICAgIG91dERhdGFbMF0gPSAocmVhbERjICogcmVhbERjICsgaW1hZ0RjICogaW1hZ0RjKSAqIG5vcm07XG5cbiAgICAgIC8vIE5xdXlzdCBpbmRleFxuICAgICAgY29uc3QgcmVhbE55ID0gdGhpcy5yZWFsW2ZmdFNpemUgLyAyXTtcbiAgICAgIGNvbnN0IGltYWdOeSA9IHRoaXMuaW1hZ1tmZnRTaXplIC8gMl07XG4gICAgICBvdXREYXRhW2ZmdFNpemUgLyAyXSA9IChyZWFsTnkgKiByZWFsTnkgKyBpbWFnTnkgKiBpbWFnTnkpICogbm9ybTtcblxuICAgICAgLy8gcG93ZXIgc3BlY3RydW1cbiAgICAgIGZvciAobGV0IGkgPSAxLCBqID0gZmZ0U2l6ZSAtIDE7IGkgPCBmZnRTaXplIC8gMjsgaSsrLCBqLS0pIHtcbiAgICAgICAgY29uc3QgcmVhbCA9IDAuNSAqICh0aGlzLnJlYWxbaV0gKyB0aGlzLnJlYWxbal0pO1xuICAgICAgICBjb25zdCBpbWFnID0gMC41ICogKHRoaXMuaW1hZ1tpXSAtIHRoaXMuaW1hZ1tqXSk7XG5cbiAgICAgICAgb3V0RGF0YVtpXSA9IDQgKiAocmVhbCAqIHJlYWwgKyBpbWFnICogaW1hZykgKiBub3JtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXREYXRhO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICB0aGlzLmlucHV0U2lnbmFsKGZyYW1lLmRhdGEpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZmdDtcbiIsImltcG9ydCBCYXNlTGZvIGZyb20gJy4uLy4uL2NvcmUvQmFzZUxmbyc7XG5cbmNvbnN0IHNxcnQgPSBNYXRoLnNxcnQ7XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICBub3JtYWxpemU6IHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfSxcbiAgfSxcbiAgcG93ZXI6IHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYWduaXR1ZGUgb2YgYSBgdmVjdG9yYCBpbnB1dC5cbiAqXG4gKiBfc3VwcG9ydCBgc3RhbmRhbG9uZWAgdXNhZ2VfXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vcm1hbGl6ZT10cnVlXSAtIE5vcm1hbGl6ZSBvdXRwdXQgYWNjb3JkaW5nIHRvXG4gKiAgdGhlIHZlY3RvciBzaXplLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wb3dlcj1mYWxzZV0gLSBJZiB0cnVlLCByZXR1cm5zIHRoZSBzcXVhcmVkXG4gKiAgbWFnbml0dWRlIChwb3dlcikuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21tb24ub3BlcmF0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jb21tb24nO1xuICpcbiAqIGNvbnN0IGV2ZW50SW4gPSBuZXcgbGZvLnNvdXJjZS5FdmVudEluKHsgZnJhbWVTaXplOiAyLCBmcmFtZVR5cGU6ICd2ZWN0b3InIH0pO1xuICogY29uc3QgbWFnbml0dWRlID0gbmV3IGxmby5vcGVyYXRvci5NYWduaXR1ZGUoKTtcbiAqIGNvbnN0IGxvZ2dlciA9IG5ldyBsZm8uc2luay5Mb2dnZXIoeyBvdXRGcmFtZTogdHJ1ZSB9KTtcbiAqXG4gKiBldmVudEluLmNvbm5lY3QobWFnbml0dWRlKTtcbiAqIG1hZ25pdHVkZS5jb25uZWN0KGxvZ2dlcik7XG4gKiBldmVudEluLnN0YXJ0KCk7XG4gKlxuICogZXZlbnRJbi5wcm9jZXNzKG51bGwsIFsxLCAxXSk7XG4gKiA+IFsxXVxuICogZXZlbnRJbi5wcm9jZXNzKG51bGwsIFsyLCAyXSk7XG4gKiA+IFsyLjgyODQyNzEyNDc1XVxuICogZXZlbnRJbi5wcm9jZXNzKG51bGwsIFszLCAzXSk7XG4gKiA+IFs0LjI0MjY0MDY4NzEyXVxuICovXG5jbGFzcyBNYWduaXR1ZGUgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoZGVmaW5pdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fbm9ybWFsaXplID0gdGhpcy5wYXJhbXMuZ2V0KCdub3JtYWxpemUnKTtcbiAgICB0aGlzLl9wb3dlciA9IHRoaXMucGFyYW1zLmdldCgncG93ZXInKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBvblBhcmFtVXBkYXRlKG5hbWUsIHZhbHVlLCBtZXRhcykge1xuICAgIHN1cGVyLm9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbm9ybWFsaXplJzpcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG93ZXInOlxuICAgICAgICB0aGlzLl9wb3dlciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IDE7XG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gJ3NjYWxhcic7XG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZGVzY3JpcHRpb24gPSBbJ21hZ25pdHVkZSddO1xuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBgTWFnbml0dWRlYCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGEgZ3JhcGgpLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fEZsb2F0MzJBcnJheX0gdmFsdWVzIC0gVmFsdWVzIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBNYWduaXR1ZGUgdmFsdWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAgICpcbiAgICogY29uc3QgbWFnbml0dWRlID0gbmV3IGxmby5vcGVyYXRvci5NYWduaXR1ZGUoeyBwb3dlcjogdHJ1ZSB9KTtcbiAgICogbWFnbml0dWRlLmluaXRTdHJlYW0oeyBmcmFtZVR5cGU6ICd2ZWN0b3InLCBmcmFtZVNpemU6IDMgfSk7XG4gICAqIG1hZ25pdHVkZS5pbnB1dFZlY3RvcihbMywgM10pO1xuICAgKiA+IDQuMjQyNjQwNjg3MTJcbiAgICovXG4gIGlucHV0VmVjdG9yKHZhbHVlcykge1xuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgc3VtICs9ICh2YWx1ZXNbaV0gKiB2YWx1ZXNbaV0pO1xuXG4gICAgbGV0IG1hZyA9IHN1bTtcblxuICAgIGlmICh0aGlzLl9ub3JtYWxpemUpXG4gICAgICBtYWcgLz0gbGVuZ3RoO1xuXG4gICAgaWYgKCF0aGlzLl9wb3dlcilcbiAgICAgIG1hZyA9IHNxcnQobWFnKTtcblxuICAgIHJldHVybiBtYWc7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgIHRoaXMuZnJhbWUuZGF0YVswXSA9IHRoaXMuaW5wdXRWZWN0b3IoZnJhbWUuZGF0YSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWFnbml0dWRlO1xuIiwiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi4vLi4vY29yZS9CYXNlTGZvJztcblxuY29uc3Qgc3FydCA9IE1hdGguc3FydDtcblxuLyoqXG4gKiBDb21wdXRlIG1lYW4gYW5kIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhIGdpdmVuIGBzaWduYWxgLlxuICpcbiAqIF9zdXBwb3J0IGBzdGFuZGFsb25lYCB1c2FnZV9cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICpcbiAqIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAqICAgLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlIH0pXG4gKiAgIC50aGVuKGluaXQpXG4gKiAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKGVyci5zdGFjaykpO1xuICpcbiAqIGZ1bmN0aW9uIGluaXQoc3RyZWFtKSB7XG4gKiAgIGNvbnN0IHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xuICpcbiAqICAgY29uc3QgYXVkaW9Jbk5vZGUgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luTm9kZSh7XG4gKiAgICAgc291cmNlTm9kZTogc291cmNlLFxuICogICAgIGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0LFxuICogICB9KTtcbiAqXG4gKiAgIGNvbnN0IG1lYW5TdGRkZXYgPSBuZXcgbGZvLm9wZXJhdG9yLk1lYW5TdGRkZXYoKTtcbiAqXG4gKiAgIGNvbnN0IHRyYWNlRGlzcGxheSA9IG5ldyBsZm8uc2luay5UcmFjZURpc3BsYXkoe1xuICogICAgIGNhbnZhczogJyN0cmFjZScsXG4gKiAgIH0pO1xuICpcbiAqICAgYXVkaW9Jbk5vZGUuY29ubmVjdChtZWFuU3RkZGV2KTtcbiAqICAgbWVhblN0ZGRldi5jb25uZWN0KHRyYWNlRGlzcGxheSk7XG4gKiAgIGF1ZGlvSW5Ob2RlLnN0YXJ0KCk7XG4gKiB9XG4gKi9cbmNsYXNzIE1lYW5TdGRkZXYgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gbm8gb3B0aW9ucyBhdmFpbGFibGUsIGp1c3QgdGhyb3cgYW4gZXJyb3IgaWYgc29tZSBwYXJhbSB0cnkgdG8gYmUgc2V0LlxuICAgIHN1cGVyKHt9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVR5cGUgPSAndmVjdG9yJztcbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPSAyO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmRlc2NyaXB0aW9uID0gWydtZWFuJywgJ3N0ZGRldiddO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhlIGBNZWFuU3RkZGV2YCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGEgZ3JhcGgpLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fEZsb2F0MzJBcnJheX0gdmFsdWVzIC0gVmFsdWVzIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIE1lYW4gYW5kIHN0YW5kYXJ0IGRldmlhdGlvbiBvZiB0aGUgaW5wdXQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gICAqXG4gICAqIGNvbnN0IG1lYW5TdGRkZXYgPSBuZXcgbGZvLm9wZXJhdG9yLk1lYW5TdGRkZXYoKTtcbiAgICogbWVhblN0ZGRldi5pbml0U3RyZWFtKHsgZnJhbWVUeXBlOiAndmVjdG9yJywgZnJhbWVTaXplOiAxMDI0IH0pO1xuICAgKiBtZWFuU3RkZGV2LmlucHV0VmVjdG9yKHNvbWVTaW5lU2lnbmFsKTtcbiAgICogPiBbMCwgMC43MDcxXVxuICAgKi9cbiAgaW5wdXRTaWduYWwodmFsdWVzKSB7XG4gICAgY29uc3Qgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICBjb25zdCBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgbGV0IG1lYW4gPSAwO1xuICAgIGxldCBtMiA9IDA7XG5cbiAgICAvLyBjb21wdXRlIG1lYW4gYW5kIHZhcmlhbmNlIHdpdGggV2VsZm9yZCBhbGdvcml0aG1cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BbGdvcml0aG1zX2Zvcl9jYWxjdWxhdGluZ192YXJpYW5jZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSB2YWx1ZXNbaV07XG4gICAgICBjb25zdCBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiArPSBkZWx0YSAvIChpICsgMSk7XG4gICAgICBtMiArPSBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgfVxuXG4gICAgY29uc3QgdmFyaWFuY2UgPSBtMiAvIChsZW5ndGggLSAxKTtcbiAgICBjb25zdCBzdGRkZXYgPSBzcXJ0KHZhcmlhbmNlKTtcblxuICAgIG91dERhdGFbMF0gPSBtZWFuO1xuICAgIG91dERhdGFbMV0gPSBzdGRkZXY7XG5cbiAgICByZXR1cm4gb3V0RGF0YTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgdGhpcy5pbnB1dFNpZ25hbChmcmFtZS5kYXRhKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZWFuU3RkZGV2O1xuIiwiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi4vLi4vY29yZS9CYXNlTGZvJztcblxuY29uc3QgbWluID0gTWF0aC5taW47XG5jb25zdCBtYXggPSBNYXRoLm1heDtcbmNvbnN0IHBvdyA9IE1hdGgucG93O1xuY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwO1xuXG5mdW5jdGlvbiBoZXJ0elRvTWVsSHRrKGZyZXFIeikge1xuICByZXR1cm4gMjU5NSAqIE1hdGgubG9nMTAoMSArIChmcmVxSHogLyA3MDApKTtcbn1cblxuZnVuY3Rpb24gbWVsVG9IZXJ0ekh0ayhmcmVxTWVsKSB7XG4gIHJldHVybiA3MDAgKiAoTWF0aC5wb3coMTAsIGZyZXFNZWwgLyAyNTk1KSAtIDEpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBkZXNjcmlwdGlvbiBvZiB0aGUgd2VpZ2h0cyB0byBhcHBseSBvbiB0aGUgZmZ0IGJpbnMgZm9yIGVhY2hcbiAqIE1lbCBiYW5kIGZpbHRlci5cbiAqIEBub3RlIC0gYWRhcHRlZCBmcm9tIGltdHItdG9vbHMvcnRhXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5ickJpbnMgLSBOdW1iZXIgb2YgZmZ0IGJpbnMuXG4gKiBAcGFyYW0ge051bWJlcn0gbmJyRmlsdGVyIC0gTnVtYmVyIG9mIG1lbCBmaWx0ZXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNhbXBsZVJhdGUgLSBTYW1wbGUgUmF0ZSBvZiB0aGUgc2lnbmFsLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbkZyZXEgLSBNaW5pbXVtIEZyZXF1ZW5jeSB0byBiZSBjb25zaWRlcmVyZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RnJlcSAtIE1heGltdW0gZnJlcXVlbmN5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gLSBEZXNjcmlwdGlvbiBvZiB0aGUgd2VpZ2h0cyB0byBhcHBseSBvbiB0aGUgYmlucyBmb3JcbiAqICBlYWNoIG1lbCBmaWx0ZXIuIEVhY2ggZGVzY3JpcHRpb24gaGFzIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuICogIHsgc3RhcnRJbmRleDogYmluSW5kZXgsIGNlbnRlckZyZXE6IGJpbkNlbnRlckZyZXF1ZW5jeSwgd2VpZ2h0czogW10gfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldE1lbEJhbmRXZWlnaHRzKG5ickJpbnMsIG5ickJhbmRzLCBzYW1wbGVSYXRlLCBtaW5GcmVxLCBtYXhGcmVxLCB0eXBlID0gJ2h0aycpIHtcblxuICBsZXQgaGVydHpUb01lbCA9IG51bGw7XG4gIGxldCBtZWxUb0hlcnR6ID0gbnVsbDtcbiAgbGV0IG1pbk1lbDtcbiAgbGV0IG1heE1lbDtcblxuICBpZiAodHlwZSA9PT0gJ2h0aycpIHtcbiAgICBoZXJ0elRvTWVsID0gaGVydHpUb01lbEh0aztcbiAgICBtZWxUb0hlcnR6ID0gbWVsVG9IZXJ0ekh0aztcbiAgICBtaW5NZWwgPSBoZXJ0elRvTWVsKG1pbkZyZXEpO1xuICAgIG1heE1lbCA9IGhlcnR6VG9NZWwobWF4RnJlcSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lbCBiYW5kIHR5cGU6IFwiJHt0eXBlfVwiYCk7XG4gIH1cblxuICBjb25zdCBtZWxCYW5kRGVzY3JpcHRpb25zID0gbmV3IEFycmF5KG5ickJhbmRzKTtcbiAgLy8gY2VudGVyIGZyZXF1ZW5jaWVzIG9mIEZmdCBiaW5zXG4gIGNvbnN0IGZmdEZyZXFzID0gbmV3IEZsb2F0MzJBcnJheShuYnJCaW5zKTtcbiAgLy8gY2VudGVyIGZyZXF1ZW5jaWVzIG9mIG1lbCBiYW5kcyAtIHVuaWZvcm1seSBzcGFjZWQgaW4gbWVsIGRvbWFpbiBiZXR3ZWVuXG4gIC8vIGxpbWl0cywgdGhlcmUgYXJlIDIgbW9yZSBmcmVxdWVuY2llcyB0aGFuIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGZpbHRlcnMgaW5cbiAgLy8gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBzbG9wZXNcbiAgY29uc3QgZmlsdGVyRnJlcXMgPSBuZXcgRmxvYXQzMkFycmF5KG5ickJhbmRzICsgMik7XG5cbiAgY29uc3QgZmZ0U2l6ZSA9IChuYnJCaW5zIC0gMSkgKiAyO1xuICAvLyBjb21wdXRlIGJpbnMgY2VudGVyIGZyZXF1ZW5jaWVzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmJyQmluczsgaSsrKVxuICAgIGZmdEZyZXFzW2ldID0gc2FtcGxlUmF0ZSAqIGkgLyBmZnRTaXplO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmJyQmFuZHMgKyAyOyBpKyspXG4gICAgZmlsdGVyRnJlcXNbaV0gPSBtZWxUb0hlcnR6KG1pbk1lbCArIGkgLyAobmJyQmFuZHMgKyAxKSAqIChtYXhNZWwgLSBtaW5NZWwpKTtcblxuICAvLyBsb29wIHRocm91Z2h0IGZpbHRlcnNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYnJCYW5kczsgaSsrKSB7XG4gICAgbGV0IG1pbldlaWdodEluZGV4RGVmaW5lZCA9IDA7XG5cbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHtcbiAgICAgIHN0YXJ0SW5kZXg6IG51bGwsXG4gICAgICBjZW50ZXJGcmVxOiBudWxsLFxuICAgICAgd2VpZ2h0czogW10sXG4gICAgfVxuXG4gICAgLy8gZGVmaW5lIGNvbnRyaWJ1dGlvbiBvZiBlYWNoIGJpbiBmb3IgdGhlIGZpbHRlciBhdCBpbmRleCAoaSArIDEpXG4gICAgLy8gZG8gbm90IHByb2Nlc3MgdGhlIGxhc3Qgc3BlY3RydW0gY29tcG9uZW50IChOeXF1aXN0KVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmJyQmlucyAtIDE7IGorKykge1xuICAgICAgY29uc3QgcG9zU2xvcGVDb250cmliID0gKGZmdEZyZXFzW2pdIC0gZmlsdGVyRnJlcXNbaV0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWx0ZXJGcmVxc1tpKzFdIC0gZmlsdGVyRnJlcXNbaV0pO1xuXG4gICAgICBjb25zdCBuZWdTbG9wZUNvbnRyaWIgPSAoZmlsdGVyRnJlcXNbaSsyXSAtIGZmdEZyZXFzW2pdKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlsdGVyRnJlcXNbaSsyXSAtIGZpbHRlckZyZXFzW2krMV0pO1xuICAgICAgLy8gbG93ZXJTbG9wZSBhbmQgdXBwZXIgc2xvcGUgaW50ZXJzZWN0IGF0IHplcm8gYW5kIHdpdGggZWFjaCBvdGhlclxuICAgICAgY29uc3QgY29udHJpYnV0aW9uID0gbWF4KDAsIG1pbihwb3NTbG9wZUNvbnRyaWIsIG5lZ1Nsb3BlQ29udHJpYikpO1xuXG4gICAgICBpZiAoY29udHJpYnV0aW9uID4gMCkge1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24uc3RhcnRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlc2NyaXB0aW9uLnN0YXJ0SW5kZXggPSBqO1xuICAgICAgICAgIGRlc2NyaXB0aW9uLmNlbnRlckZyZXEgPSBmaWx0ZXJGcmVxc1tpKzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzY3JpcHRpb24ud2VpZ2h0cy5wdXNoKGNvbnRyaWJ1dGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZW1wdHkgZmlsdGVyXG4gICAgaWYgKGRlc2NyaXB0aW9uLnN0YXJ0SW5kZXggPT09IG51bGwpIHtcbiAgICAgIGRlc2NyaXB0aW9uLnN0YXJ0SW5kZXggPSAwO1xuICAgICAgZGVzY3JpcHRpb24uY2VudGVyRnJlcSA9IDA7XG4gICAgfVxuXG4gICAgLy8gQHRvZG8gLSBkbyBzb21lIHNjYWxpbmcgZm9yIFNsYW5leS1zdHlsZSBtZWxcbiAgICBtZWxCYW5kRGVzY3JpcHRpb25zW2ldID0gZGVzY3JpcHRpb247XG4gIH1cblxuICByZXR1cm4gbWVsQmFuZERlc2NyaXB0aW9ucztcbn1cblxuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgbG9nOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH0sXG4gIH0sXG4gIG5ickJhbmRzOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIGRlZmF1bHQ6IDI0LFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH0sXG4gIH0sXG4gIG1pbkZyZXE6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfSxcbiAgfSxcbiAgbWF4RnJlcToge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9LFxuICBwb3dlcjoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9LFxuICB9LFxufTtcblxuXG4vKipcbiAqIENvbXB1dGUgdGhlIG1lbCBiYW5kcyBzcGVjdHJ1bSBmcm9tIGEgZ2l2ZW4gc3BlY3RydW0gKGB2ZWN0b3JgIHR5cGUpLlxuICogX0ltcGxlbWVudCB0aGUgYGh0a2AgbWVsIGJhbmQgc3R5bGUuX1xuICpcbiAqIF9zdXBwb3J0IGBzdGFuZGFsb25lYCB1c2FnZV9cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5sb2c9ZmFsc2VdIC0gQXBwbHkgYSBsb2dhcml0aG1pYyBzY2FsZSBvbiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm5ickJhbmRzPTI0XSAtIE51bWJlciBvZiBmaWx0ZXJzIGRlZmluaW5nIHRoZSBtZWxcbiAqICBiYW5kcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5GcmVxPTBdIC0gTWluaW11bSBmcmVxdWVuY3kgdG8gY29uc2lkZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4RnJlcT1udWxsXSAtIE1heGltdW0gZnJlcXVlbmN5IHRvIGNvbnNpZGVyLlxuICogIElmIGBudWxsYCwgaXMgc2V0IHRvIE55cXVpc3QgZnJlcXVlbmN5LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvd2VyPTFdIC0gQXBwbHkgYSBwb3dlciBzY2FsaW5nIG9uIGVhY2ggbWVsIGJhbmQuXG4gKlxuICogQHRvZG8gLSBpbXBsZW1lbnQgU2xhbmV5IHN0eWxlIG1lbCBiYW5kc1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgbGZvIGZyb20gJ3dhdmVzLWxmby9ub2RlJ1xuICpcbiAqIC8vIHJlYWQgYSBmaWxlIGZyb20gcGF0aCAobm9kZSBvbmx5IHNvdXJjZSlcbiAqIGNvbnN0IGF1ZGlvSW5GaWxlID0gbmV3IGxmby5zb3VyY2UuQXVkaW9JbkZpbGUoe1xuICogICBmaWxlbmFtZTogJ3BhdGgvdG8vZmlsZScsXG4gKiAgIGZyYW1lU2l6ZTogNTEyLFxuICogfSk7XG4gKlxuICogY29uc3Qgc2xpY2VyID0gbmV3IGxmby5vcGVyYXRvci5TbGljZXIoe1xuICogICBmcmFtZVNpemU6IDI1NixcbiAqICAgaG9wU2l6ZTogMjU2LFxuICogfSk7XG4gKlxuICogY29uc3QgZmZ0ID0gbmV3IGxmby5vcGVyYXRvci5GZnQoe1xuICogICBzaXplOiAxMDI0LFxuICogICB3aW5kb3c6ICdoYW5uJyxcbiAqICAgbW9kZTogJ3Bvd2VyJyxcbiAqICAgbm9ybTogJ3Bvd2VyJyxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IG1lbCA9IG5ldyBsZm8ub3BlcmF0b3IuTWVsKHtcbiAqICAgbG9nOiB0cnVlLFxuICogICBuYnJCYW5kczogMjQsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBsb2dnZXIgPSBuZXcgbGZvLnNpbmsuTG9nZ2VyKHsgZGF0YTogdHJ1ZSB9KTtcbiAqXG4gKiBhdWRpb0luRmlsZS5jb25uZWN0KHNsaWNlcik7XG4gKiBzbGljZXIuY29ubmVjdChmZnQpO1xuICogZmZ0LmNvbm5lY3QobWVsKTtcbiAqIG1lbC5jb25uZWN0KGxvZ2dlcik7XG4gKlxuICogYXVkaW9JbkZpbGUuc3RhcnQoKTtcbiAqL1xuY2xhc3MgTWVsIGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICBjb25zdCBuYnJCaW5zID0gcHJldlN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgY29uc3QgbmJyQmFuZHMgPSB0aGlzLnBhcmFtcy5nZXQoJ25ickJhbmRzJyk7XG4gICAgY29uc3Qgc2FtcGxlUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGU7XG4gICAgY29uc3QgbWluRnJlcSA9IHRoaXMucGFyYW1zLmdldCgnbWluRnJlcScpO1xuICAgIGxldCBtYXhGcmVxID0gdGhpcy5wYXJhbXMuZ2V0KCdtYXhGcmVxJyk7XG5cbiAgICAvL1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IG5ickJhbmRzO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICd2ZWN0b3InO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmRlc2NyaXB0aW9uID0gW107XG5cbiAgICBpZiAobWF4RnJlcSA9PT0gbnVsbClcbiAgICAgIG1heEZyZXEgPSB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlIC8gMjtcblxuICAgIHRoaXMubWVsQmFuZERlc2NyaXB0aW9ucyA9IGdldE1lbEJhbmRXZWlnaHRzKG5ickJpbnMsIG5ickJhbmRzLCBzYW1wbGVSYXRlLCBtaW5GcmVxLCBtYXhGcmVxKTtcblxuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBgTWVsYCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGEgZ3JhcGgpLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBzcGVjdHJ1bSAtIEZmdCBiaW5zLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBNZWwgYmFuZHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG1lbCA9IG5ldyBsZm8ub3BlcmF0b3IuTWVsKHsgbmJyQmFuZHM6IDI0IH0pO1xuICAgKiAvLyBtYW5kYXRvcnkgZm9yIHVzZSBpbiBzdGFuZGFsb25lIG1vZGVcbiAgICogbWVsLmluaXRTdHJlYW0oeyBmcmFtZVNpemU6IDI1NiwgZnJhbWVUeXBlOiAndmVjdG9yJywgc291cmNlU2FtcGxlUmF0ZTogNDQxMDAgfSk7XG4gICAqIG1lbC5pbnB1dFZlY3RvcihmZnRCaW5zKTtcbiAgICovXG4gIGlucHV0VmVjdG9yKGJpbnMpIHtcblxuICAgIGNvbnN0IHBvd2VyID0gdGhpcy5wYXJhbXMuZ2V0KCdwb3dlcicpO1xuICAgIGNvbnN0IGxvZyA9IHRoaXMucGFyYW1zLmdldCgnbG9nJyk7XG4gICAgY29uc3QgbWVsQmFuZHMgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgY29uc3QgbmJyQmFuZHMgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgbGV0IHNjYWxlID0gMTtcblxuICAgIGNvbnN0IG1pbkxvZ1ZhbHVlID0gMWUtNDg7XG4gICAgY29uc3QgbWluTG9nID0gLTQ4MDtcblxuICAgIGlmIChsb2cpXG4gICAgICBzY2FsZSAqPSBuYnJCYW5kcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJyQmFuZHM7IGkrKykge1xuICAgICAgY29uc3QgeyBzdGFydEluZGV4LCB3ZWlnaHRzIH0gPSB0aGlzLm1lbEJhbmREZXNjcmlwdGlvbnNbaV07XG4gICAgICBsZXQgdmFsdWUgPSAwO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdlaWdodHMubGVuZ3RoOyBqKyspXG4gICAgICAgIHZhbHVlICs9IHdlaWdodHNbal0gKiBiaW5zW3N0YXJ0SW5kZXggKyBqXTtcblxuICAgICAgLy8gYXBwbHkgc2FtZSBsb2dpYyBhcyBpbiBQaVBvQmFuZHNcbiAgICAgIGlmIChzY2FsZSAhPT0gMSlcbiAgICAgICAgdmFsdWUgKj0gc2NhbGU7XG5cbiAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gbWluTG9nVmFsdWUpXG4gICAgICAgICAgdmFsdWUgPSAxMCAqIGxvZzEwKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHZhbHVlID0gbWluTG9nO1xuICAgICAgfVxuXG4gICAgICBpZiAocG93ZXIgIT09IDEpXG4gICAgICAgIHZhbHVlID0gcG93KHZhbHVlLCBwb3dlcik7XG5cbiAgICAgIG1lbEJhbmRzW2ldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbEJhbmRzO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NWZWN0b3IoZnJhbWUpIHtcbiAgICB0aGlzLmlucHV0VmVjdG9yKGZyYW1lLmRhdGEpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lbDtcbiIsImltcG9ydCBCYXNlTGZvIGZyb20gJy4uLy4uL2NvcmUvQmFzZUxmbyc7XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICAvLyBhcnJheSBkZWZpbmluZyB0aGUgZnJhbWVTaXplcyBvZiB0aGUgaW5wdXQgc3RyZWFtc3NcbiAgLy8gZS5nLiBpZiBbMywgMiwgMV0sIHdlIHdhaXQgZm9yIDMgZGlmZmVyZW50IHNvdXJjZXMgb2YgcmVzcGVjdGl2ZSAzLCAyLCAxIGZyYW1lU2l6ZXNcbiAgZnJhbWVTaXplczoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgY29uc3RhbnQ6IHRydWUsXG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSBtdWx0aXBsZSB2ZWN0b3IgZnJhbWVzLiBUaGUgb3JkZXIgb2YgZXhlY3V0aW9uIGRlcGVuZHMgb24gdGhlXG4gKiBvcmRlciB0aGUgYnJhbmNoaW5nIHdhcyBpbml0aWFsbHkgbWFkZS4gVGhlIGZpcnN0IGJyYW5jaGUgaXMgbWFzdGVyXG4gKiBvbiB0aGUgdGltZSBhbmQgdHJpZ2dlciB0aGUgb3V0cHV0IG9mIHRoZSBmcmFtZS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5mcmFtZVNpemVzPW51bGxdIC0gQXJyYXkgdGhhdCBkZWZpbmVzIHRoZSBudW1iZXJcbiAqICBvZiB2YWx1ZXMgdG8gcGljayBmcm9tIGVhY2ggaW5jb21taW5nIHZlY3RvcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY29tb24nXG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8ub3BlcmF0b3IuRXZlbnRJbih7XG4gKiAgIHR5cGU6ICd2ZWN0b3InLFxuICogICBmcmFtZVNpemU6IDQsXG4gKiAgIGZyYW1lUmF0ZTogMCxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IG1pbk1heCA9IG5ldyBsZm8ub3BlcmF0b3IuTWluTWF4KCk7XG4gKiBjb25zdCBtYWduaXR1ZGUgPSBuZXcgbGZvLm9wZXJhdG9yLk1hZ25pdHVkZSgpO1xuICpcbiAqIC8vIHRha2UgdGhlIGZpcnN0IDIgdmFsdWVzIG9mIHRoZSBmaXJzdCBicmFuY2ggYW5kIDEgdmFsdWUgZnJvbSB0aGUgc2Vjb25kIGJyYW5jaFxuICogY29uc3QgbWVyZ2UgPSBuZXcgbGZvLm9wZXJhdG9yLk1lcmdlcih7IGZyYW1lU2l6ZXM6IFsyLCAxXSB9KTtcbiAqXG4gKiAvLyB0aGlzIGRlZmluZXMgdGhlIG9yZGVyIGluIHdoaWNoIE1lcmdlciB3aWxsIGJlIGNhbGxlZFxuICogZXZlbnRJbi5jb25uZWN0KG1pbk1heCk7XG4gKiBldmVudEluLmNvbm5lY3QobWFnbml0dWRlKTtcbiAqXG4gKiBtaW5NYXguY29ubmVjdChtZXJnZXIpO1xuICogbWFnbml0dWRlLmNvbm5lY3QobWVyZ2VyKTtcbiAqL1xuY2xhc3MgTWVyZ2VyIGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICAvLyAuLi5cbiAgICBjb25zdCBmcmFtZVNpemVzID0gdGhpcy5wYXJhbXMuZ2V0KCdmcmFtZVNpemVzJyk7XG4gICAgY29uc3QgbnVtU291cmNlcyA9IGZyYW1lU2l6ZXMubGVuZ3RoO1xuXG4gICAgbGV0IGZyYW1lU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Tb3VyY2VzOyBpKyspXG4gICAgICBmcmFtZVNpemUgKz0gZnJhbWVTaXplc1tpXTtcblxuXG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gZnJhbWVTaXplO1xuICAgIHRoaXMubnVtU291cmNlcyA9IG51bVNvdXJjZXM7XG4gICAgdGhpcy5zb3VyY2VJbmRleCA9IDA7XG5cbiAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICB9XG5cbiAgcHJvY2Vzc1ZlY3RvcigpIHt9XG4gIC8vIHByb2Nlc3NTaWduYWwoKSB7fSAvLyBtYWtlcyBubyBzZW5zIHRvIG1lcmdlIHNpZ25hbHMgKG1heWJlIE1VWCAvIERFTVVYKVxuXG4gIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuc291cmNlSW5kZXg7XG4gICAgY29uc3QgZnJhbWVTaXplcyA9IHRoaXMucGFyYW1zLmdldCgnZnJhbWVTaXplcycpO1xuICAgIGNvbnN0IG51bVNvdXJjZXMgPSBmcmFtZVNpemVzLmxlbmd0aDtcbiAgICBjb25zdCBpbnB1dCA9IGZyYW1lLmRhdGE7XG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5mcmFtZS5kYXRhO1xuXG4gICAgLy8gZmlyc3Qgc291cmNlIGRlZmluZSB0aW1lXG4gICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMClcbiAgICAgIHRoaXMuZnJhbWUudGltZSA9IGZyYW1lLnRpbWU7XG5cbiAgICBjb25zdCBjdXJyZW50RnJhbWVTaXplID0gZnJhbWVTaXplc1tjdXJyZW50SW5kZXhdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50SW5kZXg7IGkrKylcbiAgICAgIG9mZnNldCArPSBmcmFtZVNpemVzW2ldO1xuXG4gICAgLy8gY29weSBkYXRhXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50RnJhbWVTaXplOyBpKyspXG4gICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBpbnB1dFtpXTtcblxuICAgIHRoaXMuc291cmNlSW5kZXggPSAodGhpcy5zb3VyY2VJbmRleCArIDEpICUgbnVtU291cmNlcztcblxuICAgIC8vIHdlIGp1c3QgcmVjZWl2ZWQgdGhlIGxhc3QgaW5wdXQsIG91dHB1dCB0aGUgZnJhbWVcbiAgICBpZiAodGhpcy5zb3VyY2VJbmRleCA9PT0gMClcbiAgICAgIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZXJnZXI7XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuaW1wb3J0IEZmdCBmcm9tICcuL0ZmdCc7XG5pbXBvcnQgTWVsIGZyb20gJy4vTWVsJztcbmltcG9ydCBEY3QgZnJvbSAnLi9EY3QnO1xuXG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICBuYnJCYW5kczoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiAyNCxcbiAgICBtZXRhOiB7IGtpbmQ6ICdzdGF0aWMnIH0sXG4gIH0sXG4gIG5ickNvZWZzOiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIGRlZmF1bHQ6IDEyLFxuICAgIG1ldGE6IHsga2luZDogJ3N0YXRpYycgfSxcbiAgfSxcbiAgbWluRnJlcToge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtZXRhOiB7IGtpbmQ6ICdzdGF0aWMnIH0sXG4gIH0sXG4gIG1heEZyZXE6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgbWV0YTogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgTWZjYyBvZiB0aGUgaW5jb21taW5nIGBzaWduYWxgLiBJcyBiYXNpY2FsbHkgYSB3cmFwcGVyIGFyb3VuZFxuICogW2BGZnRgXXtAbGluayBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yLkZmdH0sIFtgTWVsYF17QGxpbmsgbW9kdWxlOmNvbW1vbi5vcGVyYXRvci5NZWx9XG4gKiBhbmQgW2BEY3RgXXtAbGluayBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yLkRjdH0uXG4gKlxuICogX3N1cHBvcnQgYHN0YW5kYWxvbmVgIHVzYWdlX1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge25ickJhbmRzfSBbb3B0aW9ucy5uYnJCYW5kcz0yNF0gLSBOdW1iZXIgb2YgTWVsIGJhbmRzLlxuICogQHBhcmFtIHtuYnJDb2Vmc30gW29wdGlvbnMubmJyQ29lZnM9MTJdIC0gTnVtYmVyIG9mIG91dHB1dCBjb2Vmcy5cbiAqXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yLkZmdH1cbiAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb21tb24ub3BlcmF0b3IuTWVsfVxuICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvbW1vbi5vcGVyYXRvci5EY3R9XG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBsZm8gZnJvbSAnd2F2ZXMtbGZvL25vZGUnXG4gKlxuICogY29uc3QgYXVkaW9JbkZpbGUgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luRmlsZSh7XG4gKiAgIGZpbGVuYW1lOiAncGF0aC90by9maWxlJyxcbiAqICAgZnJhbWVTaXplOiA1MTIsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBzbGljZXIgPSBuZXcgbGZvLm9wZXJhdG9yLlNsaWNlcih7XG4gKiAgIGZyYW1lU2l6ZTogMjU2LFxuICogfSk7XG4gKlxuICogY29uc3QgbWZjYyA9IG5ldyBsZm8ub3BlcmF0b3IuTWZjYyh7XG4gKiAgIG5ickJhbmRzOiAyNCxcbiAqICAgbmJyQ29lZnM6IDEyLFxuICogfSk7XG4gKlxuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogYXVkaW9JbkZpbGUuY29ubmVjdChzbGljZXIpO1xuICogc2xpY2VyLmNvbm5lY3QobWZjYyk7XG4gKiBtZmNjLmNvbm5lY3QobG9nZ2VyKTtcbiAqXG4gKiBhdWRpb0luRmlsZS5zdGFydCgpO1xuICovXG5jbGFzcyBNZmNjIGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgY29uc3QgbmJyQmFuZHMgPSB0aGlzLnBhcmFtcy5nZXQoJ25ickJhbmRzJyk7XG4gICAgY29uc3QgbmJyQ29lZnMgPSB0aGlzLnBhcmFtcy5nZXQoJ25ickNvZWZzJyk7XG4gICAgY29uc3QgbWluRnJlcSA9IHRoaXMucGFyYW1zLmdldCgnbWluRnJlcScpO1xuICAgIGNvbnN0IG1heEZyZXEgPSB0aGlzLnBhcmFtcy5nZXQoJ21heEZyZXEnKTtcbiAgICBjb25zdCBpbnB1dEZyYW1lU2l6ZSA9IHByZXZTdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgIGNvbnN0IGlucHV0RnJhbWVSYXRlID0gcHJldlN0cmVhbVBhcmFtcy5mcmFtZVJhdGU7XG4gICAgY29uc3QgaW5wdXRTYW1wbGVSYXRlID0gcHJldlN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlO1xuICAgIGNvbnN0IG5ickJpbnMgPSBpbnB1dEZyYW1lU2l6ZSAvIDIgKyAxO1xuXG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gbmJyQ29lZnM7XG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gJ3ZlY3Rvcic7XG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZGVzY3JpcHRpb24gPSBbXTtcblxuICAgIHRoaXMuZmZ0ID0gbmV3IEZmdCh7XG4gICAgICB3aW5kb3c6ICdoYW5uJyxcbiAgICAgIG1vZGU6ICdwb3dlcicsXG4gICAgICBub3JtOiAncG93ZXInLFxuICAgICAgc2l6ZTogaW5wdXRGcmFtZVNpemUsXG4gICAgfSk7XG5cbiAgICB0aGlzLm1lbCA9IG5ldyBNZWwoe1xuICAgICAgbmJyQmFuZHM6IG5ickJhbmRzLFxuICAgICAgbG9nOiB0cnVlLFxuICAgICAgcG93ZXI6IDEsXG4gICAgICBtaW5GcmVxOiBtaW5GcmVxLFxuICAgICAgbWF4RnJlcTogbWF4RnJlcSxcbiAgICB9KTtcblxuICAgIHRoaXMuZGN0ID0gbmV3IERjdCh7XG4gICAgICBvcmRlcjogbmJyQ29lZnMsXG4gICAgfSk7XG5cbiAgICAvLyBpbml0IHN0cmVhbXNcbiAgICB0aGlzLmZmdC5pbml0U3RyZWFtKHtcbiAgICAgIGZyYW1lVHlwZTogJ3NpZ25hbCcsXG4gICAgICBmcmFtZVNpemU6IGlucHV0RnJhbWVTaXplLFxuICAgICAgZnJhbWVSYXRlOiBpbnB1dEZyYW1lUmF0ZSxcbiAgICAgIHNvdXJjZVNhbXBsZVJhdGU6IGlucHV0U2FtcGxlUmF0ZSxcbiAgICB9KTtcblxuICAgIHRoaXMubWVsLmluaXRTdHJlYW0oe1xuICAgICAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAgICAgIGZyYW1lU2l6ZTogbmJyQmlucyxcbiAgICAgIGZyYW1lUmF0ZTogaW5wdXRGcmFtZVJhdGUsXG4gICAgICBzb3VyY2VTYW1wbGVSYXRlOiBpbnB1dFNhbXBsZVJhdGUsXG4gICAgfSk7XG5cbiAgICB0aGlzLmRjdC5pbml0U3RyZWFtKHtcbiAgICAgIGZyYW1lVHlwZTogJ3ZlY3RvcicsXG4gICAgICBmcmFtZVNpemU6IG5ickJhbmRzLFxuICAgICAgZnJhbWVSYXRlOiBpbnB1dEZyYW1lUmF0ZSxcbiAgICAgIHNvdXJjZVNhbXBsZVJhdGU6IGlucHV0U2FtcGxlUmF0ZSxcbiAgICB9KTtcblxuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBgTWZjY2Agb3BlcmF0b3IgaW4gYHN0YW5kYWxvbmVgIG1vZGUgKGkuZS4gb3V0c2lkZSBvZiBhIGdyYXBoKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIFNpZ25hbCBjaHVuayB0byBhbmFseXNlLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBNZmNjIGNvZWZmaWNpZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgbWZjYyA9IG5ldyBsZm8ub3BlcmF0b3IuTWZjYygpO1xuICAgKiAvLyBtYW5kYXRvcnkgZm9yIHVzZSBpbiBzdGFuZGFsb25lIG1vZGVcbiAgICogbWZjYy5pbml0U3RyZWFtKHsgZnJhbWVTaXplOiAyNTYsIGZyYW1lVHlwZTogJ3ZlY3RvcicgfSk7XG4gICAqIG1mY2MuaW5wdXRTaWduYWwoc2lnbmFsKTtcbiAgICovXG4gIGlucHV0U2lnbmFsKGRhdGEpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgY29uc3QgbmJyQ29lZnMgPSB0aGlzLnBhcmFtcy5nZXQoJ25ickNvZWZzJyk7XG5cbiAgICBjb25zdCBiaW5zID0gdGhpcy5mZnQuaW5wdXRTaWduYWwoZGF0YSk7XG4gICAgY29uc3QgbWVsQmFuZHMgPSB0aGlzLm1lbC5pbnB1dFZlY3RvcihiaW5zKTtcbiAgICAvLyBjb25zb2xlLmxvZyhtZWxCYW5kcyk7XG4gICAgY29uc3QgY29lZnMgPSB0aGlzLmRjdC5pbnB1dFNpZ25hbChtZWxCYW5kcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ickNvZWZzOyBpKyspXG4gICAgICBvdXRwdXRbaV0gPSBjb2Vmc1tpXTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1NpZ25hbChmcmFtZSkge1xuICAgIHRoaXMuaW5wdXRTaWduYWwoZnJhbWUuZGF0YSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWZjYztcbiIsImltcG9ydCBCYXNlTGZvIGZyb20gJy4uLy4uL2NvcmUvQmFzZUxmbyc7XG5cbi8qKlxuICogRmluZCBtaW5pbXVuIGFuZCBtYXhpbXVtIHZhbHVlcyBvZiBhIGdpdmVuIGBzaWduYWxgLlxuICpcbiAqIF9zdXBwb3J0IGBzdGFuZGFsb25lYCB1c2FnZV9cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NvbW1vbic7XG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICogICBmcmFtZVNpemU6IDUxMixcbiAqICAgZnJhbWVUeXBlOiAnc2lnbmFsJyxcbiAqICAgc2FtcGxlUmF0ZTogMCxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IG1pbk1heCA9IG5ldyBsZm8ub3BlcmF0b3IuTWluTWF4KCk7XG4gKlxuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogZXZlbnRJbi5jb25uZWN0KG1pbk1heCk7XG4gKiBtaW5NYXguY29ubmVjdChsb2dnZXIpO1xuICogZXZlbnRJbi5zdGFydCgpXG4gKlxuICogLy8gY3JlYXRlIGEgZnJhbWVcbiAqIGNvbnN0IHNpZ25hbCA9IG5ldyBGbG9hdDMyQXJyYXkoNTEyKTtcbiAqIGZvciAobGV0IGkgPSAwOyBpIDwgNTEyOyBpKyspXG4gKiAgIHNpZ25hbFtpXSA9IGkgKyAxO1xuICpcbiAqIGV2ZW50SW4ucHJvY2VzcyhudWxsLCBzaWduYWwpO1xuICogPiBbMSwgNTEyXTtcbiAqL1xuY2xhc3MgTWluTWF4IGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIHRocm93IGVycm9ycyBpZiBvcHRpb25zIGFyZSBnaXZlblxuICAgIHN1cGVyKHt9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMgPSB7fSkge1xuICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICd2ZWN0b3InO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IDI7XG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZGVzY3JpcHRpb24gPSBbJ21pbicsICdtYXgnXTtcblxuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBgTWluTWF4YCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGEgZ3JhcGgpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheX0gZGF0YSAtIElucHV0IHNpZ25hbC5cbiAgICogQHJldHVybiB7QXJyYXl9IC0gTWluIGFuZCBtYXggdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBtaW5NYXggPSBuZXcgTWluTWF4KCk7XG4gICAqIG1pbk1heC5pbml0U3RyZWFtKHsgZnJhbWVUeXBlOiAnc2lnbmFsJywgZnJhbWVTaXplOiAxMCB9KTtcbiAgICpcbiAgICogbWluTWF4LmlucHV0U2lnbmFsKFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XSk7XG4gICAqID4gWzAsIDVdXG4gICAqL1xuICBpbnB1dFNpZ25hbChkYXRhKSB7XG4gICAgY29uc3Qgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICBsZXQgbWluID0gK0luZmluaXR5O1xuICAgIGxldCBtYXggPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbaV07XG4gICAgICBpZiAodmFsdWUgPCBtaW4pIG1pbiA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlID4gbWF4KSBtYXggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBvdXREYXRhWzBdID0gbWluO1xuICAgIG91dERhdGFbMV0gPSBtYXg7XG5cbiAgICByZXR1cm4gb3V0RGF0YTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgdGhpcy5pbnB1dFNpZ25hbChmcmFtZS5kYXRhKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNaW5NYXg7XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgb3JkZXI6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgbWluOiAxLFxuICAgIG1heDogMWU5LFxuICAgIGRlZmF1bHQ6IDEwLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9XG4gIH0sXG4gIGZpbGw6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIG1pbjogLUluZmluaXR5LFxuICAgIG1heDogK0luZmluaXR5LFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH0sXG59O1xuXG4vKipcbiAqIENvbXB1dGUgYSBtb3ZpbmcgYXZlcmFnZSBvcGVyYXRpb24gb24gdGhlIGluY29tbWluZyBmcmFtZXMgKGBzY2FsYXJgIG9yXG4gKiBgdmVjdG9yYCB0eXBlKS4gSWYgdGhlIGlucHV0IGlzIG9mIHR5cGUgdmVjdG9yLCB0aGUgbW92aW5nIGF2ZXJhZ2UgaXNcbiAqIGNvbXB1dGVkIGZvciBlYWNoIGRpbWVuc2lvbiBpbiBwYXJhbGxlbC4gSWYgdGhlIHNvdXJjZSBzYW1wbGUgcmF0ZSBpcyBkZWZpbmVkXG4gKiBmcmFtZSB0aW1lIGlzIHNoaWZ0ZWQgdG8gdGhlIG1pZGRsZSBvZiB0aGUgd2luZG93IGRlZmluZWQgYnkgdGhlIG9yZGVyLlxuICpcbiAqIF9zdXBwb3J0IGBzdGFuZGFsb25lYCB1c2FnZV9cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9yZGVyPTEwXSAtIE51bWJlciBvZiBzdWNjZXNzaXZlIHZhbHVlcyBvbiB3aGljaFxuICogIHRoZSBhdmVyYWdlIGlzIGNvbXB1dGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZpbGw9MF0gLSBWYWx1ZSB0byBmaWxsIHRoZSByaW5nIGJ1ZmZlciB3aXRoIGJlZm9yZVxuICogIHRoZSBmaXJzdCBpbnB1dCBmcmFtZS5cbiAqXG4gKiBAdG9kbyAtIEltcGxlbWVudCBgcHJvY2Vzc1NpZ25hbGAgP1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NvbW1vbic7XG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICogICBmcmFtZVNpemU6IDIsXG4gKiAgIGZyYW1lVHlwZTogJ3ZlY3RvcidcbiAqIH0pO1xuICpcbiAqIGNvbnN0IG1vdmluZ0F2ZXJhZ2UgPSBuZXcgbGZvLm9wZXJhdG9yLk1vdmluZ0F2ZXJhZ2Uoe1xuICogICBvcmRlcjogNSxcbiAqICAgZmlsbDogMFxuICogfSk7XG4gKlxuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogZXZlbnRJbi5jb25uZWN0KG1vdmluZ0F2ZXJhZ2UpO1xuICogbW92aW5nQXZlcmFnZS5jb25uZWN0KGxvZ2dlcik7XG4gKlxuICogZXZlbnRJbi5zdGFydCgpO1xuICpcbiAqIGV2ZW50SW4ucHJvY2VzcyhudWxsLCBbMSwgMV0pO1xuICogPiBbMC4yLCAwLjJdXG4gKiBldmVudEluLnByb2Nlc3MobnVsbCwgWzEsIDFdKTtcbiAqID4gWzAuNCwgMC40XVxuICogZXZlbnRJbi5wcm9jZXNzKG51bGwsIFsxLCAxXSk7XG4gKiA+IFswLjYsIDAuNl1cbiAqIGV2ZW50SW4ucHJvY2VzcyhudWxsLCBbMSwgMV0pO1xuICogPiBbMC44LCAwLjhdXG4gKiBldmVudEluLnByb2Nlc3MobnVsbCwgWzEsIDFdKTtcbiAqID4gWzEsIDFdXG4gKi9cbmNsYXNzIE1vdmluZ0F2ZXJhZ2UgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoZGVmaW5pdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5zdW0gPSBudWxsO1xuICAgIHRoaXMucmluZ0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5yaW5nSW5kZXggPSAwO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIG9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUsIG1ldGFzKSB7XG4gICAgc3VwZXIub25QYXJhbVVwZGF0ZShuYW1lLCB2YWx1ZSwgbWV0YXMpO1xuXG4gICAgLy8gQHRvZG8gLSBzaG91bGQgYmUgZG9uZSBsYXppbHkgaW4gcHJvY2Vzc1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnb3JkZXInOlxuICAgICAgICB0aGlzLnByb2Nlc3NTdHJlYW1QYXJhbXMoKTtcbiAgICAgICAgdGhpcy5yZXNldFN0cmVhbSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZpbGwnOlxuICAgICAgICB0aGlzLnJlc2V0U3RyZWFtKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgY29uc3Qgb3JkZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ29yZGVyJyk7XG5cbiAgICB0aGlzLnJpbmdCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KG9yZGVyICogZnJhbWVTaXplKTtcblxuICAgIGlmIChmcmFtZVNpemUgPiAxKVxuICAgICAgdGhpcy5zdW0gPSBuZXcgRmxvYXQzMkFycmF5KGZyYW1lU2l6ZSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5zdW0gPSAwO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZXNldFN0cmVhbSgpIHtcbiAgICBzdXBlci5yZXNldFN0cmVhbSgpO1xuXG4gICAgY29uc3Qgb3JkZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ29yZGVyJyk7XG4gICAgY29uc3QgZmlsbCA9IHRoaXMucGFyYW1zLmdldCgnZmlsbCcpO1xuICAgIGNvbnN0IHJpbmdCdWZmZXIgPSB0aGlzLnJpbmdCdWZmZXI7XG4gICAgY29uc3QgcmluZ0xlbmd0aCA9IHJpbmdCdWZmZXIubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByaW5nTGVuZ3RoOyBpKyspXG4gICAgICByaW5nQnVmZmVyW2ldID0gZmlsbDtcblxuICAgIGNvbnN0IGZpbGxTdW0gPSBvcmRlciAqIGZpbGw7XG4gICAgY29uc3QgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuXG4gICAgaWYgKGZyYW1lU2l6ZSA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspXG4gICAgICAgIHRoaXMuc3VtW2ldID0gZmlsbFN1bTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdW0gPSBmaWxsU3VtO1xuICAgIH1cblxuICAgIHRoaXMucmluZ0luZGV4ID0gMDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU2NhbGFyKGZyYW1lKSB7XG4gICAgdGhpcy5mcmFtZS5kYXRhWzBdID0gdGhpcy5pbnB1dFNjYWxhcihmcmFtZS5kYXRhWzBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhlIGBNb3ZpbmdBdmVyYWdlYCBvcGVyYXRvciBpbiBgc3RhbmRhbG9uZWAgbW9kZSAoaS5lLiBvdXRzaWRlIG9mIGFcbiAgICogZ3JhcGgpIHdpdGggYSBgc2NhbGFyYCBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVmFsdWUgdG8gZmVlZCB0aGUgbW92aW5nIGF2ZXJhZ2Ugd2l0aC5cbiAgICogQHJldHVybiB7TnVtYmVyfSAtIEF2ZXJhZ2UgdmFsdWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAgICpcbiAgICogY29uc3QgbW92aW5nQXZlcmFnZSA9IG5ldyBsZm8ub3BlcmF0b3IuTW92aW5nQXZlcmFnZSh7IG9yZGVyOiA1IH0pO1xuICAgKiBtb3ZpbmdBdmVyYWdlLmluaXRTdHJlYW0oeyBmcmFtZVNpemU6IDEsIGZyYW1lVHlwZTogJ3NjYWxhcicgfSk7XG4gICAqXG4gICAqIG1vdmluZ0F2ZXJhZ2UuaW5wdXRTY2FsYXIoMSk7XG4gICAqID4gMC4yXG4gICAqIG1vdmluZ0F2ZXJhZ2UuaW5wdXRTY2FsYXIoMSk7XG4gICAqID4gMC40XG4gICAqIG1vdmluZ0F2ZXJhZ2UuaW5wdXRTY2FsYXIoMSk7XG4gICAqID4gMC42XG4gICAqL1xuICBpbnB1dFNjYWxhcih2YWx1ZSkge1xuICAgIGNvbnN0IG9yZGVyID0gdGhpcy5wYXJhbXMuZ2V0KCdvcmRlcicpO1xuICAgIGNvbnN0IHJpbmdJbmRleCA9IHRoaXMucmluZ0luZGV4O1xuICAgIGNvbnN0IHJpbmdCdWZmZXIgPSB0aGlzLnJpbmdCdWZmZXI7XG4gICAgbGV0IHN1bSA9IHRoaXMuc3VtO1xuXG4gICAgc3VtIC09IHJpbmdCdWZmZXJbcmluZ0luZGV4XTtcbiAgICBzdW0gKz0gdmFsdWU7XG5cbiAgICB0aGlzLnN1bSA9IHN1bTtcbiAgICB0aGlzLnJpbmdCdWZmZXJbcmluZ0luZGV4XSA9IHZhbHVlO1xuICAgIHRoaXMucmluZ0luZGV4ID0gKHJpbmdJbmRleCArIDEpICUgb3JkZXI7XG5cbiAgICByZXR1cm4gc3VtIC8gb3JkZXI7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgIHRoaXMuaW5wdXRWZWN0b3IoZnJhbWUuZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBgTW92aW5nQXZlcmFnZWAgb3BlcmF0b3IgaW4gYHN0YW5kYWxvbmVgIG1vZGUgKGkuZS4gb3V0c2lkZSBvZiBhXG4gICAqIGdyYXBoKSB3aXRoIGEgYHZlY3RvcmAgaW5wdXQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIFZhbHVlcyB0byBmZWVkIHRoZSBtb3ZpbmcgYXZlcmFnZSB3aXRoLlxuICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IC0gQXZlcmFnZSB2YWx1ZSBmb3IgZWFjaCBkaW1lbnNpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAgICpcbiAgICogY29uc3QgbW92aW5nQXZlcmFnZSA9IG5ldyBsZm8ub3BlcmF0b3IuTW92aW5nQXZlcmFnZSh7IG9yZGVyOiA1IH0pO1xuICAgKiBtb3ZpbmdBdmVyYWdlLmluaXRTdHJlYW0oeyBmcmFtZVNpemU6IDIsIGZyYW1lVHlwZTogJ3NjYWxhcicgfSk7XG4gICAqXG4gICAqIG1vdmluZ0F2ZXJhZ2UuaW5wdXRBcnJheShbMSwgMV0pO1xuICAgKiA+IFswLjIsIDAuMl1cbiAgICogbW92aW5nQXZlcmFnZS5pbnB1dEFycmF5KFsxLCAxXSk7XG4gICAqID4gWzAuNCwgMC40XVxuICAgKiBtb3ZpbmdBdmVyYWdlLmlucHV0QXJyYXkoWzEsIDFdKTtcbiAgICogPiBbMC42LCAwLjZdXG4gICAqL1xuICBpbnB1dFZlY3Rvcih2YWx1ZXMpIHtcbiAgICBjb25zdCBvcmRlciA9IHRoaXMucGFyYW1zLmdldCgnb3JkZXInKTtcbiAgICBjb25zdCBvdXRGcmFtZSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgY29uc3QgcmluZ0luZGV4ID0gdGhpcy5yaW5nSW5kZXg7XG4gICAgY29uc3QgcmluZ09mZnNldCA9IHJpbmdJbmRleCAqIGZyYW1lU2l6ZTtcbiAgICBjb25zdCByaW5nQnVmZmVyID0gdGhpcy5yaW5nQnVmZmVyO1xuICAgIGNvbnN0IHN1bSA9IHRoaXMuc3VtO1xuICAgIGNvbnN0IHNjYWxlID0gMSAvIG9yZGVyO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKykge1xuICAgICAgY29uc3QgcmluZ0J1ZmZlckluZGV4ID0gcmluZ09mZnNldCArIGk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgIGxldCBsb2NhbFN1bSA9IHN1bVtpXTtcblxuICAgICAgbG9jYWxTdW0gLT0gcmluZ0J1ZmZlcltyaW5nQnVmZmVySW5kZXhdO1xuICAgICAgbG9jYWxTdW0gKz0gdmFsdWU7XG5cbiAgICAgIHRoaXMuc3VtW2ldID0gbG9jYWxTdW07XG4gICAgICBvdXRGcmFtZVtpXSA9IGxvY2FsU3VtICogc2NhbGU7XG4gICAgICByaW5nQnVmZmVyW3JpbmdCdWZmZXJJbmRleF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnJpbmdJbmRleCA9IChyaW5nSW5kZXggKyAxKSAlIG9yZGVyO1xuXG4gICAgcmV0dXJuIG91dEZyYW1lO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgIHRoaXMucHJlcGFyZUZyYW1lKCk7XG4gICAgdGhpcy5wcm9jZXNzRnVuY3Rpb24oZnJhbWUpO1xuXG4gICAgY29uc3Qgb3JkZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ29yZGVyJyk7XG4gICAgbGV0IHRpbWUgPSBmcmFtZS50aW1lO1xuICAgIC8vIHNoaWZ0IHRpbWUgdG8gdGFrZSBhY2NvdW50IG9mIHRoZSBhZGRlZCBsYXRlbmN5XG4gICAgaWYgKHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGUpXG4gICAgICB0aW1lIC09ICgwLjUgKiAob3JkZXIgLSAxKSAvIHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGUpO1xuXG4gICAgdGhpcy5mcmFtZS50aW1lID0gdGltZTtcbiAgICB0aGlzLmZyYW1lLm1ldGFkYXRhID0gZnJhbWUubWV0YWRhdGE7XG5cbiAgICB0aGlzLnByb3BhZ2F0ZUZyYW1lKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTW92aW5nQXZlcmFnZTtcbiIsImltcG9ydCBCYXNlTGZvIGZyb20gJy4uLy4uL2NvcmUvQmFzZUxmbyc7XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICBvcmRlcjoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBtaW46IDEsXG4gICAgbWF4OiAxZTksXG4gICAgZGVmYXVsdDogOSxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9LFxuICBmaWxsOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBtaW46IC1JbmZpbml0eSxcbiAgICBtYXg6ICtJbmZpbml0eSxcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH0sXG4gIH0sXG59O1xuXG4vKipcbiAqIENvbXB1dGUgYSBtb3ZpbmcgbWVkaWFuIG9wZXJhdGlvbiBvbiB0aGUgaW5jb21taW5nIGZyYW1lcyAoYHNjYWxhcmAgb3JcbiAqIGB2ZWN0b3JgIHR5cGUpLiBJZiB0aGUgaW5wdXQgaXMgb2YgdHlwZSB2ZWN0b3IsIHRoZSBtb3ZpbmcgbWVkaWFuIGlzXG4gKiBjb21wdXRlZCBmb3IgZWFjaCBkaW1lbnNpb24gaW4gcGFyYWxsZWwuIElmIHRoZSBzb3VyY2Ugc2FtcGxlIHJhdGUgaXMgZGVmaW5lZFxuICogZnJhbWUgdGltZSBpcyBzaGlmdGVkIHRvIHRoZSBtaWRkbGUgb2YgdGhlIHdpbmRvdyBkZWZpbmVkIGJ5IHRoZSBvcmRlci5cbiAqXG4gKiBfc3VwcG9ydCBgc3RhbmRhbG9uZWAgdXNhZ2VfXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21tb24ub3BlcmF0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vcmRlcj05XSAtIE51bWJlciBvZiBzdWNjZXNzaXZlIHZhbHVlcyBpbiB3aGljaFxuICogIHRoZSBtZWRpYW4gaXMgc2VhcmNoZWQuIFRoaXMgdmFsdWUgbXVzdCBiZSBvZGQuIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5maWxsPTBdIC0gVmFsdWUgdG8gZmlsbCB0aGUgcmluZyBidWZmZXIgd2l0aCBiZWZvcmVcbiAqICB0aGUgZmlyc3QgaW5wdXQgZnJhbWUuIF9keW5hbWljIHBhcmFtZXRlcl9cbiAqXG4gKiBAdG9kbyAtIEltcGxlbWVudCBgcHJvY2Vzc1NpZ25hbGBcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jb21tb24nO1xuICpcbiAqIGNvbnN0IGV2ZW50SW4gPSBuZXcgbGZvLnNvdXJjZS5FdmVudEluKHtcbiAqICAgZnJhbWVTaXplOiAyLFxuICogICBmcmFtZVR5cGU6ICd2ZWN0b3InLFxuICogfSk7XG4gKlxuICogY29uc3QgbW92aW5nTWVkaWFuID0gbmV3IGxmby5vcGVyYXRvci5Nb3ZpbmdNZWRpYW4oe1xuICogICBvcmRlcjogNSxcbiAqICAgZmlsbDogMCxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGxvZ2dlciA9IG5ldyBsZm8uc2luay5Mb2dnZXIoeyBkYXRhOiB0cnVlIH0pO1xuICpcbiAqIGV2ZW50SW4uY29ubmVjdChtb3ZpbmdNZWRpYW4pO1xuICogbW92aW5nTWVkaWFuLmNvbm5lY3QobG9nZ2VyKTtcbiAqXG4gKiBldmVudEluLnN0YXJ0KCk7XG4gKlxuICogZXZlbnRJbi5wcm9jZXNzRnJhbWUobnVsbCwgWzEsIDFdKTtcbiAqID4gWzAsIDBdXG4gKiBldmVudEluLnByb2Nlc3NGcmFtZShudWxsLCBbMiwgMl0pO1xuICogPiBbMCwgMF1cbiAqIGV2ZW50SW4ucHJvY2Vzc0ZyYW1lKG51bGwsIFszLCAzXSk7XG4gKiA+IFsxLCAxXVxuICogZXZlbnRJbi5wcm9jZXNzRnJhbWUobnVsbCwgWzQsIDRdKTtcbiAqID4gWzIsIDJdXG4gKiBldmVudEluLnByb2Nlc3NGcmFtZShudWxsLCBbNSwgNV0pO1xuICogPiBbMywgM11cbiAqL1xuY2xhc3MgTW92aW5nTWVkaWFuIGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcblxuICAgIHRoaXMucmluZ0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5zb3J0QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnJpbmdJbmRleCA9IDA7XG5cbiAgICB0aGlzLl9lbnN1cmVPZGRPcmRlcigpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9lbnN1cmVPZGRPcmRlcigpIHtcbiAgICBpZiAodGhpcy5wYXJhbXMuZ2V0KCdvcmRlcicpICUgMiA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSAke29yZGVyfSBmb3IgcGFyYW0gXCJvcmRlclwiIC0gbXVzdCBiZSBvZGRgKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBvblBhcmFtVXBkYXRlKG5hbWUsIHZhbHVlLCBtZXRhcykge1xuICAgIHN1cGVyLm9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnb3JkZXInOlxuICAgICAgICB0aGlzLl9lbnN1cmVPZGRPcmRlcigpO1xuICAgICAgICB0aGlzLnByb2Nlc3NTdHJlYW1QYXJhbXMoKTtcbiAgICAgICAgdGhpcy5yZXNldFN0cmVhbSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZpbGwnOlxuICAgICAgICB0aGlzLnJlc2V0U3RyZWFtKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG4gICAgLy8gb3V0VHlwZSBpcyBzaW1pbGFyIHRvIGlucHV0IHR5cGVcblxuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBvcmRlciA9IHRoaXMucGFyYW1zLmdldCgnb3JkZXInKTtcblxuICAgIHRoaXMucmluZ0J1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoZnJhbWVTaXplICogb3JkZXIpO1xuICAgIHRoaXMuc29ydEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoZnJhbWVTaXplICogb3JkZXIpO1xuXG4gICAgdGhpcy5taW5JbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KGZyYW1lU2l6ZSk7XG5cbiAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlc2V0U3RyZWFtKCkge1xuICAgIHN1cGVyLnJlc2V0U3RyZWFtKCk7XG5cbiAgICBjb25zdCBmaWxsID0gdGhpcy5wYXJhbXMuZ2V0KCdmaWxsJyk7XG4gICAgY29uc3QgcmluZ0J1ZmZlciA9IHRoaXMucmluZ0J1ZmZlcjtcbiAgICBjb25zdCByaW5nTGVuZ3RoID0gcmluZ0J1ZmZlci5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJpbmdMZW5ndGg7IGkrKylcbiAgICAgIHRoaXMucmluZ0J1ZmZlcltpXSA9IGZpbGw7XG5cbiAgICB0aGlzLnJpbmdJbmRleCA9IDA7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1NjYWxhcihmcmFtZSkge1xuICAgIHRoaXMuZnJhbWUuZGF0YVswXSA9IHRoaXMuaW5wdXRTY2FsYXIoZnJhbWUuZGF0YVswXSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIGZvciB0aGUgdXNlIG9mIGEgYE1vdmluZ01lZGlhbmAgb3V0c2lkZSBhIGdyYXBoIChlLmcuIGluc2lkZVxuICAgKiBhbm90aGVyIG5vZGUpLCBpbiB0aGlzIGNhc2UgYHByb2Nlc3NTdHJlYW1QYXJhbXNgIGFuZCBgcmVzZXRTdHJlYW1gXG4gICAqIHNob3VsZCBiZSBjYWxsZWQgbWFudWFsbHkgb24gdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFZhbHVlIHRvIGZlZWQgdGhlIG1vdmluZyBtZWRpYW4gd2l0aC5cbiAgICogQHJldHVybiB7TnVtYmVyfSAtIE1lZGlhbiB2YWx1ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICAgKlxuICAgKiBjb25zdCBtb3ZpbmdNZWRpYW4gPSBuZXcgTW92aW5nTWVkaWFuKHsgb3JkZXI6IDUgfSk7XG4gICAqIG1vdmluZ01lZGlhbi5pbml0U3RyZWFtKHsgZnJhbWVTaXplOiAxLCBmcmFtZVR5cGU6ICdzY2FsYXInIH0pO1xuICAgKlxuICAgKiBtb3ZpbmdNZWRpYW4uaW5wdXRTY2FsYXIoMSk7XG4gICAqID4gMFxuICAgKiBtb3ZpbmdNZWRpYW4uaW5wdXRTY2FsYXIoMik7XG4gICAqID4gMFxuICAgKiBtb3ZpbmdNZWRpYW4uaW5wdXRTY2FsYXIoMyk7XG4gICAqID4gMVxuICAgKiBtb3ZpbmdNZWRpYW4uaW5wdXRTY2FsYXIoNCk7XG4gICAqID4gMlxuICAgKi9cbiAgaW5wdXRTY2FsYXIodmFsdWUpIHtcbiAgICBjb25zdCByaW5nSW5kZXggPSB0aGlzLnJpbmdJbmRleDtcbiAgICBjb25zdCByaW5nQnVmZmVyID0gdGhpcy5yaW5nQnVmZmVyO1xuICAgIGNvbnN0IHNvcnRCdWZmZXIgPSB0aGlzLnNvcnRCdWZmZXI7XG4gICAgY29uc3Qgb3JkZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ29yZGVyJyk7XG4gICAgY29uc3QgbWVkaWFuSW5kZXggPSAob3JkZXIgLSAxKSAvIDI7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuXG4gICAgcmluZ0J1ZmZlcltyaW5nSW5kZXhdID0gdmFsdWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtZWRpYW5JbmRleDsgaSsrKSB7XG4gICAgICBsZXQgbWluID0gK0luZmluaXR5O1xuICAgICAgbGV0IG1pbkluZGV4ID0gbnVsbDtcblxuICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0SW5kZXg7IGogPCBvcmRlcjsgaisrKSB7XG4gICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgIHNvcnRCdWZmZXJbal0gPSByaW5nQnVmZmVyW2pdO1xuXG4gICAgICAgIGlmIChzb3J0QnVmZmVyW2pdIDwgbWluKSB7XG4gICAgICAgICAgbWluID0gc29ydEJ1ZmZlcltqXTtcbiAgICAgICAgICBtaW5JbmRleCA9IGo7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc3dhcCBtaW5JbmRleCBhbmQgc3RhcnRJbmRleFxuICAgICAgY29uc3QgY2FjaGUgPSBzb3J0QnVmZmVyW3N0YXJ0SW5kZXhdO1xuICAgICAgc29ydEJ1ZmZlcltzdGFydEluZGV4XSA9IHNvcnRCdWZmZXJbbWluSW5kZXhdO1xuICAgICAgc29ydEJ1ZmZlclttaW5JbmRleF0gPSBjYWNoZTtcblxuICAgICAgc3RhcnRJbmRleCArPSAxO1xuICAgIH1cblxuICAgIGNvbnN0IG1lZGlhbiA9IHNvcnRCdWZmZXJbbWVkaWFuSW5kZXhdO1xuICAgIHRoaXMucmluZ0luZGV4ID0gKHJpbmdJbmRleCArIDEpICUgb3JkZXI7XG5cbiAgICByZXR1cm4gbWVkaWFuO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NWZWN0b3IoZnJhbWUpIHtcbiAgICB0aGlzLmlucHV0VmVjdG9yKGZyYW1lLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBmb3IgdGhlIHVzZSBvZiBhIGBNb3ZpbmdNZWRpYW5gIG91dHNpZGUgYSBncmFwaCAoZS5nLiBpbnNpZGVcbiAgICogYW5vdGhlciBub2RlKSwgaW4gdGhpcyBjYXNlIGBwcm9jZXNzU3RyZWFtUGFyYW1zYCBhbmQgYHJlc2V0U3RyZWFtYFxuICAgKiBzaG91bGQgYmUgY2FsbGVkIG1hbnVhbGx5IG9uIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgLSBWYWx1ZXMgdG8gZmVlZCB0aGUgbW92aW5nIG1lZGlhbiB3aXRoLlxuICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IC0gTWVkaWFuIHZhbHVlcyBmb3IgZWFjaCBkaW1lbnNpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAgICpcbiAgICogY29uc3QgbW92aW5nTWVkaWFuID0gbmV3IE1vdmluZ01lZGlhbih7IG9yZGVyOiAzLCBmaWxsOiAwIH0pO1xuICAgKiBtb3ZpbmdNZWRpYW4uaW5pdFN0cmVhbSh7IGZyYW1lU2l6ZTogMywgZnJhbWVUeXBlOiAndmVjdG9yJyB9KTtcbiAgICpcbiAgICogbW92aW5nTWVkaWFuLmlucHV0QXJyYXkoWzEsIDFdKTtcbiAgICogPiBbMCwgMF1cbiAgICogbW92aW5nTWVkaWFuLmlucHV0QXJyYXkoWzIsIDJdKTtcbiAgICogPiBbMSwgMV1cbiAgICogbW92aW5nTWVkaWFuLmlucHV0QXJyYXkoWzMsIDNdKTtcbiAgICogPiBbMiwgMl1cbiAgICovXG4gIGlucHV0VmVjdG9yKHZhbHVlcykge1xuICAgIGNvbnN0IG9yZGVyID0gdGhpcy5wYXJhbXMuZ2V0KCdvcmRlcicpO1xuICAgIGNvbnN0IHJpbmdCdWZmZXIgPSB0aGlzLnJpbmdCdWZmZXI7XG4gICAgY29uc3QgcmluZ0luZGV4ID0gdGhpcy5yaW5nSW5kZXg7XG4gICAgY29uc3Qgc29ydEJ1ZmZlciA9IHRoaXMuc29ydEJ1ZmZlcjtcbiAgICBjb25zdCBvdXRGcmFtZSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICBjb25zdCBtaW5JbmRpY2VzID0gdGhpcy5taW5JbmRpY2VzO1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBtZWRpYW5JbmRleCA9IE1hdGguZmxvb3Iob3JkZXIgLyAyKTtcbiAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtZWRpYW5JbmRleDsgaSsrKSB7XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZnJhbWVTaXplOyBqKyspIHtcbiAgICAgICAgb3V0RnJhbWVbal0gPSArSW5maW5pdHk7XG4gICAgICAgIG1pbkluZGljZXNbal0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGsgPSBzdGFydEluZGV4OyBrIDwgb3JkZXI7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gayAqIGZyYW1lU2l6ZSArIGo7XG5cbiAgICAgICAgICAvLyB1cGRhdGUgcmluZyBidWZmZXIgY29ycmVzcG9uZGluZyB0byBjdXJyZW50XG4gICAgICAgICAgaWYgKGsgPT09IHJpbmdJbmRleCAmJiBpID09PSAwKVxuICAgICAgICAgICAgcmluZ0J1ZmZlcltpbmRleF0gPSB2YWx1ZXNbal07XG5cbiAgICAgICAgICAvLyBjb3B5IHZhbHVlIGluIHNvcnQgYnVmZmVyIG9uIGZpcnN0IHBhc3NcbiAgICAgICAgICBpZiAoaSA9PT0gMCnCoFxuICAgICAgICAgICAgc29ydEJ1ZmZlcltpbmRleF0gPSByaW5nQnVmZmVyW2luZGV4XTtcblxuICAgICAgICAgIC8vIGZpbmQgbWluaXVtIGluIHRoZSByZW1haW5pbmcgYXJyYXlcbiAgICAgICAgICBpZiAoc29ydEJ1ZmZlcltpbmRleF0gPCBvdXRGcmFtZVtqXSkge1xuICAgICAgICAgICAgb3V0RnJhbWVbal0gPSBzb3J0QnVmZmVyW2luZGV4XTtcbiAgICAgICAgICAgIG1pbkluZGljZXNbal0gPSBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzd2FwIG1pbmltdW0gYW5kIGN1cmVudCBpbmRleFxuICAgICAgICBjb25zdCBzd2FwSW5kZXggPSBzdGFydEluZGV4ICogZnJhbWVTaXplICsgajtcbiAgICAgICAgY29uc3QgdiA9IHNvcnRCdWZmZXJbc3dhcEluZGV4XTtcbiAgICAgICAgc29ydEJ1ZmZlcltzd2FwSW5kZXhdID0gc29ydEJ1ZmZlclttaW5JbmRpY2VzW2pdXTtcbiAgICAgICAgc29ydEJ1ZmZlclttaW5JbmRpY2VzW2pdXSA9IHY7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhpcyBtaW5pbXVtIHZhbHVlIGFzIGN1cnJlbnQgcmVzdWx0XG4gICAgICAgIG91dEZyYW1lW2pdID0gc29ydEJ1ZmZlcltzd2FwSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBzdGFydEluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5yaW5nSW5kZXggPSAocmluZ0luZGV4ICsgMSkgJSBvcmRlcjtcblxuICAgIHJldHVybiB0aGlzLmZyYW1lLmRhdGE7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAgdGhpcy5wcmVwcm9jZXNzRnJhbWUoKTtcbiAgICB0aGlzLnByb2Nlc3NGdW5jdGlvbihmcmFtZSk7XG5cbiAgICBjb25zdCBvcmRlciA9IHRoaXMucGFyYW1zLmdldCgnb3JkZXInKTtcbiAgICBsZXQgdGltZSA9IGZyYW1lLnRpbWU7XG4gICAgLy8gc2hpZnQgdGltZSB0byB0YWtlIGFjY291bnQgb2YgdGhlIGFkZGVkIGxhdGVuY3lcbiAgICBpZiAodGhpcy5zdHJlYW1QYXJhbXMuc291cmNlU2FtcGxlUmF0ZSlcbiAgICAgIHRpbWUgLT0gKDAuNSAqIChvcmRlciAtIDEpIC8gdGhpcy5zdHJlYW1QYXJhbXMuc291cmNlU2FtcGxlUmF0ZSk7XG5cbiAgICB0aGlzLmZyYW1lLnRpbWUgPSB0aW1lO1xuICAgIHRoaXMuZnJhbWUubWV0YWRhdGEgPSBmcmFtZS5tZXRhZGF0YTtcblxuICAgIHRoaXMucHJvcGFnYXRlRnJhbWUodGltZSwgdGhpcy5vdXRGcmFtZSwgbWV0YWRhdGEpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vdmluZ01lZGlhbjtcbiIsImltcG9ydCBCYXNlTGZvIGZyb20gJy4uLy4uL2NvcmUvQmFzZUxmbyc7XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICAvLyBmbG9hdCBvciBhcnJheVxuICBmYWN0b3I6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiAxLFxuICB9XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGEgZ2l2ZW4gc2lnbmFsIG9yIHZlY3RvciBieSBhIGdpdmVuIGZhY3Rvci4gT24gdmVjdG9yXG4gKiBzdHJlYW1zLCBgZmFjdG9yYCBjYW4gYmUgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIGFwcGx5IG9uIGVhY2ggZGltZW5zaW9uIG9mIHRoZVxuICogdmVjdG9yIGZyYW1lcy5cbiAqXG4gKiBfc3VwcG9ydCBgc3RhbmRhbG9uZWAgdXNhZ2VfXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvdmVycmlkZSBkZWZhdWx0IHZhbHVlc1xuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IFtvcHRpb25zLmZhY3Rvcj0xXSAtIGZhY3RvciBvciBhcnJheSBvZiBmYWN0b3IgdG9cbiAqICBhcHBseSBvbiB0aGUgaW5jb21taW5nIGZyYW1lLiBTZXR0aW5nIGFuIGFycmF5IGlzIG9ubHkgZGVmaW5lZCBpbiBjYXNlIG9mXG4gKiAgYSB2ZWN0b3Igc3RyZWFtLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY29tbW9uJztcbiAqXG4gKiBjb25zdCBldmVudEluID0gbmV3IGxmby5vcGVyYXRvci5FdmVudEluKHtcbiAqICAgdHlwZTogJ3ZlY3RvcicsXG4gKiAgIGZyYW1lU2l6ZTogMixcbiAqICAgZnJhbWVSYXRlOiAwLFxuICogfSk7XG4gKiBjb25zdCBzY2FsZXIgPSBuZXcgbGZvLm9wZXJhdG9yLk11bHRpcGxpZXIoeyBmYWN0b3I6IDAuMSB9KTtcbiAqXG4gKiBldmVudEluLmNvbm5lY3Qoc2NhbGVyKTtcbiAqXG4gKiBldmVudEluLnByb2Nlc3MobnVsbCwgWzIsIDNdKTtcbiAqID4gWzAuMiwgMC4zXVxuICovXG5jbGFzcyBNdWx0aXBsaWVyIGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBgTXVsdGlwbGllcmAgb3BlcmF0b3IgaW4gc3RhbmRhbG9uZSBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheX0gZGF0YSAtIElucHV0IHZlY3RvclxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBTY2FsZWQgdmFsdWVzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHNjYWxlciA9IG5ldyBNdWx0aXBsaWVyKHsgZmFjdG9yOiBbMiwgNF0gfSk7XG4gICAqIHNjYWxlci5pbml0U3RyZWFtKHsgZnJhbWVUeXBlOiAndmVjdG9yJywgZnJhbWVTaXplOiAyIH0pO1xuICAgKlxuICAgKiBzY2FsZXIuaW5wdXRWZWN0b3IoWzMsIDJdKTtcbiAgICogPiBbNiwgOF1cbiAgICovXG4gIGlucHV0VmVjdG9yKGRhdGEpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgY29uc3QgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgIGNvbnN0IGZhY3RvciA9IHRoaXMucGFyYW1zLmdldCgnZmFjdG9yJyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmYWN0b3IpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKVxuICAgICAgICBvdXRwdXRbaV0gPSBkYXRhW2ldICogZmFjdG9yW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKVxuICAgICAgICBvdXRwdXRbaV0gPSBkYXRhW2ldICogZmFjdG9yO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgIHRoaXMuZnJhbWUuZGF0YSA9IHRoaXMuaW5wdXRWZWN0b3IoZnJhbWUuZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBgTXVsdGlwbGllcmAgb3BlcmF0b3IgaW4gc3RhbmRhbG9uZSBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheX0gZGF0YSAtIElucHV0IHNpZ25hbC5cbiAgICogQHJldHVybiB7QXJyYXl9IC0gU2NhbGVkIHNpZ25hbC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgc2NhbGVyID0gbmV3IE11bHRpcGxpZXIoeyBmYWN0b3I6IDAuMSB9KTtcbiAgICogc2NhbGVyLmluaXRTdHJlYW0oeyBmcmFtZVR5cGU6ICdzaWduYWwnLCBmcmFtZVNpemU6IDIgfSk7XG4gICAqXG4gICAqIHNjYWxlci5pbnB1dFZlY3RvcihbMSwgMl0pO1xuICAgKiA+IFswLjEsIDAuMl1cbiAgICovXG4gIGlucHV0U2lnbmFsKGRhdGEpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgY29uc3QgZnJhbWVTaXplID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgIGNvbnN0IGZhY3RvciA9IHRoaXMucGFyYW1zLmdldCgnZmFjdG9yJyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKVxuICAgICAgb3V0cHV0W2ldID0gZGF0YVtpXSAqIGZhY3RvcjtcblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1NpZ25hbChmcmFtZSkge1xuICAgIHRoaXMuZnJhbWUuZGF0YSA9IHRoaXMuaW5wdXRTaWduYWwoZnJhbWUuZGF0YSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTXVsdGlwbGllcjtcbiIsImltcG9ydCBCYXNlTGZvIGZyb20gJy4uLy4uL2NvcmUvQmFzZUxmbyc7XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICBzdGF0ZToge1xuICAgIHR5cGU6ICdlbnVtJyxcbiAgICBkZWZhdWx0OiAnb24nLFxuICAgIGxpc3Q6IFsnb24nLCAnb2ZmJ10sXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH0sXG59O1xuXG4vKipcbiAqIFRoZSBPbk9mZiBvcGVyYXRvciBhbGxvd3MgdG8gc3RvcCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHN0cmVhbSBpbiBhXG4gKiBzdWJncmFwaC4gV2hlbiBcIm9uXCIsIGZyYW1lcyBhcmUgcHJvcGFnYXRlZCwgd2hlbiBcIm9mZlwiIHRoZSBwcm9wYWdhdGlvbiBpc1xuICogc3RvcHBlZC5cbiAqXG4gKiBUaGUgYHN0cmVhbVBhcmFtc2AgcHJvcGFnYXRpb24gaXMgbmV2ZXIgYnlwYXNzZWQgc28gdGhlIHN1YnNlcXVlbnQgc3ViZ3JhcGhcbiAqIGlzIGFsd2F5cyByZWFkeSBmb3IgaW5jb21taW5nIGZyYW1lcy5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0YXRlPSdvbiddIC0gRGVmYXVsdCBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jb21tb24nO1xuICpcbiAqIGNvbnN0IGZyYW1lcyA9IFtcbiAqICAgeyB0aW1lOiAwLCBkYXRhOiBbMSwgMl0gfSxcbiAqICAgeyB0aW1lOiAxLCBkYXRhOiBbMywgNF0gfSxcbiAqICAgeyB0aW1lOiAyLCBkYXRhOiBbNSwgNl0gfSxcbiAqIF07XG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBFdmVudEluKHtcbiAqICAgZnJhbWVTaXplOiAyLFxuICogICBmcmFtZVJhdGU6IDAsXG4gKiAgIGZyYW1lVHlwZTogJ3ZlY3RvcicsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBvbk9mZiA9IG5ldyBPbk9mZigpO1xuICpcbiAqIGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoeyBkYXRhOiB0cnVlIH0pO1xuICpcbiAqIGV2ZW50SW4uY29ubmVjdChvbk9mZik7XG4gKiBvbk9mZi5jb25uZWN0KGxvZ2dlcik7XG4gKlxuICogZXZlbnRJbi5zdGFydCgpO1xuICpcbiAqIGV2ZW50SW4ucHJvY2Vzc0ZyYW1lKGZyYW1lc1swXSk7XG4gKiA+IFswLCAxXVxuICpcbiAqIC8vIGJ5cGFzcyBzdWJncmFwaFxuICogb25PZmYuc2V0U3RhdGUoJ29mZicpO1xuICogZXZlbnRJbi5wcm9jZXNzRnJhbWUoZnJhbWVzWzFdKTtcbiAqXG4gKiAvLyByZS1vcGVuIHN1YmdyYXBoXG4gKiBvbk9mZi5zZXRTdGF0ZSgnb24nKTtcbiAqIGV2ZW50SW4ucHJvY2Vzc0ZyYW1lKGZyYW1lc1syXSk7XG4gKiA+IFs1LCA2XVxuICovXG5jbGFzcyBPbk9mZiBleHRlbmRzIEJhc2VMZm8ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnN0YXRlID0gdGhpcy5wYXJhbXMuZ2V0KCdzdGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RhdGUgb2YgdGhlIGBPbk9mZmAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZSAtIE5ldyBzdGF0ZSBvZiB0aGUgb3BlcmF0b3IgKGBvbmAgb3IgYG9mZmApXG4gICAqL1xuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmIChkZWZpbml0aW9ucy5zdGF0ZS5saXN0LmluZGV4T2Yoc3RhdGUpID09PSAtMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzd2l0Y2ggc3RhdGUgdmFsdWUgXCIke3N0YXRlfVwiIFt2YWxpZCB2YWx1ZXM6IFwib25cIi9cIm9mZlwiXWApO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgLy8gZGVmaW5lIGFsbCBwb3NzaWJsZSBzdHJlYW0gQVBJXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU2NhbGFyKCkge31cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NWZWN0b3IoKSB7fVxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1NpZ25hbCgpIHt9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAnb24nKSB7XG4gICAgICB0aGlzLnByZXBhcmVGcmFtZSgpO1xuXG4gICAgICB0aGlzLmZyYW1lLnRpbWUgPSBmcmFtZS50aW1lO1xuICAgICAgdGhpcy5mcmFtZS5tZXRhZGF0YSA9IGZyYW1lLm1ldGFkYXRhO1xuICAgICAgdGhpcy5mcmFtZS5kYXRhID0gZnJhbWUuZGF0YTtcblxuICAgICAgdGhpcy5wcm9wYWdhdGVGcmFtZSgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPbk9mZjtcbiIsImltcG9ydCBCYXNlTGZvIGZyb20gJy4uLy4uL2NvcmUvQmFzZUxmbyc7XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICBleHBvbmVudDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMSxcbiAgfSxcbn07XG5cbi8qKlxuICogQXBwbHkgYW4gZXhwb25hbnQgcG93ZXIgdG8gdGhlIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtOdW1iZXJ9IGV4cG9uZW50IC0gRXhwb25lbnRcbiAqL1xuY2xhc3MgUG93ZXIgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlucHV0VmVjdG9yKGRhdGEpIHtcbiAgICBjb25zdCBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBleHBvbmVudCA9IHRoaXMucGFyYW1zLmdldCgnZXhwb25lbnQnKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVTaXplOyBpKyspXG4gICAgICBvdXREYXRhW2ldID0gTWF0aC5wb3coZGF0YVtpXSwgZXhwb25lbnQpO1xuXG4gICAgcmV0dXJuIG91dERhdGE7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgIHRoaXMuaW5wdXRWZWN0b3IoZnJhbWUuZGF0YSk7XG4gIH1cblxuICBpbnB1dFNpZ25hbChkYXRhKSB7XG4gICAgY29uc3Qgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgY29uc3QgZXhwb25lbnQgPSB0aGlzLnBhcmFtcy5nZXQoJ2V4cG9uZW50Jyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKVxuICAgICAgb3V0RGF0YVtpXSA9IE1hdGgucG93KGRhdGFbaV0sIGV4cG9uZW50KTtcblxuICAgIHJldHVybiBvdXREYXRhO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICB0aGlzLmlucHV0U2lnbmFsKGZyYW1lLmRhdGEpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvd2VyO1xuIiwiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi4vLi4vY29yZS9CYXNlTGZvJztcblxuY29uc3Qgc3FydCA9IE1hdGguc3FydDtcblxuY29uc3QgZGVmaW5pdGlvbnMgPSB7XG4gIHBvd2VyOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeW5hbWljJyB9LFxuICB9LFxufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBSb290IE1lYW4gU3F1YXJlIG9mIGEgYHNpZ25hbGAuXG4gKlxuICogX3N1cHBvcnQgYHN0YW5kYWxvbmVgIHVzYWdlX1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBvd2VyPWZhbHNlXSAtIElmIGB0cnVlYCByZW1vdmUgdGhlIFwiUlwiIG9mIHRoZVxuICogIFwiUm1zXCIgYW5kIHJldHVybiB0aGUgc3F1YXJlZCByZXN1bHQgKGkuZS4gcG93ZXIpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogLy8gYXNzdW1pbmcgc29tZSBgQXVkaW9CdWZmZXJgXG4gKiBjb25zdCBhdWRpb0luQnVmZmVyID0gbmV3IGxmby5zb3VyY2UuQXVkaW9JbkJ1ZmZlcih7XG4gKiAgIGF1ZGlvQnVmZmVyOiBhdWRpb0J1ZmZlcixcbiAqICAgZnJhbWVTaXplOiA1MTIsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBybXMgPSBuZXcgbGZvLm9wZXJhdG9yLlJtcygpO1xuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogYXVkaW9JbkJ1ZmZlci5jb25uZWN0KHJtcyk7XG4gKiBybXMuY29ubmVjdChsb2dnZXIpO1xuICpcbiAqIGF1ZGlvSW5CdWZmZXIuc3RhcnQoKTtcbiAqL1xuY2xhc3MgUm1zIGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPSAxO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICdzY2FsYXInO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmRlc2NyaXB0aW9uID0gWydybXMnXTtcblxuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIGZvciB0aGUgdXNlIG9mIGEgYFJtc2Agb3V0c2lkZSBhIGdyYXBoIChlLmcuIGluc2lkZVxuICAgKiBhbm90aGVyIG5vZGUpLiBSZXR1cm4gdGhlIHJtcyBvZiB0aGUgZ2l2ZW4gc2lnbmFsIGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2lnbmFsIC0gU2lnbmFsIGJsb2NrIHRvIGJlIGNvbXB1dGVkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gcm1zIG9mIHRoZSBpbnB1dCBzaWduYWwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAgICpcbiAgICogY29uc3Qgcm1zID0gbmV3IGxmby5vcGVyYXRvci5SbXMoKTtcbiAgICogcm1zLmluaXRTdHJlYW0oeyBmcmFtZVR5cGU6ICdzaWduYWwnLCBmcmFtZVNpemU6IDEwMDAgfSk7XG4gICAqXG4gICAqIGNvbnN0IHJlc3VsdHMgPSBybXMuaW5wdXRTaWduYWwoWy4uLnZhbHVlc10pO1xuICAgKi9cbiAgaW5wdXRTaWduYWwoc2lnbmFsKSB7XG4gICAgY29uc3QgcG93ZXIgPSB0aGlzLnBhcmFtcy5nZXQoJ3Bvd2VyJyk7XG4gICAgY29uc3QgbGVuZ3RoID0gc2lnbmFsLmxlbmd0aDtcbiAgICBsZXQgcm1zID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICBybXMgKz0gKHNpZ25hbFtpXSAqIHNpZ25hbFtpXSk7XG5cbiAgICBybXMgPSBybXMgLyBsZW5ndGg7XG5cbiAgICBpZiAoIXBvd2VyKVxuICAgICAgcm1zID0gc3FydChybXMpO1xuXG4gICAgcmV0dXJuIHJtcztcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgdGhpcy5mcmFtZS5kYXRhWzBdID0gdGhpcy5pbnB1dFNpZ25hbChmcmFtZS5kYXRhKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSbXM7XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgdHlwZToge1xuICAgIHR5cGU6ICdlbnVtJyxcbiAgICBsaXN0OiBbJ2xpbmVhciddLFxuICAgIGRlZmF1bHQ6ICdsaW5lYXInLFxuICAgIG1ldGFzOiB7XG4gICAgICBraW5kOiAnZHluYW1pYycsXG4gICAgfVxuICB9LFxuICBpbnB1dE1pbjoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtaW46IC1JbmZpbml0eSxcbiAgICBtYXg6ICtJbmZpbml0eSxcbiAgICBtZXRhczoge1xuICAgICAga2luZDogJ2R5bmFtaWMnLFxuICAgIH0sXG4gIH0sXG4gIGlucHV0TWF4OiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbjogLUluZmluaXR5LFxuICAgIG1heDogK0luZmluaXR5LFxuICAgIG1ldGFzOiB7XG4gICAgICBraW5kOiAnZHluYW1pYycsXG4gICAgfSxcbiAgfSxcbiAgb3V0cHV0TWluOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbjogLUluZmluaXR5LFxuICAgIG1heDogK0luZmluaXR5LFxuICAgIG1ldGFzOiB7XG4gICAgICBraW5kOiAnZHluYW1pYycsXG4gICAgfSxcbiAgfSxcbiAgb3V0cHV0TWF4OiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbjogLUluZmluaXR5LFxuICAgIG1heDogK0luZmluaXR5LFxuICAgIG1ldGFzOiB7XG4gICAgICBraW5kOiAnZHluYW1pYycsXG4gICAgfSxcbiAgfSxcbn1cblxuLyoqXG4gKiBBcHBseSBhIGxpbmVhciBzY2FsZSBvbiB0aGUgaW5jb21taW5nIHN0cmVhbS4gVGhlIG91dHB1dCBpcyBub3QgY2xpcHBlZC5cbiAqXG4gKiBAdG9kbyAtIGltcGxlbWVudCBsb2cgYW5kIGV4cCBzY2FsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaW5wdXRNaW49MF0gLSBJbnB1dCBNaW5pbXVtXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaW5wdXRNYXg9MV0gLSBJbnB1dCBNYXhpbXVtXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub3V0cHV0TWluPTBdIC0gT3V0cHV0IE1pbmltdW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vdXRwdXRNYXg9MV0gLSBPdXRwdXQgTWF4aW11bVxuICovXG5jbGFzcyBTY2FsZSBleHRlbmRzIEJhc2VMZm8ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoZGVmaW5pdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5zY2FsZSA9IG51bGw7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3NldFNjYWxlRnVuY3Rpb24oKSB7XG4gICAgY29uc3QgaW5wdXRNaW4gPSB0aGlzLnBhcmFtcy5nZXQoJ2lucHV0TWluJyk7XG4gICAgY29uc3QgaW5wdXRNYXggPSB0aGlzLnBhcmFtcy5nZXQoJ2lucHV0TWF4Jyk7XG4gICAgY29uc3Qgb3V0cHV0TWluID0gdGhpcy5wYXJhbXMuZ2V0KCdvdXRwdXRNaW4nKTtcbiAgICBjb25zdCBvdXRwdXRNYXggPSB0aGlzLnBhcmFtcy5nZXQoJ291dHB1dE1heCcpO1xuXG4gICAgY29uc3QgYSA9IChvdXRwdXRNYXggLSBvdXRwdXRNaW4pIC8gKGlucHV0TWF4IC0gaW5wdXRNaW4pO1xuICAgIGNvbnN0IGIgPSBvdXRwdXRNaW4gLSBhICogaW5wdXRNaW47XG5cbiAgICB0aGlzLnNjYWxlID0gKHgpID0+IGEgKiB4ICsgYjtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBvblBhcmFtVXBkYXRlKG5hbWUsIHZhbHVlLCBtZXRhcykge1xuICAgIHN1cGVyLm9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgIGlmIChuYW1lICE9PSAndHlwZScpXG4gICAgICB0aGlzLl9zZXRTY2FsZUZ1bmN0aW9uKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgdGhpcy5fc2V0U2NhbGVGdW5jdGlvbigpO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIGlucHV0VmVjdG9yKGRhdGEpIHtcbiAgICBjb25zdCBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKVxuICAgICAgb3V0RGF0YVtpXSA9IHNjYWxlKGRhdGFbaV0pO1xuXG4gICAgcmV0dXJuIG91dERhdGE7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgIHRoaXMuZnJhbWUuZGF0YSA9IHRoaXMuaW5wdXRWZWN0b3IoZnJhbWUuZGF0YSk7XG4gIH1cblxuICBpbnB1dFNpZ25hbChkYXRhKSB7XG4gICAgY29uc3Qgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVNpemU7IGkrKylcbiAgICAgIG91dERhdGFbaV0gPSBzY2FsZShkYXRhW2ldKTtcblxuICAgIHJldHVybiBvdXREYXRhO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICB0aGlzLmZyYW1lLmRhdGEgPSB0aGlzLmlucHV0VmVjdG9yKGZyYW1lLmRhdGEpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjYWxlO1xuIiwiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi4vLi4vY29yZS9CYXNlTGZvJztcbmltcG9ydCBNb3ZpbmdBdmVyYWdlIGZyb20gJy4vTW92aW5nQXZlcmFnZSc7XG5cbmNvbnN0IG1pbiA9IE1hdGgubWluO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5cbmNvbnN0IGRlZmluaXRpb25zID0ge1xuICBsb2dJbnB1dDoge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfSxcbiAgfSxcbiAgbWluSW5wdXQ6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDAuMDAwMDAwMDAwMDAxLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9LFxuICB9LFxuICBmaWx0ZXJPcmRlcjoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiA1LFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9LFxuICB9LFxuICB0aHJlc2hvbGQ6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDMsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH0sXG4gIH0sXG4gIG9mZlRocmVzaG9sZDoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogLUluZmluaXR5LFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdkeWFubWljJyB9LFxuICB9LFxuICBtaW5JbnRlcjoge1xuICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgZGVmYXVsdDogMC4wNTAsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5YW5taWMnIH0sXG4gIH0sXG4gIG1heER1cmF0aW9uOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiBJbmZpbml0eSxcbiAgICBtZXRhczogeyBraW5kOiAnZHlhbm1pYycgfSxcbiAgfSxcbn1cblxuLyoqXG4gKiBDcmVhdGUgc2VnbWVudHMgYmFzZWQgb24gYXR0YWNrcy5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5sb2dJbnB1dD1mYWxzZV0gLSBBcHBseSBsb2cgb24gdGhlIGlucHV0LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbklucHV0PTAuMDAwMDAwMDAwMDAxXSAtIE1pbmltdW0gdmFsdWUgdG8gdXNlIGFzXG4gKiAgaW5wdXQuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmlsdGVyT3JkZXI9NV0gLSBPcmRlciBvZiB0aGUgaW50ZXJuYWxseSB1c2VkIG1vdmluZ1xuICogIGF2ZXJhZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTNdIC0gVGhyZXNob2xkIHRoYXQgdHJpZ2dlcnMgYSBzZWdtZW50XG4gKiAgc3RhcnQuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2ZmVGhyZXNob2xkPS1JbmZpbml0eV0gLSBUaHJlc2hvbGQgdGhhdCB0cmlnZ2Vyc1xuICogIGEgc2VnbWVudCBlbmQuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluSW50ZXI9MC4wNTBdIC0gTWluaW11bSBkZWxheSBiZXR3ZWVuIHR3byBzZW1nZW50cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhEdXJhdGlvbj1JbmZpbml0eV0gLSBNYXhpbXVtIGR1cmF0aW9uIG9mIGEgc2VnbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jbGllbnQnO1xuICpcbiAqIC8vIGFzc3VtaW5nIGEgc3RyZWFtIGZyb20gdGhlIG1pY3JvcGhvbmVcbiAqIGNvbnN0IHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xuICpcbiAqIGNvbnN0IGF1ZGlvSW5Ob2RlID0gbmV3IGxmby5zb3VyY2UuQXVkaW9Jbk5vZGUoe1xuICogICBzb3VyY2VOb2RlOiBzb3VyY2UsXG4gKiAgIGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0LFxuICogfSk7XG4gKlxuICogY29uc3Qgc2xpY2VyID0gbmV3IGxmby5vcGVyYXRvci5TbGljZXIoe1xuICogICBmcmFtZVNpemU6IGZyYW1lU2l6ZSxcbiAqICAgaG9wU2l6ZTogaG9wU2l6ZSxcbiAqICAgY2VudGVyZWRUaW1lVGFnczogdHJ1ZVxuICogfSk7XG4gKlxuICogY29uc3QgcG93ZXIgPSBuZXcgbGZvLm9wZXJhdG9yLlJNUyh7XG4gKiAgIHBvd2VyOiB0cnVlLFxuICogfSk7XG4gKlxuICogY29uc3Qgc2VnbWVudGVyID0gbmV3IGxmby5vcGVyYXRvci5TZWdtZW50ZXIoe1xuICogICBsb2dJbnB1dDogdHJ1ZSxcbiAqICAgZmlsdGVyT3JkZXI6IDUsXG4gKiAgIHRocmVzaG9sZDogMyxcbiAqICAgb2ZmVGhyZXNob2xkOiAtSW5maW5pdHksXG4gKiAgIG1pbkludGVyOiAwLjA1MCxcbiAqICAgbWF4RHVyYXRpb246IDAuMDUwLFxuICogfSk7XG4gKlxuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IHRpbWU6IHRydWUgfSk7XG4gKlxuICogYXVkaW9Jbk5vZGUuY29ubmVjdChzbGljZXIpO1xuICogc2xpY2VyLmNvbm5lY3QocG93ZXIpO1xuICogcG93ZXIuY29ubmVjdChzZWdtZW50ZXIpO1xuICogc2VnbWVudGVyLmNvbm5lY3QobG9nZ2VyKTtcbiAqXG4gKiBhdWRpb0luTm9kZS5zdGFydCgpO1xuICovXG5jbGFzcyBTZWdtZW50ZXIgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaW5zaWRlU2VnbWVudCA9IGZhbHNlO1xuICAgIHRoaXMub25zZXRUaW1lID0gLUluZmluaXR5O1xuXG4gICAgLy8gc3RhdHNcbiAgICB0aGlzLm1pbiA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4ID0gLUluZmluaXR5O1xuICAgIHRoaXMuc3VtID0gMDtcbiAgICB0aGlzLnN1bU9mU3F1YXJlcyA9IDA7XG4gICAgdGhpcy5jb3VudCA9IDA7XG5cbiAgICBjb25zdCBtaW5JbnB1dCA9IHRoaXMucGFyYW1zLmdldCgnbWluSW5wdXQnKTtcbiAgICBsZXQgZmlsbCA9IG1pbklucHV0O1xuXG4gICAgaWYgKHRoaXMucGFyYW1zLmdldCgnbG9nSW5wdXQnKSAmJiBtaW5JbnB1dCA+IDApXG4gICAgICBmaWxsID0gTWF0aC5sb2cobWluSW5wdXQpO1xuXG4gICAgdGhpcy5tb3ZpbmdBdmVyYWdlID0gbmV3IE1vdmluZ0F2ZXJhZ2Uoe1xuICAgICAgb3JkZXI6IHRoaXMucGFyYW1zLmdldCgnZmlsdGVyT3JkZXInKSxcbiAgICAgIGZpbGw6IGZpbGwsXG4gICAgfSk7XG5cbiAgICB0aGlzLmxhc3RNdmF2cmcgPSBmaWxsO1xuICB9XG5cbiAgb25QYXJhbVVwZGF0ZShuYW1lLCB2YWx1ZSwgbWV0YXMpIHtcbiAgICBzdXBlci5vblBhcmFtVXBkYXRlKG5hbWUsIHZhbHVlLCBtZXRhcyk7XG5cbiAgICBpZiAobmFtZSA9PT0gJ2ZpbHRlck9yZGVyJylcbiAgICAgIHRoaXMubW92aW5nQXZlcmFnZS5wYXJhbXMuc2V0KCdvcmRlcicsIHZhbHVlKTtcbiAgfVxuXG4gIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICd2ZWN0b3InO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IDU7XG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlID0gMDtcbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5kZXNjcmlwdGlvbiA9IFsnZHVyYXRpb24nLCAnbWluJywgJ21heCcsICdtZWFuJywgJ3N0ZGRldiddO1xuXG5cbiAgICB0aGlzLm1vdmluZ0F2ZXJhZ2UuaW5pdFN0cmVhbShwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICByZXNldFN0cmVhbSgpIHtcbiAgICBzdXBlci5yZXNldFN0cmVhbSgpO1xuICAgIHRoaXMubW92aW5nQXZlcmFnZS5yZXNldFN0cmVhbSgpO1xuICAgIHRoaXMucmVzZXRTZWdtZW50KCk7XG4gIH1cblxuICBmaW5hbGl6ZVN0cmVhbShlbmRUaW1lKSB7XG4gICAgaWYgKHRoaXMuaW5zaWRlU2VnbWVudClcbiAgICAgIHRoaXMub3V0cHV0U2VnbWVudChlbmRUaW1lKTtcblxuICAgIHN1cGVyLmZpbmFsaXplU3RyZWFtKGVuZFRpbWUpO1xuICB9XG5cbiAgcmVzZXRTZWdtZW50KCkge1xuICAgIHRoaXMuaW5zaWRlU2VnbWVudCA9IGZhbHNlO1xuICAgIHRoaXMub25zZXRUaW1lID0gLUluZmluaXR5O1xuICAgIC8vIHN0YXRzXG4gICAgdGhpcy5taW4gPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heCA9IC1JbmZpbml0eTtcbiAgICB0aGlzLnN1bSA9IDA7XG4gICAgdGhpcy5zdW1PZlNxdWFyZXMgPSAwO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG5cbiAgb3V0cHV0U2VnbWVudChlbmRUaW1lKSB7XG4gICAgY29uc3Qgb3V0RGF0YSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICBvdXREYXRhWzBdID0gZW5kVGltZSAtIHRoaXMub25zZXRUaW1lO1xuICAgIG91dERhdGFbMV0gPSB0aGlzLm1pbjtcbiAgICBvdXREYXRhWzJdID0gdGhpcy5tYXg7XG5cbiAgICBjb25zdCBub3JtID0gMSAvIHRoaXMuY291bnQ7XG4gICAgY29uc3QgbWVhbiA9IHRoaXMuc3VtICogbm9ybTtcbiAgICBjb25zdCBtZWFuT2ZTcXVhcmUgPSB0aGlzLnN1bU9mU3F1YXJlcyAqIG5vcm07XG4gICAgY29uc3Qgc3F1YXJlT2ZtZWFuID0gbWVhbiAqIG1lYW47XG5cbiAgICBvdXREYXRhWzNdID0gbWVhbjtcbiAgICBvdXREYXRhWzRdID0gMDtcblxuICAgIGlmIChtZWFuT2ZTcXVhcmUgPiBzcXVhcmVPZm1lYW4pXG4gICAgICBvdXREYXRhWzRdID0gTWF0aC5zcXJ0KG1lYW5PZlNxdWFyZSAtIHNxdWFyZU9mbWVhbik7XG5cbiAgICB0aGlzLmZyYW1lLnRpbWUgPSB0aGlzLm9uc2V0VGltZTtcblxuICAgIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcbiAgfVxuXG4gIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICBjb25zdCBsb2dJbnB1dCA9IHRoaXMucGFyYW1zLmdldCgnbG9nSW5wdXQnKTtcbiAgICBjb25zdCBtaW5JbnB1dCA9IHRoaXMucGFyYW1zLmdldCgnbWluSW5wdXQnKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLnBhcmFtcy5nZXQoJ3RocmVzaG9sZCcpO1xuICAgIGNvbnN0IG1pbkludGVyID0gdGhpcy5wYXJhbXMuZ2V0KCdtaW5JbnRlcicpO1xuICAgIGNvbnN0IG1heER1cmF0aW9uID0gdGhpcy5wYXJhbXMuZ2V0KCdtYXhEdXJhdGlvbicpO1xuICAgIGNvbnN0IG9mZlRocmVzaG9sZCA9IHRoaXMucGFyYW1zLmdldCgnb2ZmVGhyZXNob2xkJyk7XG4gICAgY29uc3QgcmF3VmFsdWUgPSBmcmFtZS5kYXRhWzBdO1xuICAgIGNvbnN0IHRpbWUgPSBmcmFtZS50aW1lO1xuICAgIGxldCB2YWx1ZSA9IE1hdGgubWF4KHJhd1ZhbHVlLCBtaW5JbnB1dCk7XG5cbiAgICBpZiAobG9nSW5wdXQpXG4gICAgICB2YWx1ZSA9IE1hdGgubG9nKHZhbHVlKTtcblxuICAgIGNvbnN0IGRpZmYgPSB2YWx1ZSAtIHRoaXMubGFzdE12YXZyZztcbiAgICB0aGlzLmxhc3RNdmF2cmcgPSB0aGlzLm1vdmluZ0F2ZXJhZ2UuaW5wdXRTY2FsYXIodmFsdWUpO1xuXG4gICAgLy8gdXBkYXRlIGZyYW1lIG1ldGFkYXRhXG4gICAgdGhpcy5mcmFtZS5tZXRhZGF0YSA9IGZyYW1lLm1ldGFkYXRhO1xuXG4gICAgaWYgKGRpZmYgPiB0aHJlc2hvbGQgJiYgdGltZSAtIHRoaXMub25zZXRUaW1lID4gbWluSW50ZXIpIHtcbiAgICAgIGlmICh0aGlzLmluc2lkZVNlZ21lbnQpXG4gICAgICAgIHRoaXMub3V0cHV0U2VnbWVudCh0aW1lKTtcblxuICAgICAgLy8gc3RhcnQgc2VnbWVudFxuICAgICAgdGhpcy5pbnNpZGVTZWdtZW50ID0gdHJ1ZTtcbiAgICAgIHRoaXMub25zZXRUaW1lID0gdGltZTtcbiAgICAgIHRoaXMubWF4ID0gLUluZmluaXR5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmluc2lkZVNlZ21lbnQpIHtcbiAgICAgIHRoaXMubWluID0gbWluKHRoaXMubWluLCByYXdWYWx1ZSk7XG4gICAgICB0aGlzLm1heCA9IG1heCh0aGlzLm1heCwgcmF3VmFsdWUpO1xuICAgICAgdGhpcy5zdW0gKz0gcmF3VmFsdWU7XG4gICAgICB0aGlzLnN1bU9mU3F1YXJlcyArPSByYXdWYWx1ZSAqIHJhd1ZhbHVlO1xuICAgICAgdGhpcy5jb3VudCsrO1xuXG4gICAgICBpZiAodGltZSAtIHRoaXMub25zZXRUaW1lID49IG1heER1cmF0aW9uIHx8IHZhbHVlIDw9IG9mZlRocmVzaG9sZCkge1xuICAgICAgICB0aGlzLm91dHB1dFNlZ21lbnQodGltZSk7XG4gICAgICAgIHRoaXMuaW5zaWRlU2VnbWVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgIHRoaXMucHJlcGFyZUZyYW1lKCk7XG4gICAgdGhpcy5wcm9jZXNzRnVuY3Rpb24oZnJhbWUpO1xuICAgIC8vIGRvIG5vdCBwcm9wYWdhdGUgaGVyZSBhcyB0aGUgZnJhbWVSYXRlIGlzIG5vdyB6ZXJvXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VnbWVudGVyO1xuIiwiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi4vLi4vY29yZS9CYXNlTGZvJztcblxuY29uc3QgZGVmaW5pdGlvbnMgPSB7XG4gIGluZGV4OiB7XG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfSxcbiAgfSxcbiAgaW5kZXhlczoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH1cbn07XG5cbi8qKlxuICogU2VsZWN0IG9uZSBvciBzZXZlcmFsIGluZGV4ZXMgZnJvbSBhIGB2ZWN0b3JgIGlucHV0LiBJZiBvbmx5IG9uZSBpbmRleCBpc1xuICogc2VsZWN0ZWQsIHRoZSBvdXRwdXQgd2lsbCBiZSBvZiB0eXBlIGBzY2FsYXJgLCBvdGhlcndpc2UgdGhlIG91dHB1dCB3aWxsXG4gKiBiZSBhIHZlY3RvciBjb250YWluaW5nIHRoZSBzZWxlY3RlZCBpbmRleGVzLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHZhbHVlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmluZGV4IC0gSW5kZXggdG8gc2VsZWN0IGZyb20gdGhlIGlucHV0IGZyYW1lLlxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBvcHRpb25zLmluZGV4ZXMgLSBJbmRpY2VzIHRvIHNlbGVjdCBmcm9tIHRoZSBpbnB1dFxuICogIGZyYW1lLCBpZiBkZWZpbmVkLCB0YWtlIHByZWNlZGFuY2Ugb3ZlciBgb3B0aW9uLmluZGV4YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jb21tb24nO1xuICpcbiAqIGNvbnN0IGV2ZW50SW4gPSBuZXcgbGZvLnNvdXJjZS5FdmVudEluKHtcbiAqICAgZnJhbWVUeXBlOiAndmVjdG9yJyxcbiAqICAgZnJhbWVTaXplOiAzLFxuICogfSk7XG4gKlxuICogY29uc3Qgc2VsZWN0ID0gbmV3IGxmby5vcGVyYXRvci5TZWxlY3Qoe1xuICogICBpbmRleGVzOiBbMiwgMF0sXG4gKiB9KTtcbiAqXG4gKiBldmVudEluLnN0YXJ0KCk7XG4gKiBldmVudEluLnByb2Nlc3MoMCwgWzAsIDIsIDRdKTtcbiAqID4gWzQsIDBdXG4gKiBldmVudEluLnByb2Nlc3MoMCwgWzEsIDMsIDVdKTtcbiAqID4gWzUsIDFdXG4gKi9cbmNsYXNzIFNlbGVjdCBleHRlbmRzIEJhc2VMZm8ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgb25QYXJhbVVwZGF0ZShuYW1lLCB2YWx1ZSwgbWV0YXMgPSB7fSkge1xuICAgIHN1cGVyLm9uUGFyYW1VcGRhdGUobmFtZSwgdmFsdWUsIG1ldGFzKTtcblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYXJhbXMuZ2V0KCdpbmRleCcpO1xuICAgIGNvbnN0IGluZGV4ZXMgPSB0aGlzLnBhcmFtcy5nZXQoJ2luZGV4ZXMnKTtcblxuICAgIHRoaXMuc2VsZWN0ID0gKGluZGV4ZXMgIT09IG51bGwpID8gaW5kZXhlcyA6IFtpbmRleF07XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBhcmFtcy5nZXQoJ2luZGV4Jyk7XG4gICAgY29uc3QgaW5kZXhlcyA9IHRoaXMucGFyYW1zLmdldCgnaW5kZXhlcycpO1xuXG4gICAgbGV0IG1heCA9IChpbmRleGVzICE9PSBudWxsKSA/ICBNYXRoLm1heC5hcHBseShudWxsLCBpbmRleGVzKSA6IGluZGV4O1xuXG4gICAgaWYgKG1heCA+PSBwcmV2U3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZWxlY3QgaW5kZXggXCIke21heH1cImApO1xuXG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gKGluZGV4ZXMgIT09IG51bGwpID8gJ3ZlY3RvcicgOiAnc2NhbGFyJztcbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPSAoaW5kZXhlcyAhPT0gbnVsbCkgPyBpbmRleGVzLmxlbmd0aCA6IDE7XG5cbiAgICB0aGlzLnNlbGVjdCA9IChpbmRleGVzICE9PSBudWxsKSA/IGluZGV4ZXMgOiBbaW5kZXhdO1xuXG4gICAgLy8gc3RlYWwgZGVzY3JpcHRpb24oKSBmcm9tIHBhcmVudFxuICAgIGlmIChwcmV2U3RyZWFtUGFyYW1zLmRlc2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnNlbGVjdC5mb3JFYWNoKCh2YWwsIGluZGV4KSA9PiB7XG4gICAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmRlc2NyaXB0aW9uW2luZGV4XSA9IHByZXZTdHJlYW1QYXJhbXMuZGVzY3JpcHRpb25bdmFsXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgIGNvbnN0IGRhdGEgPSBmcmFtZS5kYXRhO1xuICAgIGNvbnN0IG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgY29uc3Qgc2VsZWN0ID0gdGhpcy5zZWxlY3Q7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5sZW5ndGg7IGkrKylcbiAgICAgIG91dERhdGFbaV0gPSBkYXRhW3NlbGVjdFtpXV07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0O1xuIiwiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi4vLi4vY29yZS9CYXNlTGZvJztcblxuY29uc3QgZGVmaW5pdGlvbnMgPSB7XG4gIGZyYW1lU2l6ZToge1xuICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICBkZWZhdWx0OiA1MTIsXG4gICAgbWV0YXM6IHsga2luZDogJ3N0YXRpYycgfSxcbiAgfSxcbiAgaG9wU2l6ZTogeyAvLyBzaG91bGQgYmUgbnVsbGFibGVcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9LFxuICBjZW50ZXJlZFRpbWVUYWdzOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICB9XG59XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBgZnJhbWVTaXplYCBhbmQgYGhvcFNpemVgIG9mIGEgYHNpZ25hbGAgaW5wdXQgYWNjb3JkaW5nIHRvXG4gKiB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqIFRoaXMgb3BlcmF0b3IgdXBkYXRlcyB0aGUgc3RyZWFtIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGl0cyBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJhbWVTaXplPTUxMl0gLSBGcmFtZSBzaXplIG9mIHRoZSBvdXRwdXQgc2lnbmFsLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhvcFNpemU9bnVsbF0gLSBOdW1iZXIgb2Ygc2FtcGxlcyBiZXR3ZWVuIHR3b1xuICogIGNvbnNlY3V0aXZlIGZyYW1lcy4gSWYgbnVsbCwgYGhvcFNpemVgIGlzIHNldCB0byBgZnJhbWVTaXplYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2VudGVyZWRUaW1lVGFnc10gLSBNb3ZlIHRoZSB0aW1lIHRhZyB0byB0aGUgbWlkZGxlXG4gKiAgb2YgdGhlIGZyYW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NvbW1vbic7XG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICogICBmcmFtZVR5cGU6ICdzaWduYWwnLFxuICogICBmcmFtZVNpemU6IDEwLFxuICogICBzYW1wbGVSYXRlOiAyLFxuICogfSk7XG4gKlxuICogY29uc3Qgc2xpY2VyID0gbmV3IGxmby5vcGVyYXRvci5TbGljZXIoe1xuICogICBmcmFtZVNpemU6IDQsXG4gKiAgIGhvcFNpemU6IDJcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGxvZ2dlciA9IG5ldyBsZm8uc2luay5Mb2dnZXIoeyB0aW1lOiB0cnVlLCBkYXRhOiB0cnVlIH0pO1xuICpcbiAqIGV2ZW50SW4uY29ubmVjdChzbGljZXIpO1xuICogc2xpY2VyLmNvbm5lY3QobG9nZ2VyKTtcbiAqIGV2ZW50SW4uc3RhcnQoKTtcbiAqXG4gKiBldmVudEluLnByb2Nlc3MoMCwgWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldKTtcbiAqID4geyB0aW1lOiAwLCBkYXRhOiBbMCwgMSwgMiwgM10gfVxuICogPiB7IHRpbWU6IDEsIGRhdGE6IFsyLCAzLCA0LCA1XSB9XG4gKiA+IHsgdGltZTogMiwgZGF0YTogWzQsIDUsIDYsIDddIH1cbiAqID4geyB0aW1lOiAzLCBkYXRhOiBbNiwgNywgOCwgOV0gfVxuICovXG5jbGFzcyBTbGljZXIgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoZGVmaW5pdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgaG9wU2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnaG9wU2l6ZScpO1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnZnJhbWVTaXplJyk7XG5cbiAgICBpZiAoIWhvcFNpemUpXG4gICAgICB0aGlzLnBhcmFtcy5zZXQoJ2hvcFNpemUnLCBmcmFtZVNpemUpO1xuXG4gICAgdGhpcy5wYXJhbXMuYWRkTGlzdGVuZXIodGhpcy5vblBhcmFtVXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICBjb25zdCBob3BTaXplID0gdGhpcy5wYXJhbXMuZ2V0KCdob3BTaXplJyk7XG4gICAgY29uc3QgZnJhbWVTaXplID0gdGhpcy5wYXJhbXMuZ2V0KCdmcmFtZVNpemUnKTtcblxuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IGZyYW1lU2l6ZTtcbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVJhdGUgPSBwcmV2U3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGUgLyBob3BTaXplO1xuXG4gICAgaWYgKHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9PT0gMSlcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICdzY2FsYXInO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSA9ICdzaWduYWwnO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZXNldFN0cmVhbSgpIHtcbiAgICBzdXBlci5yZXNldFN0cmVhbSgpO1xuICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZmluYWxpemVTdHJlYW0oZW5kVGltZSkge1xuICAgIGlmICh0aGlzLmZyYW1lSW5kZXggPiAwKSB7XG4gICAgICBjb25zdCBmcmFtZVJhdGUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVJhdGU7XG4gICAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgICAgLy8gc2V0IHRoZSB0aW1lIG9mIHRoZSBsYXN0IGZyYW1lXG4gICAgICB0aGlzLmZyYW1lLnRpbWUgKz0gKDEgLyBmcmFtZVJhdGUpO1xuXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFtZUluZGV4OyBpIDwgZnJhbWVTaXplOyBpKyspXG4gICAgICAgIGRhdGFbaV0gPSAwO1xuXG4gICAgICB0aGlzLnByb3BhZ2F0ZUZyYW1lKCk7XG4gICAgfVxuXG4gICAgc3VwZXIuZmluYWxpemVTdHJlYW0oZW5kVGltZSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAgdGhpcy5wcmVwYXJlRnJhbWUoKTtcbiAgICB0aGlzLnByb2Nlc3NGdW5jdGlvbihmcmFtZSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1NpZ25hbChmcmFtZSkge1xuICAgIGNvbnN0IHRpbWUgPSBmcmFtZS50aW1lO1xuICAgIGNvbnN0IGJsb2NrID0gZnJhbWUuZGF0YTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGZyYW1lLm1ldGFkYXRhO1xuXG4gICAgY29uc3QgY2VudGVyZWRUaW1lVGFncyA9IHRoaXMucGFyYW1zLmdldCgnY2VudGVyZWRUaW1lVGFncycpO1xuICAgIGNvbnN0IGhvcFNpemUgPSB0aGlzLnBhcmFtcy5nZXQoJ2hvcFNpemUnKTtcbiAgICBjb25zdCBvdXRGcmFtZSA9IHRoaXMuZnJhbWUuZGF0YTtcbiAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgY29uc3Qgc2FtcGxlUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGU7XG4gICAgY29uc3Qgc2FtcGxlUGVyaW9kID0gMSAvIHNhbXBsZVJhdGU7XG4gICAgY29uc3QgYmxvY2tTaXplID0gYmxvY2subGVuZ3RoO1xuXG4gICAgbGV0IGZyYW1lSW5kZXggPSB0aGlzLmZyYW1lSW5kZXg7XG4gICAgbGV0IGJsb2NrSW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGJsb2NrSW5kZXggPCBibG9ja1NpemUpIHtcbiAgICAgIGxldCBudW1Ta2lwID0gMDtcblxuICAgICAgLy8gc2tpcCBibG9jayBzYW1wbGVzIGZvciBuZWdhdGl2ZSBmcmFtZUluZGV4IChmcmFtZVNpemUgPCBob3BTaXplKVxuICAgICAgaWYgKGZyYW1lSW5kZXggPCAwKSB7XG4gICAgICAgIG51bVNraXAgPSAtZnJhbWVJbmRleDtcbiAgICAgICAgZnJhbWVJbmRleCA9IDA7IC8vIHJlc2V0IGBmcmFtZUluZGV4YFxuICAgICAgfVxuXG4gICAgICBpZiAobnVtU2tpcCA8IGJsb2NrU2l6ZSkge1xuICAgICAgICBibG9ja0luZGV4ICs9IG51bVNraXA7IC8vIHNraXAgYmxvY2sgc2VnbWVudFxuICAgICAgICAvLyBjYW4gY29weSBhbGwgdGhlIHJlc3Qgb2YgdGhlIGluY29taW5nIGJsb2NrXG4gICAgICAgIGxldCBudW1Db3B5ID0gYmxvY2tTaXplIC0gYmxvY2tJbmRleDtcbiAgICAgICAgLy8gY29ubm90IGNvcHkgbW9yZSB0aGFuIHdoYXQgZml0cyBpbnRvIHRoZSBmcmFtZVxuICAgICAgICBjb25zdCBtYXhDb3B5ID0gZnJhbWVTaXplIC0gZnJhbWVJbmRleDtcblxuICAgICAgICBpZiAobnVtQ29weSA+PSBtYXhDb3B5KVxuICAgICAgICAgIG51bUNvcHkgPSBtYXhDb3B5O1xuXG4gICAgICAgIC8vIGNvcHkgYmxvY2sgc2VnbWVudCBpbnRvIGZyYW1lXG4gICAgICAgIGNvbnN0IGNvcHkgPSBibG9jay5zdWJhcnJheShibG9ja0luZGV4LCBibG9ja0luZGV4ICsgbnVtQ29weSk7XG4gICAgICAgIG91dEZyYW1lLnNldChjb3B5LCBmcmFtZUluZGV4KTtcbiAgICAgICAgLy8gYWR2YW5jZSBibG9jayBhbmQgZnJhbWUgaW5kZXhcbiAgICAgICAgYmxvY2tJbmRleCArPSBudW1Db3B5O1xuICAgICAgICBmcmFtZUluZGV4ICs9IG51bUNvcHk7XG5cbiAgICAgICAgLy8gc2VuZCBmcmFtZSB3aGVuIGNvbXBsZXRlZFxuICAgICAgICBpZiAoZnJhbWVJbmRleCA9PT0gZnJhbWVTaXplKSB7XG4gICAgICAgICAgLy8gZGVmaW5lIHRpbWUgdGFnIGZvciB0aGUgb3V0RnJhbWUgYWNjb3JkaW5nIHRvIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICBpZiAoY2VudGVyZWRUaW1lVGFncylcbiAgICAgICAgICAgIHRoaXMuZnJhbWUudGltZSA9IHRpbWUgKyAoYmxvY2tJbmRleCAtIGZyYW1lU2l6ZSAvIDIpICogc2FtcGxlUGVyaW9kO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZnJhbWUudGltZSA9IHRpbWUgKyAoYmxvY2tJbmRleCAtIGZyYW1lU2l6ZSkgKiBzYW1wbGVQZXJpb2Q7XG5cbiAgICAgICAgICB0aGlzLmZyYW1lLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgICAgLy8gZm9yd2FyZCB0byBuZXh0IG5vZGVzXG4gICAgICAgICAgdGhpcy5wcm9wYWdhdGVGcmFtZSgpO1xuXG4gICAgICAgICAgLy8gc2hpZnQgZnJhbWUgbGVmdFxuICAgICAgICAgIGlmIChob3BTaXplIDwgZnJhbWVTaXplKVxuICAgICAgICAgICAgb3V0RnJhbWUuc2V0KG91dEZyYW1lLnN1YmFycmF5KGhvcFNpemUsIGZyYW1lU2l6ZSksIDApO1xuXG4gICAgICAgICAgZnJhbWVJbmRleCAtPSBob3BTaXplOyAvLyBob3AgZm9yd2FyZFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBza2lwIGVudGlyZSBibG9ja1xuICAgICAgICBjb25zdCBibG9ja1Jlc3QgPSBibG9ja1NpemUgLSBibG9ja0luZGV4O1xuICAgICAgICBmcmFtZUluZGV4ICs9IGJsb2NrUmVzdDtcbiAgICAgICAgYmxvY2tJbmRleCArPSBibG9ja1Jlc3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZUluZGV4ID0gZnJhbWVJbmRleDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTbGljZXI7XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5jb25zdCBjZWlsID0gTWF0aC5jZWlsO1xuXG4vKipcbiAqIHBhcGVyOiBodHRwOi8vcmVjaGVyY2hlLmlyY2FtLmZyL2VxdWlwZXMvcGNtL2NoZXZlaWduL3Bzcy8yMDAyX0pBU0FfWUlOLnBkZlxuICogaW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2FzaG9rZmVybmFuZGV6L1lpbi1QaXRjaC1UcmFja2luZ1xuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgdGhyZXNob2xkOiB7XG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiAwLjEsIC8vIGRlZmF1bHQgZnJvbSBwYXBlclxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH0sXG4gIH0sXG4gIGRvd25TYW1wbGluZ0V4cDogeyAvLyBkb3duc2FtcGxpbmcgZmFjdG9yXG4gICAgdHlwZTogJ2ludGVnZXInLFxuICAgIGRlZmF1bHQ6IDIsXG4gICAgbWluOiAwLFxuICAgIG1heDogMyxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9LFxuICBtaW5GcmVxOiB7IC8vXG4gICAgdHlwZTogJ2Zsb2F0JyxcbiAgICBkZWZhdWx0OiA2MCwgLy8gbWVhbiA3MzUgc2FtcGxlc1xuICAgIG1pbjogMCxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9LFxufVxuXG4vKipcbiAqIFlpbiBmdW5kYW1lbnRhbCBmcmVxdWVuY3kgZXN0aW1hdG9yLCBiYXNlZCBvbiBhbGdvcml0aG0gZGVzY3JpYmVkIGluXG4gKiBbWUlOLCBhIGZ1bmRhbWVudGFsIGZyZXF1ZW5jeSBlc3RpbWF0b3IgZm9yIHNwZWVjaCBhbmQgbXVzaWNdKGh0dHA6Ly9yZWNoZXJjaGUuaXJjYW0uZnIvZXF1aXBlcy9wY20vY2hldmVpZ24vcHNzLzIwMDJfSkFTQV9ZSU4ucGRmKVxuICogYnkgQ2hldmVpZ25lIGFuZCBLYXdhaGFyYS5cbiAqIE9uIGVhY2ggZnJhbWUsIHRoaXMgb3BlcmF0b3IgcHJvcGFnYXRlIGEgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZ1xuICogdmFsdWVzOiBgZnJlcXVlbmN5YCwgYHByb2JhYmlsaXR5YC5cbiAqXG4gKiBGb3IgZ29vZCByZXN1bHRzIHRoZSBpbnB1dCBmcmFtZSBzaXplIHNob3VsZCBiZSBsYXJnZSAoMTAyNCBvciAyMDQ4KS5cbiAqXG4gKiBfc3VwcG9ydCBgc3RhbmRhbG9uZWAgdXNhZ2VfXG4gKlxuICogQG5vdGUgLSBJbiBub2RlIGZvciBhIGZyYW1lIG9mIDIwNDggc2FtcGxlcywgYXZlcmFnZSBjb21wdXRhdGlvbiB0aW1lIGlzOlxuICogICAgICAgICAwLjAwMDE2NzQyMjgzMzM5OTkzMzg5IHNlY29uZC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5vcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0wLjFdIC0gQWJzb2x1dGUgdGhyZXNob2xkIHRvIHRlc3QgdGhlXG4gKiAgbm9ybWFsaXplZCBkaWZmZXJlbmNlIChzZWUgcGFwZXIgZm9yIG1vcmUgaW5mb3JtYXRpb25zKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kb3duU2FtcGxpbmdFeHA9Ml0gLSBEb3duIHNhbXBsZSB0aGUgaW5wdXQgZnJhbWUgYnlcbiAqICBhIGZhY3RvciBvZiAyIGF0IHRoZSBwb3dlciBvZiBgZG93blNhbXBsaW5nRXhwYCAobWluPTAgYW5kIG1heD0zKSBmb3JcbiAqICBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudHMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluRnJlcT02MF0gLSBNaW5pbXVtIGZyZXF1ZW5jeSB0aGUgb3BlcmF0b3IgY2FuXG4gKiAgc2VhcmNoIGZvci4gVGhpcyBwYXJhbWV0ZXIgZGVmaW5lcyB0aGUgc2l6ZSBvZiB0aGUgYXV0b2NvcnJlbGF0aW9uIHBlcmZvcm1lZFxuICogIG9uIHRoZSBzaWduYWwsIHRoZSBpbnB1dCBmcmFtZSBzaXplIHNob3VsZCBiZSBhcm91bmQgMiB0aW1lIHRoaXMgc2l6ZSBmb3JcbiAqICBnb29kIHJlc3VsdHMgKGkuZS4gYGlucHV0RnJhbWVTaXplIOKJiCAyICogKHNhbXBsaW5nUmF0ZSAvIG1pbkZyZXEpYCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAqXG4gKiAvLyBhc3N1bWluZyBzb21lIEF1ZGlvQnVmZmVyXG4gKiBjb25zdCBzb3VyY2UgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luQnVmZmVyKHtcbiAqICAgYXVkaW9CdWZmZXI6IGF1ZGlvQnVmZmVyLFxuICogfSk7XG4gKlxuICogY29uc3Qgc2xpY2VyID0gbmV3IGxmby5vcGVyYXRvci5TbGljZXIoe1xuICogICBmcmFtZVNpemU6IDIwNDgsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCB5aW4gPSBuZXcgbGZvLm9wZXJhdG9yLllpbigpO1xuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogc291cmNlLmNvbm5lY3Qoc2xpY2VyKTtcbiAqIHNsaWNlci5jb25uZWN0KHlpbik7XG4gKiB5aW4uY29ubmVjdChsb2dnZXIpO1xuICpcbiAqIHNvdXJjZS5zdGFydCgpO1xuICovXG5jbGFzcyBZaW4gZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcblxuICAgIHRoaXMucHJvYmFiaWxpdHkgPSAwO1xuICAgIHRoaXMucGl0Y2ggPSAtMTtcblxuICAgIHRoaXMudGVzdCA9IDA7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2Rvd25zYW1wbGUoaW5wdXQsIHNpemUsIG91dHB1dCwgZG93blNhbXBsaW5nRXhwKSB7XG4gICAgY29uc3Qgb3V0cHV0U2l6ZSA9IHNpemUgPj4gZG93blNhbXBsaW5nRXhwO1xuICAgIGxldCBpLCBqO1xuXG4gICAgc3dpdGNoIChkb3duU2FtcGxpbmdFeHApIHtcbiAgICAgIGNhc2UgMDogLy8gbm8gZG93biBzYW1wbGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuICAgICAgICAgIG91dHB1dFtpXSA9IGlucHV0W2ldO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG91dHB1dFNpemU7IGkrKywgaiArPSAyKVxuICAgICAgICAgIG91dHB1dFtpXSA9IDAuNSAqIChpbnB1dFtqXSArIGlucHV0W2ogKyAxXSk7XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyssIGogKz0gNClcbiAgICAgICAgICBvdXRwdXRbaV0gPSAwLjI1ICogKGlucHV0W2pdICsgaW5wdXRbaiArIDFdICsgaW5wdXRbaiArIDJdICsgaW5wdXRbaiArIDNdKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBvdXRwdXRTaXplOyBpKyssIGogKz0gOClcbiAgICAgICAgICBvdXRwdXRbaV0gPSAwLjEyNSAqIChpbnB1dFtqXSArIGlucHV0W2ogKyAxXSArIGlucHV0W2ogKyAyXSArIGlucHV0W2ogKyAzXSArIGlucHV0W2ogKyA0XSArIGlucHV0W2ogKyA1XSArIGlucHV0W2ogKyA2XSArIGlucHV0W2ogKyA3XSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dFNpemU7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1N0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKSB7XG4gICAgdGhpcy5wcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gJ3ZlY3Rvcic7XG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gMjtcbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5kZXNjcmlwdGlvbiA9IFsnZnJlcXVlbmN5JywgJ2NvbmZpZGVuY2UnXTtcblxuICAgIHRoaXMuaW5wdXRGcmFtZVNpemUgPSBwcmV2U3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTtcbiAgICAvLyBoYW5kbGUgcGFyYW1zXG4gICAgY29uc3Qgc291cmNlU2FtcGxlUmF0ZSA9IHRoaXMuc3RyZWFtUGFyYW1zLnNvdXJjZVNhbXBsZVJhdGU7XG4gICAgY29uc3QgZG93blNhbXBsaW5nRXhwID0gdGhpcy5wYXJhbXMuZ2V0KCdkb3duU2FtcGxpbmdFeHAnKTtcbiAgICBjb25zdCBkb3duRmFjdG9yID0gMSA8PCBkb3duU2FtcGxpbmdFeHA7IC8vIDJeblxuICAgIGNvbnN0IGRvd25TUiA9IHNvdXJjZVNhbXBsZVJhdGUgLyBkb3duRmFjdG9yO1xuICAgIGNvbnN0IGRvd25GcmFtZVNpemUgPSB0aGlzLmlucHV0RnJhbWVTaXplIC8gZG93bkZhY3RvcjsgLy8gbl90aWNrX2Rvd24gLy8gMSAvIDJeblxuXG4gICAgY29uc3QgbWluRnJlcSA9IHRoaXMucGFyYW1zLmdldCgnbWluRnJlcScpO1xuICAgIC8vIGxpbWl0IG1pbiBmcmVxLCBjZi4gcGFwZXIgSVYuIHNlbnNpdGl2aXR5IHRvIHBhcmFtZXRlcnNcbiAgICBjb25zdCBtaW5GcmVxTmJyU2FtcGxlcyA9IGRvd25TUiAvIG1pbkZyZXE7XG4gICAgLy8gY29uc3QgYnVmZmVyU2l6ZSA9IHByZXZTdHJlYW1QYXJhbXMuZnJhbWVTaXplO1xuICAgIHRoaXMuaGFsZkJ1ZmZlclNpemUgPSBkb3duRnJhbWVTaXplIC8gMjtcblxuICAgIC8vIG1pbmltdW0gZXJyb3IgdG8gbm90IGNyYXNoIGJ1dCBub3QgZW5vdWdodCB0byBoYXZlIHJlc3VsdHNcbiAgICBpZiAobWluRnJlcU5iclNhbXBsZXMgPiB0aGlzLmhhbGZCdWZmZXJTaXplKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IGZyYW1lIHNpemUsIHRvbyBzbWFsbCBmb3IgZ2l2ZW4gXCJtaW5GcmVxXCInKTtcblxuICAgIHRoaXMuZG93blNhbXBsaW5nRXhwID0gZG93blNhbXBsaW5nRXhwO1xuICAgIHRoaXMuZG93blNhbXBsaW5nUmF0ZSA9IGRvd25TUjtcbiAgICB0aGlzLmRvd25GcmFtZVNpemUgPSBkb3duRnJhbWVTaXplO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShkb3duRnJhbWVTaXplKTtcbiAgICAvLyBhdXRvY29ycmVsYXRpb24gYnVmZmVyXG4gICAgdGhpcy55aW5CdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuaGFsZkJ1ZmZlclNpemUpO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfZG93bnNhbXBsZShpbnB1dCwgc2l6ZSwgb3V0cHV0LCBkb3duU2FtcGxpbmdFeHApIHtcbiAgICBjb25zdCBvdXRwdXRTaXplID0gc2l6ZSA+PiBkb3duU2FtcGxpbmdFeHA7XG4gICAgbGV0IGksIGo7XG5cbiAgICBzd2l0Y2ggKGRvd25TYW1wbGluZ0V4cCkge1xuICAgICAgY2FzZSAwOiAvLyBubyBkb3duIHNhbXBsaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspXG4gICAgICAgICAgb3V0cHV0W2ldID0gaW5wdXRbaV07XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgb3V0cHV0U2l6ZTsgaSsrLCBqICs9IDIpXG4gICAgICAgICAgb3V0cHV0W2ldID0gMC41ICogKGlucHV0W2pdICsgaW5wdXRbaiArIDFdKTtcblxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyOlxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG91dHB1dFNpemU7IGkrKywgaiArPSA0KVxuICAgICAgICAgIG91dHB1dFtpXSA9IDAuMjUgKiAoaW5wdXRbal0gKyBpbnB1dFtqICsgMV0gKyBpbnB1dFtqICsgMl0gKyBpbnB1dFtqICsgM10pO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG91dHB1dFNpemU7IGkrKywgaiArPSA4KVxuICAgICAgICAgIG91dHB1dFtpXSA9IDAuMTI1ICogKGlucHV0W2pdICsgaW5wdXRbaiArIDFdICsgaW5wdXRbaiArIDJdICsgaW5wdXRbaiArIDNdICsgaW5wdXRbaiArIDRdICsgaW5wdXRbaiArIDVdICsgaW5wdXRbaiArIDZdICsgaW5wdXRbaiArIDddKTtcblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0U2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGVwIDEsIDIgYW5kIDMgLSBTcXVhcmVkIGRpZmZlcmVuY2Ugb2YgdGhlIHNoaWZ0ZWQgc2lnbmFsIHdpdGggaXRzZWxmLlxuICAgKiBjdW11bGF0aXZlIG1lYW4gbm9ybWFsaXplZCBkaWZmZXJlbmNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25vcm1hbGl6ZWREaWZmZXJlbmNlKGJ1ZmZlcikge1xuICAgIGNvbnN0IGhhbGZCdWZmZXJTaXplID0gdGhpcy5oYWxmQnVmZmVyU2l6ZTtcbiAgICBjb25zdCB5aW5CdWZmZXIgPSB0aGlzLnlpbkJ1ZmZlcjtcbiAgICBsZXQgc3VtID0gMDtcblxuICAgIC8vIGRpZmZlcmVuY2UgZm9yIGRpZmZlcmVudCBzaGlmdCB2YWx1ZXMgKHRhdSlcbiAgICBmb3IgKGxldCB0YXUgPSAwOyB0YXUgPCBoYWxmQnVmZmVyU2l6ZTsgdGF1KyspIHtcbiAgICAgIGxldCBzcXVhcmVkRGlmZmVyZW5jZSA9IDA7IC8vIHJlc2V0IGJ1ZmZlclxuXG4gICAgICAvLyB0YWtlIGRpZmZlcmVuY2Ugb2YgdGhlIHNpZ25hbCB3aXRoIGEgc2hpZnRlZCB2ZXJzaW9uIG9mIGl0c2VsZiB0aGVuXG4gICAgICAvLyBzcWF1cmUgdGhlIHJlc3VsdFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYWxmQnVmZmVyU2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gYnVmZmVyW2ldIC0gYnVmZmVyW2kgKyB0YXVdO1xuICAgICAgICBzcXVhcmVkRGlmZmVyZW5jZSArPSBkZWx0YSAqIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICAvLyBzdGVwIDMgLSBub3JtYWxpemUgeWluQnVmZmVyXG4gICAgICBpZiAodGF1ID4gMCkge1xuICAgICAgICBzdW0gKz0gc3F1YXJlZERpZmZlcmVuY2U7XG4gICAgICAgIHlpbkJ1ZmZlclt0YXVdID0gc3F1YXJlZERpZmZlcmVuY2UgKiAodGF1IC8gc3VtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB5aW5CdWZmZXJbMF0gPSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0ZXAgNCAtIGZpbmQgZmlyc3QgYmVzdCB0YXUgdGhhdCBpcyB1bmRlciB0aGUgdGhyZXNvbGQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWJzb2x1dGVUaHJlc2hvbGQoKSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5wYXJhbXMuZ2V0KCd0aHJlc2hvbGQnKTtcbiAgICBjb25zdCB5aW5CdWZmZXIgPSB0aGlzLnlpbkJ1ZmZlcjtcbiAgICBjb25zdCBoYWxmQnVmZmVyU2l6ZSA9IHRoaXMuaGFsZkJ1ZmZlclNpemU7XG4gICAgbGV0IHRhdTtcblxuICAgIGZvciAodGF1ID0gMTsgdGF1IDwgaGFsZkJ1ZmZlclNpemU7IHRhdSsrKSB7XG4gICAgICBpZiAoeWluQnVmZmVyW3RhdV0gPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgLy8ga2VlcCBpbmNyZWFzaW5nIHRhdSBpZiBuZXh0IHZhbHVlIGlzIGJldHRlclxuICAgICAgICB3aGlsZSAodGF1ICsgMSA8IGhhbGZCdWZmZXJTaXplICYmIHlpbkJ1ZmZlclt0YXUgKyAxXSA8IHlpbkJ1ZmZlclt0YXVdKVxuICAgICAgICAgIHRhdSArPSAxO1xuXG4gICAgICAgIC8vIGJlc3QgdGF1IGZvdW5kICwgeWluQnVmZmVyW3RhdV0gY2FuIGJlIHNlZW4gYXMgYW4gZXN0aW1hdGlvbiBvZlxuICAgICAgICAvLyBhcGVyaW9kaWNpdHkgdGhlbjogcGVyaW9kaWNpdHkgPSAxIC0gYXBlcmlvZGljaXR5XG4gICAgICAgIHRoaXMucHJvYmFiaWxpdHkgPSAxIC0geWluQnVmZmVyW3RhdV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiAtMSBpZiBub3QgbWF0Y2ggZm91bmRcbiAgICByZXR1cm4gKHRhdSA9PT0gaGFsZkJ1ZmZlclNpemUpID8gLTEgOiB0YXU7XG4gIH1cblxuICAvKipcbiAgICogU3RlcCA1IC0gRmluZCBhIGJldHRlciBmcmFjdGlvbm5hbCBhcHByb3hpbWF0ZSBvZiB0YXUuXG4gICAqIHRoaXMgY2FuIHByb2JhYmx5IGJlIHNpbXBsaWZpZWQuLi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wYXJhYm9saWNJbnRlcnBvbGF0aW9uKHRhdUVzdGltYXRlKSB7XG4gICAgY29uc3QgaGFsZkJ1ZmZlclNpemUgPSB0aGlzLmhhbGZCdWZmZXJTaXplO1xuICAgIGNvbnN0IHlpbkJ1ZmZlciA9IHRoaXMueWluQnVmZmVyO1xuICAgIGxldCBiZXR0ZXJUYXU7XG4gICAgLy8gQG5vdGUgLSB0YXVFc3RpbWF0ZSBjYW5ub3QgYmUgemVybyBhcyB0aGUgbG9vcCBzdGFydCBhdCAxIGluIHN0ZXAgNFxuICAgIGNvbnN0IHgwID0gdGF1RXN0aW1hdGUgLSAxO1xuICAgIGNvbnN0IHgyID0gKHRhdUVzdGltYXRlIDwgaGFsZkJ1ZmZlclNpemUgLSAxKSA/IHRhdUVzdGltYXRlICsgMSA6IHRhdUVzdGltYXRlO1xuXG4gICAgLy8gaWYgYHRhdUVzdGltYXRlYCBpcyBsYXN0IGluZGV4LCB3ZSBjYW4ndCBpbnRlcnBvbGF0ZVxuICAgIGlmICh4MiA9PT0gdGF1RXN0aW1hdGUpIHtcbiAgICAgICAgYmV0dGVyVGF1ID0gdGF1RXN0aW1hdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMwID0geWluQnVmZmVyW3gwXTtcbiAgICAgIGNvbnN0IHMxID0geWluQnVmZmVyW3RhdUVzdGltYXRlXTtcbiAgICAgIGNvbnN0IHMyID0geWluQnVmZmVyW3gyXTtcblxuICAgICAgLy8gQG5vdGUgLSBkb24ndCBmdWxseSB1bmRlcnN0YW5kIHRoaXMgZm9ybXVsYSBuZWl0aGVyLi4uXG4gICAgICBiZXR0ZXJUYXUgPSB0YXVFc3RpbWF0ZSArIChzMiAtIHMwKSAvICgyICogKDIgKiBzMSAtIHMyIC0gczApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmV0dGVyVGF1O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGUgYFlpbmAgb3BlcmF0b3IgaW4gYHN0YW5kYWxvbmVgIG1vZGUgKGkuZS4gb3V0c2lkZSBvZiBhIGdyYXBoKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheXxGbG9hdDMyQXJyYXl9IGlucHV0IC0gVGhlIHNpZ25hbCBmcmFnbWVudCB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBBcnJheSBjb250YWluaW5nIHRoZSBgZnJlcXVlbmN5YCwgYGVuZXJneWAsIGBwZXJpb2RpY2l0eWBcbiAgICogIGFuZCBgQUMxYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gICAqXG4gICAqIGNvbnN0IHlpbiA9IG5ldyBsZm8ub3BlcmF0b3IuWWluKCk7XG4gICAqIHlpbi5pbml0U3RyZWFtKHtcbiAgICogICBmcmFtZVNpemU6IDIwNDgsXG4gICAqICAgZnJhbWVUeXBlOiAnc2lnbmFsJyxcbiAgICogICBzb3VyY2VTYW1wbGVSYXRlOiA0NDEwMFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgcmVzdWx0cyA9IHlpbi5pbnB1dFNpZ25hbChzaWduYWwpO1xuICAgKi9cbiAgaW5wdXRTaWduYWwoaW5wdXQpIHtcbiAgICB0aGlzLnBpdGNoID0gLTE7XG4gICAgdGhpcy5wcm9iYWJpbGl0eSA9IDA7XG5cbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICBjb25zdCBpbnB1dEZyYW1lU2l6ZSA9IHRoaXMuaW5wdXRGcmFtZVNpemU7XG4gICAgY29uc3QgZG93blNhbXBsaW5nRXhwID0gdGhpcy5kb3duU2FtcGxpbmdFeHA7XG4gICAgY29uc3Qgc2FtcGxlUmF0ZSA9IHRoaXMuZG93blNhbXBsaW5nUmF0ZTtcbiAgICBjb25zdCBvdXREYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuICAgIGxldCB0YXVFc3RpbWF0ZSA9IC0xO1xuXG4gICAgLy8gc3Vic2FtcGxpbmdcbiAgICB0aGlzLl9kb3duc2FtcGxlKGlucHV0LCBpbnB1dEZyYW1lU2l6ZSwgYnVmZmVyLCBkb3duU2FtcGxpbmdFeHApO1xuICAgIC8vIHN0ZXAgMSwgMiwgMyAtIG5vcm1hbGl6ZWQgc3F1YXJlZCBkaWZmZXJlbmNlIG9mIHRoZSBzaWduYWwgd2l0aCBhXG4gICAgLy8gc2hpZnRlZCB2ZXJzaW9uIG9mIGl0c2VsZlxuICAgIHRoaXMuX25vcm1hbGl6ZWREaWZmZXJlbmNlKGJ1ZmZlcik7XG4gICAgLy8gc3RlcCA0IC0gZmluZCBmaXJzdCBiZXN0IHRhdSBlc3RpbWF0ZSB0aGF0IGlzIG92ZXIgdGhlIHRocmVzaG9sZFxuICAgIHRhdUVzdGltYXRlID0gdGhpcy5fYWJzb2x1dGVUaHJlc2hvbGQoKTtcblxuICAgIGlmICh0YXVFc3RpbWF0ZSAhPT0gLTEpIHtcbiAgICAgIC8vIHN0ZXAgNSAtIHNvIGZhciB0YXUgaXMgYW4gaW50ZWdlciBzaGlmdCBvZiB0aGUgc2lnbmFsLCBjaGVjayBpZlxuICAgICAgLy8gdGhlcmUgaXMgYSBiZXR0ZXIgZnJhY3Rpb25uYWwgdmFsdWUgYXJvdW5kXG4gICAgICB0YXVFc3RpbWF0ZSA9IHRoaXMuX3BhcmFib2xpY0ludGVycG9sYXRpb24odGF1RXN0aW1hdGUpO1xuICAgICAgdGhpcy5waXRjaCA9IHNhbXBsZVJhdGUgLyB0YXVFc3RpbWF0ZTtcbiAgICB9XG5cbiAgICBvdXREYXRhWzBdID0gdGhpcy5waXRjaDtcbiAgICBvdXREYXRhWzFdID0gdGhpcy5wcm9iYWJpbGl0eTtcblxuICAgIHJldHVybiBvdXREYXRhO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTaWduYWwoZnJhbWUpIHtcbiAgICB0aGlzLmlucHV0U2lnbmFsKGZyYW1lLmRhdGEpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFlpbjtcbiIsImltcG9ydCBCaXF1YWQgZnJvbSAnLi9CaXF1YWQnO1xuaW1wb3J0IENsaXAgZnJvbSAnLi9DbGlwJztcbmltcG9ydCBEY3QgZnJvbSAnLi9EY3QnO1xuaW1wb3J0IERlbHRhIGZyb20gJy4vRGVsdGEnO1xuaW1wb3J0IEZmdCBmcm9tICcuL0ZmdCc7XG5pbXBvcnQgTWFnbml0dWRlIGZyb20gJy4vTWFnbml0dWRlJztcbmltcG9ydCBNZWFuU3RkZGV2IGZyb20gJy4vTWVhblN0ZGRldic7XG5pbXBvcnQgTWVsIGZyb20gJy4vTWVsJztcbmltcG9ydCBNZXJnZXIgZnJvbSAnLi9NZXJnZXInO1xuaW1wb3J0IE1mY2MgZnJvbSAnLi9NZmNjJztcbmltcG9ydCBNaW5NYXggZnJvbSAnLi9NaW5NYXgnO1xuaW1wb3J0IE1vdmluZ0F2ZXJhZ2UgZnJvbSAnLi9Nb3ZpbmdBdmVyYWdlJztcbmltcG9ydCBNb3ZpbmdNZWRpYW4gZnJvbSAnLi9Nb3ZpbmdNZWRpYW4nO1xuaW1wb3J0IE9uT2ZmIGZyb20gJy4vT25PZmYnO1xuaW1wb3J0IFBvd2VyIGZyb20gJy4vUG93ZXInO1xuaW1wb3J0IFJtcyBmcm9tICcuL1Jtcyc7XG5pbXBvcnQgTXVsdGlwbGllciBmcm9tICcuL011bHRpcGxpZXInO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4vU2NhbGUnO1xuaW1wb3J0IFNlZ21lbnRlciBmcm9tICcuL1NlZ21lbnRlcic7XG5pbXBvcnQgU2VsZWN0IGZyb20gJy4vU2VsZWN0JztcbmltcG9ydCBTbGljZXIgZnJvbSAnLi9TbGljZXInO1xuaW1wb3J0IFlpbiBmcm9tICcuL1lpbic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQmlxdWFkLFxuICBDbGlwLFxuICBEY3QsXG4gIERlbHRhLFxuICBGZnQsXG4gIE1hZ25pdHVkZSxcbiAgTWVhblN0ZGRldixcbiAgTWVsLFxuICBNZXJnZXIsXG4gIE1mY2MsXG4gIE1pbk1heCxcbiAgTW92aW5nQXZlcmFnZSxcbiAgTW92aW5nTWVkaWFuLFxuICBPbk9mZixcbiAgUG93ZXIsXG4gIFJtcyxcbiAgTXVsdGlwbGllcixcbiAgU2NhbGUsXG4gIFNlZ21lbnRlcixcbiAgU2VsZWN0LFxuICBTbGljZXIsXG4gIFlpbixcbn07XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgcHJvY2Vzc1N0cmVhbVBhcmFtczoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH0sXG4gIHByb2Nlc3NGcmFtZToge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH0sXG4gIGZpbmFsaXplU3RyZWFtOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfSxcbiAgfSxcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgYnJpZGdlIGJldHdlZW4gdGhlIGdyYXBoIGFuZCBhcHBsaWNhdGlvbiBsb2dpYy4gSGFuZGxlIGBwdXNoYFxuICogYW5kIGBwdWxsYCBwYXJhZGlnbXMuXG4gKlxuICogVGhpcyBzaW5rIGNhbiBoYW5kbGUgYW55IHR5cGUgb2YgaW5wdXQgKGBzaWduYWxgLCBgdmVjdG9yYCwgYHNjYWxhcmApXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21tb24uc2lua1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMucHJvY2Vzc0ZyYW1lPW51bGxdIC0gQ2FsbGJhY2sgZXhlY3V0ZWQgb24gZWFjaFxuICogIGBwcm9jZXNzRnJhbWVgIGNhbGwuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5maW5hbGl6ZVN0cmVhbT1udWxsXSAtIENhbGxiYWNrIGV4ZWN1dGVkIG9uIGVhY2hcbiAqICBgZmluYWxpemVTdHJlYW1gIGNhbGwuXG4gKlxuICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzRnJhbWV9XG4gKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Byb2Nlc3NTdHJlYW1QYXJhbXN9XG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY29tbW9uJztcbiAqXG4gKiBjb25zdCBmcmFtZXMgPSBbXG4gKiAgeyB0aW1lOiAwLCBkYXRhOiBbMCwgMV0gfSxcbiAqICB7IHRpbWU6IDEsIGRhdGE6IFsxLCAyXSB9LFxuICogXTtcbiAqXG4gKiBjb25zdCBldmVudEluID0gbmV3IEV2ZW50SW4oe1xuICogICBmcmFtZVR5cGU6ICd2ZWN0b3InLFxuICogICBmcmFtZVNpemU6IDIsXG4gKiAgIGZyYW1lUmF0ZTogMSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGJyaWRnZSA9IG5ldyBCcmlkZ2Uoe1xuICogICBwcm9jZXNzRnJhbWU6IChmcmFtZSkgPT4gY29uc29sZS5sb2coZnJhbWUpLFxuICogfSk7XG4gKlxuICogZXZlbnRJbi5jb25uZWN0KGJyaWRnZSk7XG4gKiBldmVudEluLnN0YXJ0KCk7XG4gKlxuICogLy8gY2FsbGJhY2sgZXhlY3V0ZWQgb24gZWFjaCBmcmFtZVxuICogZXZlbnRJbi5wcm9jZXNzRnJhbWUoZnJhbWVbMF0pO1xuICogPiB7IHRpbWU6IDAsIGRhdGE6IFswLCAxXSB9XG4gKiBldmVudEluLnByb2Nlc3NGcmFtZShmcmFtZVsxXSk7XG4gKiA+IHsgdGltZTogMSwgZGF0YTogWzEsIDJdIH1cbiAqXG4gKiAvLyBwdWxsIGN1cnJlbnQgZnJhbWUgd2hlbiBuZWVkZWRcbiAqIGNvbnNvbGUubG9nKGJyaWRnZS5mcmFtZSk7XG4gKiA+IHsgdGltZTogMSwgZGF0YTogWzEsIDJdIH1cbiAqL1xuY2xhc3MgQnJpZGdlIGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICB0aGlzLnByZXBhcmVTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcyk7XG5cbiAgICBjb25zdCBwcm9jZXNzU3RyZWFtUGFyYW1zQ2FsbGJhY2sgPSB0aGlzLnBhcmFtcy5nZXQoJ3Byb2Nlc3NTdHJlYW1QYXJhbXMnKTtcblxuICAgIGlmIChwcm9jZXNzU3RyZWFtUGFyYW1zQ2FsbGJhY2sgIT09IG51bGwpXG4gICAgICBwcm9jZXNzU3RyZWFtUGFyYW1zQ2FsbGJhY2sodGhpcy5zdHJlYW1QYXJhbXMpO1xuXG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBmaW5hbGl6ZVN0cmVhbShlbmRUaW1lKSB7XG4gICAgY29uc3QgZmluYWxpemVTdHJlYW1DYWxsYmFjayA9IHRoaXMucGFyYW1zLmdldCgnZmluYWxpemVTdHJlYW0nKTtcblxuICAgIGlmIChmaW5hbGl6ZVN0cmVhbUNhbGxiYWNrICE9PSBudWxsKVxuICAgICAgZmluYWxpemVTdHJlYW1DYWxsYmFjayhlbmRUaW1lKTtcbiAgfVxuXG4gIC8vIHByb2Nlc3MgYW55IHR5cGVcbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTY2FsYXIoKSB7fVxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1ZlY3RvcigpIHt9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU2lnbmFsKCkge31cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAgdGhpcy5wcmVwYXJlRnJhbWUoKTtcblxuICAgIGNvbnN0IHByb2Nlc3NGcmFtZUNhbGxiYWNrID0gdGhpcy5wYXJhbXMuZ2V0KCdwcm9jZXNzRnJhbWUnKTtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmZyYW1lO1xuICAgIG91dHB1dC5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUpO1xuICAgIC8vIHB1bGwgaW50ZXJmYWNlICh3ZSBjb3B5IGRhdGEgc2luY2Ugd2UgZG9uJ3Qga25vdyB3aGF0IGNvdWxkXG4gICAgLy8gYmUgZG9uZSBvdXRzaWRlIHRoZSBncmFwaClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTsgaSsrKVxuICAgICAgb3V0cHV0LmRhdGFbaV0gPSBmcmFtZS5kYXRhW2ldO1xuXG4gICAgb3V0cHV0LnRpbWUgPSBmcmFtZS50aW1lO1xuICAgIG91dHB1dC5tZXRhZGF0YSA9IGZyYW1lLm1ldGFkYXRhO1xuXG4gICAgLy8gYHB1c2hgIGludGVyZmFjZVxuICAgIGlmIChwcm9jZXNzRnJhbWVDYWxsYmFjayAhPT0gbnVsbClcbiAgICAgIHByb2Nlc3NGcmFtZUNhbGxiYWNrKG91dHB1dCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJpZGdlO1xuIiwiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi4vLi4vY29yZS9CYXNlTGZvJztcblxuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgc2VwYXJhdGVBcnJheXM6IHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgY29uc3RhbnQ6IHRydWUsXG4gIH0sXG4gIGNhbGxiYWNrOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfSxcbiAgfSxcbn07XG5cbi8qKlxuICogUmVjb3JkIGlucHV0IGZyYW1lcyBmcm9tIGEgZ3JhcGguIFRoaXMgc2luayBjYW4gaGFuZGxlIGBzaWduYWxgLCBgdmVjdG9yYFxuICogb3IgYHNjYWxhcmAgaW5wdXRzLlxuICpcbiAqIFdoZW4gdGhlIHJlY29yZGluZyBpcyBzdG9wcGVkIChlaXRoZXIgYnkgY2FsbGluZyBgc3RvcGAgb24gdGhlIG5vZGUgb3Igd2hlblxuICogdGhlIHN0cmVhbSBpcyBmaW5hbGl6ZWQpLCB0aGUgY2FsbGJhY2sgZ2l2ZW4gYXMgcGFyYW1ldGVyIGlzIGV4ZWN1dGVkIHdpdGhcbiAqIHRoZSByZWNvcmRlciBkYXRhIGFzIGFyZ3VtZW50LlxuICpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VwYXJhdGVBcnJheXM9ZmFsc2VdIC0gRm9ybWF0IG9mIHRoZSByZXRyaWV2ZWRcbiAqICB2YWx1ZXM6XG4gKiAgLSB3aGVuIGBmYWxzZWAsIGZvcm1hdCBpcyBbeyB0aW1lLCBkYXRhIH0sIHsgdGltZSwgZGF0YSB9LCAuLi5dXG4gKiAgLSB3aGVuIGB0cnVlYCwgZm9ybWF0IGlzIHsgdGltZTogWy4uLl0sIGRhdGE6IFsuLi5dIH1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBhIG5ldyByZWNvcmRcbiAqICBpcyBlbmRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW46XG4gKiAgLSBgc3RvcGAgaXMgY2FsbGVkIG9uIHRoZSByZWNvcmRlclxuICogIC0gYHN0b3BgIGlzIGNhbGxlZCBvbiB0aGUgc291cmNlLlxuICpcbiAqIEB0b2RvIC0gQWRkIGF1dG8gcmVjb3JkIHBhcmFtLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLnNpbmtcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jb21tb24nO1xuICpcbiAqIGNvbnN0IGV2ZW50SW4gPSBuZXcgbGZvLnNvdXJjZS5FdmVudEluKHtcbiAqICBmcmFtZVR5cGU6ICd2ZWN0b3InLFxuICogIGZyYW1lU2l6ZTogMixcbiAqICBmcmFtZVJhdGU6IDAsXG4gKiB9KTtcbiAqXG4gKiBjb25zdCByZWNvcmRlciA9IG5ldyBsZm8uc2luay5EYXRhUmVjb3JkZXIoe1xuICogICBjYWxsYmFjazogKGRhdGEpID0+IGNvbnNvbGUubG9nKGRhdGEpLFxuICogfSk7XG4gKlxuICogZXZlbnRJbi5jb25uZWN0KHJlY29yZGVyKTtcbiAqIGV2ZW50SW4uc3RhcnQoKTtcbiAqIHJlY29yZGVyLnN0YXJ0KCk7XG4gKlxuICogZXZlbnRJbi5wcm9jZXNzKDAsIFswLCAxXSk7XG4gKiBldmVudEluLnByb2Nlc3MoMSwgWzEsIDJdKTtcbiAqXG4gKiByZWNvcmRlci5zdG9wKCk7XG4gKiA+IFt7IHRpbWU6IDAsIGRhdGE6IFswLCAxXSB9LCB7IHRpbWU6IDEsIGRhdGE6IFsxLCAyXSB9XTtcbiAqL1xuY2xhc3MgRGF0YVJlY29yZGVyIGV4dGVuZHMgQmFzZUxmbyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZSBpZiB0aGUgbm9kZSBpcyBjdXJyZW50bHkgcmVjb3JkaW5nLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQG5hbWUgaXNSZWNvcmRpbmdcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOnNpbmsuU2lnbmFsUmVjb3JkZXJcbiAgICAgKi9cbiAgICB0aGlzLmlzUmVjb3JkaW5nID0gZmFsc2U7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2luaXRTdG9yZSgpIHtcbiAgICBjb25zdCBzZXBhcmF0ZUFycmF5cyA9IHRoaXMucGFyYW1zLmdldCgnc2VwYXJhdGVBcnJheXMnKTtcblxuICAgIGlmIChzZXBhcmF0ZUFycmF5cylcbiAgICAgIHRoaXMuX3N0b3JlID0geyB0aW1lOiBbXSwgZGF0YTogW10gfTtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9zdG9yZSA9IFtdO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcbiAgICB0aGlzLl9pbml0U3RvcmUoKTtcbiAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHJlY29yZGluZy5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNsaWVudC5zaW5rLkRhdGFSZWNvcmRlciNzdG9wfVxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5pc1JlY29yZGluZyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCByZWNvcmRpbmcgYW5kIGV4ZWN1dGUgdGhlIGNhbGxiYWNrIGRlZmluZWQgaW4gcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNsaWVudC5zaW5rLkRhdGFSZWNvcmRlciNzdGFydH1cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcpIHtcbiAgICAgIHRoaXMuaXNSZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5wYXJhbXMuZ2V0KCdjYWxsYmFjaycpO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpXG4gICAgICAgIGNhbGxiYWNrKHRoaXMuX3N0b3JlKTtcblxuICAgICAgdGhpcy5faW5pdFN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGZpbmFsaXplU3RyZWFtKCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICB9XG5cbiAgLy8gaGFuZGxlIGFueSBpbnB1dCB0eXBlc1xuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1NjYWxhcihmcmFtZSkge31cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTaWduYWwoZnJhbWUpIHt9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzVmVjdG9yKGZyYW1lKSB7fVxuXG4gIHByb2Nlc3NGcmFtZShmcmFtZSkge1xuICAgIGlmICh0aGlzLmlzUmVjb3JkaW5nKSB7XG4gICAgICB0aGlzLnByZXBhcmVGcmFtZShmcmFtZSk7XG5cbiAgICAgIGNvbnN0IHNlcGFyYXRlQXJyYXlzID0gdGhpcy5wYXJhbXMuZ2V0KCdzZXBhcmF0ZUFycmF5cycpO1xuICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgIHRpbWU6IGZyYW1lLnRpbWUsXG4gICAgICAgIGRhdGE6IG5ldyBGbG9hdDMyQXJyYXkoZnJhbWUuZGF0YSksXG4gICAgICB9O1xuXG4gICAgICBpZiAoIXNlcGFyYXRlQXJyYXlzKSB7XG4gICAgICAgIHRoaXMuX3N0b3JlLnB1c2goZW50cnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RvcmUudGltZS5wdXNoKGVudHJ5LnRpbWUpO1xuICAgICAgICB0aGlzLl9zdG9yZS5kYXRhLnB1c2goZW50cnkuZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFSZWNvcmRlcjtcblxuIiwiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi4vLi4vY29yZS9CYXNlTGZvJztcblxuY29uc3QgZGVmaW5pdGlvbnMgPSB7XG4gIHRpbWU6IHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgZGF0YToge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICBtZXRhZGF0YToge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxuICBzdHJlYW1QYXJhbXM6IHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH1cbiAgfSxcbiAgZnJhbWVJbmRleDoge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBtZXRhczogeyBraW5kOiAnZHluYW1pYycgfVxuICB9LFxufVxuXG4vKipcbiAqIExvZyBgZnJhbWUudGltZWAsIGBmcmFtZS5kYXRhYCwgYGZyYW1lLm1ldGFkYXRhYCBhbmQvb3JcbiAqIGBzdHJlYW1BdHRyaWJ1dGVzYCBvZiBhbnkgbm9kZSBpbiB0aGUgY29uc29sZS5cbiAqXG4gKiBUaGlzIHNpbmsgY2FuIGhhbmRsZSBhbnkgdHlwZSBpZiBpbnB1dCAoYHNpZ25hbGAsIGB2ZWN0b3JgLCBgc2NhbGFyYClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIHBhcmFtZXRlcnMgZGVmYXVsdCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWU9ZmFsc2VdIC0gTG9nIGluY29tbWluZyBgZnJhbWUudGltZWAgaWYgYHRydWVgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kYXRhPWZhbHNlXSAtIExvZyBpbmNvbW1pbmcgYGZyYW1lLmRhdGFgIGlmIGB0cnVlYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWV0YWRhdGE9ZmFsc2VdIC0gTG9nIGluY29tbWluZyBgZnJhbWUubWV0YWRhdGFgXG4gKiAgaWYgYHRydWVgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdHJlYW1QYXJhbXM9ZmFsc2VdIC0gTG9nIGBzdHJlYW1QYXJhbXNgIG9mIHRoZVxuICogIHByZXZpb3VzIG5vZGUgd2hlbiBncmFwaCBpcyBzdGFydGVkLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mcmFtZUluZGV4PWZhbHNlXSAtIExvZyBpbmRleCBvZiB0aGUgaW5jb21taW5nXG4gKiAgYGZyYW1lYC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbW1vbi5zaW5rXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY29tbW9uJztcbiAqXG4gKiBjb25zdCBsb2dnZXIgPSBuZXcgbGZvLnNpbmsuTG9nZ2VyKHsgZGF0YTogdHJ1ZSB9KTtcbiAqIHdoYXRldmVyT3BlcmF0b3IuY29ubmVjdChsb2dnZXIpO1xuICovXG5jbGFzcyBMb2dnZXIgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpIHtcbiAgICBpZiAodGhpcy5wYXJhbXMuZ2V0KCdzdHJlYW1QYXJhbXMnKSA9PT0gdHJ1ZSlcbiAgICAgIGNvbnNvbGUubG9nKHByZXZTdHJlYW1QYXJhbXMpO1xuXG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzRnVuY3Rpb24oZnJhbWUpIHtcbiAgICBpZiAodGhpcy5wYXJhbXMuZ2V0KCdmcmFtZUluZGV4JykgPT09IHRydWUpXG4gICAgICBjb25zb2xlLmxvZyh0aGlzLmZyYW1lSW5kZXgrKyk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuZ2V0KCd0aW1lJykgPT09IHRydWUpXG4gICAgICBjb25zb2xlLmxvZyhmcmFtZS50aW1lKTtcblxuICAgIGlmICh0aGlzLnBhcmFtcy5nZXQoJ2RhdGEnKSA9PT0gdHJ1ZSlcbiAgICAgIGNvbnNvbGUubG9nKGZyYW1lLmRhdGEpO1xuXG4gICAgaWYgKHRoaXMucGFyYW1zLmdldCgnbWV0YWRhdGEnKSA9PT0gdHJ1ZSlcbiAgICAgIGNvbnNvbGUubG9nKGZyYW1lLm1ldGFkYXRhKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2dnZXI7XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgZHVyYXRpb246IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IDEwLFxuICAgIG1pbjogMCxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9LFxuICBjYWxsYmFjazoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gICAgbWV0YXM6IHsga2luZDogJ2R5bmFtaWMnIH0sXG4gIH0sXG4gIGlnbm9yZUxlYWRpbmdaZXJvczoge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH0sXG4gIH0sXG4gIHJldHJpZXZlQXVkaW9CdWZmZXI6IHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgY29uc3RhbnQ6IHRydWUsXG4gIH0sXG4gIGF1ZGlvQ29udGV4dDoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbnVsbGFibGU6IHRydWUsXG4gIH0sXG59O1xuXG4vKipcbiAqIFJlY29yZCBhbiBgc2lnbmFsYCBpbnB1dCBzdHJlYW0gb2YgYXJiaXRyYXJ5IGR1cmF0aW9uIGFuZCByZXRyaWV2ZSBpdFxuICogd2hlbiBkb25lLlxuICpcbiAqIFdoZW4gcmVjb3JkaW5nIGlzIHN0b3BwZWQgKGVpdGhlciB3aGVuIHRoZSBgc3RvcGAgbWV0aG9kIGlzIGNhbGxlZCwgdGhlXG4gKiBkZWZpbmVkIGR1cmF0aW9uIGhhcyBiZWVuIHJlY29yZGVkLCBvciB0aGUgc291cmNlIG9mIHRoZSBncmFwaCBmaW5hbGl6ZWRcbiAqIHRoZSBzdHJlYW0pLCB0aGUgY2FsbGJhY2sgZ2l2ZW4gYXMgcGFyYW1ldGVyIGlzIGV4ZWN1dGVkICB3aXRoIHRoZVxuICogYEF1ZGlvQnVmZmVyYCBvciBgRmxvYXQzMkFycmF5YCBjb250YWluaW5nIHRoZSByZWNvcmRlZCBzaWduYWwgYXMgYXJndW1lbnQuXG4gKlxuICogQHRvZG8gLSBhZGQgb3B0aW9uIHRvIHJldHVybiBvbmx5IHRoZSBGbG9hdDMyQXJyYXkgYW5kIG5vdCBhbiBhdWRpbyBidWZmZXJcbiAqICAobm9kZSBjb21wbGlhbnQpIGByZXRyaWV2ZUF1ZGlvQnVmZmVyOiBmYWxzZWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbj0xMF0gLSBNYXhpbXVtIGR1cmF0aW9uIG9mIHRoZSByZWNvcmRpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2FsbGJhY2tdIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGEgbmV3IHJlY29yZCBpc1xuICogIGVuZGVkLiBUaGlzIGNhbiBoYXBwZW46IGBzdG9wYCBpcyBjYWxsZWQgb24gdGhlIHJlY29yZGVyLCBgc3RvcGAgaXMgY2FsbGVkXG4gKiAgb24gdGhlIHNvdXJjZSBvciB3aGVuIHRoZSBidWZmZXIgaXMgZnVsbCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGBkdXJhdGlvbmAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaWdub3JlTGVhZGluZ1plcm9zPXRydWVdIC0gU3RhcnQgdGhlIGVmZmVjdGl2ZVxuICogIHJlY29yZGluZyBvbiB0aGUgZmlyc3Qgbm9uLXplcm8gdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJldHJpZXZlQXVkaW9CdWZmZXI9ZmFsc2VdIC0gRGVmaW5lIGlmIGFuIGBBdWRpb0J1ZmZlcmBcbiAqICBzaG91bGQgYmUgcmV0cmlldmVkIG9yIG9ubHkgdGhlIHJhdyBGbG9hdDMyQXJyYXkgb2YgZGF0YS5cbiAqICAod29ya3Mgb25seSBpbiBicm93c2VyKVxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IFtvcHRpb25zLmF1ZGlvQ29udGV4dD1udWxsXSAtIElmXG4gKiAgYHJldHJpZXZlQXVkaW9CdWZmZXJgIGlzIHNldCB0byBgdHJ1ZWAsIGF1ZGlvIGNvbnRleHQgdG8gYmUgdXNlZFxuICogIGluIG9yZGVyIHRvIGNyZWF0ZSB0aGUgZmluYWwgYXVkaW8gYnVmZmVyLlxuICogICh3b3JrcyBvbmx5IGluIGJyb3dzZXIpXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21tb24uc2lua1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICpcbiAqIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAqICAgLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlIH0pXG4gKiAgIC50aGVuKGluaXQpXG4gKiAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKGVyci5zdGFjaykpO1xuICpcbiAqIGZ1bmN0aW9uIGluaXQoc3RyZWFtKSB7XG4gKiAgIGNvbnN0IHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xuICpcbiAqICAgY29uc3QgYXVkaW9Jbk5vZGUgPSBuZXcgbGZvLnNvdXJjZS5BdWRpb0luTm9kZSh7XG4gKiAgICAgc291cmNlTm9kZTogc291cmNlLFxuICogICAgIGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0LFxuICogICB9KTtcbiAqXG4gKiAgIGNvbnN0IHNpZ25hbFJlY29yZGVyID0gbmV3IGxmby5zaW5rLlNpZ25hbFJlY29yZGVyKHtcbiAqICAgICBkdXJhdGlvbjogNixcbiAqICAgICByZXRyaWV2ZUF1ZGlvQnVmZmVyOiB0cnVlLFxuICogICAgIGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0LFxuICogICAgIGNhbGxiYWNrOiAoYnVmZmVyKSA9PiB7XG4gKiAgICAgICBjb25zdCBidWZmZXJTb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gKiAgICAgICBidWZmZXJTb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xuICogICAgICAgYnVmZmVyU291cmNlLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAqICAgICAgIGJ1ZmZlclNvdXJjZS5zdGFydCgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogICBhdWRpb0luTm9kZS5jb25uZWN0KHNpZ25hbFJlY29yZGVyKTtcbiAqICAgYXVkaW9Jbk5vZGUuc3RhcnQoKTtcbiAqICAgc2lnbmFsUmVjb3JkZXIuc3RhcnQoKTtcbiAqIH0pO1xuICovXG5jbGFzcyBTaWduYWxSZWNvcmRlciBleHRlbmRzIEJhc2VMZm8ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgaXMgdGhlIG5vZGUgaXMgY3VycmVudGx5IHJlY29yZGluZyBvciBub3QuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAbmFtZSBpc1JlY29yZGluZ1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y2xpZW50LnNpbmsuU2lnbmFsUmVjb3JkZXJcbiAgICAgKi9cbiAgICB0aGlzLmlzUmVjb3JkaW5nID0gZmFsc2U7XG5cbiAgICBjb25zdCByZXRyaWV2ZUF1ZGlvQnVmZmVyID0gdGhpcy5wYXJhbXMuZ2V0KCdyZXRyaWV2ZUF1ZGlvQnVmZmVyJyk7XG4gICAgY29uc3QgYXVkaW9Db250ZXh0ID0gdGhpcy5wYXJhbXMuZ2V0KCdhdWRpb0NvbnRleHQnKTtcbiAgICAvLyBuZWVkZWQgdG8gcmV0cmlldmUgYW4gQXVkaW9CdWZmZXJcbiAgICBpZiAocmV0cmlldmVBdWRpb0J1ZmZlciAmJiBhdWRpb0NvbnRleHQgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyIFwiYXVkaW9Db250ZXh0XCI6IGFuIEF1ZGlvQ29udGV4dCBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gYHJldHJpZXZlQXVkaW9CdWZmZXJgIGlzIHNldCB0byBgdHJ1ZWAnKVxuXG4gICAgdGhpcy5fYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICAgIHRoaXMuX2lnbm9yZVplcm9zID0gZmFsc2U7XG4gICAgdGhpcy5faXNJbmZpbml0ZUJ1ZmZlciA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YWNrID0gW107XG4gICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9idWZmZXJMZW5ndGggPSBudWxsO1xuICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IG51bGw7XG4gIH1cblxuICBfaW5pdEJ1ZmZlcigpIHtcbiAgICB0aGlzLl9idWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX2J1ZmZlckxlbmd0aCk7XG4gICAgdGhpcy5fc3RhY2subGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jdXJyZW50SW5kZXggPSAwO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5wYXJhbXMuZ2V0KCdkdXJhdGlvbicpO1xuICAgIGNvbnN0IHNhbXBsZVJhdGUgPSB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlO1xuXG4gICAgaWYgKGlzRmluaXRlKGR1cmF0aW9uKSkge1xuICAgICAgdGhpcy5faXNJbmZpbml0ZUJ1ZmZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fYnVmZmVyTGVuZ3RoID0gc2FtcGxlUmF0ZSAqIGR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc0luZmluaXRlQnVmZmVyID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2J1ZmZlckxlbmd0aCA9IHNhbXBsZVJhdGUgKiAxMDtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0QnVmZmVyKCk7XG4gICAgdGhpcy5wcm9wYWdhdGVTdHJlYW1QYXJhbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCByZWNvcmRpbmcuXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICB0aGlzLmlzUmVjb3JkaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9pZ25vcmVaZXJvcyA9IHRoaXMucGFyYW1zLmdldCgnaWdub3JlTGVhZGluZ1plcm9zJyk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCByZWNvcmRpbmcgYW5kIGV4ZWN1dGUgdGhlIGNhbGxiYWNrIGRlZmluZWQgaW4gcGFyYW1ldGVycy5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcpIHtcbiAgICAgIC8vIGlnbm9yZSBuZXh0IGluY29tbWluZyBmcmFtZVxuICAgICAgdGhpcy5pc1JlY29yZGluZyA9IGZhbHNlO1xuXG4gICAgICBjb25zdCByZXRyaWV2ZUF1ZGlvQnVmZmVyID0gdGhpcy5wYXJhbXMuZ2V0KCdyZXRyaWV2ZUF1ZGlvQnVmZmVyJyk7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMucGFyYW1zLmdldCgnY2FsbGJhY2snKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2N1cnJlbnRJbmRleDtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcbiAgICAgIGxldCBvdXRwdXQ7XG5cbiAgICAgIGlmICghdGhpcy5faXNJbmZpbml0ZUJ1ZmZlcikge1xuICAgICAgICBvdXRwdXQgPSBuZXcgRmxvYXQzMkFycmF5KGN1cnJlbnRJbmRleCk7XG4gICAgICAgIG91dHB1dC5zZXQoYnVmZmVyLnN1YmFycmF5KDAsIGN1cnJlbnRJbmRleCksIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVmZmVyTGVuZ3RoID0gdGhpcy5fYnVmZmVyTGVuZ3RoO1xuICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuX3N0YWNrO1xuXG4gICAgICAgIG91dHB1dCA9IG5ldyBGbG9hdDMyQXJyYXkoc3RhY2subGVuZ3RoICogYnVmZmVyTGVuZ3RoICsgY3VycmVudEluZGV4KTtcblxuICAgICAgICAvLyBjb3B5IGFsbCBzdGFja2VkIGJ1ZmZlcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHN0YWNrZWRCdWZmZXIgPSBzdGFja1tpXTtcbiAgICAgICAgICBvdXRwdXQuc2V0KHN0YWNrZWRCdWZmZXIsIGJ1ZmZlckxlbmd0aCAqIGkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBjb3B5IGRhdGEgY29udGFpbmVkIGluIGN1cnJlbnQgYnVmZmVyXG4gICAgICAgIG91dHB1dC5zZXQoYnVmZmVyLnN1YmFycmF5KDAsIGN1cnJlbnRJbmRleCksIHN0YWNrLmxlbmd0aCAqIGJ1ZmZlckxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXRyaWV2ZUF1ZGlvQnVmZmVyICYmIHRoaXMuX2F1ZGlvQ29udGV4dCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICBjb25zdCBzYW1wbGVSYXRlID0gdGhpcy5zdHJlYW1QYXJhbXMuc291cmNlU2FtcGxlUmF0ZTtcbiAgICAgICAgY29uc3QgYXVkaW9CdWZmZXIgPSB0aGlzLl9hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIGxlbmd0aCwgc2FtcGxlUmF0ZSk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxEYXRhID0gYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgIGNoYW5uZWxEYXRhLnNldChvdXRwdXQsIDApO1xuXG4gICAgICAgIGNhbGxiYWNrKGF1ZGlvQnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG91dHB1dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlaW5pdCBidWZmZXIsIHN0YWNrLCBhbmQgY3VycmVudEluZGV4XG4gICAgICB0aGlzLl9pbml0QnVmZmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGZpbmFsaXplU3RyZWFtKGVuZFRpbWUpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU2lnbmFsKGZyYW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKVxuICAgICAgcmV0dXJuO1xuXG4gICAgbGV0IGJsb2NrID0gbnVsbDtcbiAgICBjb25zdCBpbnB1dCA9IGZyYW1lLmRhdGE7XG4gICAgY29uc3QgYnVmZmVyTGVuZ3RoID0gdGhpcy5fYnVmZmVyTGVuZ3RoO1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcblxuICAgIGlmICh0aGlzLl9pZ25vcmVaZXJvcyA9PT0gZmFsc2UpIHtcbiAgICAgIGJsb2NrID0gbmV3IEZsb2F0MzJBcnJheShpbnB1dCk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFtpbnB1dC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgLy8gZmluZCBmaXJzdCBpbmRleCB3aGVyZSB2YWx1ZSAhPT0gMFxuICAgICAgbGV0IGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGlucHV0W2ldICE9PSAwKSBicmVhaztcblxuICAgICAgLy8gY29weSBub24gemVybyBzZWdtZW50XG4gICAgICBibG9jayA9IG5ldyBGbG9hdDMyQXJyYXkoaW5wdXQuc3ViYXJyYXkoaSkpO1xuICAgICAgLy8gZG9uJ3QgcmVwZWF0IHRoaXMgbG9naWMgb25jZSBhIG5vbi16ZXJvIHZhbHVlIGhhcyBiZWVuIGZvdW5kXG4gICAgICB0aGlzLl9pZ25vcmVaZXJvcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChibG9jayAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgYXZhaWxhYmxlU3BhY2UgPSBidWZmZXJMZW5ndGggLSB0aGlzLl9jdXJyZW50SW5kZXg7XG4gICAgICBsZXQgY3VycmVudEJsb2NrO1xuXG4gICAgICBpZiAoYXZhaWxhYmxlU3BhY2UgPCBibG9jay5sZW5ndGgpXG4gICAgICAgIGN1cnJlbnRCbG9jayA9IGJsb2NrLnN1YmFycmF5KDAsIGF2YWlsYWJsZVNwYWNlKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY3VycmVudEJsb2NrID0gYmxvY2s7XG5cbiAgICAgIGJ1ZmZlci5zZXQoY3VycmVudEJsb2NrLCB0aGlzLl9jdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy5fY3VycmVudEluZGV4ICs9IGN1cnJlbnRCbG9jay5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzLl9pc0luZmluaXRlQnVmZmVyICYmIHRoaXMuX2N1cnJlbnRJbmRleCA9PT0gYnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3N0YWNrLnB1c2goYnVmZmVyKTtcblxuICAgICAgICBjdXJyZW50QmxvY2sgPSBibG9jay5zdWJhcnJheShhdmFpbGFibGVTcGFjZSk7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyLnNldChjdXJyZW50QmxvY2ssIDApO1xuICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSBjdXJyZW50QmxvY2subGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyAgc3RvcCBpZiB0aGUgYnVmZmVyIGlzIGZpbml0ZSBhbmQgZnVsbFxuICAgICAgaWYgKCF0aGlzLl9pc0luZmluaXRlQnVmZmVyICYmIHRoaXMuX2N1cnJlbnRJbmRleCA9PT0gYnVmZmVyTGVuZ3RoKVxuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2lnbmFsUmVjb3JkZXI7XG5cbiIsImltcG9ydCBCcmlkZ2UgZnJvbSAnLi9CcmlkZ2UnO1xuaW1wb3J0IERhdGFSZWNvcmRlciBmcm9tICcuL0RhdGFSZWNvcmRlcic7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4vTG9nZ2VyJztcbmltcG9ydCBTaWduYWxSZWNvcmRlciBmcm9tICcuL1NpZ25hbFJlY29yZGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBCcmlkZ2UsXG4gIERhdGFSZWNvcmRlcixcbiAgTG9nZ2VyLFxuICBTaWduYWxSZWNvcmRlcixcbn07XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuaW1wb3J0IFNvdXJjZU1peGluIGZyb20gJy4uLy4uL2NvcmUvU291cmNlTWl4aW4nO1xuaW1wb3J0IFRpY2tlciBmcm9tICdAaXJjYW0vdGlja2VyJztcblxuY29uc3QgZGVmaW5pdGlvbnMgPSB7XG4gIHNvdXJjZToge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbWV0YXM6IHtcbiAgICAgIGtpbmQ6ICdzdGF0aWMnLFxuICAgIH0sXG4gIH0sXG59XG5cbi8qKlxuICogUmVnZW5lcmF0ZSBhIHZlY3RvciBzdHJlYW0gKHBvc3NpYmx5IGluIHRpbWUpIGluIHRpbWUgZnJvbSBhIHJlY29yZGluZy5cbiAqIFRoZSBnaXZlbiByZWNvcmRpbmcgc2hvdWxkIGNvbXBseSB3aXRoIHRoZSBmb3JtYXQgb3V0cHV0IGJ5IHRoZSBEYXRhUmVjb3JkZXJcbiAqIGxmby5cbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBwYXJhbWV0ZXJzJyBkZWZhdWx0IHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW29wdGlvbnMuc291cmNlXSAtIEFjdHVhbCByZWNvcmRpbmcgdG8gcHJvY2Vzcy4gU2hvdWxkXG4gKiAgYmUgY29tcGxpYW50IHdpdGggZm9ybWF0IG91dHB1dCBieSB0aGUgRGF0YVJlY29yZGVyXG4gKlxuICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvbW1vbi5zaW5rLkRhdGFSZWNvcmRlcn1cbiAqL1xuY2xhc3MgRGF0YVJlYWRlciBleHRlbmRzIFNvdXJjZU1peGluKEJhc2VMZm8pIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcblxuICAgIHRoaXMuc291cmNlU3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLnNvdXJjZUVuZFRpbWUgPSBudWxsO1xuXG4gICAgdGhpcy5fdGlja2VyID0gbnVsbDtcbiAgICB0aGlzLl9mcmFtZXMgPSBudWxsO1xuICAgIHRoaXMuX2ZyYW1lSW5kZXggPSAwO1xuICAgIHRoaXMuX251bUZyYW1lcyA9IG51bGw7XG4gICAgdGhpcy5faGFzU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogZGVmaW5lIGlmIHRoZSByZWNvcmRpbmcgaGFzIHRoZSBmb3JtYXQ6XG4gICAgICogeyB0aW1lOiBbLi4uXSwgZGF0YTogW1suLi5dLCBbLi4uXV0gfSAvLyB0cnVlXG4gICAgICogb3JcbiAgICAgKiBbeyB0aW1lLCBkYXRhIH0sIHsgdGltZSwgZGF0YSB9XVxuICAgICAqL1xuICAgIHRoaXMuX3NlcGFyYXRlQXJyYXlGcmFtZXMgPSBudWxsO1xuXG4gICAgdGhpcy5wcm9jZXNzRnJhbWUgPSB0aGlzLnByb2Nlc3NGcmFtZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcHJvY2Vzc1N0cmVhbVBhcmFtcygpIHtcbiAgICBsZXQgc291cmNlID0gdGhpcy5wYXJhbXMuZ2V0KCdzb3VyY2UnKTtcblxuICAgIHRyeSB7XG4gICAgICBzb3VyY2UgPSBKU09OLnBhcnNlKCk7XG4gICAgfSBjYXRjaChlcnIpIHt9IC8vIGFscmVhZHkgSlNPTiwgZG8gbm90aGluZ1xuXG4gICAgaWYgKHNvdXJjZSA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIERhdGFSZWFkZXIgc291cmNlJyk7XG5cbiAgICB0aGlzLnN0cmVhbVBhcmFtcyA9IHNvdXJjZS5zdHJlYW1QYXJhbXM7XG4gICAgdGhpcy5fZnJhbWVzID0gc291cmNlLmZyYW1lcztcblxuICAgIGlmICh0aGlzLnN0cmVhbVBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8wqB0aGlzLl9mcmFtZXMgPT09IHVuZGVmaW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBEYXRhUmVhZGVyIHNvdXJjZScpO1xuXG4gICAgY29uc3QgZnJhbWVSYXRlID0gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlO1xuICAgIGNvbnN0IGZyYW1lcyA9IHRoaXMuX2ZyYW1lcztcbiAgICBjb25zdCBudW1GcmFtZXMgPSB0aGlzLl9zZXBhcmF0ZUFycmF5RnJhbWVzID8gZnJhbWVzLnRpbWUubGVuZ3RoIDogZnJhbWVzLmxlbmd0aDtcbiAgICBjb25zdCBzZXBhcmF0ZUFycmF5RnJhbWVzID0gQXJyYXkuaXNBcnJheShmcmFtZXNbMF0udGltZSkgPyB0cnVlIDogZmFsc2U7XG5cbiAgICBpZiAoZnJhbWVSYXRlID09PSAwKSB7XG4gICAgICAvLyB0aGUgcmVjb3JkaW5nIGRvZXNuJ3QgaGF2ZSBhIGZyYW1lUmF0ZSwgZXN0aW1hdGUgZnJvbSAxMCBmaXJzdCBmcmFtZXNcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKDEwLCBudW1GcmFtZXMpO1xuICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4IC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRpbWUwID0gc2VwYXJhdGVBcnJheUZyYW1lcyA/IGZyYW1lcy50aW1lW2ldIDogZnJhbWVzW2ldLnRpbWU7XG4gICAgICAgIGNvbnN0IHRpbWUxID0gc2VwYXJhdGVBcnJheUZyYW1lcyA/IGZyYW1lcy50aW1lW2kgKyAxXSA6IGZyYW1lc1tpICsgMV0udGltZTtcbiAgICAgICAgY29uc3QgZHQgPSB0aW1lMSAtIHRpbWUwO1xuICAgICAgICBzdW0gKz0gZHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBlcmlvZCA9IHN1bSAvIChtYXggLSAxKTtcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lUmF0ZSA9IDEgLyBwZXJpb2Q7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VTdGFydFRpbWUgPSBzZXBhcmF0ZUFycmF5RnJhbWVzID8gZnJhbWVzLnRpbWVbMF0gOiBmcmFtZXNbMF0udGltZTtcbiAgICB0aGlzLnNvdXJjZUVuZFRpbWUgPSBzZXBhcmF0ZUFycmF5RnJhbWVzID8gZnJhbWVzLnRpbWVbbnVtRnJhbWVzIC0gMV0gOiBmcmFtZXNbbnVtRnJhbWVzIC0gMV0udGltZTtcbiAgICB0aGlzLl9udW1GcmFtZXMgPSBudW1GcmFtZXM7XG4gICAgdGhpcy5fc2VwYXJhdGVBcnJheUZyYW1lcyA9IHNlcGFyYXRlQXJyYXlGcmFtZXM7XG5cbiAgICBjb25zdCBwZXJpb2QgPSAxIC8gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlO1xuXG4gICAgLy8ga2VlcCBvbmx5IG9uZSB0aWNrZXIgaW5zdGFuY2VcbiAgICBpZiAodGhpcy5fdGlja2VyID09PSBudWxsKVxuICAgICAgdGhpcy5fdGlja2VyID0gbmV3IFRpY2tlcihwZXJpb2QgKiAxMDAwLCB0aGlzLnByb2Nlc3NGcmFtZSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5fdGlja2VyLnBlcmlvZCA9IHBlcmlvZCAqIDEwMDA7XG5cbiAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG91dHB1dCBzdHJlYW0uXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgIGlmICh0aGlzLmluaXRQcm9taXNlID09PSBudWxsKSAvLyBpbml0IGhhcyBub3QgeWV0IGJlZW4gY2FsbGVkXG4gICAgICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLmluaXQoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuaW5pdFByb21pc2UudGhlbigoKSA9PiB0aGlzLnN0YXJ0KCkpO1xuICAgIH1cblxuICAgIHRoaXMuX2hhc1N0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3RpY2tlci5zdGFydCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIG91dHB1dCBzdHJlYW0gYW5kIHRoZSBwb2ludGVyLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5faGFzU3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fdGlja2VyLnN0b3AoKTtcbiAgICAgIC8vIGNvbnN0IGVuZCB0aW1lXG4gICAgICBjb25zdCBwZXJpb2QgPSAxIC8gdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVSYXRlO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5zb3VyY2VTdGFydFRpbWU7XG4gICAgICBjb25zdCBlbmRUaW1lID0gdGhpcy5fZnJhbWVJbmRleCAqIHBlcmlvZCArIG9mZnNldDtcblxuICAgICAgdGhpcy5fZnJhbWVJbmRleCA9IDA7XG4gICAgICB0aGlzLl9oYXNTdGFydGVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuZmluYWxpemVTdHJlYW0oZW5kVGltZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIG91dHB1dCBzdHJlYW0gd2l0aG91dCByZXNldGluZyB0aGUgcG9pbnRlci5cbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLl9oYXNTdGFydGVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl90aWNrZXIuc3RvcCgpO1xuXG4gICAgICB0aGlzLl9oYXNTdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIHRvIGEgZ2l2ZW4gdGltZS4gVGhlIGdpdmVuIHRpbWUgbXVzdCBiZSBpbiB0aGUgYm91bmRhcmllcyBkZWZpbmVkIGJ5IHRoZVxuICAgKlxuICAgKlxuICAgKi9cbiAgc2Vlayh0aW1lKSB7XG4gICAgLy8gZmluZCB0aGUgaW5kZXggY2xvc2VzdCB0byB0aGUgZ2l2ZW4gdGltZVxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5zb3VyY2VFbmRUaW1lIC0gdGhpcy5zb3VyY2VTdGFydFRpbWU7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5zb3VyY2VTdGFydFRpbWU7XG4gICAgY29uc3QgcGhhc2UgPSAodGltZSAtIG9mZnNldCkgLyAoZHVyYXRpb24gLSBvZmZzZXQpO1xuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcihwaGFzZSAqIHRoaXMuX251bUZyYW1lcyk7XG5cbiAgICB0aGlzLl9mcmFtZUluZGV4ID0gaW5kZXg7XG4gIH1cblxuICBwcmVwYXJlRnJhbWUoKSB7XG4gICAgLy8gdGhpcyBwcmV2ZW50IHNlZWsgYmVmb3JlIHN0YXJ0Li4uXG4gICAgLy8gaWYgKHRoaXMuX3JlaW5pdCA9PT0gdHJ1ZSkgLy8gc291cmNlIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAvLyAgIHRoaXMuX2ZyYW1lSW5kZXggPSAwO1xuXG4gICAgc3VwZXIucHJlcGFyZUZyYW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogVGlja2VyIGNhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm9jZXNzRnJhbWUobG9naWNhbFRpbWUpIHtcbiAgICB0aGlzLnByZXBhcmVGcmFtZSgpO1xuXG4gICAgbGV0IGZyYW1lO1xuXG4gICAgaWYgKHRoaXMuX3NlcGFyYXRlQXJyYXlGcmFtZXMpIHtcbiAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9mcmFtZXMudGltZVt0aGlzLl9mcmFtZUluZGV4XTtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9mcmFtZXMuZGF0YVt0aGlzLl9mcmFtZUluZGV4XTtcblxuICAgICAgZnJhbWUgPSB7IHRpbWUsIGRhdGEgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUgPSB0aGlzLl9mcmFtZXNbdGhpcy5fZnJhbWVJbmRleF07XG4gICAgfVxuXG4gICAgdGhpcy5fZnJhbWVJbmRleCArPSAxO1xuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcblxuICAgIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcblxuICAgIGlmICh0aGlzLl9mcmFtZUluZGV4ID49IHRoaXMuX251bUZyYW1lcylcbiAgICAgIHRoaXMuc3RvcCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFSZWFkZXI7XG4iLCJpbXBvcnQgQmFzZUxmbyBmcm9tICcuLi8uLi9jb3JlL0Jhc2VMZm8nO1xuaW1wb3J0IFNvdXJjZU1peGluIGZyb20gJy4uLy4uL2NvcmUvU291cmNlTWl4aW4nO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3NTc1NzkwL2Vudmlyb25tZW50LWRldGVjdGlvbi1ub2RlLWpzLW9yLWJyb3dzZXJcbmNvbnN0IGlzTm9kZSA9IG5ldyBGdW5jdGlvbigndHJ5IHsgcmV0dXJuIHRoaXMgPT09IGdsb2JhbDsgfSBjYXRjaChlKSB7IHJldHVybiBmYWxzZSB9Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRpbWUgaW4gc2Vjb25kcyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnRcbiAqIGVudmlyb25uZW1lbnQgKG5vZGUgb3IgYnJvd3NlcikuXG4gKiBJZiBydW5uaW5nIGluIG5vZGUgdGhlIHRpbWUgcmVseSBvbiBgcHJvY2Vzcy5ocnRpbWVgLCB3aGlsZSBpZiBpbiB0aGUgYnJvd3NlclxuICogaXQgaXMgcHJvdmlkZWQgYnkgdGhlIGBjdXJyZW50VGltZWAgb2YgYW4gYEF1ZGlvQ29udGV4dGAsIHRoaXMgY29udGV4dCBjYW5cbiAqIG9wdGlvbm5hbHkgYmUgcHJvdmlkZWQgdG8ga2VlcCB0aW1lIGNvbnNpc3RlbmN5IGJldHdlZW4gc2V2ZXJhbCBgRXZlbnRJbmBcbiAqIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBbYXVkaW9Db250ZXh0PW51bGxdIC0gT3B0aW9ubmFsIGF1ZGlvIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFRpbWVGdW5jdGlvbihhdWRpb0NvbnRleHQgPSBudWxsKSB7XG4gIGlmIChpc05vZGUoKSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAgIHJldHVybiB0WzBdICsgdFsxXSAqIDFlLTk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKSAvIDEwMDA7XG4gIH1cbn1cblxuXG5jb25zdCBkZWZpbml0aW9ucyA9IHtcbiAgYWJzb2x1dGVUaW1lOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIGNvbnN0YW50OiB0cnVlLFxuICB9LFxuICBhdWRpb0NvbnRleHQ6IHtcbiAgICB0eXBlOiAnYW55JyxcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIGNvbnN0YW50OiB0cnVlLFxuICAgIG51bGxhYmxlOiB0cnVlLFxuICB9LFxuICBmcmFtZVR5cGU6IHtcbiAgICB0eXBlOiAnZW51bScsXG4gICAgbGlzdDogWydzaWduYWwnLCAndmVjdG9yJywgJ3NjYWxhciddLFxuICAgIGRlZmF1bHQ6ICdzaWduYWwnLFxuICAgIGNvbnN0YW50OiB0cnVlLFxuICB9LFxuICBmcmFtZVNpemU6IHtcbiAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtaW46IDEsXG4gICAgbWF4OiArSW5maW5pdHksIC8vIG5vdCByZWNvbW1lbmRlZC4uLlxuICAgIG1ldGFzOiB7IGtpbmQ6ICdzdGF0aWMnIH0sXG4gIH0sXG4gIHNhbXBsZVJhdGU6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbWluOiAwLFxuICAgIG1heDogK0luZmluaXR5LCAvLyBzYW1lIGhlcmVcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9LFxuICBmcmFtZVJhdGU6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbWluOiAwLFxuICAgIG1heDogK0luZmluaXR5LCAvLyBzYW1lIGhlcmVcbiAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICBtZXRhczogeyBraW5kOiAnc3RhdGljJyB9LFxuICB9LFxuICBkZXNjcmlwdGlvbjoge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgY29uc3RhbnQ6IHRydWUsXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBFdmVudEluYCBvcGVyYXRvciBhbGxvd3MgdG8gbWFudWFsbHkgY3JlYXRlIGEgc3RyZWFtIG9mIGRhdGEgb3IgdG8gZmVlZFxuICogYSBzdHJlYW0gZnJvbSBhbm90aGVyIHNvdXJjZSAoZS5nLiBzZW5zb3JzKSBpbnRvIGEgcHJvY2Vzc2luZyBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlIHBhcmFtZXRlcnMnIGRlZmF1bHQgdmFsdWVzLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZyYW1lVHlwZT0nc2lnbmFsJ10gLSBUeXBlIG9mIHRoZSBpbnB1dCAtIGFsbG93ZWRcbiAqIHZhbHVlczogYHNpZ25hbGAsICBgdmVjdG9yYCBvciBgc2NhbGFyYC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mcmFtZVNpemU9MV0gLSBTaXplIG9mIHRoZSBvdXRwdXQgZnJhbWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2FtcGxlUmF0ZT1udWxsXSAtIFNhbXBsZSByYXRlIG9mIHRoZSBzb3VyY2Ugc3RyZWFtLFxuICogIGlmIG9mIHR5cGUgYHNpZ25hbGAuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJhbWVSYXRlPW51bGxdIC0gUmF0ZSBvZiB0aGUgc291cmNlIHN0cmVhbSwgaWYgb2ZcbiAqICB0eXBlIGB2ZWN0b3JgLlxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXSAtIE9wdGlvbm5hbCBkZXNjcmlwdGlvblxuICogIGRlc2NyaWJpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG91dHB1dCBmcmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hYnNvbHV0ZVRpbWU9ZmFsc2VdIC0gRGVmaW5lIGlmIHRpbWUgc2hvdWxkIGJlIHVzZWRcbiAqICBhcyBmb3J3YXJkZWQgYXMgZ2l2ZW4gaW4gdGhlIHByb2Nlc3MgbWV0aG9kLCBvciByZWxhdGl2ZWx5IHRvIHRoZSB0aW1lIG9mXG4gKiAgdGhlIGZpcnN0IGBwcm9jZXNzYCBjYWxsIGFmdGVyIHN0YXJ0LlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLnNvdXJjZVxuICpcbiAqIEB0b2RvIC0gQWRkIGEgYGxvZ2ljYWxUaW1lYCBwYXJhbWV0ZXIgdG8gdGFnIGZyYW1lIGFjY29yZGluZyB0byBmcmFtZSByYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgKiBhcyBsZm8gZnJvbSAnd2F2ZXMtbGZvL2NsaWVudCc7XG4gKlxuICogY29uc3QgZXZlbnRJbiA9IG5ldyBsZm8uc291cmNlLkV2ZW50SW4oe1xuICogICBmcmFtZVR5cGU6ICd2ZWN0b3InLFxuICogICBmcmFtZVNpemU6IDMsXG4gKiAgIGZyYW1lUmF0ZTogMSAvIDUwLFxuICogICBkZXNjcmlwdGlvbjogWydhbHBoYScsICdiZXRhJywgJ2dhbW1hJ10sXG4gKiB9KTtcbiAqXG4gKiAvLyBjb25uZWN0IHNvdXJjZSB0byBvcGVyYXRvcnMgYW5kIHNpbmsocylcbiAqXG4gKiAvLyBpbml0aWFsaXplIGFuZCBzdGFydCB0aGUgZ3JhcGhcbiAqIGV2ZW50SW4uc3RhcnQoKTtcbiAqXG4gKiAvLyBmZWVkIGBkZXZpY2VvcmllbnRhdGlvbmAgZGF0YSBpbnRvIHRoZSBncmFwaFxuICogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZW9yaWVudGF0aW9uJywgKGUpID0+IHtcbiAqICAgY29uc3QgZnJhbWUgPSB7XG4gKiAgICAgdGltZTogd2luZG93LnBlcmZvcm1hY2Uubm93KCkgLyAxMDAwLFxuICogICAgIGRhdGE6IFtlLmFscGhhLCBlLmJldGEsIGUuZ2FtbWFdLFxuICogICB9O1xuICpcbiAqICAgZXZlbnRJbi5wcm9jZXNzRnJhbWUoZnJhbWUpO1xuICogfSwgZmFsc2UpO1xuICovXG5jbGFzcyBFdmVudEluIGV4dGVuZHMgU291cmNlTWl4aW4oQmFzZUxmbykge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihkZWZpbml0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB0aGlzLnBhcmFtcy5nZXQoJ2F1ZGlvQ29udGV4dCcpO1xuICAgIHRoaXMuX2dldFRpbWUgPSBnZXRUaW1lRnVuY3Rpb24oYXVkaW9Db250ZXh0KTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMuX3N5c3RlbVRpbWUgPSBudWxsO1xuICAgIHRoaXMuX2Fic29sdXRlVGltZSA9IHRoaXMucGFyYW1zLmdldCgnYWJzb2x1dGVUaW1lJyk7XG4gIH1cblxuICAvKipcbiAgICogUHJvcGFnYXRlIHRoZSBgc3RyZWFtUGFyYW1zYCBpbiB0aGUgZ3JhcGggYW5kIGFsbG93IHRvIHB1c2ggZnJhbWVzIGludG9cbiAgICogdGhlIGdyYXBoLiBBbnkgY2FsbCB0byBgcHJvY2Vzc2Agb3IgYHByb2Nlc3NGcmFtZWAgYmVmb3JlIGBzdGFydGAgd2lsbCBiZVxuICAgKiBpZ25vcmVkLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Byb2Nlc3NTdHJlYW1QYXJhbXN9XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcmVzZXRTdHJlYW19XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb21tb24uc291cmNlLkV2ZW50SW4jc3RvcH1cbiAgICovXG4gIHN0YXJ0KHN0YXJ0VGltZSA9IG51bGwpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgIGlmICh0aGlzLmluaXRQcm9taXNlID09PSBudWxsKSAvLyBpbml0IGhhcyBub3QgeWV0IGJlZW4gY2FsbGVkXG4gICAgICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLmluaXQoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuaW5pdFByb21pc2UudGhlbigoKSA9PiB0aGlzLnN0YXJ0KHN0YXJ0VGltZSkpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB0aGlzLl9zeXN0ZW1UaW1lID0gbnVsbDsgLy8gdmFsdWUgc2V0IGluIHRoZSBmaXJzdCBgcHJvY2Vzc2AgY2FsbFxuXG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZSB0aGUgc3RyZWFtIGFuZCBzdG9wIHRoZSB3aG9sZSBncmFwaC4gQW55IGNhbGwgdG8gYHByb2Nlc3NgIG9yXG4gICAqIGBwcm9jZXNzRnJhbWVgIGFmdGVyIGBzdG9wYCB3aWxsIGJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jZmluYWxpemVTdHJlYW19XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb21tb24uc291cmNlLkV2ZW50SW4jc3RhcnR9XG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQgJiYgdGhpcy5fc3RhcnRUaW1lICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IHRoaXMuX2dldFRpbWUoKTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSB0aGlzLmZyYW1lLnRpbWUgKyAoY3VycmVudFRpbWUgLSB0aGlzLl9zeXN0ZW1UaW1lKTtcblxuICAgICAgdGhpcy5maW5hbGl6ZVN0cmVhbShlbmRUaW1lKTtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKCkge1xuICAgIGNvbnN0IGZyYW1lU2l6ZSA9IHRoaXMucGFyYW1zLmdldCgnZnJhbWVTaXplJyk7XG4gICAgY29uc3QgZnJhbWVUeXBlID0gdGhpcy5wYXJhbXMuZ2V0KCdmcmFtZVR5cGUnKTtcbiAgICBjb25zdCBzYW1wbGVSYXRlID0gdGhpcy5wYXJhbXMuZ2V0KCdzYW1wbGVSYXRlJyk7XG4gICAgY29uc3QgZnJhbWVSYXRlID0gdGhpcy5wYXJhbXMuZ2V0KCdmcmFtZVJhdGUnKTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMucGFyYW1zLmdldCgnZGVzY3JpcHRpb24nKTtcblxuICAgIC8vIGluaXQgb3BlcmF0b3IncyBzdHJlYW0gcGFyYW1zXG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplID0gZnJhbWVUeXBlID09PSAnc2NhbGFyJyA/IDEgOiBmcmFtZVNpemU7XG4gICAgdGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlID0gZnJhbWVUeXBlO1xuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG5cbiAgICBpZiAoZnJhbWVUeXBlID09PSAnc2lnbmFsJykge1xuICAgICAgaWYgKHNhbXBsZVJhdGUgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIFwic2FtcGxlUmF0ZVwiIGZvciBcInNpZ25hbFwiIHN0cmVhbScpO1xuXG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcbiAgICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lUmF0ZSA9IHNhbXBsZVJhdGUgLyBmcmFtZVNpemU7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVDb3VudCA9IGZyYW1lU2l6ZTtcblxuICAgIH0gZWxzZSBpZiAoZnJhbWVUeXBlID09PSAndmVjdG9yJyB8fCBmcmFtZVR5cGUgPT09ICdzY2FsYXInKSB7XG4gICAgICBpZiAoZnJhbWVSYXRlID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZGVmaW5lZCBcImZyYW1lUmF0ZVwiIGZvciBcIiR7ZnJhbWVUeXBlfVwiIHN0cmVhbWApO1xuXG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVJhdGUgPSBmcmFtZVJhdGU7XG4gICAgICB0aGlzLnN0cmVhbVBhcmFtcy5zb3VyY2VTYW1wbGVSYXRlID0gZnJhbWVSYXRlO1xuICAgICAgdGhpcy5zdHJlYW1QYXJhbXMuc291cmNlU2FtcGxlQ291bnQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc0Z1bmN0aW9uKGZyYW1lKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSB0aGlzLl9nZXRUaW1lKCk7XG4gICAgY29uc3QgaW5EYXRhID0gZnJhbWUuZGF0YS5sZW5ndGggPyBmcmFtZS5kYXRhIDogW2ZyYW1lLmRhdGFdO1xuICAgIGNvbnN0IG91dERhdGEgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgLy8gaWYgbm8gdGltZSBwcm92aWRlZCwgdXNlIHN5c3RlbSB0aW1lXG4gICAgbGV0IHRpbWUgPSBOdW1iZXIuaXNGaW5pdGUoZnJhbWUudGltZSkgPyBmcmFtZS50aW1lIDogY3VycmVudFRpbWU7XG5cbiAgICBpZiAodGhpcy5fc3RhcnRUaW1lID09PSBudWxsKVxuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZTtcblxuICAgIGlmICh0aGlzLl9hYnNvbHV0ZVRpbWUgPT09IGZhbHNlKVxuICAgICAgdGltZSA9IHRpbWUgLSB0aGlzLl9zdGFydFRpbWU7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZTsgaSA8IGw7IGkrKylcbiAgICAgIG91dERhdGFbaV0gPSBpbkRhdGFbaV07XG5cbiAgICB0aGlzLmZyYW1lLnRpbWUgPSB0aW1lO1xuICAgIHRoaXMuZnJhbWUubWV0YWRhdGEgPSBmcmFtZS5tZXRhZGF0YTtcbiAgICAvLyBzdG9yZSBjdXJyZW50IHRpbWUgdG8gY29tcHV0ZSBgZW5kVGltZWAgb24gc3RvcFxuICAgIHRoaXMuX3N5c3RlbVRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbHRlcm5hdGl2ZSBpbnRlcmZhY2UgdG8gcHJvcGFnYXRlIGEgZnJhbWUgaW4gdGhlIGdyYXBoLiBQYWNrIGB0aW1lYCxcbiAgICogYGRhdGFgIGFuZCBgbWV0YWRhdGFgIGluIGEgZnJhbWUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIEZyYW1lIHRpbWUuXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5fSBkYXRhIC0gRnJhbWUgZGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFkYXRhIC0gT3B0aW9ubmFsIGZyYW1lIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBldmVudEluLnByb2Nlc3MoMSwgWzAsIDEsIDJdKTtcbiAgICogLy8gaXMgZXF1aXZhbGVudCB0b1xuICAgKiBldmVudEluLnByb2Nlc3NGcmFtZSh7IHRpbWU6IDEsIGRhdGE6IFswLCAxLCAyXSB9KTtcbiAgICovXG4gIHByb2Nlc3ModGltZSwgZGF0YSwgbWV0YWRhdGEgPSBudWxsKSB7XG4gICAgdGhpcy5wcm9jZXNzRnJhbWUoeyB0aW1lLCBkYXRhLCBtZXRhZGF0YSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wYWdhdGUgYSBmcmFtZSBvYmplY3QgaW4gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZnJhbWUgLSBJbnB1dCBmcmFtZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lLnRpbWUgLSBGcmFtZSB0aW1lLlxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheX0gZnJhbWUuZGF0YSAtIEZyYW1lIGRhdGEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZnJhbWUubWV0YWRhdGE9dW5kZWZpbmVkXSAtIE9wdGlvbm5hbCBmcmFtZSBtZXRhZGF0YS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZXZlbnRJbi5wcm9jZXNzRnJhbWUoeyB0aW1lOiAxLCBkYXRhOiBbMCwgMSwgMl0gfSk7XG4gICAqL1xuICBwcm9jZXNzRnJhbWUoZnJhbWUpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkgcmV0dXJuO1xuXG4gICAgdGhpcy5wcmVwYXJlRnJhbWUoKTtcbiAgICB0aGlzLnByb2Nlc3NGdW5jdGlvbihmcmFtZSk7XG4gICAgdGhpcy5wcm9wYWdhdGVGcmFtZSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50SW47XG4iLCJpbXBvcnQgRXZlbnRJbiBmcm9tICcuL0V2ZW50SW4nO1xuaW1wb3J0IERhdGFSZWFkZXIgZnJvbSAnLi9EYXRhUmVhZGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBFdmVudEluLFxuICBEYXRhUmVhZGVyLFxufTtcbiIsIi8vIGV4cG9ydCB7IGRlZmF1bHQgYXMgaW5pdFdpbmRvdyB9IGZyb20gJy4vd2luZG93cyc7XG5cbmltcG9ydCBpbml0V2luZG93IGZyb20gJy4vd2luZG93cyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdFdpbmRvdyxcbn07XG4iLCJcbi8vIHNob3J0Y3V0cyAvIGhlbHBlcnNcbmNvbnN0IFBJICAgPSBNYXRoLlBJO1xuY29uc3QgY29zICA9IE1hdGguY29zO1xuY29uc3Qgc2luICA9IE1hdGguc2luO1xuY29uc3Qgc3FydCA9IE1hdGguc3FydDtcblxuLy8gd2luZG93IGNyZWF0aW9uIGZ1bmN0aW9uc1xuZnVuY3Rpb24gaW5pdEhhbm5XaW5kb3coYnVmZmVyLCBzaXplLCBub3JtQ29lZnMpIHtcbiAgbGV0IGxpblN1bSA9IDA7XG4gIGxldCBwb3dTdW0gPSAwO1xuICBjb25zdCBzdGVwID0gMiAqIFBJIC8gc2l6ZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGNvbnN0IHBoaSA9IGkgKiBzdGVwO1xuICAgIGNvbnN0IHZhbHVlID0gMC41IC0gMC41ICogY29zKHBoaSk7XG5cbiAgICBidWZmZXJbaV0gPSB2YWx1ZTtcblxuICAgIGxpblN1bSArPSB2YWx1ZTtcbiAgICBwb3dTdW0gKz0gdmFsdWUgKiB2YWx1ZTtcbiAgfVxuXG4gIG5vcm1Db2Vmcy5saW5lYXIgPSBzaXplIC8gbGluU3VtO1xuICBub3JtQ29lZnMucG93ZXIgPSBzcXJ0KHNpemUgLyBwb3dTdW0pO1xufVxuXG5mdW5jdGlvbiBpbml0SGFtbWluZ1dpbmRvdyhidWZmZXIsIHNpemUsIG5vcm1Db2Vmcykge1xuICBsZXQgbGluU3VtID0gMDtcbiAgbGV0IHBvd1N1bSA9IDA7XG4gIGNvbnN0IHN0ZXAgPSAyICogUEkgLyBzaXplO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgY29uc3QgcGhpID0gaSAqIHN0ZXA7XG4gICAgY29uc3QgdmFsdWUgPSAwLjU0IC0gMC40NiAqIGNvcyhwaGkpO1xuXG4gICAgYnVmZmVyW2ldID0gdmFsdWU7XG5cbiAgICBsaW5TdW0gKz0gdmFsdWU7XG4gICAgcG93U3VtICs9IHZhbHVlICogdmFsdWU7XG4gIH1cblxuICBub3JtQ29lZnMubGluZWFyID0gc2l6ZSAvIGxpblN1bTtcbiAgbm9ybUNvZWZzLnBvd2VyID0gc3FydChzaXplIC8gcG93U3VtKTtcbn1cblxuZnVuY3Rpb24gaW5pdEJsYWNrbWFuV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKSB7XG4gIGxldCBsaW5TdW0gPSAwO1xuICBsZXQgcG93U3VtID0gMDtcbiAgY29uc3Qgc3RlcCA9IDIgKiBQSSAvIHNpemU7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBjb25zdCBwaGkgPSBpICogc3RlcDtcbiAgICBjb25zdCB2YWx1ZSA9IDAuNDIgLSAwLjUgKiBjb3MocGhpKSArIDAuMDggKiBjb3MoMiAqIHBoaSk7XG5cbiAgICBidWZmZXJbaV0gPSB2YWx1ZTtcblxuICAgIGxpblN1bSArPSB2YWx1ZTtcbiAgICBwb3dTdW0gKz0gdmFsdWUgKiB2YWx1ZTtcbiAgfVxuXG4gIG5vcm1Db2Vmcy5saW5lYXIgPSBzaXplIC8gbGluU3VtO1xuICBub3JtQ29lZnMucG93ZXIgPSBzcXJ0KHNpemUgLyBwb3dTdW0pO1xufVxuXG5mdW5jdGlvbiBpbml0QmxhY2ttYW5IYXJyaXNXaW5kb3coYnVmZmVyLCBzaXplLCBub3JtQ29lZnMpIHtcbiAgbGV0IGxpblN1bSA9IDA7XG4gIGxldCBwb3dTdW0gPSAwO1xuICBjb25zdCBhMCA9IDAuMzU4NzU7XG4gIGNvbnN0IGExID0gMC40ODgyOTtcbiAgY29uc3QgYTIgPSAwLjE0MTI4O1xuICBjb25zdCBhMyA9IDAuMDExNjg7XG4gIGNvbnN0IHN0ZXAgPSAyICogUEkgLyBzaXplO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgY29uc3QgcGhpID0gaSAqIHN0ZXA7XG4gICAgY29uc3QgdmFsdWUgPSBhMCAtIGExICogY29zKHBoaSkgKyBhMiAqIGNvcygyICogcGhpKTsgLSBhMyAqIGNvcygzICogcGhpKTtcblxuICAgIGJ1ZmZlcltpXSA9IHZhbHVlO1xuXG4gICAgbGluU3VtICs9IHZhbHVlO1xuICAgIHBvd1N1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICB9XG5cbiAgbm9ybUNvZWZzLmxpbmVhciA9IHNpemUgLyBsaW5TdW07XG4gIG5vcm1Db2Vmcy5wb3dlciA9IHNxcnQoc2l6ZSAvIHBvd1N1bSk7XG59XG5cbmZ1bmN0aW9uIGluaXRTaW5lV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKSB7XG4gIGxldCBsaW5TdW0gPSAwO1xuICBsZXQgcG93U3VtID0gMDtcbiAgY29uc3Qgc3RlcCA9IFBJIC8gc2l6ZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGNvbnN0IHBoaSA9IGkgKiBzdGVwO1xuICAgIGNvbnN0IHZhbHVlID0gc2luKHBoaSk7XG5cbiAgICBidWZmZXJbaV0gPSB2YWx1ZTtcblxuICAgIGxpblN1bSArPSB2YWx1ZTtcbiAgICBwb3dTdW0gKz0gdmFsdWUgKiB2YWx1ZTtcbiAgfVxuXG4gIG5vcm1Db2Vmcy5saW5lYXIgPSBzaXplIC8gbGluU3VtO1xuICBub3JtQ29lZnMucG93ZXIgPSBzcXJ0KHNpemUgLyBwb3dTdW0pO1xufVxuXG5mdW5jdGlvbiBpbml0UmVjdGFuZ2xlV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuICAgIGJ1ZmZlcltpXSA9IDE7XG5cbiAgLy8gQHRvZG8gLSBjaGVjayBpZiB0aGVzZSBhcmUgcHJvcGVyIHZhbHVlc1xuICBub3JtQ29lZnMubGluZWFyID0gMTtcbiAgbm9ybUNvZWZzLnBvd2VyID0gMTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBidWZmZXIgd2l0aCB3aW5kb3cgc2lnbmFsLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLnV0aWxzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSB3aW5kb3cuXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYnVmZmVyIC0gQnVmZmVyIHRvIGJlIHBvcHVsYXRlZCB3aXRoIHRoZSB3aW5kb3cgc2lnbmFsLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgLSBTaXplIG9mIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gbm9ybUNvZWZzIC0gT2JqZWN0IHRvIGJlIHBvcHVsYXRlZCB3aXRoIHRoZSBub3JtYWlsemF0aW9uXG4gKiAgY29lZmZpY2llbnRzLlxuICovXG5mdW5jdGlvbiBpbml0V2luZG93KG5hbWUsIGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKSB7XG4gIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnaGFubic6XG4gICAgY2FzZSAnaGFubmluZyc6XG4gICAgICBpbml0SGFubldpbmRvdyhidWZmZXIsIHNpemUsIG5vcm1Db2Vmcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdoYW1taW5nJzpcbiAgICAgIGluaXRIYW1taW5nV2luZG93KGJ1ZmZlciwgc2l6ZSwgbm9ybUNvZWZzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JsYWNrbWFuJzpcbiAgICAgIGluaXRCbGFja21hbldpbmRvdyhidWZmZXIsIHNpemUsIG5vcm1Db2Vmcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdibGFja21hbmhhcnJpcyc6XG4gICAgICBpbml0QmxhY2ttYW5IYXJyaXNXaW5kb3coYnVmZmVyLCBzaXplLCBub3JtQ29lZnMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2luZSc6XG4gICAgICBpbml0U2luZVdpbmRvdyhidWZmZXIsIHNpemUsIG5vcm1Db2Vmcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0YW5nbGUnOlxuICAgICAgaW5pdFJlY3RhbmdsZVdpbmRvdyhidWZmZXIsIHNpemUsIG5vcm1Db2Vmcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBpbml0V2luZG93O1xuXG5cbiIsImltcG9ydCBwYXJhbWV0ZXJzIGZyb20gJ0BpcmNhbS9wYXJhbWV0ZXJzJztcblxubGV0IGlkID0gMDtcblxuLyoqXG4gKiBCYXNlIGBsZm9gIGNsYXNzIHRvIGJlIGV4dGVuZGVkIGluIG9yZGVyIHRvIGNyZWF0ZSBuZXcgbm9kZXMuXG4gKlxuICogTm9kZXMgYXJlIGRpdmlkZWQgaW4gMyBjYXRlZ29yaWVzOlxuICogLSAqKmBzb3VyY2VgKiogYXJlIHJlc3BvbnNpYmxlIGZvciBhY3F1ZXJpbmcgYSBzaWduYWwgYW5kIGl0cyBwcm9wZXJ0aWVzXG4gKiAgIChmcmFtZVJhdGUsIGZyYW1lU2l6ZSwgZXRjLilcbiAqIC0gKipgc2lua2AqKiBhcmUgZW5kcG9pbnRzIG9mIHRoZSBncmFwaCwgc3VjaCBub2RlcyBjYW4gYmUgcmVjb3JkZXJzLFxuICogICB2aXN1YWxpemVycywgZXRjLlxuICogLSAqKmBvcGVyYXRvcmAqKiBhcmUgdXNlZCB0byBtYWtlIGNvbXB1dGF0aW9uIG9uIHRoZSBpbnB1dCBzaWduYWwgYW5kXG4gKiAgIGZvcndhcmQgdGhlIHJlc3VsdHMgYmVsb3cgaW4gdGhlIGdyYXBoLlxuICpcbiAqIEluIG1vc3QgY2FzZXMgdGhlIG1ldGhvZHMgdG8gb3ZlcnJpZGUgLyBleHRlbmQgYXJlOlxuICogLSB0aGUgKipgY29uc3RydWN0b3JgKiogdG8gZGVmaW5lIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBuZXcgbGZvIG5vZGUuXG4gKiAtIHRoZSAqKmBwcm9jZXNzU3RyZWFtUGFyYW1zYCoqIG1ldGhvZCB0byBkZWZpbmUgaG93IHRoZSBub2RlIG1vZGlmeSB0aGVcbiAqICAgc3RyZWFtIGF0dHJpYnV0ZXMgKGUuZy4gYnkgY2hhbmdpbmcgdGhlIGZyYW1lIHNpemUpXG4gKiAtIHRoZSAqKmBwcm9jZXNze0ZyYW1lVHlwZX1gKiogbWV0aG9kIHRvIGRlZmluZSB0aGUgb3BlcmF0aW9ucyB0aGF0IHRoZVxuICogICBub2RlIGFwcGx5IG9uIHRoZSBzdHJlYW0uIFRoZSB0eXBlIG9mIGlucHV0IGEgbm9kZSBjYW4gaGFuZGxlIGlzIGRlZmluZWRcbiAqICAgYnkgaXRzIGltcGxlbWVudGVkIGludGVyZmFjZSwgaWYgaXQgaW1wbGVtZW50cyBgcHJvY2Vzc1NpZ25hbGAsIGEgc3RyZWFtXG4gKiAgIG9mIHR5cGUgYHNpZ25hbGAgY2FuIGJlIHByb2Nlc3NlZCwgYHByb2Nlc3NWZWN0b3JgIHRvIGhhbmRsZVxuICogICBhbiBpbnB1dCBvZiB0eXBlIGB2ZWN0b3JgLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwid2FybmluZ1wiPl9UaGlzIGNsYXNzIHNob3VsZCBiZSBjb25zaWRlcmVkIGFic3RyYWN0IGFuZCBvbmx5XG4gKiBiZSB1c2VkIGFzIGEgYmFzZSBjbGFzcyB0byBleHRlbmQuXzwvc3Bhbj5cbiAqXG4gKiAjIyMjIG92ZXJ2aWV3IG9mIHRoZSBpbnRlcmZhY2VcbiAqXG4gKiAqKmluaXRNb2R1bGUqKlxuICpcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbW9kdWxlIGlzIGluaXRpYWxpemVkLiBJc1xuICogZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yIG1vZHVsZXMgdGhhdCByZWx5IG9uIGFzeW5jaHJvbm91cyB1bmRlcmx5aW5nIEFQSXMuXG4gKlxuICogKipwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMpKipcbiAqXG4gKiBgYmFzZWAgY2xhc3MgKGRlZmF1bHQgaW1wbGVtZW50YXRpb24pXG4gKiAtIGNhbGwgYHByZXBhcmVTdHJlYW1QYXJhbXNgXG4gKiAtIGNhbGwgYHByb3BhZ2F0ZVN0cmVhbVBhcmFtc2BcbiAqXG4gKiBgY2hpbGRgIGNsYXNzXG4gKiAtIG92ZXJyaWRlIHNvbWUgb2YgdGhlIGluaGVyaXRlZCBgc3RyZWFtUGFyYW1zYFxuICogLSBjcmVhdGVzIHRoZSBhbnkgcmVsYXRlZCBsb2dpYyBidWZmZXJzXG4gKiAtIGNhbGwgYHByb3BhZ2F0ZVN0cmVhbVBhcmFtc2BcbiAqXG4gKiBfc2hvdWxkIG5vdCBjYWxsIGBzdXBlci5wcm9jZXNzU3RyZWFtUGFyYW1zYF9cbiAqXG4gKiAqKnByZXBhcmVTdHJlYW1QYXJhbXMoKSoqXG4gKlxuICogLSBhc3NpZ24gcHJldlN0cmVhbVBhcmFtcyB0byB0aGlzLnN0cmVhbVBhcmFtc1xuICogLSBjaGVjayBpZiB0aGUgY2xhc3MgaW1wbGVtZW50cyB0aGUgY29ycmVjdCBgcHJvY2Vzc0lucHV0YCBtZXRob2RcbiAqXG4gKiBfc2hvdWxkbid0IGJlIGV4dGVuZGVkLCBvbmx5IGNvbnN1bWVkIGluIGBwcm9jZXNzU3RyZWFtUGFyYW1zYF9cbiAqXG4gKiAqKnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpKipcbiAqXG4gKiAtIGNyZWF0ZXMgdGhlIGBmcmFtZURhdGFgIGJ1ZmZlclxuICogLSBwcm9wYWdhdGUgYHN0cmVhbVBhcmFtc2AgdG8gY2hpbGRyZW5cbiAqXG4gKiBfc2hvdWxkbid0IGJlIGV4dGVuZGVkLCBvbmx5IGNvbnN1bWVkIGluIGBwcm9jZXNzU3RyZWFtUGFyYW1zYF9cbiAqXG4gKiAqKnByb2Nlc3NGcmFtZSgpKipcbiAqXG4gKiBgYmFzZWAgY2xhc3MgKGRlZmF1bHQgaW1wbGVtZW50YXRpb24pXG4gKiAtIGNhbGwgYHByZXBhcmVGcmFtZWBcbiAqIC0gYXNzaWduIGZyYW1lVGltZSBhbmQgZnJhbWVNZXRhZGF0YSB0byBpZGVudGl0eVxuICogLSBjYWxsIHRoZSBwcm9wZXIgZnVuY3Rpb24gYWNjb3JkaW5nIHRvIGlucHV0VHlwZVxuICogLSBjYWxsIGBwcm9wYWdhdGVGcmFtZWBcbiAqXG4gKiBgY2hpbGRgIGNsYXNzXG4gKiAtIGNhbGwgYHByZXBhcmVGcmFtZWBcbiAqIC0gZG8gd2hhdGV2ZXIgeW91IHdhbnQgd2l0aCBpbmNvbW1pbmcgZnJhbWVcbiAqIC0gY2FsbCBgcHJvcGFnYXRlRnJhbWVgXG4gKlxuICogX3Nob3VsZCBub3QgY2FsbCBgc3VwZXIucHJvY2Vzc0ZyYW1lYF9cbiAqXG4gKiAqKnByZXBhcmVGcmFtZSgpKipcbiAqXG4gKiAtIGlmIGByZWluaXRgIGFuZCB0cmlnZ2VyIGBwcm9jZXNzU3RyZWFtUGFyYW1zYCBpZiBuZWVkZWRcbiAqXG4gKiBfc2hvdWxkbid0IGJlIGV4dGVuZGVkLCBvbmx5IGNvbnN1bWVkIGluIGBwcm9jZXNzRnJhbWVgX1xuICpcbiAqICoqcHJvcGFnYXRlRnJhbWUoKSoqXG4gKlxuICogLSBwcm9wYWdhdGUgZnJhbWUgdG8gY2hpbGRyZW5cbiAqXG4gKiBfc2hvdWxkbid0IGJlIGV4dGVuZGVkLCBvbmx5IGNvbnN1bWVkIGluIGBwcm9jZXNzRnJhbWVgX1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZVxuICovXG5jbGFzcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3IoZGVmaW5pdGlvbnMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5jaWQgPSBpZCsrO1xuXG4gICAgLyoqXG4gICAgICogUGFyYW1ldGVyIGJhZyBjb250YWluaW5nIHBhcmFtZXRlciBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBuYW1lIHBhcmFtc1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5CYXNlTGZvXG4gICAgICovXG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbWV0ZXJzKGRlZmluaXRpb25zLCBvcHRpb25zKTtcbiAgICAvLyBsaXN0ZW4gZm9yIHBhcmFtIHVwZGF0ZXNcbiAgICB0aGlzLnBhcmFtcy5hZGRMaXN0ZW5lcih0aGlzLm9uUGFyYW1VcGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvbiBvZiB0aGUgc3RyZWFtIG91dHB1dCBvZiB0aGUgbm9kZS5cbiAgICAgKiBTZXQgdG8gYG51bGxgIHdoZW4gdGhlIG5vZGUgaXMgZGVzdHJveWVkLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJhbWVTaXplIC0gRnJhbWUgc2l6ZSBhdCB0aGUgb3V0cHV0IG9mIHRoZSBub2RlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBmcmFtZVJhdGUgLSBGcmFtZSByYXRlIGF0IHRoZSBvdXRwdXQgb2YgdGhlIG5vZGUuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGZyYW1lVHlwZSAtIEZyYW1lIHR5cGUgYXQgdGhlIG91dHB1dCBvZiB0aGUgbm9kZSxcbiAgICAgKiAgcG9zc2libGUgdmFsdWVzIGFyZSBgc2lnbmFsYCwgYHZlY3RvcmAgb3IgYHNjYWxhcmAuXG4gICAgICogQHByb3BlcnR5IHtBcnJheXxTdHJpbmd9IGRlc2NyaXB0aW9uIC0gSWYgdHlwZSBpcyBgdmVjdG9yYCwgZGVzY3JpYmVcbiAgICAgKiAgdGhlIGRpbWVuc2lvbihzKSBvZiBvdXRwdXQgc3RyZWFtLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzb3VyY2VTYW1wbGVSYXRlIC0gU2FtcGxlIHJhdGUgb2YgdGhlIHNvdXJjZSBvZiB0aGVcbiAgICAgKiAgZ3JhcGguIF9UaGUgdmFsdWUgc2hvdWxkIGJlIGRlZmluZWQgYnkgc291cmNlcyBhbmQgbmV2ZXIgbW9kaWZpZWRfLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzb3VyY2VTYW1wbGVDb3VudCAtIE51bWJlciBvZiBjb25zZWN1dGl2ZSBkaXNjcmV0ZVxuICAgICAqICB0aW1lIHZhbHVlcyBjb250YWluZWQgaW4gdGhlIGRhdGEgZnJhbWUgb3V0cHV0IGJ5IHRoZSBzb3VyY2UuXG4gICAgICogIF9UaGUgdmFsdWUgc2hvdWxkIGJlIGRlZmluZWQgYnkgc291cmNlcyBhbmQgbmV2ZXIgbW9kaWZpZWRfLlxuICAgICAqXG4gICAgICogQG5hbWUgc3RyZWFtUGFyYW1zXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkJhc2VMZm9cbiAgICAgKi9cbiAgICB0aGlzLnN0cmVhbVBhcmFtcyA9IHtcbiAgICAgIGZyYW1lVHlwZTogbnVsbCxcbiAgICAgIGZyYW1lU2l6ZTogMSxcbiAgICAgIGZyYW1lUmF0ZTogMCxcbiAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgc291cmNlU2FtcGxlUmF0ZTogMCxcbiAgICAgIHNvdXJjZVNhbXBsZUNvdW50OiBudWxsLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGZyYW1lLiBUaGlzIG9iamVjdCBhbmQgaXRzIGRhdGEgYXJlIHVwZGF0ZWQgYXQgZWFjaCBpbmNvbW1pbmdcbiAgICAgKiBmcmFtZSB3aXRob3V0IHJlYWxsb2NhdGluZyBtZW1vcnkuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBuYW1lIGZyYW1lXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbWUgLSBUaW1lIG9mIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBkYXRhIC0gRGF0YSBvZiB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gbWV0YWRhdGEgLSBNZXRhZGF0YSBhc3NvY2l0ZWQgdG8gdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkJhc2VMZm9cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lID0ge1xuICAgICAgdGltZTogMCxcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICBtZXRhZGF0YToge30sXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2Ygbm9kZXMgY29ubmVjdGVkIHRvIHRoZSBvdXB1dCBvZiB0aGUgbm9kZSAobG93ZXIgaW4gdGhlIGdyYXBoKS5cbiAgICAgKiBBdCBlYWNoIGZyYW1lLCB0aGUgbm9kZSBmb3J3YXJkIGl0cyBgZnJhbWVgIHRvIHRvIGFsbCBpdHMgYG5leHRNb2R1bGVzYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxCYXNlTGZvPn1cbiAgICAgKiBAbmFtZSBuZXh0TW9kdWxlc1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5CYXNlTGZvXG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNjb25uZWN0fVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jZGlzY29ubmVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHRNb2R1bGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZSBmcm9tIHdoaWNoIHRoZSBub2RlIHJlY2VpdmUgdGhlIGZyYW1lcyAodXBwZXIgaW4gdGhlIGdyYXBoKS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCYXNlTGZvfVxuICAgICAqIEBuYW1lIHByZXZNb2R1bGVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQmFzZUxmb1xuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jY29ubmVjdH1cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI2Rpc2Nvbm5lY3R9XG4gICAgICovXG4gICAgdGhpcy5wcmV2TW9kdWxlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIElzIHNldCB0byB0cnVlIHdoZW4gYSBzdGF0aWMgcGFyYW1ldGVyIGlzIHVwZGF0ZWQuIE9uIHRoZSBuZXh0IGlucHV0XG4gICAgICogZnJhbWUgYWxsIHRoZSBzdWJncmFwaCBzdHJlYW1QYXJhbXMgc3RhcnRpbmcgZnJvbSB0aGlzIG5vZGUgd2lsbCBiZVxuICAgICAqIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAbmFtZSBfcmVpbml0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkJhc2VMZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3JlaW5pdCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGRlc2NyaWJpbmcgZWFjaCBhdmFpbGFibGUgcGFyYW1ldGVyIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRQYXJhbXNEZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMuZ2V0RGVmaW5pdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBhbGwgcGFyYW1ldGVycyB0byB0aGVpciBpbml0aWFsIHZhbHVlIChhcyBkZWZpbmVkIG9uIGluc3RhbnRpY2F0aW9uKVxuICAgKlxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3N0cmVhbVBhcmFtc31cbiAgICovXG4gIHJlc2V0UGFyYW1zKCkge1xuICAgIHRoaXMucGFyYW1zLnJlc2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gY2FsbGVkIHdoZW4gYSBwYXJhbSBpcyB1cGRhdGVkLiBCeSBkZWZhdWx0IHNldCB0aGUgYF9yZWluaXRgXG4gICAqIGZsYWcgdG8gYHRydWVgIGlmIHRoZSBwYXJhbSBpcyBgc3RhdGljYCBvbmUuIFRoaXMgbWV0aG9kIHNob3VsZCBiZVxuICAgKiBleHRlbmRlZCB0byBoYW5kbGUgcGFydGljdWxhciBsb2dpYyBib3VuZCB0byBhIHNwZWNpZmljIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFzIC0gTWV0YWRhdGEgYXNzb2NpYXRlZCB0byB0aGUgcGFyYW1ldGVyLlxuICAgKi9cbiAgb25QYXJhbVVwZGF0ZShuYW1lLCB2YWx1ZSwgbWV0YXMgPSB7fSkge1xuICAgIGlmIChtZXRhcy5raW5kID09PSAnc3RhdGljJylcbiAgICAgIHRoaXMuX3JlaW5pdCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdCB0aGUgY3VycmVudCBub2RlIChgcHJldk1vZHVsZWApIHRvIGFub3RoZXIgbm9kZSAoYG5leHRPcGApLlxuICAgKiBBIGdpdmVuIG5vZGUgY2FuIGJlIGNvbm5lY3RlZCB0byBzZXZlcmFsIG9wZXJhdG9ycyBhbmQgcHJvcGFnYXRlIGZyYW1lc1xuICAgKiB0byBlYWNoIG9mIHRoZW0uXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZUxmb30gbmV4dCAtIE5leHQgb3BlcmF0b3IgaW4gdGhlIGdyYXBoLlxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Byb2Nlc3NGcmFtZX1cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNkaXNjb25uZWN0fVxuICAgKi9cbiAgY29ubmVjdChuZXh0KSB7XG4gICAgaWYgKHRoaXMuc3RyZWFtUGFyYW1zID09PSBudWxsIHx8IG5leHQuc3RyZWFtUGFyYW1zID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbm5lY3Rpb246IGNhbm5vdCBjb25uZWN0IGEgZGVhZCBub2RlJyk7XG5cbiAgICBpZiAodGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVUeXBlICE9PSBudWxsKSB7IC8vIGdyYXBoIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZFxuICAgICAgLy8gbmV4dC5wcm9jZXNzU3RyZWFtUGFyYW1zKHRoaXMuc3RyZWFtUGFyYW1zKTtcbiAgICAgIG5leHQuaW5pdE1vZHVsZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBuZXh0LnByb2Nlc3NTdHJlYW1QYXJhbXModGhpcy5zdHJlYW1QYXJhbXMpO1xuICAgICAgICAvLyB3ZSBjYW4gZm9yd2FyZCBmcmFtZSBmcm9tIG5vd1xuICAgICAgICB0aGlzLm5leHRNb2R1bGVzLnB1c2gobmV4dCk7XG4gICAgICAgIG5leHQucHJldk1vZHVsZSA9IHRoaXM7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZXh0TW9kdWxlcy5wdXNoKG5leHQpO1xuICAgICAgbmV4dC5wcmV2TW9kdWxlID0gdGhpcztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBvcGVyYXRvciBmcm9tIGl0cyBwcmV2aW91cyBvcGVyYXRvcnMnIGBuZXh0TW9kdWxlc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZUxmb30gW25leHQ9bnVsbF0gLSBUaGUgb3BlcmF0b3IgdG8gZGlzY29ubmVjdCBmcm9tIHRoZSBjdXJyZW50XG4gICAqICBvcGVyYXRvci4gSWYgYG51bGxgIGRpc2Nvbm5lY3QgYWxsIHRoZSBuZXh0IG9wZXJhdG9ycy5cbiAgICovXG4gIGRpc2Nvbm5lY3QobmV4dCA9IG51bGwpIHtcbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0TW9kdWxlcy5mb3JFYWNoKChuZXh0KSA9PiB0aGlzLmRpc2Nvbm5lY3QobmV4dCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMubmV4dE1vZHVsZXMuaW5kZXhPZih0aGlzKTtcbiAgICAgIHRoaXMubmV4dE1vZHVsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIG5leHQucHJldk1vZHVsZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgYWxsIHRoZSBub2RlcyBpbiB0aGUgc3ViLWdyYXBoIHN0YXJ0aW5nIGZyb20gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICogV2hlbiBkZXRyb3llZCwgdGhlIGBzdHJlYW1QYXJhbXNgIG9mIHRoZSBub2RlIGFyZSBzZXQgdG8gYG51bGxgLCB0aGVcbiAgICogb3BlcmF0b3IgaXMgdGhlbiBjb25zaWRlcmVkIGFzIGBkZWFkYCBhbmQgY2Fubm90IGJlIHJlY29ubmVjdGVkLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI2Nvbm5lY3R9XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIC8vIGRlc3Ryb3kgYWxsIGNoaWRyZW5cbiAgICBsZXQgaW5kZXggPSB0aGlzLm5leHRNb2R1bGVzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tKVxuICAgICAgdGhpcy5uZXh0TW9kdWxlc1tpbmRleF0uZGVzdHJveSgpO1xuXG4gICAgLy8gZGlzY29ubmVjdCBpdHNlbGYgZnJvbSB0aGUgcHJldmlvdXMgb3BlcmF0b3JcbiAgICBpZiAodGhpcy5wcmV2TW9kdWxlKVxuICAgICAgdGhpcy5wcmV2TW9kdWxlLmRpc2Nvbm5lY3QodGhpcyk7XG5cbiAgICAvLyBtYXJrIHRoZSBvYmplY3QgYXMgZGVhZFxuICAgIHRoaXMuc3RyZWFtUGFyYW1zID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlIHdoZW4gdGhlIG1vZHVsZSBpcyByZWFkeSB0byBiZSBjb25zdW1lZC5cbiAgICogU29tZSBtb2R1bGVzIHJlbGllcyBvbiBhc3luY2hyb25vdXMgQVBJcyBhdCBpbml0aWFsaXphdGlvbiBhbmQgdGh1cyBjb3VsZFxuICAgKiBiZSBub3QgcmVhZHkgdG8gYmUgY29uc3VtZWQgd2hlbiB0aGUgZ3JhcGggc3RhcnRzLlxuICAgKiBBIG1vZHVsZSBzaG91bGQgYmUgY29uc2lkZXIgYXMgaW5pdGlhbGl6ZWQgd2hlbiBhbGwgbmV4dCBtb2R1bGVzIChjaGlsZHJlbilcbiAgICogYXJlIHRoZW1zZWx2ZXMgaW5pdGlhbGl6ZWQuIFRoZSBldmVudCBidWJibGVzIHVwIGZyb20gc2lua3MgdG8gc291cmNlcy5cbiAgICogV2hlbiBhbGwgaXRzIG5leHQgb3BlcmF0b3JzIGFyZSByZWFkeSwgYSBzb3VyY2UgY2FuIGNvbnNpZGVyIHRoZSB3aG9sZSBncmFwaFxuICAgKiBhcyByZWFkeSBhbmQgdGhlbiBzdGFydCB0byBwcm9kdWNlIGZyYW1lcy5cbiAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmVzb2x2ZXMgd2hlbiBhbGwgbmV4dCBvcGVyYXRvcnMgYXJlIHJlc29sdmVkXG4gICAqIHRoZW1zZWx2ZXMuXG4gICAqIEFuIG9wZXJhdG9yIHJlbHlpbmcgb24gZXh0ZXJuYWwgYXN5bmMgQVBJIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG9cbiAgICogcmVzb2x2ZSBvbmx5IHdoZW4gaXRzIGRlcGVuZGVjeSBpcyByZWFkeS5cbiAgICpcbiAgICogQHJldHVybiBQcm9taXNlXG4gICAqIEB0b2RvIC0gSGFuZGxlIGR5bmFtaWMgY29ubmVjdGlvbnNcbiAgICovXG4gIGluaXRNb2R1bGUoKSB7XG4gICAgY29uc3QgbmV4dFByb21pc2VzID0gdGhpcy5uZXh0TW9kdWxlcy5tYXAoKG1vZHVsZSkgPT4ge1xuICAgICAgcmV0dXJuIG1vZHVsZS5pbml0TW9kdWxlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwobmV4dFByb21pc2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gaW5pdGlhbGl6ZSB0aGUgc3RyZWFtIGluIHN0YW5kYWxvbmUgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzdHJlYW1QYXJhbXM9e31dIC0gUGFyYW1ldGVycyBvZiB0aGUgc3RyZWFtLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Byb2Nlc3NTdHJlYW1QYXJhbXN9XG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcmVzZXRTdHJlYW19XG4gICAqL1xuICBpbml0U3RyZWFtKHN0cmVhbVBhcmFtcyA9IHt9KSB7XG4gICAgdGhpcy5wcm9jZXNzU3RyZWFtUGFyYW1zKHN0cmVhbVBhcmFtcyk7XG4gICAgdGhpcy5yZXNldFN0cmVhbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBgZnJhbWUuZGF0YWAgYnVmZmVyIGJ5IHNldHRpbmcgYWxsIGl0cyB2YWx1ZXMgdG8gMC5cbiAgICogQSBzb3VyY2Ugb3BlcmF0b3Igc2hvdWxkIGNhbGwgYHByb2Nlc3NTdHJlYW1QYXJhbXNgIGFuZCBgcmVzZXRTdHJlYW1gIHdoZW5cbiAgICogc3RhcnRlZCwgZWFjaCBvZiB0aGVzZSBtZXRob2QgcHJvcGFnYXRlIHRocm91Z2ggdGhlIGdyYXBoIGF1dG9tYXRpY2FseS5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzU3RyZWFtUGFyYW1zfVxuICAgKi9cbiAgcmVzZXRTdHJlYW0oKSB7XG4gICAgLy8gYnV0dG9tIHVwXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLm5leHRNb2R1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMubmV4dE1vZHVsZXNbaV0ucmVzZXRTdHJlYW0oKTtcblxuICAgIC8vIG5vIGJ1ZmZlciBmb3IgYHNjYWxhcmAgdHlwZSBvciBzaW5rIG5vZGVcbiAgICAvLyBAbm90ZSAtIHRoaXMgc2hvdWxkIGJlIHJldmlld2VkXG4gICAgaWYgKHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lVHlwZSAhPT0gJ3NjYWxhcicgJiYgdGhpcy5mcmFtZS5kYXRhICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBmcmFtZVNpemUgPSB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemU7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5mcmFtZS5kYXRhO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lU2l6ZTsgaSsrKVxuICAgICAgICBkYXRhW2ldID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluYWxpemUgdGhlIHN0cmVhbS4gQSBzb3VyY2Ugbm9kZSBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZCB3aGVuIHN0b3BwZWQsXG4gICAqIGBmaW5hbGl6ZVN0cmVhbWAgaXMgYXV0b21hdGljYWxseSBwcm9wYWdhdGVkIHRocm91Z2h0IHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFRpbWUgLSBMb2dpY2FsIHRpbWUgYXQgd2hpY2ggdGhlIGdyYXBoIGlzIHN0b3BwZWQuXG4gICAqL1xuICBmaW5hbGl6ZVN0cmVhbShlbmRUaW1lKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLm5leHRNb2R1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMubmV4dE1vZHVsZXNbaV0uZmluYWxpemVTdHJlYW0oZW5kVGltZSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBvciB1cGRhdGUgdGhlIG9wZXJhdG9yJ3MgYHN0cmVhbVBhcmFtc2AgYWNjb3JkaW5nIHRvIHRoZVxuICAgKiBwcmV2aW91cyBvcGVyYXRvcnMgYHN0cmVhbVBhcmFtc2AgdmFsdWVzLlxuICAgKlxuICAgKiBXaGVuIGltcGxlbWVudGluZyBhIG5ldyBvcGVyYXRvciB0aGlzIG1ldGhvZCBzaG91bGQ6XG4gICAqIDEuIGNhbGwgYHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtc2Agd2l0aCB0aGUgZ2l2ZW4gYHByZXZTdHJlYW1QYXJhbXNgXG4gICAqIDIuIG9wdGlvbm5hbGx5IGNoYW5nZSB2YWx1ZXMgdG8gYHRoaXMuc3RyZWFtUGFyYW1zYCBhY2NvcmRpbmcgdG8gdGhlXG4gICAqICAgIGxvZ2ljIHBlcmZvcm1lZCBieSB0aGUgb3BlcmF0b3IuXG4gICAqIDMuIG9wdGlvbm5hbGx5IGFsbG9jYXRlIG1lbW9yeSBmb3IgcmluZyBidWZmZXJzLCBldGMuXG4gICAqIDQuIGNhbGwgYHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zYCB0byB0cmlnZ2VyIHRoZSBtZXRob2Qgb24gdGhlIG5leHRcbiAgICogICAgb3BlcmF0b3JzIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdHJlYW1QYXJhbXMgLSBgc3RyZWFtUGFyYW1zYCBvZiB0aGUgcHJldmlvdXMgb3BlcmF0b3IuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcHJlcGFyZVN0cmVhbVBhcmFtc31cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9wYWdhdGVTdHJlYW1QYXJhbXN9XG4gICAqL1xuICBwcm9jZXNzU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMgPSB7fSkge1xuICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcbiAgICB0aGlzLnByb3BhZ2F0ZVN0cmVhbVBhcmFtcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbW1vbiBsb2dpYyB0byBkbyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBgcHJvY2Vzc1N0cmVhbVBhcmFtYCwgbXVzdCBiZVxuICAgKiBjYWxsZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBhbnkgYHByb2Nlc3NTdHJlYW1QYXJhbWAgaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoZSBtZXRob2QgbWFpbmx5IGNoZWNrIGlmIHRoZSBjdXJyZW50IG5vZGUgaW1wbGVtZW50IHRoZSBpbnRlcmZhY2UgdG9cbiAgICogaGFuZGxlIHRoZSB0eXBlIG9mIGZyYW1lIHByb3BhZ2F0ZWQgYnkgaXQncyBwYXJlbnQ6XG4gICAqIC0gdG8gaGFuZGxlIGEgYHZlY3RvcmAgZnJhbWUgdHlwZSwgdGhlIGNsYXNzIG11c3QgaW1wbGVtZW50IGBwcm9jZXNzVmVjdG9yYFxuICAgKiAtIHRvIGhhbmRsZSBhIGBzaWduYWxgIGZyYW1lIHR5cGUsIHRoZSBjbGFzcyBtdXN0IGltcGxlbWVudCBgcHJvY2Vzc1NpZ25hbGBcbiAgICogLSBpbiBjYXNlIG9mIGEgJ3NjYWxhcicgZnJhbWUgdHlwZSwgdGhlIGNsYXNzIGNhbiBpbXBsZW1lbnQgYW55IG9mIHRoZVxuICAgKiBmb2xsb3dpbmcgYnkgb3JkZXIgb2YgcHJlZmVyZW5jZTogYHByb2Nlc3NTY2FsYXJgLCBgcHJvY2Vzc1ZlY3RvcmAsXG4gICAqIGBwcm9jZXNzU2lnbmFsYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdHJlYW1QYXJhbXMgLSBgc3RyZWFtUGFyYW1zYCBvZiB0aGUgcHJldmlvdXMgb3BlcmF0b3IuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcHJvY2Vzc1N0cmVhbVBhcmFtc31cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9wYWdhdGVTdHJlYW1QYXJhbXN9XG4gICAqL1xuICBwcmVwYXJlU3RyZWFtUGFyYW1zKHByZXZTdHJlYW1QYXJhbXMgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdHJlYW1QYXJhbXMsIHByZXZTdHJlYW1QYXJhbXMpO1xuICAgIGNvbnN0IHByZXZGcmFtZVR5cGUgPSBwcmV2U3RyZWFtUGFyYW1zLmZyYW1lVHlwZTtcblxuICAgIHN3aXRjaCAocHJldkZyYW1lVHlwZSkge1xuICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc1NjYWxhcilcbiAgICAgICAgICB0aGlzLnByb2Nlc3NGdW5jdGlvbiA9IHRoaXMucHJvY2Vzc1NjYWxhcjtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9jZXNzVmVjdG9yKVxuICAgICAgICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uID0gdGhpcy5wcm9jZXNzVmVjdG9yO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnByb2Nlc3NTaWduYWwpXG4gICAgICAgICAgdGhpcy5wcm9jZXNzRnVuY3Rpb24gPSB0aGlzLnByb2Nlc3NTaWduYWw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAtIG5vIFwicHJvY2Vzc1wiIGZ1bmN0aW9uIGZvdW5kYCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndmVjdG9yJzpcbiAgICAgICAgaWYgKCEoJ3Byb2Nlc3NWZWN0b3InIGluIHRoaXMpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IC0gXCJwcm9jZXNzVmVjdG9yXCIgaXMgbm90IGRlZmluZWRgKTtcblxuICAgICAgICB0aGlzLnByb2Nlc3NGdW5jdGlvbiA9IHRoaXMucHJvY2Vzc1ZlY3RvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzaWduYWwnOlxuICAgICAgICBpZiAoISgncHJvY2Vzc1NpZ25hbCcgaW4gdGhpcykpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gLSBcInByb2Nlc3NTaWduYWxcIiBpcyBub3QgZGVmaW5lZGApO1xuXG4gICAgICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uID0gdGhpcy5wcm9jZXNzU2lnbmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGRlZmF1bHRzIHRvIHByb2Nlc3NGdW5jdGlvblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgdGhpcy5mcmFtZS5kYXRhYCBidWZmZXIgYW5kIGZvcndhcmQgdGhlIG9wZXJhdG9yJ3MgYHN0cmVhbVBhcmFtYFxuICAgKiB0byBhbGwgaXRzIG5leHQgb3BlcmF0b3JzLCBtdXN0IGJlIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGFueVxuICAgKiBgcHJvY2Vzc1N0cmVhbVBhcmFtc2AgaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcHJvY2Vzc1N0cmVhbVBhcmFtc31cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcmVwYXJlU3RyZWFtUGFyYW1zfVxuICAgKi9cbiAgcHJvcGFnYXRlU3RyZWFtUGFyYW1zKCkge1xuICAgIHRoaXMuZnJhbWUuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5zdHJlYW1QYXJhbXMuZnJhbWVTaXplKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5uZXh0TW9kdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLm5leHRNb2R1bGVzW2ldLnByb2Nlc3NTdHJlYW1QYXJhbXModGhpcy5zdHJlYW1QYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSB0aGUgcGFydGljdWxhciBsb2dpYyB0aGUgb3BlcmF0b3IgYXBwbGllcyB0byB0aGUgc3RyZWFtLlxuICAgKiBBY2NvcmRpbmcgdG8gdGhlIGZyYW1lIHR5cGUgb2YgdGhlIHByZXZpb3VzIG5vZGUsIHRoZSBtZXRob2QgY2FsbHMgb25lXG4gICAqIG9mIHRoZSBmb2xsb3dpbmcgbWV0aG9kIGBwcm9jZXNzVmVjdG9yYCwgYHByb2Nlc3NTaWduYWxgIG9yIGBwcm9jZXNzU2NhbGFyYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZnJhbWUgLSBGcmFtZSAodGltZSwgZGF0YSwgYW5kIG1ldGFkYXRhKSBhcyBnaXZlbiBieSB0aGVcbiAgICogIHByZXZpb3VzIG9wZXJhdG9yLiBUaGUgaW5jb21taW5nIGZyYW1lIHNob3VsZCBuZXZlciBiZSBtb2RpZmllZCBieVxuICAgKiAgdGhlIG9wZXJhdG9yLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3ByZXBhcmVGcmFtZX1cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9wYWdhdGVGcmFtZX1cbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzU3RyZWFtUGFyYW1zfVxuICAgKi9cbiAgcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAgdGhpcy5wcmVwYXJlRnJhbWUoKTtcblxuICAgIC8vIGZyYW1lVGltZSBhbmQgZnJhbWVNZXRhZGF0YSBkZWZhdWx0cyB0byBpZGVudGl0eVxuICAgIHRoaXMuZnJhbWUudGltZSA9IGZyYW1lLnRpbWU7XG4gICAgdGhpcy5mcmFtZS5tZXRhZGF0YSA9IGZyYW1lLm1ldGFkYXRhO1xuXG4gICAgdGhpcy5wcm9jZXNzRnVuY3Rpb24oZnJhbWUpO1xuICAgIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2ludGVyIHRvIHRoZSBtZXRob2QgY2FsbGVkIGluIGBwcm9jZXNzRnJhbWVgIGFjY29yZGluZyB0byB0aGVcbiAgICogZnJhbWUgdHlwZSBvZiB0aGUgcHJldmlvdXMgb3BlcmF0b3IuIElzIGR5bmFtaWNhbGx5IGFzc2lnbmVkIGluXG4gICAqIGBwcmVwYXJlU3RyZWFtUGFyYW1zYC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcmVwYXJlU3RyZWFtUGFyYW1zfVxuICAgKiBAc2VlIHtAbGluayBtb2R1bGU6Y29yZS5CYXNlTGZvI3Byb2Nlc3NGcmFtZX1cbiAgICovXG4gIHByb2Nlc3NGdW5jdGlvbihmcmFtZSkge1xuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21tb24gbG9naWMgdG8gcGVyZm9ybSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBgcHJvY2Vzc0ZyYW1lYC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmNvcmUuQmFzZUxmbyNwcm9jZXNzRnJhbWV9XG4gICAqL1xuICBwcmVwYXJlRnJhbWUoKSB7XG4gICAgaWYgKHRoaXMuX3JlaW5pdCA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3Qgc3RyZWFtUGFyYW1zID0gdGhpcy5wcmV2TW9kdWxlICE9PSBudWxsID8gdGhpcy5wcmV2TW9kdWxlLnN0cmVhbVBhcmFtcyA6IHt9O1xuICAgICAgdGhpcy5pbml0U3RyZWFtKHN0cmVhbVBhcmFtcyk7XG4gICAgICB0aGlzLl9yZWluaXQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yd2FyZCB0aGUgY3VycmVudCBgZnJhbWVgIHRvIHRoZSBuZXh0IG9wZXJhdG9ycywgaXMgY2FsbGVkIGF0IHRoZSBlbmQgb2ZcbiAgICogYHByb2Nlc3NGcmFtZWAuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIG1vZHVsZTpjb3JlLkJhc2VMZm8jcHJvY2Vzc0ZyYW1lfVxuICAgKi9cbiAgcHJvcGFnYXRlRnJhbWUoKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLm5leHRNb2R1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMubmV4dE1vZHVsZXNbaV0ucHJvY2Vzc0ZyYW1lKHRoaXMuZnJhbWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VMZm87XG4iLCJcbi8qKlxuICogSW50ZXJmYWNlIGFkZGVkIHRvIGBMZm9Db3JlIHRvIGltcGxlbWVudCBzb3VyY2VcbiAqXG4gKiBTb3VyY2UgaGF2ZSBzb21lIHJlc3BvbnNhYmlsaXR5IG9uIGdyYXBoIGFzIHRoZXkgbW9zdGx5IGNvbnRyb2wgaXRzIHdob2xlXG4gKiBsaWZlY3ljbGUuIFRoZXkgbXVzdCBpbXBsZW1lbnQgdGhlIHN0YXJ0IGFuZCBzdG9wIG1ldGhvZCBpbiBvcmRlciB0b1xuICogbWFrZSBzdXJlIHRoZSBncmFwaCBpcyBpbml0aWFsaXplZCBhbmQgc2V0IGBzdGFydGVkYCB0byB0cnVlLlxuICogQSBzb3VyY2Ugc2hvdWxkIG5ldmVyIGFjY2VwdCBhbmQgcHJvcGFnYXRlIGluY29tbWluZyBmcmFtZXMgdW50aWwgYHN0YXJ0ZWRgXG4gKiBpcyBzZXQgdG8gYHRydWVgLlxuICpcbiAqIEBuYW1lIFNvdXJjZU1peGluXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmVcbiAqIEBtaXhpblxuICpcbiAqIEBleGFtcGxlXG4gKiBjbGFzcyBNeVNvdXJjZSBleHRlbmRzIFNvdXJjZU1peGluKEJhc2VMZm8pIHt9XG4gKi9cbiBjb25zdCBTb3VyY2VNaXhpbiA9IChzdXBlcmNsYXNzKSA9PiBjbGFzcyBleHRlbmRzIHN1cGVyY2xhc3Mge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5pbml0UHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5zdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3RvcCA9IHRoaXMuc3RvcC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGdyYXBoIGJ5IGNhbGxpbmcgYGluaXRNb2R1bGVgLiBXaGVuIHRoZSByZXR1cm5lZCBgUHJvbWlzZWBcbiAgICogZnVsZmlsbHMsIHRoZSBncmFwaCBjYW4gYmUgY29uc2lkZXJlZCBhcyBpbml0aWFsaXplZCBhbmQgYHN0YXJ0YCBjYW4gYmVcbiAgICogY2FsbGVkIHNhZmVseS4gSWYgYHN0YXJ0YCBpcyBjYWxsZWQgd2hpdGhvdXQgZXhwbGljaXQgYGluaXRgLCBgaW5pdGAgaXNcbiAgICogbWFkZSBpbnRlcm5hbGx5LCBhY3R1YWwgc3RhcnQgb2YgdGhlIGdyYXBoIGlzIHRoZW4gbm90IGdhcmFudGVlZCB0byBiZVxuICAgKiBzeW5jaHJvbm91cy5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLlNvdXJjZU1peGluXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbmFtZSBpbml0XG4gICAqXG4gICAqIEByZXR1cm4gUHJvbWlzZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBzYWZlIGluaXRpYWxpemF0aW9uIGFuZCBzdGFydFxuICAgKiBzb3VyY2UuaW5pdCgpLnRoZW4oKCkgPT4gc291cmNlLnN0YXJ0KCkpXG4gICAqIC8vIHNhZmUgaW5pdGlhbGl6YXRpb24gYW5kIHN0YXJ0XG4gICAqIHNvdXJjZS5zdGFydCgpO1xuICAgKi9cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5pbml0TW9kdWxlKCkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmluaXRTdHJlYW0oKTsgLy8gdGhpcyBpcyBzeW5jaHJvbm91c1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuaW5pdFByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCB0byBpbXBsZW1lbnQgdGhhdCBzdGFydHMgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBUaGUgbWV0aG9kIG1haW4gcHVycG9zZSBpcyB0byBtYWtlIHN1cmUgdGFrZSB2ZXJpZnkgaW5pdGlhbGl6YXRpb24gc3RlcCBhbmRcbiAgICogc2V0IGBzdGFydGVkYCB0byBgdHJ1ZWAgd2hlbiBkb25lLlxuICAgKiBTaG91bGQgYmVoYXZlIHN5bmNocm9ub3VzbHkgd2hlbiBjYWxsZWQgaW5zaWRlIGBpbml0KCkudGhlbigpYCBhbmQgYXN5bmNcbiAgICogaWYgY2FsbGVkIHdpdGhvdXQgaW5pdCBzdGVwLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuU291cmNlTWl4aW5cbiAgICogQGluc3RhbmNlXG4gICAqIEBuYW1lIHN0YXJ0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGJhc2ljIGBzdGFydGAgaW1wbGVtZW50YXRpb25cbiAgICogc3RhcnQoKSB7XG4gICAqICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IGZhbHNlKSB7XG4gICAqICAgICBpZiAodGhpcy5pbml0UHJvbWlzZSA9PT0gbnVsbCkgLy8gaW5pdCBoYXMgbm90IHlldCBiZWVuIGNhbGxlZFxuICAgKiAgICAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5pbml0KCk7XG4gICAqXG4gICAqICAgICB0aGlzLmluaXRQcm9taXNlLnRoZW4odGhpcy5zdGFydCk7XG4gICAqICAgICByZXR1cm47XG4gICAqICAgfVxuICAgKlxuICAgKiAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAqIH1cbiAgICovXG4gIHN0YXJ0KCkge31cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCB0byBpbXBsZW1lbnQgdGhhdCBzdG9wcyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Tb3VyY2VNaXhpblxuICAgKiBAaW5zdGFuY2VcbiAgICogQG5hbWUgc3RvcFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBiYXNpYyBgc3RvcGAgaW1wbGVtZW50YXRpb25cbiAgICogc3RvcCgpIHtcbiAgICogICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICogfVxuICAgKi9cbiAgc3RvcCgpIHt9XG5cbiAgLyoqXG4gICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgbmV2ZXIgYWxsb3cgaW5jb21taW5nIGZyYW1lc1xuICAgKiBpZiBgdGhpcy5zdGFydGVkYCBpcyBub3QgYHRydWVgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuU291cmNlTWl4aW5cbiAgICogQGluc3RhbmNlXG4gICAqIEBuYW1lIHByb2Nlc3NGcmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZnJhbWVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gYmFzaWMgYHByb2Nlc3NGcmFtZWAgaW1wbGVtZW50YXRpb25cbiAgICogcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAqICAgaWYgKHRoaXMuc3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgKiAgICAgdGhpcy5wcmVwYXJlRnJhbWUoKTtcbiAgICogICAgIHRoaXMucHJvY2Vzc0Z1bmN0aW9uKGZyYW1lKTtcbiAgICogICAgIHRoaXMucHJvcGFnYXRlRnJhbWUoKTtcbiAgICogICB9XG4gICAqIH1cbiAgICovXG4gIHByb2Nlc3NGcmFtZShmcmFtZSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgU291cmNlTWl4aW47XG4iLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcldmVyc2lvbiUnO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2VMZm8gfSBmcm9tICcuL0Jhc2VMZm8nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTb3VyY2VNaXhpbiB9IGZyb20gJy4vU291cmNlTWl4aW4nO1xuIiwiaW1wb3J0IG5zIGZyb20gJy4uL2NvcmUvbmFtZXNwYWNlJztcbmltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL0xheWVyJztcblxuXG4vKipcbiAqIFNpbXBsaWZpZWQgTGF5ZXIgZm9yIEF4aXMuIFRoZSBtYWluIGRpZmZlcmVuY2Ugd2l0aCBhIHJlZ3VsYXIgbGF5ZXIgaXMgdGhhdFxuICogYW4gYXhpcyBsYXllciB1c2UgdGhlIGBUaW1lbGluZX50aW1lQ29udGV4dGAgYXR0cmlidXRlcyB0byByZW5kZXIgaXQncyBsYXlvdXRcbiAqIGFuZCBzdGF5IHN5bmNocm9uaXplZCB3aXRoIHRoZSB0cmFja3MgdmlzaWJsZSBhcmVhLiBBbGwgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICogdG8gdGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCBhdHRyaWJ1dGVzIGFyZSBieXBhc3NlZC5cbiAqXG4gKiBJdCBhbHNvIGhhbmRsZSBpdCdzIG93biBkYXRhIGFuZCBpdHMgdXBkYXRlcy4gVGhlIGBfZ2VuZXJhdGVEYXRhYCBtZXRob2QgaXNcbiAqIHJlc3BvbnNpYmxlIHRvIGNyZWF0ZSBzb21lIHVzZWZ1bGwgZGF0YSB0byB2aXN1YWxpemVcbiAqXG4gKiBbZXhhbXBsZSB1c2FnZSBvZiB0aGUgbGF5ZXItYXhpc10oLi9leGFtcGxlcy9sYXllci1heGlzLmh0bWwpXG4gKi9cbmNsYXNzIEF4aXNMYXllciBleHRlbmRzIExheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGdlbmVyYXRvciAtIEEgZnVuY3Rpb24gdG8gY3JlYXRlIGRhdGEgYWNjb3JkaW5nIHRvXG4gICAqICAgIHRoZSBgVGltZWxpbmV+dGltZUNvbnRleHRgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIExheWVyIG9wdGlvbnMsIGNmLiBMYXllciBmb3IgYXZhaWxhYmxlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICBzdXBlcignZW50aXR5JywgW10sIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzZXQgc3RyZXRjaFJhdGlvKHZhbHVlKSB7IHJldHVybjsgfVxuICAvKiogQHByaXZhdGUgKi9cbiAgc2V0IG9mZnNldCh2YWx1ZSkgeyByZXR1cm47IH1cbiAgLyoqIEBwcml2YXRlICovXG4gIHNldCBzdGFydCh2YWx1ZSkgeyByZXR1cm47IH1cbiAgLyoqIEBwcml2YXRlICovXG4gIHNldCBkdXJhdGlvbih2YWx1ZSkgeyByZXR1cm47IH1cbiAgLyoqIEBwcml2YXRlICovXG4gIGdldCBzdHJldGNoUmF0aW8oKSB7IHJldHVybjsgfVxuICAvKiogQHByaXZhdGUgKi9cbiAgZ2V0IG9mZnNldCgpIHsgcmV0dXJuOyB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBnZXQgc3RhcnQoKSB7IHJldHVybjsgfVxuICAvKiogQHByaXZhdGUgKi9cbiAgZ2V0IGR1cmF0aW9uKCkgeyByZXR1cm47IH1cblxuXG4gIC8qKlxuICAgKiBUaGUgZ2VuZXJhdG9yIHRoYXQgY3JlYXRlcyB0aGUgZGF0YSB0byBiZSByZW5kZXJlZCB0byBkaXNwbGF5IHRoZSBheGlzLlxuICAgKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICBzZXQgZ2VuZXJhdG9yKGZ1bmMpIHtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSBmdW5jO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBnZW5lcmF0b3IgdGhhdCBjcmVhdGVzIHRoZSBkYXRhIHRvIGJlIHJlbmRlcmVkIHRvIGRpc3BsYXkgdGhlIGF4aXMuXG4gICAqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIGdldCBnZW5lcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgbWFpbiBkaWZmZXJlbmNlIHdpdGggYSBjbGFzc2ljYWwgbGF5ZXIuIEFuIGBBeGlzTGF5ZXJgXG4gICAqIGluc3RhbmNlIGdlbmVyYXRlcyBhbmQgbWFpbnRhaW5zIGl0J3Mgb3duIGRhdGEuXG4gICAqL1xuICBfZ2VuZXJhdGVEYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9nZW5lcmF0b3IodGhpcy50aW1lQ29udGV4dCk7XG4gICAgLy8gcHJlcGVuZCBmaXJzdCBhcmd1bWVudHMgb2Ygc3BsaWNlIGZvciBhbiBhcHBseVxuICAgIGRhdGEudW5zaGlmdCgwLCB0aGlzLmRhdGFbMF0ubGVuZ3RoKTtcbiAgICAvLyBtYWtlIHN1cmUgdG8ga2VlcCB0aGUgc2FtZSByZWZlcmVuY2VcbiAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHRoaXMuZGF0YVswXSwgZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoZSBzaGFwZXMuXG4gICAqL1xuICBfdXBkYXRlUmVuZGVyaW5nQ29udGV4dCgpIHtcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbDtcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCA9IHRoaXMuX3ZhbHVlVG9QaXhlbDtcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LmhlaWdodCA9IHRoaXMucGFyYW1zLmhlaWdodDtcbiAgICAvLyB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LndpZHRoICA9IHRoaXMudGltZUNvbnRleHQudGltZVRvUGl4ZWwodGhpcy50aW1lQ29udGV4dC5kdXJhdGlvbik7XG5cbiAgICAvLyBmb3IgZm9yZWlnbiBvYmplY3QgaXNzdWUgaW4gY2hyb21lXG4gICAgdGhpcy5fcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0Lm9mZnNldCk7XG4gICAgdGhpcy5fcmVuZGVyaW5nQ29udGV4dC52aXNpYmxlV2lkdGggPSB0aGlzLnRpbWVDb250ZXh0LnZpc2libGVXaWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIGRhdGEgYW5kIHVwZGF0ZSB0aGUgbGF5ZXIuXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVEYXRhKCk7XG4gICAgc3VwZXIudXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBET00gaW4gbWVtb3J5IG9uIGxheWVyIGNyZWF0aW9uIHRvIGJlIGFibGUgdG8gdXNlIGl0IGJlZm9yZVxuICAgKiB0aGUgbGF5ZXIgaXMgYWN0dWFsbHkgaW5zZXJ0ZWQgaW4gdGhlIERPTVxuICAgKi9cbiAgX3JlbmRlckNvbnRhaW5lcigpIHtcbiAgICAvLyB3cmFwcGVyIGdyb3VwIGZvciBgc3RhcnQsIHRvcCBhbmQgY29udGV4dCBmbGlwIG1hdHJpeFxuICAgIHRoaXMuJGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnZycpO1xuICAgIGlmICh0aGlzLnBhcmFtcy5jbGFzc05hbWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5hZGQoJ2xheWVyJywgdGhpcy5wYXJhbXMuY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICAvLyBncm91cCB0byBhcHBseSBvZmZzZXRcbiAgICB0aGlzLiRvZmZzZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdnJyk7XG4gICAgdGhpcy4kb2Zmc2V0LmNsYXNzTGlzdC5hZGQoJ29mZnNldCcsICdpdGVtcycpO1xuICAgIC8vIGxheWVyIGJhY2tncm91bmRcbiAgICB0aGlzLiRiYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAncmVjdCcpO1xuICAgIHRoaXMuJGJhY2tncm91bmQuY2xhc3NMaXN0LmFkZCgnYmFja2dyb3VuZCcpO1xuICAgIHRoaXMuJGJhY2tncm91bmQuc3R5bGUuZmlsbE9wYWNpdHkgPSAwO1xuICAgIHRoaXMuJGJhY2tncm91bmQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAvLyBjcmVhdGUgdGhlIERPTSB0cmVlXG4gICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQodGhpcy4kb2Zmc2V0KTtcbiAgICB0aGlzLiRvZmZzZXQuYXBwZW5kQ2hpbGQodGhpcy4kYmFja2dyb3VuZCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbGF5b3V0IG9mIHRoZSBsYXllci5cbiAgICovXG4gIHVwZGF0ZUNvbnRhaW5lcigpIHtcbiAgICB0aGlzLl91cGRhdGVSZW5kZXJpbmdDb250ZXh0KCk7XG5cbiAgICBjb25zdCB0b3AgPSB0aGlzLnBhcmFtcy50b3A7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5wYXJhbXMuaGVpZ2h0O1xuICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1heCgwLCAtdGhpcy5fcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYKTtcbiAgICAvLyBtYXRyaXggdG8gaW52ZXJ0IHRoZSBjb29yZGluYXRlIHN5c3RlbVxuICAgIGNvbnN0IHRyYW5zbGF0ZU1hdHJpeCA9IGBtYXRyaXgoMSwgMCwgMCwgLTEsIDAsICR7dG9wICsgaGVpZ2h0fSlgO1xuICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVNYXRyaXgpO1xuXG4gICAgLy8ga2VlcCBiYWNrZ3JvdW5kIG9uIHRoZSB2aXNpYmxlIGFyZWFcbiAgICB0aGlzLiRiYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCBoZWlnaHQpO1xuICAgIHRoaXMuJGJhY2tncm91bmQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgdGhpcy50aW1lQ29udGV4dC52aXNpYmxlV2lkdGgpO1xuICAgIHRoaXMuJGJhY2tncm91bmQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCBsZWZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBeGlzTGF5ZXI7XG4iLCIvKipcbiAqIEEgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBkYXRhIGZvciBncmlkIGF4aXMgYWNjb3JkaW5nIHRvIGEgYGJwbWAgYW5kIGEgYG1ldGVyYC5cbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci1heGlzLmh0bWwpXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGJwbSAtIE51bWJlciBvZiBiZWF0cyBwZXIgbWludXRlc1xuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25hdHVyZSAtIE1ldGVyIG9mIHRoZSBtZXN1cmUgKGAnNC80J2AsIGAnMy84J2AsIC4uLilcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIEZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGUgZGF0YSB0byBiZSBkaXBsYXllZFxuICovXG5mdW5jdGlvbiBncmlkQXhpc0dlbmVyYXRvcihicG0sIHNpZ25hdHVyZSkge1xuICBjb25zdCBfYnBzID0gIGJwbSAvIDYwOyAvLyBzZWNcbiAgY29uc3QgX3VuaXQgPSAxIC8gcGFyc2VJbnQoc2lnbmF0dXJlLnNwbGl0KCcvJylbMV0sIDEwKTtcbiAgY29uc3QgX25iclVuaXRzUGVyTWVzdXJlID0gcGFyc2VJbnQoc2lnbmF0dXJlLnNwbGl0KCcvJylbMF0sIDEwKTtcblxuICByZXR1cm4gZnVuY3Rpb24odGltZUNvbnRleHQpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRpbWVDb250ZXh0LnZpc2libGVEdXJhdGlvbjtcbiAgICBjb25zdCBvZmZzZXQgPSB0aW1lQ29udGV4dC5vZmZzZXQ7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuXG4gICAgLy8gY29uc3QgbWluID0gTWF0aC5taW4oLW9mZnNldCwgMCk7XG4gICAgY29uc3QgbWluID0gLSBvZmZzZXQ7XG4gICAgLy8gcmVtb3ZlIHRoZSB0aW1lbGluZSdzIG9mZnNldCB0byBrZWVwIHRoZSBsYXllciBjZW50ZXJlZFxuICAgIGNvbnN0IG1heCA9IGR1cmF0aW9uIC0gb2Zmc2V0O1xuXG4gICAgLy8gZGVmaW5lIHBpeGVscyBmb3IgMSBzZWNvbmRcbiAgICBjb25zdCBwaXhlbHNQZXJTZWNvbmQgPSB0aW1lQ29udGV4dC5jb21wdXRlZFBpeGVsc1BlclNlY29uZDtcbiAgICAvLyB0aW1lIGZvciBvbmUgX3VuaXRcbiAgICBjb25zdCB1bml0VGltZSA9IDEgLyBfYnBzO1xuICAgIC8vIGRlZmluZSB0aGUgZmlyc3QgdGljayA+IG1pblxuICAgIGNvbnN0IG1vZHVsbyA9IG1pbiAlIHVuaXRUaW1lO1xuICAgIGNvbnN0IG11bHQgPSAobWluIC0gbW9kdWxvKSAvIHVuaXRUaW1lO1xuICAgIGNvbnN0IGZpcnN0VGlja1RpbWUgPSB1bml0VGltZSAqIG11bHQ7XG4gICAgLy8gdHJhY2sgd2hpY2ggcG9zaXRpb24gb2YgY3VycmVudCBiZWF0IGluIHRoZSBtZXN1cmVcbiAgICBsZXQgcG9zaXRpb25Jbk1lc3VyZSA9IG11bHQgJSBfbmJyVW5pdHNQZXJNZXN1cmU7XG5cbiAgICAvLyByZW1vdmUgbm90IGZvY3VzZWQgYmVhdHMsIGlmIHpvb21lZCBvdXRcbiAgICBjb25zdCBwaXhlbHNQZXJUaWNrID0gcGl4ZWxzUGVyU2Vjb25kIC8gX2JwcztcbiAgICBjb25zdCBtaW5TdGVwID0gNTtcblxuICAgIC8vIHRpbWUgc2hvdWxkIGJlXG4gICAgZm9yIChsZXQgdGltZSA9IGZpcnN0VGlja1RpbWU7IHRpbWUgPCBtYXg7IHRpbWUgKz0gdW5pdFRpbWUpIHtcbiAgICAgIC8vIGZpbmQgZmlyc3QgYmVhdFxuICAgICAgY29uc3QgZm9jdXNlZCA9IChwb3NpdGlvbkluTWVzdXJlKysgJSBfbmJyVW5pdHNQZXJNZXN1cmUgPT09IDApO1xuICAgICAgLy8gaWdub3JlIGlmIHBpeGVscyBwZXIgdGlja3MgaXMgdG9vIHNtYWxsXG4gICAgICBpZiAoKHBpeGVsc1BlclRpY2sgPD0gbWluU3RlcCkgJiYgIWZvY3VzZWQpIHsgY29udGludWU7IH1cblxuICAgICAgZGF0YS5wdXNoKHsgdGltZSwgZm9jdXNlZCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ3JpZEF4aXNHZW5lcmF0b3I7XG4iLCJpbXBvcnQgeyBwYWRMZWZ0IH0gZnJvbSAnLi4vdXRpbHMvZm9ybWF0JztcblxuXG4vKipcbiAqIEEgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBkYXRhIGZvciB0aW1lIGF4aXMuXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvbGF5ZXItYXhpcy5odG1sKVxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIFRoZSBjb25maWd1cmVkIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgZGF0YSB3aGVuIGNhbGxlZC5cbiAqL1xuZnVuY3Rpb24gdGltZUF4aXNHZW5lcmF0b3IoKSB7XG4gIC8vIGFkZCBmYWN0b3J5IHRvIHNoYXJlIEFQSSB3aXRoIGJwbUdlbmVyYXRvclxuICByZXR1cm4gZnVuY3Rpb24odGltZUNvbnRleHQpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRpbWVDb250ZXh0LnZpc2libGVEdXJhdGlvbjtcbiAgICBjb25zdCBvZmZzZXQgPSB0aW1lQ29udGV4dC5vZmZzZXQ7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuXG4gICAgLy8gY29uc3QgbWluID0gTWF0aC5taW4oLW9mZnNldCwgMCk7XG4gICAgY29uc3QgbWluID0gLSBvZmZzZXQ7XG4gICAgLy8gcmVtb3ZlIHRoZSB0aW1lbGluZSdzIG9mZnNldCB0byBrZWVwIHRoZSBsYXllciBjZW50ZXJlZFxuICAgIGNvbnN0IG1heCA9IGR1cmF0aW9uIC0gb2Zmc2V0O1xuXG4gICAgLy8gZGVmaW5lIHBpeGVscyBmb3IgMSBzZWNvbmRcbiAgICBjb25zdCBwaXhlbHNQZXJTZWNvbmQgPSB0aW1lQ29udGV4dC5jb21wdXRlZFBpeGVsc1BlclNlY29uZDtcbiAgICBjb25zdCBtaW5TdGVwID0gNztcblxuICAgIC8vIGRlZmluZSBhbGwgZGlzcGxheSBpbmZvcm1hdGlvbiBhY2NvcmRpbmcgdG8gdGhlIHBpeGVsc1BlclNlY29uZCByYXRpb1xuICAgIGxldCBzdGVwLCB0eXBlLCB0b0ZpeGVkLCBtYXJrZXJNb2R1bG8sIGluY2x1ZGVNb2R1bG87XG5cbiAgICBpZiAocGl4ZWxzUGVyU2Vjb25kICogNCA+IG1pblN0ZXApIHtcbiAgICAgIHN0ZXAgPSAxOyAvLyB0aGUgc3RlcCB0byB1c2UgdG8gY29tcHV0ZSB0aW1lXG4gICAgICB0b0ZpeGVkID0gMDtcbiAgICAgIG1hcmtlck1vZHVsbyA9IDYwOyAvLyBhIHRpbWVzdGFtcCBldmVyeSA1IHN0ZXBpeGVsc1BlclNlY29uZFxuICAgICAgaW5jbHVkZU1vZHVsbyA9IDU7IC8vIGEgdGljayBldmVyeSA1IHN0ZXBpeGVsc1BlclNlY29uZFxuICAgICAgdHlwZSA9ICc2MHNlYyc7XG4gICAgfVxuXG4gICAgaWYgKHBpeGVsc1BlclNlY29uZCAqIDIgPiBtaW5TdGVwKSB7XG4gICAgICBzdGVwID0gMTtcbiAgICAgIHRvRml4ZWQgPSAwO1xuICAgICAgbWFya2VyTW9kdWxvID0gMzA7XG4gICAgICBpbmNsdWRlTW9kdWxvID0gMTtcbiAgICAgIHR5cGUgPSAnMzBzZWMnO1xuICAgIH1cblxuICAgIGlmIChwaXhlbHNQZXJTZWNvbmQgPiBtaW5TdGVwKSB7XG4gICAgICBzdGVwID0gMTtcbiAgICAgIHRvRml4ZWQgPSAwO1xuICAgICAgbWFya2VyTW9kdWxvID0gMTA7XG4gICAgICBpbmNsdWRlTW9kdWxvID0gMTtcbiAgICAgIHR5cGUgPSAnc2VjJztcbiAgICB9XG5cbiAgICBpZiAocGl4ZWxzUGVyU2Vjb25kIC8gMTAgPiBtaW5TdGVwKSB7XG4gICAgICBzdGVwID0gMSAvIDEwO1xuICAgICAgdG9GaXhlZCA9IDE7XG4gICAgICBtYXJrZXJNb2R1bG8gPSAxMDtcbiAgICAgIGluY2x1ZGVNb2R1bG8gPSAxO1xuICAgICAgdHlwZSA9ICdkcyc7XG4gICAgfVxuXG4gICAgaWYgKHBpeGVsc1BlclNlY29uZCAvIDEwMCA+IG1pblN0ZXApIHtcbiAgICAgIHN0ZXAgPSAxIC8gMTAwO1xuICAgICAgdG9GaXhlZCA9IDI7XG4gICAgICBtYXJrZXJNb2R1bG8gPSAxMDtcbiAgICAgIGluY2x1ZGVNb2R1bG8gPSAxO1xuICAgICAgdHlwZSA9ICdjcyc7XG4gICAgfVxuXG4gICAgaWYgKHBpeGVsc1BlclNlY29uZCAvIDEwMDAgPiBtaW5TdGVwKSB7XG4gICAgICBzdGVwID0gMSAvIDEwMDA7XG4gICAgICB0b0ZpeGVkID0gMztcbiAgICAgIG1hcmtlck1vZHVsbyA9IDEwO1xuICAgICAgaW5jbHVkZU1vZHVsbyA9IDE7XG4gICAgICB0eXBlID0gJ21zJztcbiAgICB9XG5cbiAgICBmb3IgKGxldCB0aW1lID0gbWluOyB0aW1lIDwgbWF4OyB0aW1lICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFRpbWUgPSB0aW1lLnRvRml4ZWQodG9GaXhlZCk7XG5cbiAgICAgIGlmIChNYXRoLnJvdW5kKGZvcm1hdHRlZFRpbWUgLyBzdGVwKSAlIGluY2x1ZGVNb2R1bG8gIT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9yc1xuICAgICAgY29uc3QgZm9jdXNlZCA9IE1hdGgucm91bmQoZm9ybWF0dGVkVGltZSAvIHN0ZXApICUgbWFya2VyTW9kdWxvID09PSAwID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICBjb25zdCBkYXR1bSA9IHsgdGltZTogZm9ybWF0dGVkVGltZSwgZm9jdXNlZCB9O1xuXG4gICAgICBpZiAoZm9jdXNlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoMTAwMCAqIGZvcm1hdHRlZFRpbWUpO1xuICAgICAgICBjb25zdCBtaW4gPSBwYWRMZWZ0KGRhdGUuZ2V0TWludXRlcygpLCAwLCAyKTtcbiAgICAgICAgY29uc3Qgc2VjID0gcGFkTGVmdChkYXRlLmdldFNlY29uZHMoKSwgMCwgMik7XG4gICAgICAgIGNvbnN0IG1pbGxpID0gcGFkTGVmdChkYXRlLmdldE1pbGxpc2Vjb25kcygpLCAwLCAzKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBgJHttaW59OiR7c2VjfToke21pbGxpfWA7XG5cbiAgICAgICAgZGF0dW0ubGFiZWwgPSBsYWJlbDtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wdXNoKGRhdHVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGltZUF4aXNHZW5lcmF0b3I7XG4iLCIvKipcbiAqIElzIGFuIGFic3RyYWN0IGNsYXNzIG9yIGludGVyZmFjZSB0byBiZSBvdmVycmlkZW4gaW4gb3JkZXIgdG8gZGVmaW5lIHRoZSB3YXlcbiAqIGEgZ2l2ZW4gc2hhcGUgc2hvdWxkIGJlaGF2ZSB3aGVuIHNlbGVjdGVkIG9yIGVkaXRlZCBieSBhIHVzZXIuIEluc3RhbmNlcyBvZlxuICogYEJhc2VCZWhhdmlvcmAgYXJlIGludGVybmFsbHkgdXNlZCBieSBgTGF5ZXJgIGluc3RhbmNlcyB0byBtb2RpZnkgdGhlIGRhdGFcbiAqIGFjY29yZGluZyB0byBhIHVzZXIgaW50ZXJhY3Rpb24gYW5kIGEgZ2l2ZW4gc2hhcGUuIEEgc2luZ2xlIGluc3RhbmNlIG9mXG4gKiBgQmVoYXZpb3JgIGlzIGNyZWF0ZWQgaW4gb25lIGdpdmVuIHNoYXBlLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBvbmx5IG1ldGhvZCB0byBvdmVycmlkZSB0byBkZWZpbmUgYSBuZXcgYmVoYXZpb3IgZm9yIGFcbiAqIHNoYXBlIGlzIHRoZSBgZWRpdGAgbWV0aG9kLiBIb3dldmVyLCBpZiBuZWVkZWQgaW4gc3BlY2lhbCBjYXNlcywgYWxsIHRoZVxuICogc2VsZWN0aW9uIGhhbmRsaW5nIGNhbiBiZSBvdmVycmlkZW4gdG9vLlxuICpcbiAqIFRoZSBmbG93IGlzIHRoZSBmb2xsb3dpbmc6XG4gKiBgRXZlbnRgICAtIChmb3J3YXJkZWQgdG8pIC0+IGBMYXllcmAgLSAoY29tbWFuZCkgLT4gYEJlaGF2aW9yYCAtIChtb2RpZnkpIC0+IGBkYXRhYCAtICh1cGF0ZXMpIC0+IGBTaGFwZWBcbiAqXG4gKiBUaGUgYmVoYXZpb3IgcmVzcG9uc2FiaWxpdHkgaXMgdGhlbiB0byBtb2RpZnkgdGhlIGRhdGEgYWNjb3JkaW5nIHRvIHRoZVxuICogdXNlciBpbnRlcmFjdGlvbnMsIHdoaWxlIHNoYXBlcyBhcmUgYWx3YXlzIGEgdmlldyBvZiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcbiAqIGRhdGEuXG4gKi9cbmNsYXNzIEJhc2VCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkSXRlbXMgPSBuZXcgU2V0KCk7IC8vIG5vIGR1cGxpY2F0ZSBpbiBTZXRcbiAgICB0aGlzLl9zZWxlY3RlZENsYXNzID0gbnVsbDtcbiAgICB0aGlzLl9sYXllciA9IG51bGw7XG4gIH1cblxuICBpbml0aWFsaXplKGxheWVyKSB7XG4gICAgdGhpcy5fbGF5ZXIgPSBsYXllcjtcbiAgICB0aGlzLl9zZWxlY3RlZENsYXNzID0gbGF5ZXIucGFyYW1zLnNlbGVjdGVkQ2xhc3NOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIHJlZmVyZW5jZXMgdG8gdGhlIHNlbGVjdGVkIGl0ZW1zLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAdG9kbyAtIHJlbmFtZSB0byBgY2xlYXJTZWxlY3Rpb25gIChyZW1vdmluZyB0aGUgY2xhc3MpID9cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWRJdGVtcy5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyB0byBhZGQgdG8gdGhlIHNoYXBlcyB3aGVuIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc2V0IHNlbGVjdGVkQ2xhc3ModmFsdWUpIHtcbiAgICB0aGlzLl9zZWxlY3RlZENsYXNzID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNsYXNzIHRvIGFkZCB0byB0aGUgc2hhcGVzIHdoZW4gc2VsZWN0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgc2VsZWN0ZWRDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRDbGFzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgc2VsZWN0ZWQgaXRlbXMgb2YgdGhlIGxheWVyLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICBnZXQgc2VsZWN0ZWRJdGVtcygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3NlbGVjdGVkSXRlbXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gJGl0ZW0gLSBUaGUgaXRlbSB0byBzZWxlY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXR1bSAtIE5vdCB1c2VkIGluIHRoaXMgaW1wbGVtZW50YXRpb24uIENvdWxkIGJlXG4gICAqICAgIHVzZWQgdG8gbWFyayB0aGUgZGF0YSBhcyBzZWxlY3RlZC5cbiAgICogQHRvZG8gLSBQYXNzIHRoZSBzaGFwZSBvYmplY3QgdG8gZ2V0IHRoZSBhY2Nlc3NvcnMgP1xuICAgKi9cbiAgc2VsZWN0KCRpdGVtLCBkYXR1bSkge1xuICAgICRpdGVtLmNsYXNzTGlzdC5hZGQodGhpcy5zZWxlY3RlZENsYXNzKTtcbiAgICB0aGlzLl9zZWxlY3RlZEl0ZW1zLmFkZCgkaXRlbSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSAkaXRlbSAtIFRoZSBpdGVtIHRvIHVuc2VsZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0dW0gLSBOb3QgdXNlZCBpbiB0aGlzIGltcGxlbWVudGF0aW9uLiBDb3VsZCBiZVxuICAgKiAgICB1c2VkIHRvIG1hcmsgdGhlIGRhdGEgYXMgc2VsZWN0ZWQuXG4gICAqIEB0b2RvIC0gUGFzcyB0aGUgc2hhcGUgb2JqZWN0IHRvIGdldCB0aGUgYWNjZXNzb3JzID9cbiAgICovXG4gIHVuc2VsZWN0KCRpdGVtLCBkYXR1bSkge1xuICAgICRpdGVtLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5zZWxlY3RlZENsYXNzKTtcbiAgICB0aGlzLl9zZWxlY3RlZEl0ZW1zLmRlbGV0ZSgkaXRlbSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSAkaXRlbSAtIFRoZSBpdGVtIHRvIHRvZ2dsZSBzZWxlY3Rpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXR1bSAtIE5vdCB1c2VkIGluIHRoaXMgaW1wbGVtZW50YXRpb24uIENvdWxkIGJlXG4gICAqICAgIHVzZWQgdG8gbWFyayB0aGUgZGF0YSBhcyBzZWxlY3RlZC5cbiAgICogQHRvZG8gLSBQYXNzIHRoZSBzaGFwZSBvYmplY3QgdG8gZ2V0IHRoZSBhY2Nlc3NvcnMgP1xuICAgKi9cbiAgdG9nZ2xlU2VsZWN0aW9uKCRpdGVtLCBkYXR1bSkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuX3NlbGVjdGVkSXRlbXMuaGFzKCRpdGVtKSA/ICd1bnNlbGVjdCcgOiAnc2VsZWN0JztcbiAgICB0aGlzW21ldGhvZF0oJGl0ZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyZmFjZSBtZXRob2QgdG8gb3ZlcnJpZGUgaW4gb3JkZXIgdG8gZGVmaW5lIGl0cyBwYXJ0aWN1bGFyIGJlaGF2aW9yIHdoZW5cbiAgICogaW50ZXJhY3RlZCB3aXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVuZGVyaW5nQ29udGV4dCAtIFRoZSBsYXllciByZW5kZXJpbmcgY29udGV4dC5cbiAgICogQHBhcmFtIHtCYXNlU2hhcGV9IHNoYXBlIC0gVGhlIHNoYXBlIG9iamVjdCB0byBiZSBlZGl0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXR1bSAtIFRoZSByZWxhdGVkIGRhdHVtIHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR4IC0gVGhlIHZhbHVlIG9mIHRoZSBpbnRlcmFjdGlvbiBpbiB0aGUgeCBheGlzIChpbiBwaXhlbHMpLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHkgLSBUaGUgdmFsdWUgb2YgdGhlIGludGVyYWN0aW9uIGluIHRoZSB5IGF4aXMgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gJHRhcmdldCAtIFRoZSB0YXJnZXQgRE9NIGVsZW1lbnQgb2YgdGhlIGludGVyYWN0aW9uLlxuICAgKi9cbiAgZWRpdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgJHRhcmdldCkge1xuICAgIC8vIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gY2hpbGRyZW5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlQmVoYXZpb3I7XG4iLCJpbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vQmFzZUJlaGF2aW9yJztcblxuXG4vKipcbiAqIERlZmluZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGEgYnJlYWtwb2ludCBmdW5jdGlvbi5cbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci1icmVha3BvaW50Lmh0bWwpXG4gKi9cbmNsYXNzIEJyZWFrcG9pbnRCZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGNvbnN0IGRhdGEgID0gdGhpcy5fbGF5ZXIuZGF0YTtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0O1xuICAgIC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS5jeChkYXR1bSkpO1xuICAgIGNvbnN0IHkgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS5jeShkYXR1bSkpO1xuICAgIC8vIHRhcmdldCBwb3NpdGlvblxuICAgIGxldCB0YXJnZXRYID0geCArIGR4O1xuICAgIGxldCB0YXJnZXRZID0geSAtIGR5O1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMikge1xuICAgICAgLy8gY3JlYXRlIGEgc29ydGVkIG1hcCBvZiBhbGwgYHhgIHBvc2l0aW9uc1xuICAgICAgY29uc3QgeE1hcCA9IGRhdGEubWFwKChkKSA9PiByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLmN4KGQpKSk7XG4gICAgICB4TWFwLnNvcnQoKGEsIGIpID0+IGEgPCBiID8gLTEgOiAxKTtcbiAgICAgIC8vIGZpbmQgaW5kZXggb2Ygb3VyIHNoYXBlIHggcG9zaXRpb25cbiAgICAgIGNvbnN0IGluZGV4ID0geE1hcC5pbmRleE9mKHgpO1xuICAgICAgLy8gbG9jayB0byBuZXh0IHNpYmxpbmdzXG4gICAgICBpZiAodGFyZ2V0WCA8IHhNYXBbaW5kZXggLSAxXSB8fMKgdGFyZ2V0WCA+IHhNYXBbaW5kZXggKyAxXSkge1xuICAgICAgICB0YXJnZXRYID0geDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsb2NrIGluIHkgYXhpc1xuICAgIGlmICh0YXJnZXRZIDwgMCkge1xuICAgICAgdGFyZ2V0WSA9IDA7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRZID4gbGF5ZXJIZWlnaHQpIHtcbiAgICAgIHRhcmdldFkgPSBsYXllckhlaWdodDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZGF0dW0gd2l0aCBuZXcgdmFsdWVzXG4gICAgc2hhcGUuY3goZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICBzaGFwZS5jeShkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFkpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCcmVha3BvaW50QmVoYXZpb3I7XG4iLCJpbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vQmFzZUJlaGF2aW9yJztcblxuXG4vKipcbiAqIERlZmluZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGEgbWFya2VyLlxuICpcbiAqIFtleGFtcGxlIHVzYWdlXSguL2V4YW1wbGVzL2xheWVyLW1hcmtlci5odG1sKVxuICovXG5jbGFzcyBNYXJrZXJCZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB0YXJnZXRYID0gKHggKyBkeCkgPiAwID8geCArIGR4IDogMDtcblxuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXJrZXJCZWhhdmlvcjtcbiIsImltcG9ydCBCYXNlQmVoYXZpb3IgZnJvbSAnLi9CYXNlQmVoYXZpb3InO1xuXG5cbi8qKlxuICogRGVmaW5lcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBmb3IgYSBzZWdtZW50LlxuICpcbiAqIFtleGFtcGxlIHVzYWdlXSguL2V4YW1wbGVzL2xheWVyLW1hcmtlci5odG1sKVxuICovXG5jbGFzcyBTZWdtZW50QmVoYXZpb3IgZXh0ZW5kcyBCYXNlQmVoYXZpb3Ige1xuICBlZGl0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICBjb25zdCBjbGFzc0xpc3QgPSB0YXJnZXQuY2xhc3NMaXN0O1xuICAgIGxldCBhY3Rpb24gPSAnbW92ZSc7XG5cbiAgICBpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKCdoYW5kbGVyJykgJiYgY2xhc3NMaXN0LmNvbnRhaW5zKCdsZWZ0JykpIHtcbiAgICAgIGFjdGlvbiA9ICdyZXNpemVMZWZ0JztcbiAgICB9IGVsc2UgaWYgKGNsYXNzTGlzdC5jb250YWlucygnaGFuZGxlcicpICYmIGNsYXNzTGlzdC5jb250YWlucygncmlnaHQnKSkge1xuICAgICAgYWN0aW9uID0gJ3Jlc2l6ZVJpZ2h0JztcbiAgICB9XG5cbiAgICB0aGlzW2BfJHthY3Rpb259YF0ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCk7XG4gIH1cblxuICBfbW92ZShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUueShkYXR1bSkpO1xuICAgIGNvbnN0IGhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLmhlaWdodChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgdGFyZ2V0WCA9IE1hdGgubWF4KHggKyBkeCwgMCk7XG4gICAgbGV0IHRhcmdldFkgPSB5IC0gZHk7XG5cbiAgICAvLyBsb2NrIGluIGxheWVyJ3MgeSBheGlzXG4gICAgaWYgKHRhcmdldFkgPCAwKSB7XG4gICAgICB0YXJnZXRZID0gMDtcbiAgICB9IGVsc2UgaWYgKHRhcmdldFkgKyBoZWlnaHQgPiBsYXllckhlaWdodCkge1xuICAgICAgdGFyZ2V0WSA9IGxheWVySGVpZ2h0IC0gaGVpZ2h0O1xuICAgIH1cblxuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICBzaGFwZS55KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5pbnZlcnQodGFyZ2V0WSkpO1xuICB9XG5cbiAgX3Jlc2l6ZUxlZnQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIC8vIGN1cnJlbnQgdmFsdWVzXG4gICAgY29uc3QgeCAgICAgPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IG1heFRhcmdldFggID0geCArIHdpZHRoO1xuICAgIGxldCB0YXJnZXRYICAgICA9IHggKyBkeCA8IG1heFRhcmdldFggPyBNYXRoLm1heCh4ICsgZHgsIDApIDogeDtcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSB0YXJnZXRYICE9PSAwID8gTWF0aC5tYXgod2lkdGggLSBkeCwgMSkgOiB3aWR0aDtcblxuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICBzaGFwZS53aWR0aChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpKTtcbiAgfVxuXG4gIF9yZXNpemVSaWdodChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IHRhcmdldFdpZHRoID0gTWF0aC5tYXgod2lkdGggKyBkeCwgMSk7XG5cbiAgICBzaGFwZS53aWR0aChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWdtZW50QmVoYXZpb3I7XG4iLCIvKipcbiAqIFRpbWVDb250ZXh0QmVoYXZpb3IgaXMgdXNlZCBpbnRlcm5hbGx5IGluIExheWVycyB0byBtb2RpZnkgdGhlaXIgVGltZUNvbnRleHQuXG4gKiBUaGlzIG9iamVjdCBpcyBkaWZmZXJlbnQgZnJvbSBvdGhlciBTaGFwZXMgQmVoYXZpb3JzIGFuZCBleGlzdHMgbW9zdGx5IHRvIGRlY3JlYXNlIHRoZSBzaXplIG9mIHRoZSBMYXllci5cbiAqIEFsbCB0aGUgY29kZSBoZXJlIGNvdWxkIGJlIGNvbnNpZGVyZWQgYXMgcGFydCBvZiB0aGUgbGF5ZXIuXG4gKi9cbmNsYXNzIFRpbWVDb250ZXh0QmVoYXZpb3Ige1xuICBlZGl0KGxheWVyLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGNvbnN0IHRpbWVDb250ZXh0ID0gbGF5ZXIudGltZUNvbnRleHQ7XG5cbiAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnaGFuZGxlcicpICYmIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2xlZnQnKSkge1xuICAgICAgdGhpcy5fZWRpdExlZnQodGltZUNvbnRleHQsIGR4KTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2hhbmRsZXInKSAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdyaWdodCcpKSB7XG4gICAgICB0aGlzLl9lZGl0UmlnaHQodGltZUNvbnRleHQsIGR4KTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3NlZ21lbnQnKSkge1xuICAgICAgdGhpcy5fbW92ZSh0aW1lQ29udGV4dCwgZHgpO1xuICAgIH1cbiAgfVxuXG4gIF9lZGl0TGVmdCh0aW1lQ29udGV4dCwgZHgpIHtcbiAgICAvLyBlZGl0IGBzdGFydGAsIGBvZmZzZXRgIGFuZCBgZHVyYXRpb25gXG4gICAgY29uc3QgeCA9IHRpbWVDb250ZXh0LnBhcmVudC50aW1lVG9QaXhlbCh0aW1lQ29udGV4dC5zdGFydCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwodGltZUNvbnRleHQub2Zmc2V0KTtcbiAgICBjb25zdCB3aWR0aCA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRpbWVDb250ZXh0LmR1cmF0aW9uKTtcblxuICAgIGNvbnN0IHRhcmdldFggPSB4ICsgZHg7XG4gICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0IC0gZHg7XG4gICAgY29uc3QgdGFyZ2V0V2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIGR4LCAxKTtcblxuICAgIHRpbWVDb250ZXh0LnN0YXJ0ID0gdGltZUNvbnRleHQucGFyZW50LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKTtcbiAgICB0aW1lQ29udGV4dC5vZmZzZXQgPSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0T2Zmc2V0KTtcbiAgICB0aW1lQ29udGV4dC5kdXJhdGlvbiA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRXaWR0aCk7XG4gIH1cblxuICBfZWRpdFJpZ2h0KHRpbWVDb250ZXh0LCBkeCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwodGltZUNvbnRleHQuZHVyYXRpb24pO1xuICAgIGNvbnN0IHRhcmdldFdpZHRoID0gTWF0aC5tYXgod2lkdGggKyBkeCwgMSk7XG5cbiAgICB0aW1lQ29udGV4dC5kdXJhdGlvbiA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRXaWR0aCk7XG4gIH1cblxuICBfbW92ZSh0aW1lQ29udGV4dCwgZHgpIHtcbiAgICBjb25zdCB4ID0gdGltZUNvbnRleHQucGFyZW50LnRpbWVUb1BpeGVsKHRpbWVDb250ZXh0LnN0YXJ0KTtcbiAgICBjb25zdCB0YXJnZXRYID0gTWF0aC5tYXgoeCArIGR4LCAwKTtcblxuICAgIHRpbWVDb250ZXh0LnN0YXJ0ID0gdGltZUNvbnRleHQucGFyZW50LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKTtcbiAgfVxuXG4gIHN0cmV0Y2gobGF5ZXIsIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgdGltZUNvbnRleHQgPSBsYXllci50aW1lQ29udGV4dDtcbiAgICBjb25zdCBsYXN0RHVyYXRpb24gPSB0aW1lQ29udGV4dC5kdXJhdGlvbjtcbiAgICBjb25zdCBsYXN0T2Zmc2V0ID0gdGltZUNvbnRleHQub2Zmc2V0O1xuXG4gICAgdGhpcy5lZGl0KGxheWVyLCBkeCwgZHksIHRhcmdldCk7XG5cbiAgICBjb25zdCBuZXdEdXJhdGlvbiA9IHRpbWVDb250ZXh0LmR1cmF0aW9uO1xuICAgIGNvbnN0IHJhdGlvID0gKG5ld0R1cmF0aW9uIC8gbGFzdER1cmF0aW9uKTtcblxuICAgIHRpbWVDb250ZXh0LnN0cmV0Y2hSYXRpbyAqPSByYXRpbztcbiAgICB0aW1lQ29udGV4dC5vZmZzZXQgPSBsYXN0T2Zmc2V0O1xuICAgIHRpbWVDb250ZXh0LmR1cmF0aW9uID0gbGFzdER1cmF0aW9uO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVDb250ZXh0QmVoYXZpb3I7XG4iLCJpbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vQmFzZUJlaGF2aW9yJztcblxuXG4vKipcbiAqIERlZmluZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGEgdHJhY2UgdmlzdWFsaXphdGlvbi5cbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci10cmFjZS5odG1sKVxuICovXG5jbGFzcyBUcmFjZUJlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcbiAgZWRpdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ21pbicpKSB7XG4gICAgICB0aGlzLl9lZGl0UmFuZ2UocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksICdtaW4nKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ21heCcpKSB7XG4gICAgICB0aGlzLl9lZGl0UmFuZ2UocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksICdtYXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZWRpdE1lYW4ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHkpO1xuICAgIH1cbiAgfVxuXG4gIF9lZGl0TWVhbihyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSkge1xuICAgIC8vIHdvcmsgaW4gcGl4ZWwgZG9tYWluXG4gICAgY29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUueChkYXR1bSkpO1xuICAgIGNvbnN0IHkgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS5tZWFuKGRhdHVtKSk7XG5cbiAgICBsZXQgdGFyZ2V0WCA9IHggKyBkeDtcbiAgICBsZXQgdGFyZ2V0WSA9IHkgLSBkeTtcblxuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICBzaGFwZS5tZWFuKGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5pbnZlcnQodGFyZ2V0WSkpO1xuICB9XG5cbiAgX2VkaXRSYW5nZShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgcmFuZ2VTaWRlKSB7XG4gICAgY29uc3QgcmFuZ2UgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS5yYW5nZShkYXR1bSkpO1xuXG4gICAgbGV0IHRhcmdldFJhbmdlID0gcmFuZ2VTaWRlID09PSAnbWluJyA/IHJhbmdlICsgMiAqIGR5IDogcmFuZ2UgLSAyICogZHk7XG4gICAgdGFyZ2V0UmFuZ2UgPSBNYXRoLm1heCh0YXJnZXRSYW5nZSwgMCk7XG5cbiAgICBzaGFwZS5yYW5nZShkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFJhbmdlKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJhY2VCZWhhdmlvcjtcbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgbnMgZnJvbSAnLi9uYW1lc3BhY2UnO1xuaW1wb3J0IHNjYWxlcyBmcm9tICcuLi91dGlscy9zY2FsZXMnO1xuaW1wb3J0IFNlZ21lbnQgZnJvbSAnLi4vc2hhcGVzL1NlZ21lbnQnO1xuaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuLi9zaGFwZXMvQmFzZVNoYXBlJztcbmltcG9ydCBUaW1lQ29udGV4dEJlaGF2aW9yIGZyb20gJy4uL2JlaGF2aW9ycy9UaW1lQ29udGV4dEJlaGF2aW9yJztcblxuLy8gdGltZSBjb250ZXh0IGJhaGV2aW9yXG5sZXQgdGltZUNvbnRleHRCZWhhdmlvciA9IG51bGw7XG5sZXQgdGltZUNvbnRleHRCZWhhdmlvckN0b3IgPSBUaW1lQ29udGV4dEJlaGF2aW9yO1xuXG4vKipcbiAqIFRoZSBsYXllciBjbGFzcyBpcyB0aGUgbWFpbiB2aXN1YWxpemF0aW9uIGNsYXNzLiBJdCBpcyBtYWlubHkgZGVmaW5lcyBieSBpdHNcbiAqIHJlbGF0ZWQgYExheWVyVGltZUNvbnRleHRgIHdoaWNoIGRldGVybWluZXMgaXRzIHBvc2l0aW9uIGluIHRoZSBvdmVyYWxsXG4gKiB0aW1lbGluZSAodGhyb3VnaCB0aGUgYHN0YXJ0YCwgYGR1cmF0aW9uYCwgYG9mZnNldGAgYW5kIGBzdHJldGNoUmF0aW9gXG4gKiBhdHRyaWJ1dGVzKSBhbmQgYnkgaXQncyByZWdpc3RlcmVkIFNoYXBlIHdoaWNoIGRlZmluZXMgaG93IHRvIGRpc3BsYXkgdGhlXG4gKiBkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIGxheWVyLiBFYWNoIGNyZWF0ZWQgbGF5ZXIgbXVzdCBiZSBpbnNlcnRlZCBpbnRvIGFcbiAqIGBUcmFja2AgaW5zdGFuY2UgaW4gb3JkZXIgdG8gYmUgZGlzcGxheWVkLlxuICpcbiAqIF9Ob3RlOiBpbiB0aGUgY29udGV4dCBvZiB0aGUgbGF5ZXIsIGFuIF9faXRlbV9fIGlzIHRoZSBTVkcgZWxlbWVudFxuICogcmV0dXJuZWQgYnkgYSBgU2hhcGVgIGluc3RhbmNlIGFuZCBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIF9fZGF0dW1fXy5fXG4gKlxuICogIyMjIExheWVyIERPTSBzdHJ1Y3R1cmVcbiAqIGBgYFxuICogPGcgY2xhc3M9XCJsYXllclwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgke3N0YXJ0fSwgMClcIj5cbiAqICAgPHN2ZyBjbGFzcz1cImJvdW5kaW5nLWJveFwiIHdpZHRoPVwiJHtkdXJhdGlvbn1cIj5cbiAqICAgICA8ZyBjbGFzcz1cIm9mZnNldFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgke29mZnNldCwgMH0pXCI+XG4gKiAgICAgICA8IS0tIGJhY2tncm91bmQgLS0+XG4gKiAgICAgICA8cmVjdCBjbGFzcz1cImJhY2tncm91bmRcIj48L3JlY3Q+XG4gKiAgICAgICA8IS0tIHNoYXBlcyBhbmQgY29tbW9uIHNoYXBlcyBhcmUgaW5zZXJ0ZWQgaGVyZSAtLT5cbiAqICAgICA8L2c+XG4gKiAgICAgPGcgY2xhc3M9XCJpbnRlcmFjdGlvbnNcIj48IS0tIGZvciBmZWVkYmFjayAtLT48L2c+XG4gKiAgIDwvc3ZnPlxuICogPC9nPlxuICogYGBgXG4gKi9cbmNsYXNzIExheWVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhVHlwZSAtIERlZmluZXMgaG93IHRoZSBsYXllciBzaG91bGQgbG9vayBhdCB0aGUgZGF0YS5cbiAgICogICAgQ2FuIGJlICdlbnRpdHknIG9yICdjb2xsZWN0aW9uJy5cbiAgICogQHBhcmFtIHsoQXJyYXl8T2JqZWN0KX0gZGF0YSAtIFRoZSBkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENvbmZpZ3VyZXMgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTEwMF0gLSBEZWZpbmVzIHRoZSBoZWlnaHQgb2YgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9wPTBdIC0gRGVmaW5lcyB0aGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9wYWNpdHk9MV0gLSBEZWZpbmVzIHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnlEb21haW49WzAsMV1dIC0gRGVmaW5lcyBib3VuZGFyaWVzIG9mIHRoZSBkYXRhXG4gICAqICAgIHZhbHVlcyBpbiB5IGF4aXMgKGZvciBleGVtcGxlIHRvIGRpc3BsYXkgYW4gYXVkaW8gYnVmZmVyLCB0aGlzIGF0dHJpYnV0ZVxuICAgKiAgICBzaG91bGQgYmUgc2V0IHRvIFstMSwgMV0uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jbGFzc05hbWU9bnVsbF0gLSBBbiBvcHRpb25uYWwgY2xhc3MgdG8gYWRkIHRvIGVhY2hcbiAgICogICAgY3JlYXRlZCBzaGFwZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNsYXNzTmFtZT0nc2VsZWN0ZWQnXSAtIFRoZSBjbGFzcyB0byBhZGQgdG8gYSBzaGFwZVxuICAgKiAgICB3aGVuIHNlbGVjdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29udGV4dEhhbmRsZXJXaWR0aD0yXSAtIFRoZSB3aWR0aCBvZiB0aGUgaGFuZGxlcnNcbiAgICogICAgZGlzcGxheWVkIHRvIGVkaXQgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGl0dGFibGU9ZmFsc2VdIC0gRGVmaW5lcyBpZiB0aGUgbGF5ZXIgY2FuIGJlIGludGVyYWN0ZWRcbiAgICogICAgd2l0aC4gQmFzaWNhbGx5LCB0aGUgbGF5ZXIgaXMgbm90IHJldHVybmVkIGJ5IGBCYXNlU3RhdGUuZ2V0SGl0TGF5ZXJzYCB3aGVuXG4gICAqICAgIHNldCB0byBmYWxzZSAoYSBjb21tb24gdXNlIGNhc2UgaXMgYSBsYXllciB0aGF0IGNvbnRhaW5zIGEgY3Vyc29yKVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3pJbmRleD0wXSAtIHpJbmRleCBvZiB0aGUgbGF5ZXIsIHNob3VsZCBiZSA+PSAwXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhVHlwZSwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgaGVpZ2h0OiAxMDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgeURvbWFpbjogWzAsIDFdLFxuICAgICAgY2xhc3NOYW1lOiBudWxsLFxuICAgICAgc2VsZWN0ZWRDbGFzc05hbWU6ICdzZWxlY3RlZCcsXG4gICAgICBjb250ZXh0SGFuZGxlcldpZHRoOiAyLFxuICAgICAgaGl0dGFibGU6IHRydWUsIC8vIHdoZW4gZmFsc2UgdGhlIGxheWVyIGlzIG5vdCByZXR1cm5lZCBieSBgQmFzZVN0YXRlLmdldEhpdExheWVyc2BcbiAgICAgIGlkOiAnJywgLy8gdXNlZCA/XG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsIC8vIHVzZWZ1bGwgP1xuICAgICAgekluZGV4OiAwLCAvLyB6SW5kZXggb2YgdGhlIGxheWVyLCBjYW5ub3QgYmUgbmVnYXRpdmVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyYW1ldGVycyBvZiB0aGUgbGF5ZXJzLCBgZGVmYXVsdHNgIG92ZXJyaWRlZCB3aXRoIG9wdGlvbnMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGhvdyB0aGUgbGF5ZXIgc2hvdWxkIGxvb2sgYXQgdGhlIGRhdGEgKGAnZW50aXR5J2Agb3IgYCdjb2xsZWN0aW9uJ2ApLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5kYXRhVHlwZSA9IGRhdGFUeXBlOyAvLyAnZW50aXR5JyB8fCAnY29sbGVjdGlvbic7XG4gICAgLyoqIEB0eXBlIHtMYXllclRpbWVDb250ZXh0fSAqL1xuICAgIHRoaXMudGltZUNvbnRleHQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7RWxlbWVudH0gKi9cbiAgICB0aGlzLiRlbCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgIHRoaXMuJGJhY2tncm91bmQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7RWxlbWVudH0gKi9cbiAgICB0aGlzLiRib3VuZGluZ0JveCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgIHRoaXMuJG9mZnNldCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgIHRoaXMuJGludGVyYWN0aW9ucyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQSBTZWdtZW50IGluc3RhbmNpYXRlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBMYXllciBpdHNlbGYuXG4gICAgICogQHR5cGUge1NlZ21lbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0U2hhcGUgPSBudWxsO1xuXG4gICAgdGhpcy5fc2hhcGVDb25maWd1cmF0aW9uID0gbnVsbDsgICAgICAgLy8geyBjdG9yLCBhY2Nlc3NvcnMsIG9wdGlvbnMgfVxuICAgIHRoaXMuX2NvbW1vblNoYXBlQ29uZmlndXJhdGlvbiA9IG51bGw7IC8vIHsgY3RvciwgYWNjZXNzb3JzLCBvcHRpb25zIH1cbiAgICB0aGlzLl8kaXRlbVNoYXBlTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuXyRpdGVtRGF0YU1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl8kaXRlbUNvbW1vblNoYXBlTWFwID0gbmV3IE1hcCgpO1xuXG4gICAgdGhpcy5faXNDb250ZXh0RWRpdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLl9iZWhhdmlvciA9IG51bGw7XG5cbiAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLnBhcmFtcy5oZWlnaHQ7XG4gICAgdGhpcy5fdG9wID0gdGhpcy5wYXJhbXMudG9wO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucGFyYW1zLnlEb21haW4pO1xuICAgIC8vIGNvbnNvbGUubG9nKFt0aGlzLl9oZWlnaHQsIDBdKVxuICAgIHRoaXMuX3ZhbHVlVG9QaXhlbCA9IHNjYWxlcy5saW5lYXIoKVxuICAgICAgLmRvbWFpbih0aGlzLnBhcmFtcy55RG9tYWluKVxuICAgICAgLnJhbmdlKFswLCB0aGlzLl9oZWlnaHRdKTtcbiAgICAgIC8vIC5yYW5nZShbdGhpcy5faGVpZ2h0LCAwXSk7XG5cbiAgICAvLyBpbml0aWFsaXplIHRpbWVDb250ZXh0IGxheW91dFxuICAgIHRoaXMuX3JlbmRlckNvbnRhaW5lcigpO1xuICAgIC8vIGNyZWF0ZXMgdGhlIHRpbWVDb250ZXh0QmVoYXZpb3IgZm9yIGFsbCBsYXllcnNcbiAgICBpZiAodGltZUNvbnRleHRCZWhhdmlvciA9PT0gbnVsbCkge1xuICAgICAgdGltZUNvbnRleHRCZWhhdmlvciA9IG5ldyB0aW1lQ29udGV4dEJlaGF2aW9yQ3RvcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBsYXllciwgY2xlYXIgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMudGltZUNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuICAgIHRoaXMuX2JlaGF2aW9yID0gbnVsbDtcblxuICAgIHRoaXMuXyRpdGVtU2hhcGVNYXAuY2xlYXIoKTtcbiAgICB0aGlzLl8kaXRlbURhdGFNYXAuY2xlYXIoKTtcbiAgICB0aGlzLl8kaXRlbUNvbW1vblNoYXBlTWFwLmNsZWFyKCk7XG5cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyB0byBvdmVycmlkZSBkZWZhdWx0IHRoZSBgVGltZUNvbnRleHRCZWhhdmlvcmAgdXNlZCB0byBlZGl0IHRoZSBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGN0b3JcbiAgICovXG4gIHN0YXRpYyBjb25maWd1cmVUaW1lQ29udGV4dEJlaGF2aW9yKGN0b3IpIHtcbiAgICB0aW1lQ29udGV4dEJlaGF2aW9yQ3RvciA9IGN0b3I7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgTGF5ZXJUaW1lQ29udGV4dGAncyBgc3RhcnRgIHRpbWUgZG9tYWluIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVDb250ZXh0LnN0YXJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYExheWVyVGltZUNvbnRleHRgJ3MgYHN0YXJ0YCB0aW1lIGRvbWFpbiB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBzdGFydCh2YWx1ZSkge1xuICAgIHRoaXMudGltZUNvbnRleHQuc3RhcnQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGBMYXllclRpbWVDb250ZXh0YCdzIGBvZmZzZXRgIHRpbWUgZG9tYWluIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC5vZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBgTGF5ZXJUaW1lQ29udGV4dGAncyBgb2Zmc2V0YCB0aW1lIGRvbWFpbiB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLnRpbWVDb250ZXh0Lm9mZnNldCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYExheWVyVGltZUNvbnRleHRgJ3MgYGR1cmF0aW9uYCB0aW1lIGRvbWFpbiB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC5kdXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGBMYXllclRpbWVDb250ZXh0YCdzIGBkdXJhdGlvbmAgdGltZSBkb21haW4gdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgZHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnRpbWVDb250ZXh0LmR1cmF0aW9uID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgTGF5ZXJUaW1lQ29udGV4dGAncyBgc3RyZXRjaFJhdGlvYCB0aW1lIGRvbWFpbiB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzdHJldGNoUmF0aW8oKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZUNvbnRleHQuc3RyZXRjaFJhdGlvO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYExheWVyVGltZUNvbnRleHRgJ3MgYHN0cmV0Y2hSYXRpb2AgdGltZSBkb21haW4gdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgc3RyZXRjaFJhdGlvKHZhbHVlKSB7XG4gICAgdGhpcy50aW1lQ29udGV4dC5zdHJldGNoUmF0aW8gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRvbWFpbiBib3VuZGFyaWVzIG9mIHRoZSBkYXRhIGZvciB0aGUgeSBheGlzLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICBzZXQgeURvbWFpbihkb21haW4pIHtcbiAgICB0aGlzLnBhcmFtcy55RG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMuX3ZhbHVlVG9QaXhlbC5kb21haW4oZG9tYWluKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkb21haW4gYm91bmRhcmllcyBvZiB0aGUgZGF0YSBmb3IgdGhlIHkgYXhpcy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgZ2V0IHlEb21haW4oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLnlEb21haW47XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgd2hvbGUgbGF5ZXIuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgb3BhY2l0eSh2YWx1ZSkge1xuICAgIHRoaXMucGFyYW1zLm9wYWNpdHkgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcGFjaXR5IG9mIHRoZSB3aG9sZSBsYXllci5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBvcGFjaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy5vcGFjaXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRyYW5zZmVydCBmdW5jdGlvbiB1c2VkIHRvIGRpc3BsYXkgdGhlIGRhdGEgaW4gdGhlIHggYXhpcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB0aW1lVG9QaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0cmFuc2ZlcnQgZnVuY3Rpb24gdXNlZCB0byBkaXNwbGF5IHRoZSBkYXRhIGluIHRoZSB5IGF4aXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgdmFsdWVUb1BpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZVRvUGl4ZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgZGlzcGxheWVkIGl0ZW1zLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8RWxlbWVudD59XG4gICAqL1xuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fJGl0ZW1EYXRhTWFwLmtleXMoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSBsYXllci5cbiAgICpcbiAgICogQHR5cGUge09iamVjdFtdfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7IHJldHVybiB0aGlzLl9kYXRhOyB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBsYXllci5cbiAgICpcbiAgICogQHR5cGUge09iamVjdHxPYmplY3RbXX1cbiAgICovXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICBzd2l0Y2ggKHRoaXMuZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgJ2VudGl0eSc6XG4gICAgICAgIGlmICh0aGlzLl9kYXRhKSB7ICAvLyBpZiBkYXRhIGFscmVhZHkgZXhpc3RzLCByZXVzZSB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgdGhpcy5fZGF0YVswXSA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbGxlY3Rpb24nOlxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSGVpZ2h0KHByZXZUcmFja0hlaWdodCwgbmV3VHJhY2tIZWlnaHQpIHtcbiAgICBjb25zdCByYXRpbyA9IG5ld1RyYWNrSGVpZ2h0IC8gcHJldlRyYWNrSGVpZ2h0O1xuXG4gICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5faGVpZ2h0ICogcmF0aW87XG4gICAgdGhpcy5fdG9wID0gdGhpcy5fdG9wICogcmF0aW87XG4gICAgdGhpcy5fdmFsdWVUb1BpeGVsLnJhbmdlKFswLCB0aGlzLl9oZWlnaHRdKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gSW5pdGlhbGl6YXRpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgRE9NIGluIG1lbW9yeSBvbiBsYXllciBjcmVhdGlvbiB0byBiZSBhYmxlIHRvIHVzZSBpdCBiZWZvcmVcbiAgICogdGhlIGxheWVyIGlzIGFjdHVhbGx5IGluc2VydGVkIGluIHRoZSBET00uXG4gICAqL1xuICBfcmVuZGVyQ29udGFpbmVyKCkge1xuICAgIC8vIHdyYXBwZXIgZ3JvdXAgZm9yIGBzdGFydCwgdG9wIGFuZCBjb250ZXh0IGZsaXAgbWF0cml4XG4gICAgdGhpcy4kZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdnJyk7XG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCgnbGF5ZXInKTtcblxuICAgIGlmICh0aGlzLnBhcmFtcy5jbGFzc05hbWUgIT09IG51bGwpXG4gICAgICB0aGlzLiRlbC5jbGFzc0xpc3QuYWRkKHRoaXMucGFyYW1zLmNsYXNzTmFtZSk7XG5cbiAgICAvLyBjbGlwIHRoZSBjb250ZXh0IHdpdGggYSBgc3ZnYCBlbGVtZW50XG4gICAgdGhpcy4kYm91bmRpbmdCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdzdmcnKTtcbiAgICB0aGlzLiRib3VuZGluZ0JveC5jbGFzc0xpc3QuYWRkKCdib3VuZGluZy1ib3gnKTtcbiAgICB0aGlzLiRib3VuZGluZ0JveC5zdHlsZS5vdmVyZmxvdyA9IHRoaXMucGFyYW1zLm92ZXJmbG93O1xuICAgIC8vIGdyb3VwIHRvIGFwcGx5IG9mZnNldFxuICAgIHRoaXMuJG9mZnNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ2cnKTtcbiAgICB0aGlzLiRvZmZzZXQuY2xhc3NMaXN0LmFkZCgnb2Zmc2V0JywgJ2l0ZW1zJyk7XG4gICAgLy8gbGF5ZXIgYmFja2dyb3VuZFxuICAgIHRoaXMuJGJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdyZWN0Jyk7XG4gICAgdGhpcy4kYmFja2dyb3VuZC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgJzEwMCUnKTtcbiAgICB0aGlzLiRiYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsICcxMDAlJyk7XG4gICAgdGhpcy4kYmFja2dyb3VuZC5jbGFzc0xpc3QuYWRkKCdiYWNrZ3JvdW5kJyk7XG4gICAgdGhpcy4kYmFja2dyb3VuZC5zdHlsZS5maWxsT3BhY2l0eSA9IDA7XG4gICAgdGhpcy4kYmFja2dyb3VuZC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIC8vIGNvbnRleHQgaW50ZXJhY3Rpb25zXG4gICAgdGhpcy4kaW50ZXJhY3Rpb25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnZycpO1xuICAgIHRoaXMuJGludGVyYWN0aW9ucy5jbGFzc0xpc3QuYWRkKCdpbnRlcmFjdGlvbnMnKTtcbiAgICB0aGlzLiRpbnRlcmFjdGlvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAvLyBATk9URTogd29ya3MgYnV0IGtpbmcgb2YgdWdseS4uLiBzaG91bGQgYmUgY2xlYW5lZFxuICAgIHRoaXMuY29udGV4dFNoYXBlID0gbmV3IFNlZ21lbnQoKTtcbiAgICB0aGlzLmNvbnRleHRTaGFwZS5pbnN0YWxsKHtcbiAgICAgIG9wYWNpdHk6ICgpID0+IDAuMSxcbiAgICAgIGNvbG9yICA6ICgpID0+ICcjNzg3ODc4JyxcbiAgICAgIHdpZHRoICA6ICgpID0+IHRoaXMudGltZUNvbnRleHQuZHVyYXRpb24sXG4gICAgICBoZWlnaHQgOiAoKSA9PiB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5kb21haW4oKVsxXSxcbiAgICAgIHkgICAgICA6ICgpID0+IHRoaXMuX3JlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmRvbWFpbigpWzBdXG4gICAgfSk7XG5cbiAgICB0aGlzLiRpbnRlcmFjdGlvbnMuYXBwZW5kQ2hpbGQodGhpcy5jb250ZXh0U2hhcGUucmVuZGVyKCkpO1xuICAgIC8vIGNyZWF0ZSB0aGUgRE9NIHRyZWVcbiAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZCh0aGlzLiRib3VuZGluZ0JveCk7XG4gICAgdGhpcy4kYm91bmRpbmdCb3guYXBwZW5kQ2hpbGQodGhpcy4kb2Zmc2V0KTtcbiAgICB0aGlzLiRvZmZzZXQuYXBwZW5kQ2hpbGQodGhpcy4kYmFja2dyb3VuZCk7XG4gICAgdGhpcy4kYm91bmRpbmdCb3guYXBwZW5kQ2hpbGQodGhpcy4kaW50ZXJhY3Rpb25zKTtcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIENvbXBvbmVudCBDb25maWd1cmF0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbnRleHQgb2YgdGhlIGxheWVyLCB0aHVzIGRlZmluaW5nIGl0cyBgc3RhcnRgLCBgZHVyYXRpb25gLFxuICAgKiBgb2Zmc2V0YCBhbmQgYHN0cmV0Y2hSYXRpb2AuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZUNvbnRleHR9IHRpbWVDb250ZXh0IC0gVGhlIHRpbWVDb250ZXh0IGluIHdoaWNoIHRoZSBsYXllciBpcyBkaXNwbGF5ZWQuXG4gICAqL1xuICBzZXRUaW1lQ29udGV4dCh0aW1lQ29udGV4dCkge1xuICAgIHRoaXMudGltZUNvbnRleHQgPSB0aW1lQ29udGV4dDtcbiAgICAvLyBjcmVhdGUgYSBtaXhpbiB0byBwYXNzIHRvIHRoZSBzaGFwZXNcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0ID0ge307XG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyaW5nQ29udGV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgc2hhcGUgYW5kIGl0cyBjb25maWd1cmF0aW9uIHRvIHVzZSBpbiBvcmRlciB0byByZW5kZXIgdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZVNoYXBlfSBjdG9yIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzaGFwZSB0byBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2FjY2Vzc29ycz17fV0gLSBEZWZpbmVzIGhvdyB0aGUgc2hhcGUgc2hvdWxkIGFkYXB0IHRvIGEgcGFydGljdWxhciBkYXRhIHN0cnV0dXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gR2xvYmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzaGFwZXMsIGlzIHNwZWNpZmljIHRvIGVhY2ggYFNoYXBlYC5cbiAgICovXG4gIGNvbmZpZ3VyZVNoYXBlKGN0b3IsIGFjY2Vzc29ycyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9zaGFwZUNvbmZpZ3VyYXRpb24gPSB7IGN0b3IsIGFjY2Vzc29ycywgb3B0aW9ucyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdGlvbm5hbHkgcmVnaXN0ZXIgYSBzaGFwZSB0byBiZSB1c2VkIGFjY3JvcyB0aGUgZW50aXJlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZVNoYXBlfSBjdG9yIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzaGFwZSB0byBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2FjY2Vzc29ycz17fV0gLSBEZWZpbmVzIGhvdyB0aGUgc2hhcGUgc2hvdWxkIGFkYXB0IHRvIGEgcGFydGljdWxhciBkYXRhIHN0cnV0dXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gR2xvYmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzaGFwZXMsIGlzIHNwZWNpZmljIHRvIGVhY2ggYFNoYXBlYC5cbiAgICovXG4gIGNvbmZpZ3VyZUNvbW1vblNoYXBlKGN0b3IsIGFjY2Vzc29ycyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9jb21tb25TaGFwZUNvbmZpZ3VyYXRpb24gPSB7IGN0b3IsIGFjY2Vzc29ycywgb3B0aW9ucyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRoZSBiZWhhdmlvciB0byB1c2Ugd2hlbiBpbnRlcmFjdGluZyB3aXRoIGEgc2hhcGUuXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZUJlaGF2aW9yfSBiZWhhdmlvclxuICAgKi9cbiAgc2V0QmVoYXZpb3IoYmVoYXZpb3IpIHtcbiAgICBiZWhhdmlvci5pbml0aWFsaXplKHRoaXMpO1xuICAgIHRoaXMuX2JlaGF2aW9yID0gYmVoYXZpb3I7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdmFsdWVzIHN0b3JlZCBpbnQgdGhlIGBfcmVuZGVyaW5nQ29udGV4dGAgcGFzc2VkICB0byBzaGFwZXNcbiAgICogZm9yIHJlbmRlcmluZyBhbmQgdXBkYXRpbmcuXG4gICAqL1xuICBfdXBkYXRlUmVuZGVyaW5nQ29udGV4dCgpIHtcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbDtcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCA9IHRoaXMuX3ZhbHVlVG9QaXhlbDtcblxuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICBjb25zdCB3aWR0aCAgPSB0aGlzLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMudGltZUNvbnRleHQuZHVyYXRpb24pO1xuICAgIGNvbnN0IG9mZnNldFggPSB0aGlzLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMudGltZUNvbnRleHQub2Zmc2V0KTtcbiAgICBjb25zdCBzdGFydFggPSB0aGlzLnRpbWVDb250ZXh0LnBhcmVudC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0LnN0YXJ0KTtcbiAgICBjb25zdCB0cmFja09mZnNldFggPSB0aGlzLnRpbWVDb250ZXh0LnBhcmVudC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0LnBhcmVudC5vZmZzZXQpO1xuICAgIGNvbnN0IHZpc2libGVXaWR0aCA9IHRoaXMudGltZUNvbnRleHQucGFyZW50LnZpc2libGVXaWR0aDtcblxuICAgIC8vIEB0b2RvIC0gbWFrZSB0aGlzIG1lc3MgbW9yZSByZWFkYWJsZVxuICAgIGxldCBtaW5YID0gTWF0aC5tYXgoLW9mZnNldFgsIDApO1xuICAgIGxldCB0cmFja0RlY2F5ID0gdHJhY2tPZmZzZXRYICsgc3RhcnRYO1xuICAgIGlmICh0cmFja0RlY2F5IDwgMClcbiAgICAgIG1pblggPSAtdHJhY2tEZWNheTtcblxuICAgIGxldCBtYXhYID0gbWluWDtcbiAgICBtYXhYICs9ICh3aWR0aCAtIG1pblggPCB2aXNpYmxlV2lkdGgpID8gd2lkdGggOiB2aXNpYmxlV2lkdGg7XG5cbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnN0YXJ0WCA9IHN0YXJ0WDtcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0Lm1pblggPSBtaW5YO1xuICAgIHRoaXMuX3JlbmRlcmluZ0NvbnRleHQubWF4WCA9IG1heFg7XG4gICAgLy8gbmVlZGVkIGZvciBjYW52YXMgZm9yZWlnbk9iamVjdHMgaW4gY2hyb21lIGFuZCBzYWZhcmlcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnRyYWNrT2Zmc2V0WCA9IHRyYWNrT2Zmc2V0WDtcbiAgICAvLyB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnZpc2libGVXaWR0aCA9IHZpc2libGVXaWR0aDtcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEJlaGF2aW9yIEFjY2Vzc29yc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVtcyBtYXJrZWQgYXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxFbGVtZW50Pn1cbiAgICovXG4gIGdldCBzZWxlY3RlZEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9iZWhhdmlvciA/IHRoaXMuX2JlaGF2aW9yLnNlbGVjdGVkSXRlbXMgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIGl0ZW0ocykgYXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119ICRpdGVtc1xuICAgKi9cbiAgc2VsZWN0KC4uLiRpdGVtcykge1xuICAgIGlmICghdGhpcy5fYmVoYXZpb3IpIHsgcmV0dXJuOyB9XG4gICAgaWYgKCEkaXRlbXMubGVuZ3RoKSB7ICRpdGVtcyA9IHRoaXMuXyRpdGVtRGF0YU1hcC5rZXlzKCk7IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSgkaXRlbXNbMF0pKSB7ICRpdGVtcyA9ICRpdGVtc1swXTsgfVxuXG4gICAgZm9yIChsZXQgJGl0ZW0gb2YgJGl0ZW1zKSB7XG4gICAgICBjb25zdCBkYXR1bSA9IHRoaXMuXyRpdGVtRGF0YU1hcC5nZXQoJGl0ZW0pO1xuICAgICAgdGhpcy5fYmVoYXZpb3Iuc2VsZWN0KCRpdGVtLCBkYXR1bSk7XG4gICAgICB0aGlzLl90b0Zyb250KCRpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBpdGVtKHMpIGZyb20gc2VsZWN0ZWQgaXRlbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119ICRpdGVtc1xuICAgKi9cbiAgdW5zZWxlY3QoLi4uJGl0ZW1zKSB7XG4gICAgaWYgKCF0aGlzLl9iZWhhdmlvcikgeyByZXR1cm47IH1cbiAgICBpZiAoISRpdGVtcy5sZW5ndGgpIHsgJGl0ZW1zID0gdGhpcy5fJGl0ZW1EYXRhTWFwLmtleXMoKTsgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KCRpdGVtc1swXSkpIHsgJGl0ZW1zID0gJGl0ZW1zWzBdOyB9XG5cbiAgICBmb3IgKGxldCAkaXRlbSBvZiAkaXRlbXMpIHtcbiAgICAgIGNvbnN0IGRhdHVtID0gdGhpcy5fJGl0ZW1EYXRhTWFwLmdldCgkaXRlbSk7XG4gICAgICB0aGlzLl9iZWhhdmlvci51bnNlbGVjdCgkaXRlbSwgZGF0dW0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgaXRlbShzKSBzZWxlY3Rpb24gc3RhdGUgYWNjb3JkaW5nIHRvIHRoZWlyIGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119ICRpdGVtc1xuICAgKi9cbiAgdG9nZ2xlU2VsZWN0aW9uKC4uLiRpdGVtcykge1xuICAgIGlmICghdGhpcy5fYmVoYXZpb3IpIHsgcmV0dXJuOyB9XG4gICAgaWYgKCEkaXRlbXMubGVuZ3RoKSB7ICRpdGVtcyA9IHRoaXMuXyRpdGVtRGF0YU1hcC5rZXlzKCk7IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSgkaXRlbXNbMF0pKSB7ICRpdGVtcyA9ICRpdGVtc1swXTsgfVxuXG4gICAgZm9yIChsZXQgJGl0ZW0gb2YgJGl0ZW1zKSB7XG4gICAgICBjb25zdCBkYXR1bSA9IHRoaXMuXyRpdGVtRGF0YU1hcC5nZXQoJGl0ZW0pO1xuICAgICAgdGhpcy5fYmVoYXZpb3IudG9nZ2xlU2VsZWN0aW9uKCRpdGVtLCBkYXR1bSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVkaXQgaXRlbShzKSBhY2NvcmRpbmcgdG8gdGhlIGBlZGl0YCBkZWZpbmVkIGluIHRoZSByZWdpc3RlcmVkIGBCZWhhdmlvcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119ICRpdGVtcyAtIEl0ZW0ocykgdG8gZWRpdFxuICAgKiBAcGFyYW0ge051bWJlcn0gZHggLSBNb2RpZmljYXRpb24gdG8gYXBwbHkgaW4gdGhlIHggYXhpcyAoaW4gcGl4ZWwgZG9tYWluKVxuICAgKiBAcGFyYW0ge051bWJlcn0gZHkgLSBNb2RpZmljYXRpb24gdG8gYXBwbHkgaW4gdGhlIHkgYXhpcyAoaW4gcGl4ZWwgZG9tYWluKVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICR0YXJnZXQgLSBUYXJnZXQgb2YgdGhlIGludGVyYWN0aW9uIChmb3IgZXhhbXBsZSwgbGVmdFxuICAgKiAgaGFuZGxlciBET00gZWxlbWVudCBpbiBhIHNlZ21lbnQpLlxuICAgKi9cbiAgZWRpdCgkaXRlbXMsIGR4LCBkeSwgJHRhcmdldCkge1xuICAgIGlmICghdGhpcy5fYmVoYXZpb3IpIHsgcmV0dXJuOyB9XG4gICAgJGl0ZW1zID0gIUFycmF5LmlzQXJyYXkoJGl0ZW1zKSA/IFskaXRlbXNdIDogJGl0ZW1zO1xuXG4gICAgZm9yIChsZXQgJGl0ZW0gb2YgJGl0ZW1zKSB7XG4gICAgICBjb25zdCBzaGFwZSA9IHRoaXMuXyRpdGVtU2hhcGVNYXAuZ2V0KCRpdGVtKTtcbiAgICAgIGNvbnN0IGRhdHVtID0gdGhpcy5fJGl0ZW1EYXRhTWFwLmdldCgkaXRlbSk7XG5cbiAgICAgIHRoaXMuX2JlaGF2aW9yLmVkaXQodGhpcy5fcmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksICR0YXJnZXQpO1xuICAgICAgdGhpcy5lbWl0KCdlZGl0Jywgc2hhcGUsIGRhdHVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lcyBpZiB0aGUgYExheWVyYCwgYW5kIHRodXMgdGhlIGBMYXllclRpbWVDb250ZXh0YCBpcyBlZGl0YWJsZSBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbXMge0Jvb2xlYW59IFtib29sPXRydWVdXG4gICAqL1xuICBzZXRDb250ZXh0RWRpdGFibGUoYm9vbCA9IHRydWUpIHtcbiAgICBjb25zdCBkaXNwbGF5ID0gYm9vbCA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgdGhpcy4kaW50ZXJhY3Rpb25zLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuICAgIHRoaXMuX2lzQ29udGV4dEVkaXRhYmxlID0gYm9vbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFZGl0IHRoZSBsYXllciBhbmQgdGh1cyBpdHMgcmVsYXRlZCBgTGF5ZXJUaW1lQ29udGV4dGAgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR4IC0gVGhlIG1vZGlmaWNhdGlvbiB0byBhcHBseSBpbiB0aGUgeCBheGlzIChpbiBwaXhlbHMpLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHkgLSBUaGUgbW9kaWZpY2F0aW9uIHRvIGFwcGx5IGluIHRoZSB5IGF4aXMgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gJHRhcmdldCAtIFRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50IG9mIHRoZSBpbnRlcmFjdGlvbi5cbiAgICovXG4gIGVkaXRDb250ZXh0KGR4LCBkeSwgJHRhcmdldCkge1xuICAgIHRpbWVDb250ZXh0QmVoYXZpb3IuZWRpdCh0aGlzLCBkeCwgZHksICR0YXJnZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmV0Y2ggdGhlIGxheWVyIGFuZCB0aHVzIGl0cyByZWxhdGVkIGBMYXllclRpbWVDb250ZXh0YCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHggLSBUaGUgbW9kaWZpY2F0aW9uIHRvIGFwcGx5IGluIHRoZSB4IGF4aXMgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkeSAtIFRoZSBtb2RpZmljYXRpb24gdG8gYXBwbHkgaW4gdGhlIHkgYXhpcyAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSAkdGFyZ2V0IC0gVGhlIHRhcmdldCBvZiB0aGUgZXZlbnQgb2YgdGhlIGludGVyYWN0aW9uLlxuICAgKi9cbiAgc3RyZXRjaENvbnRleHQoZHgsIGR5LCAkdGFyZ2V0KSB7XG4gICAgdGltZUNvbnRleHRCZWhhdmlvci5zdHJldGNoKHRoaXMsIGR4LCBkeSwgJHRhcmdldCk7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBIZWxwZXJzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaXRlbSBmcm9tIGEgRE9NIGVsZW1lbnQgcmVsYXRlZCB0byB0aGUgc2hhcGUsIG51bGwgb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICRlbCAtIHRoZSBlbGVtZW50IHRvIGJlIHRlc3RlZFxuICAgKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XG4gICAqL1xuICBnZXRJdGVtRnJvbURPTUVsZW1lbnQoJGVsKSB7XG4gICAgbGV0ICRpdGVtO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKCRlbC5jbGFzc0xpc3QgJiYgJGVsLmNsYXNzTGlzdC5jb250YWlucygnaXRlbScpKSB7XG4gICAgICAgICRpdGVtID0gJGVsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgJGVsID0gJGVsLnBhcmVudE5vZGU7XG4gICAgfSB3aGlsZSAoJGVsICE9PSBudWxsKTtcblxuICAgIHJldHVybiB0aGlzLmhhc0l0ZW0oJGl0ZW0pID8gJGl0ZW0gOsKgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaGFwZSBhc3NvY2lhdGVkIHRvIGEgc3BlY2lmaWMgaXRlbS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSAkaXRlbVxuICAgKiBAcmV0dXJuIHtTaGFwZX1cbiAgICovXG4gIGdldFNoYXBlRnJvbUl0ZW0oJGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy5oYXNJdGVtKCRpdGVtKSA/IHRoaXMuXyRpdGVtU2hhcGVNYXAuZ2V0KCRpdGVtKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2hhcGUgYXNzb2NpYXRlZCB0byBhIHNwZWNpZmljIGl0ZW0gZnJvbSBhbnkgRE9NIGVsZW1lbnRcbiAgICogY29tcG9zaW5nIHRoZSBzaGFwZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSAkaXRlbVxuICAgKiBAcmV0dXJuIHtTaGFwZX1cbiAgICovXG4gIGdldFNoYXBlRnJvbURPTUVsZW1lbnQoJGVsKSB7XG4gICAgY29uc3QgJGl0ZW0gPSB0aGlzLmdldEl0ZW1Gcm9tRE9NRWxlbWVudCgkZWwpO1xuICAgIHJldHVybiB0aGlzLmdldFNoYXBlRnJvbUl0ZW0oJGl0ZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdHVtIGFzc29jaWF0ZWQgdG8gYSBzcGVjaWZpYyBpdGVtLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICRpdGVtXG4gICAqIEByZXR1cm4ge09iamVjdHxBcnJheXxudWxsfVxuICAgKi9cbiAgZ2V0RGF0dW1Gcm9tSXRlbSgkaXRlbSkge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5fJGl0ZW1EYXRhTWFwLmdldCgkaXRlbSk7XG4gICAgcmV0dXJuIGRhdHVtID8gZGF0dW0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdHVtIGFzc29jaWF0ZWQgdG8gYSBzcGVjaWZpYyBpdGVtIGZyb20gYW55IERPTSBlbGVtZW50XG4gICAqIGNvbXBvc2luZyB0aGUgc2hhcGUuIEJhc2ljYWxseSBhIHNob3J0Y3V0IGZvciBgZ2V0SXRlbUZyb21ET01FbGVtZW50YCBhbmRcbiAgICogYGdldERhdHVtRnJvbUl0ZW1gIG1ldGhvZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gJGVsXG4gICAqIEByZXR1cm4ge09iamVjdHxBcnJheXxudWxsfVxuICAgKi9cbiAgZ2V0RGF0dW1Gcm9tRE9NRWxlbWVudCgkZWwpIHtcbiAgICBjb25zdCAkaXRlbSA9IHRoaXMuZ2V0SXRlbUZyb21ET01FbGVtZW50KCRlbCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0dW1Gcm9tSXRlbSgkaXRlbSk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdHMgaWYgdGhlIGdpdmVuIERPTSBlbGVtZW50IGlzIGFuIGl0ZW0gb2YgdGhlIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICRpdGVtIC0gVGhlIGl0ZW0gdG8gYmUgdGVzdGVkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaGFzSXRlbSgkaXRlbSkge1xuICAgIHJldHVybiB0aGlzLl8kaXRlbURhdGFNYXAuaGFzKCRpdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGlmIGEgZ2l2ZW4gZWxlbWVudCBiZWxvbmdzIHRvIHRoZSBsYXllci4gSXMgbW9yZSBnZW5lcmFsIHRoYW5cbiAgICogYGhhc0l0ZW1gLCBjYW4gbW9zdGx5IHVzZWQgdG8gY2hlY2sgaW50ZXJhY3Rpb25zIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICRlbCAtIFRoZSBET00gZWxlbWVudCB0byBiZSB0ZXN0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2x9XG4gICAqL1xuICBoYXNFbGVtZW50KCRlbCkge1xuICAgIGRvIHtcbiAgICAgIGlmICgkZWwgPT09IHRoaXMuJGVsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAkZWwgPSAkZWwucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlICgkZWwgIT09IG51bGwpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGFsbCB0aGUgaXRlbXMgaW4gYSBnaXZlbiBhcmVhIGFzIGRlZmluZWQgaW4gdGhlIHJlZ2lzdGVyZWQgYFNoYXBlfmluQXJlYWAgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJlYSAtIFRoZSBhcmVhIGluIHdoaWNoIHRvIGZpbmQgdGhlIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhcmVhLnRvcFxuICAgKiBAcGFyYW0ge051bWJlcn0gYXJlYS5sZWZ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhcmVhLndpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhcmVhLmhlaWdodFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBsaXN0IG9mIHRoZSBpdGVtcyBwcmVzZW50cyBpbiB0aGUgYXJlYVxuICAgKi9cbiAgZ2V0SXRlbXNJbkFyZWEoYXJlYSkge1xuICAgIGNvbnN0IHN0YXJ0ICAgID0gdGhpcy50aW1lQ29udGV4dC5wYXJlbnQudGltZVRvUGl4ZWwodGhpcy50aW1lQ29udGV4dC5zdGFydCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMudGltZUNvbnRleHQuZHVyYXRpb24pO1xuICAgIGNvbnN0IG9mZnNldCAgID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0Lm9mZnNldCk7XG4gICAgY29uc3QgdG9wICAgICAgPSB0aGlzLl90b3A7XG4gICAgLy8gYmUgYXdhcmUgYWYgY29udGV4dCdzIHRyYW5zbGF0aW9ucyAtIGNvbnN0cmFpbiBpbiB3b3JraW5nIHZpZXdcbiAgICBsZXQgeDEgPSBNYXRoLm1heChhcmVhLmxlZnQsIHN0YXJ0KTtcbiAgICBsZXQgeDIgPSBNYXRoLm1pbihhcmVhLmxlZnQgKyBhcmVhLndpZHRoLCBzdGFydCArIGR1cmF0aW9uKTtcbiAgICB4MSAtPSAoc3RhcnQgKyBvZmZzZXQpO1xuICAgIHgyIC09IChzdGFydCArIG9mZnNldCk7XG4gICAgLy8ga2VlcCBjb25zaXN0ZW50IHdpdGggY29udGV4dCB5IGNvb3JkaW5hdGVzIHN5c3RlbVxuICAgIGxldCB5MSA9IHRoaXMuX2hlaWdodCAtIChhcmVhLnRvcCArIGFyZWEuaGVpZ2h0KTtcbiAgICBsZXQgeTIgPSB0aGlzLl9oZWlnaHQgLSBhcmVhLnRvcDtcblxuICAgIHkxICs9IHRoaXMuX3RvcDtcbiAgICB5MiArPSB0aGlzLl90b3A7XG5cbiAgICBjb25zdCAkZmlsdGVyZWRJdGVtcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgWyRpdGVtLCBkYXR1bV0gb2YgdGhpcy5fJGl0ZW1EYXRhTWFwLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLl8kaXRlbVNoYXBlTWFwLmdldCgkaXRlbSk7XG4gICAgICBjb25zdCBpbkFyZWEgPSBzaGFwZS5pbkFyZWEodGhpcy5fcmVuZGVyaW5nQ29udGV4dCwgZGF0dW0sIHgxLCB5MSwgeDIsIHkyKTtcblxuICAgICAgaWYgKGluQXJlYSkgeyAkZmlsdGVyZWRJdGVtcy5wdXNoKCRpdGVtKTsgfVxuICAgIH1cblxuICAgIHJldHVybiAkZmlsdGVyZWRJdGVtcztcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFJlbmRlcmluZyAvIERpc3BsYXkgbWV0aG9kc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBpdGVtIHRvIHRoZSBlbmQgb2YgdGhlIGxheWVyIHRvIGRpc3BsYXkgaXQgZnJvbnQgb2YgaXRzXG4gICAqIHNpYmxpbmdzIChzdmcgei1pbmRleC4uLikuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gJGl0ZW0gLSBUaGUgaXRlbSB0byBiZSBtb3ZlZC5cbiAgICovXG4gIF90b0Zyb250KCRpdGVtKSB7XG4gICAgdGhpcy4kb2Zmc2V0LmFwcGVuZENoaWxkKCRpdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIERPTSBzdHJ1Y3R1cmUgb2YgdGhlIHNoYXBlcyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGRhdGEuIEluc3BpcmVkXG4gICAqIGZyb20gdGhlIGBlbnRlcmAgYW5kIGBleGl0YCBkMy5qcyBwYXJhZGlnbSwgdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZFxuICAgKiBlYWNoIHRpbWUgYSBkYXR1bSBpcyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGRhdGEuIFdoaWxlIHRoZSBET00gaXNcbiAgICogY3JlYXRlZCB0aGUgYHVwZGF0ZWAgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGluIG9yZGVyIHRvIHVwZGF0ZSB0aGUgc2hhcGVzXG4gICAqIGF0dHJpYnV0ZXMgYW5kIHRodXMgcGxhY2UgdGhlbSB3aGVyZSB0aGV5IHNob3VsZC5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICAvLyByZW5kZXIgYGNvbW1vblNoYXBlYCBvbmx5IG9uY2VcbiAgICBpZiAoXG4gICAgICB0aGlzLl9jb21tb25TaGFwZUNvbmZpZ3VyYXRpb24gIT09IG51bGwgJiZcbiAgICAgIHRoaXMuXyRpdGVtQ29tbW9uU2hhcGVNYXAuc2l6ZSA9PT0gMFxuICAgICkge1xuICAgICAgY29uc3QgeyBjdG9yLCBhY2Nlc3NvcnMsIG9wdGlvbnMgfSA9IHRoaXMuX2NvbW1vblNoYXBlQ29uZmlndXJhdGlvbjtcbiAgICAgIGNvbnN0ICRncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ2cnKTtcbiAgICAgIGNvbnN0IHNoYXBlID0gbmV3IGN0b3Iob3B0aW9ucyk7XG5cbiAgICAgIHNoYXBlLmluc3RhbGwoYWNjZXNzb3JzKTtcbiAgICAgICRncm91cC5hcHBlbmRDaGlsZChzaGFwZS5yZW5kZXIoKSk7XG4gICAgICAkZ3JvdXAuY2xhc3NMaXN0LmFkZCgnaXRlbScsICdjb21tb24nLCBzaGFwZS5nZXRDbGFzc05hbWUoKSk7XG5cbiAgICAgIHRoaXMuXyRpdGVtQ29tbW9uU2hhcGVNYXAuc2V0KCRncm91cCwgc2hhcGUpO1xuICAgICAgdGhpcy4kb2Zmc2V0LmFwcGVuZENoaWxkKCRncm91cCk7XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIGVsZW1lbnRzIGFsbCBhdCBvbmNlXG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5fJGl0ZW1EYXRhTWFwLnZhbHVlcygpOyAvLyBpdGVyYXRvclxuXG4gICAgLy8gZW50ZXJcbiAgICB0aGlzLmRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykgeyBpZiAodmFsdWUgPT09IGRhdHVtKSB7IHJldHVybjsgfSB9XG5cbiAgICAgIGNvbnN0IHsgY3RvciwgYWNjZXNzb3JzLCBvcHRpb25zIH0gPSB0aGlzLl9zaGFwZUNvbmZpZ3VyYXRpb247XG4gICAgICBjb25zdCBzaGFwZSA9IG5ldyBjdG9yKG9wdGlvbnMpO1xuICAgICAgc2hhcGUuaW5zdGFsbChhY2Nlc3NvcnMpO1xuXG4gICAgICBjb25zdCAkZWwgPSBzaGFwZS5yZW5kZXIodGhpcy5fcmVuZGVyaW5nQ29udGV4dCk7XG4gICAgICAkZWwuY2xhc3NMaXN0LmFkZCgnaXRlbScsIHNoYXBlLmdldENsYXNzTmFtZSgpKTtcblxuICAgICAgdGhpcy5fJGl0ZW1TaGFwZU1hcC5zZXQoJGVsLCBzaGFwZSk7XG4gICAgICB0aGlzLl8kaXRlbURhdGFNYXAuc2V0KCRlbCwgZGF0dW0pO1xuXG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCgkZWwpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kb2Zmc2V0LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblxuICAgIC8vIHJlbW92ZVxuICAgIGZvciAobGV0IFskaXRlbSwgZGF0dW1dIG9mIHRoaXMuXyRpdGVtRGF0YU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEuaW5kZXhPZihkYXR1bSkgIT09IC0xKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fJGl0ZW1TaGFwZU1hcC5nZXQoJGl0ZW0pO1xuXG4gICAgICB0aGlzLiRvZmZzZXQucmVtb3ZlQ2hpbGQoJGl0ZW0pO1xuICAgICAgc2hhcGUuZGVzdHJveSgpO1xuICAgICAgLy8gYSByZW1vdmVkIGl0ZW0gY2Fubm90IGJlIHNlbGVjdGVkXG4gICAgICBpZiAodGhpcy5fYmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5fYmVoYXZpb3IudW5zZWxlY3QoJGl0ZW0sIGRhdHVtKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fJGl0ZW1EYXRhTWFwLmRlbGV0ZSgkaXRlbSk7XG4gICAgICB0aGlzLl8kaXRlbVNoYXBlTWFwLmRlbGV0ZSgkaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbnRhaW5lciBvZiB0aGUgbGF5ZXIgYW5kIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBleGlzdGluZyBzaGFwZXMuXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVDb250YWluZXIoKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXBlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbnRhaW5lciBvZiB0aGUgbGF5ZXIuXG4gICAqL1xuICB1cGRhdGVDb250YWluZXIoKSB7XG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyaW5nQ29udGV4dCgpO1xuXG4gICAgY29uc3QgdGltZUNvbnRleHQgPSB0aGlzLnRpbWVDb250ZXh0O1xuICAgIGNvbnN0IHdpZHRoICA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRpbWVDb250ZXh0LmR1cmF0aW9uKTtcbiAgICAvLyB4IGlzIHJlbGF0aXZlIHRvIHRpbWVsaW5lJ3MgdGltZUNvbnRleHRcbiAgICBjb25zdCB4ID0gdGltZUNvbnRleHQucGFyZW50LnRpbWVUb1BpeGVsKHRpbWVDb250ZXh0LnN0YXJ0KTtcbiAgICBjb25zdCBvZmZzZXQgPSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aW1lQ29udGV4dC5vZmZzZXQpO1xuICAgIGNvbnN0IHRvcCA9IHRoaXMuX3RvcDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgLy8gbWF0cml4IHRvIGludmVydCB0aGUgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICBjb25zdCB0cmFuc2xhdGVNYXRyaXggPSBgbWF0cml4KDEsIDAsIDAsIC0xLCAke3h9LCAke3RvcCArIGhlaWdodH0pYDtcbiAgICB0aGlzLiRlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgdHJhbnNsYXRlTWF0cml4KTtcbiAgICAvLyB0aGlzLiRlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCAke3RvcH0pYCk7XG5cbiAgICB0aGlzLiRib3VuZGluZ0JveC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCB3aWR0aCk7XG4gICAgdGhpcy4kYm91bmRpbmdCb3guc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgdGhpcy4kYm91bmRpbmdCb3guc3R5bGUub3BhY2l0eSA9IHRoaXMucGFyYW1zLm9wYWNpdHk7XG5cbiAgICB0aGlzLiRvZmZzZXQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtvZmZzZXR9LCAwKWApO1xuICAgIC8vIG1haW50YWluIGNvbnRleHQgc2hhcGVcbiAgICB0aGlzLmNvbnRleHRTaGFwZS51cGRhdGUodGhpcy5fcmVuZGVyaW5nQ29udGV4dCwgdGhpcy50aW1lQ29udGV4dCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYXR0cmlidXRlcyBvZiBhbGwgdGhlIGBTaGFwZWAgaW5zdGFuY2VzIHJlbmRlcmVkIGludG8gdGhlIGxheWVyLlxuICAgKlxuICAgKiBAdG9kbyAtIGFsbG93IHRvIGZpbHRlciB3aGljaCBzaGFwZShzKSBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICovXG4gIHVwZGF0ZVNoYXBlcygpIHtcbiAgICB0aGlzLl91cGRhdGVSZW5kZXJpbmdDb250ZXh0KCk7XG4gICAgLy8gdXBkYXRlIGNvbW1vbiBzaGFwZXNcbiAgICB0aGlzLl8kaXRlbUNvbW1vblNoYXBlTWFwLmZvckVhY2goKHNoYXBlLCAkaXRlbSkgPT4ge1xuICAgICAgc2hhcGUudXBkYXRlKHRoaXMuX3JlbmRlcmluZ0NvbnRleHQsIHRoaXMuZGF0YSk7XG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBbJGl0ZW0sIGRhdHVtXSBvZiB0aGlzLl8kaXRlbURhdGFNYXAuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBzaGFwZSA9IHRoaXMuXyRpdGVtU2hhcGVNYXAuZ2V0KCRpdGVtKTtcbiAgICAgIHNoYXBlLnVwZGF0ZSh0aGlzLl9yZW5kZXJpbmdDb250ZXh0LCBkYXR1bSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyO1xuIiwiaW1wb3J0IHNjYWxlcyBmcm9tICcuLi91dGlscy9zY2FsZXMnO1xuXG5cbi8qKlxuICogQSBgTGF5ZXJUaW1lQ29udGV4dGAgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHRpbWUgc2VnbWVudCBpbnRvIGEgYFRpbWVsaW5lVGltZUNvbnRleHRgLlxuICogSXQgbXVzdCBiZSBhdHRhY2hlZCB0byBhIGBUaW1lbGluZVRpbWVDb250ZXh0YCAodGhlIG9uZSBvZiB0aGUgdGltZWxpbmUgaXRcbiAqIGJlbG9uZ3MgdG8pLiBJdCByZWxpZXMgb24gaXRzIHBhcmVudCdzIGB0aW1lVG9QaXhlbGAgKHRpbWUgdG8gcGl4ZWwgdHJhbnNmZXJ0XG4gKiBmdW5jdGlvbikgdG8gY3JlYXRlIHRoZSB0aW1lIHRvIHBpeGVsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMYXllciAodGhlIHZpZXcpIGl0IGlzIGF0dGFjaGVkIHRvLlxuICpcbiAqIFRoZSBgbGF5ZXJUaW1lQ29udGV4dGAgaGFzIGZvdXIgaW1wb3J0YW50IGF0dHJpYnV0ZXM6XG4gKiAtIGBzdGFydGAgcmVwcmVzZW50IHRoZSB0aW1lIGF0IHdoaWNoIHRlbXBvcmFsIGRhdGEgbXVzdCBiZSByZXByZXNlbnRlZFxuICogICBpbiB0aGUgdGltZWxpbmUgKGZvciBpbnN0YW5jZSB0aGUgYmVnaW5pbmcgb2YgYSBzb3VuZGZpbGUgaW4gYSBEQVcpLlxuICogLSBgb2Zmc2V0YCByZXByZXNlbnRzIG9mZnNldCB0aW1lIG9mIHRoZSBkYXRhIGluIHRoZSBjb250ZXh0IG9mIGEgTGF5ZXIuXG4gKiAgIChAVE9ETyBnaXZlIGEgdXNlIGNhc2UgZXhhbXBsZSBoZXJlIFwiY3JvcCA/XCIsIGFuZC9vciBleHBsYWluIHRoYXQgaXQncyBub3QgYSBjb21tb24gdXNlIGNhc2UpLlxuICogLSBgZHVyYXRpb25gIGlzIHRoZSBkdXJhdGlvbiBvZiB0aGUgdmlldyBvbiB0aGUgZGF0YS5cbiAqIC0gYHN0cmV0Y2hSYXRpb2AgaXMgdGhlIHN0cmV0Y2ggYXBwbHllZCB0byB0aGUgdGVtcG9yYWwgZGF0YSBjb250YWluZWQgaW5cbiAqICAgdGhlIHZpZXcgKHRoaXMgdmFsdWUgY2FuIGJlIHNlZW4gYXMgYSBsb2NhbCB6b29tIG9uIHRoZSBkYXRhLCBvciBhcyBhIHN0cmV0Y2hcbiAqICAgb24gdGhlIHRpbWUgY29tcG9uZW50cyBvZiB0aGUgZGF0YSkuIFdoZW4gYXBwbHllZCwgdGhlIHN0cmV0Y2ggcmF0aW8gbWFpbnRhaW5cbiAqICAgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSB2aWV3IGluIHRoZSB0aW1lbGluZS5cbiAqXG4gKiBgYGBcbiAqICsgdGltZWxpbmUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIDAgICAgICAgICA1ICAgICAgICAgMTAgICAgICAgICAgMTUgICAgICAgICAgMjAgICAgICAgIDI1ICAgICAgICAgIDMwIHNlY29uZHNcbiAqICstLS0rKioqKioqKioqKioqKioqKiorLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyoqKioqKiorLS1cbiAqICAgICB8KioqIHNvdW5kZmlsZSAqKip8TGF5ZXIgKHZpZXcgb24gdGhlIHNvdW5kIGZpbGUpICAgICAgICAgICAgfCoqKioqKip8XG4gKiAgICAgKyoqKioqKioqKioqKioqKioqKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsqKioqKioqK1xuICpcbiAqICAgICA8LS0tLSBvZmZzZXQgLS0tLT48LS0tLS0tLS0tLS0tLS0tIGR1cmF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tPlxuICogPC0tLS0tLS0tIHN0YXJ0IC0tLS0tPlxuICpcbiAqIFRoZSBwYXJ0cyBvZiB0aGUgc291bmQgZmlsZSByZXByZXNlbnRlZCB3aXRoICcqJyBhcmUgaGlkZGVuIGZyb20gdGhlIHZpZXdcbiAqIGBgYFxuICpcbiAqIFtleGFtcGxlIHVzYWdlXSguL2V4YW1wbGVzL3RpbWUtY29udGV4dHMuaHRtbClcbiAqL1xuY2xhc3MgTGF5ZXJUaW1lQ29udGV4dCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpbWVsaW5lVGltZUNvbnRleHR9IHBhcmVudCAtIFRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAgaW5zdGFuY2Ugb2YgdGhlIHRpbWVsaW5lLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgaWYgKCFwYXJlbnQpIHsgdGhyb3cgbmV3IEVycm9yKCdMYXllclRpbWVDb250ZXh0IG11c3QgaGF2ZSBhIHBhcmVudCcpOyB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYFRpbWVsaW5lVGltZUNvbnRleHRgIGluc3RhbmNlIG9mIHRoZSB0aW1lbGluZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtUaW1lbGluZVRpbWVDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gICAgdGhpcy5fdGltZVRvUGl4ZWwgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0ID0gMDtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHBhcmVudC52aXNpYmxlRHVyYXRpb247XG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9zdHJldGNoUmF0aW8gPSAxO1xuICAgIC8vIHJlZ2lzdGVyIGludG8gdGhlIHRpbWVsaW5lJ3MgVGltZUNvbnRleHRcbiAgICB0aGlzLnBhcmVudC5fY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgdGltZSBjb250ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtMYXllclRpbWVDb250ZXh0fVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY3R4ID0gbmV3IHRoaXMoKTtcblxuICAgIGN0eC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICBjdHguc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIGN0eC5kdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgY3R4Lm9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgIGN0eC5zdHJldGNoUmF0aW8gPSB0aGlzLnN0cmV0Y2hSYXRpbzsgLy8gY3JlYXRlcyB0aGUgbG9jYWwgc2NhbGUgaWYgbmVlZGVkXG5cbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSB0aW1lIGNvbnRleHQgKGluIHNlY29uZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgdGltZSBjb250ZXh0IChpbiBzZWNvbmRzKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBzdGFydCh2YWx1ZSkge1xuICAgIHRoaXMuX3N0YXJ0ID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZHVyYXRpb24gb2YgdGhlIHRpbWUgY29udGV4dCAoaW4gc2Vjb25kcykuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGR1cmF0aW9uIG9mIHRoZSB0aW1lIGNvbnRleHQgKGluIHNlY29uZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgdGhlIHRpbWUgY29udGV4dCAoaW4gc2Vjb25kcykuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb2Zmc2V0IG9mIHRoZSB0aW1lIGNvbnRleHQgKGluIHNlY29uZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMuX29mZnNldCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmV0Y2ggcmF0aW8gb2YgdGhlIHRpbWUgY29udGV4dC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzdHJldGNoUmF0aW8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmV0Y2hSYXRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJldGNoIHJhdGlvIG9mIHRoZSB0aW1lIGNvbnRleHQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgc3RyZXRjaFJhdGlvKHZhbHVlKSB7XG4gICAgLy8gcmVtb3ZlIGxvY2FsIHNjYWxlIGlmIHJhdGlvID0gMVxuICAgIGlmICh2YWx1ZSA9PT0gIDEpIHtcbiAgICAgIHRoaXMuX3RpbWVUb1BpeGVsID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmV1c2UgcHJldmlzb3VzbHkgY3JlYXRlZCBsb2NhbCBzY2FsZSBpZiBleGlzdHNcbiAgICBjb25zdCB0aW1lVG9QaXhlbCA9IHRoaXMuX3RpbWVUb1BpeGVsID9cbiAgICAgIHRoaXMuX3RpbWVUb1BpeGVsIDogc2NhbGVzLmxpbmVhcigpLmRvbWFpbihbMCwgMV0pO1xuXG4gICAgdGltZVRvUGl4ZWwucmFuZ2UoWzAsIHRoaXMucGFyZW50LmNvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kICogdmFsdWVdKTtcblxuICAgIHRoaXMuX3RpbWVUb1BpeGVsID0gdGltZVRvUGl4ZWw7XG4gICAgdGhpcy5fc3RyZXRjaFJhdGlvID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGltZSB0byBwaXhlbCB0cmFuc2ZlcnQgZnVuY3Rpb24gb2YgdGhlIHRpbWUgY29udGV4dC4gSWZcbiAgICogdGhlIGBzdHJldGNoUmF0aW9gIGF0dHJpYnV0ZSBpcyBlcXVhbCB0byAxLCB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBnbG9iYWxcbiAgICogb25lIGZyb20gdGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgZ2V0IHRpbWVUb1BpeGVsKCkge1xuICAgIGlmICghdGhpcy5fdGltZVRvUGl4ZWwpXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudGltZVRvUGl4ZWw7XG5cbiAgICByZXR1cm4gdGhpcy5fdGltZVRvUGl4ZWw7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgcGl4ZWwgdG8gdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHB4XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHBpeGVsVG9UaW1lKHB4KSB7XG4gICAgaWYgKCF0aGlzLl90aW1lVG9QaXhlbCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnRpbWVUb1BpeGVsLmludmVydChweCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVUb1BpeGVsLmludmVydChweCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXJUaW1lQ29udGV4dDtcbiIsImltcG9ydCBzY2FsZXMgZnJvbSAnLi4vdXRpbHMvc2NhbGVzJztcblxuXG4vKipcbiAqIERlZmluZXMgYW5kIG1haW50YWlucyBnbG9iYWwgYXNwZWN0cyBvZiB0aGUgdmlzdWFsaXphdGlvbiBjb25jZXJuaW5nIHRoZVxuICogcmVsYXRpb25zIGJldHdlZW4gdGltZSBhbmQgcGl4ZWxzLlxuICpcbiAqIFRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAgaW5zdGFuY2UgKHVuaXF1ZSBhY3Jvc3MgYSB2aXN1YWxpemF0aW9uKSBrZWVwcyB0aGVcbiAqIG1haW4gcmVmZXJlbmNlIG9uIGhvdyBtYW55IHBpeGVscyBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgb25lIHNlY29uZFxuICogdGhvdWdoIGl0cyBgdGltZVRvUGl4ZWxgIG1ldGhvZC4gVGhlIGF0dHJpYnV0ZXMgYHpvb21gLCBgb2Zmc2V0YCAoaS5lLiBmcm9tXG4gKiBvcmlnaW4pIGFuZCBgdmlzaWJsZVdpZHRoYCBhbGxvdyBmb3IgbmF2aWdhdGluZyBpbiB0aW1lIGFuZCBmb3IgbWFpbnRhaW5pbmdcbiAqIHZpZXcgY29uc2lzdGVuY3kgdXBvbiB0aGUgRE9NIHN0cnVjdHVyZSAoYDxzdmc+YCBhbmQgYDxnPmAgdGFncykgY3JlYXRlZCBieVxuICogdGhlIHJlZ2lzdGVyZWQgdHJhY2tzLlxuICpcbiAqIEl0IGFsc28gbWFpbnRhaW4gYW4gYXJyYXkgb2YgYWxsIHJlZmVyZW5jZXMgdG8gYExheWVyVGltZUNvbnRleHRgIGluc3RhbmNlc1xuICogdG8gcHJvcGFnYXRlIHRvIGBsYXllcnNgLCBjaGFuZ2VzIG1hZGUgb24gdGhlIHRpbWUgdG8gcGl4ZWwgcmVwcmVzZW50YXRpb24uXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvdGltZS1jb250ZXh0cy5odG1sKVxuICovXG5jbGFzcyBUaW1lbGluZVRpbWVDb250ZXh0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwaXhlbHNQZXJTZWNvbmQgLSBUaGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHNob3VsZCBiZVxuICAgKiAgICB1c2VkIHRvIGRpc3BsYXkgb25lIHNlY29uZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZpc2libGVXaWR0aCAtIFRoZSBkZWZhdWx0IHdpdGggb2YgdGhlIHZpc2libGUgYXJlYVxuICAgKiAgICBkaXNwbGF5ZWQgaW4gYHRyYWNrc2AgKGluIHBpeGVscykuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwaXhlbHNQZXJTZWNvbmQsIHZpc2libGVXaWR0aCkge1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG5cbiAgICB0aGlzLl90aW1lVG9QaXhlbCA9IG51bGw7XG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB0aGlzLl96b29tID0gMTtcbiAgICB0aGlzLl9jb21wdXRlZFBpeGVsc1BlclNlY29uZCA9IHBpeGVsc1BlclNlY29uZDtcbiAgICAvLyBwYXJhbXNcbiAgICB0aGlzLl92aXNpYmxlV2lkdGggPSB2aXNpYmxlV2lkdGg7XG4gICAgdGhpcy5fbWFpbnRhaW5WaXNpYmxlRHVyYXRpb24gPSBmYWxzZTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgdGltZVRvUGl4ZWwgc2NhbGVcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlcy5saW5lYXIoKVxuICAgICAgLmRvbWFpbihbMCwgMV0pXG4gICAgICAucmFuZ2UoWzAsIHBpeGVsc1BlclNlY29uZF0pO1xuXG4gICAgdGhpcy5fdGltZVRvUGl4ZWwgPSBzY2FsZTtcblxuICAgIHRoaXMuX29yaWdpbmFsUGl4ZWxzUGVyU2Vjb25kID0gdGhpcy5fY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBpeGVscyBwZXIgc2Vjb25kcyBpZ25vcmluZyB0aGUgY3VycmVudCB6b29tIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHBpeGVsc1BlclNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxQaXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhbGwgdGhlIGNhcmFjdGVyaXN0aWNzIG9mIHRoaXMgb2JqZWN0IGFjY29yZGluZyB0byB0aGUgbmV3XG4gICAqIGdpdmVuIHZhbHVlIG9mIHBpeGVscyBwZXIgc2Vjb25kcy4gUHJvcGFnYXRlcyB0aGUgY2hhbmdlcyB0byB0aGVcbiAgICogYExheWVyVGltZUNvbnRleHRgIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IHBpeGVsc1BlclNlY29uZCh2YWx1ZSkge1xuICAgIHRoaXMuX2NvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kID0gdmFsdWUgKiB0aGlzLnpvb207XG4gICAgdGhpcy5fb3JpZ2luYWxQaXhlbHNQZXJTZWNvbmQgPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVUaW1lVG9QaXhlbFJhbmdlKCk7XG5cbiAgICAvLyBmb3JjZSBjaGlsZHJlbiBzY2FsZSB1cGRhdGVcbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuc3RyZXRjaFJhdGlvICE9PSAxKVxuICAgICAgICBjaGlsZC5zdHJldGNoUmF0aW8gPSBjaGlsZC5zdHJldGNoUmF0aW87XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBpeGVscyBwZXIgc2Vjb25kcyBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgem9vbSB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb21wdXRlZFBpeGVsc1BlclNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBvZmZzZXQgYXBwbGllZCB0byB0aGUgcmVnaXN0ZXJlZCBgVHJhY2tgIGluc3RhbmNlc1xuICAgKiBmcm9tIG9yaWdpbiAoaW4gc2Vjb25kcykuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb2Zmc2V0IHRvIGFwcGx5IHRvIHRoZSByZWdpc3RlcmVkIGBUcmFja2AgaW5zdGFuY2VzIGZyb20gb3JpZ2luXG4gICAqIChpbiBzZWNvbmRzKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLl9vZmZzZXQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYXBwbGllZCB0byB0aGUgd2hvbGUgdmlzdWFsaXphdGlvbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB6b29tKCkge1xuICAgIHJldHVybiB0aGlzLl96b29tO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHpvb20gcmF0aW8gZm9yIHRoZSB3aG9sZSB2aXN1YWxpemF0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IHpvb20odmFsdWUpIHtcbiAgICAvLyBDb21wdXRlIGNoYW5nZSB0byBwcm9wYWdhdGUgdG8gY2hpbGRyZW4gd2hvIGhhdmUgdGhlaXIgb3duIHRpbWVUb1BpeGVsXG4gICAgY29uc3QgcmF0aW9DaGFuZ2UgPSB2YWx1ZSAvIHRoaXMuX3pvb207XG4gICAgdGhpcy5fem9vbSA9IHZhbHVlO1xuICAgIHRoaXMuX2NvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kID0gdGhpcy5fb3JpZ2luYWxQaXhlbHNQZXJTZWNvbmQgKiB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVUaW1lVG9QaXhlbFJhbmdlKCk7XG5cbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuc3RyZXRjaFJhdGlvICE9PSAxKVxuICAgICAgICBjaGlsZC5zdHJldGNoUmF0aW8gPSBjaGlsZC5zdHJldGNoUmF0aW8gKiByYXRpb0NoYW5nZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2aXNpYmxlIHdpZHRoIG9mIHRoZSBgVHJhY2tgIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB2aXNpYmxlV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGVXaWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2aXNpYmxlIHdpZHRoIG9mIHRoZSBgVHJhY2tgIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCB2aXNpYmxlV2lkdGgodmFsdWUpIHtcbiAgICBjb25zdCB3aWR0aFJhdGlvID0gdmFsdWUgLyB0aGlzLl92aXNpYmxlV2lkdGg7XG4gICAgdGhpcy5fdmlzaWJsZVdpZHRoID0gdmFsdWU7XG5cbiAgICBpZiAodGhpcy5tYWludGFpblZpc2libGVEdXJhdGlvbilcbiAgICAgIHRoaXMucGl4ZWxzUGVyU2Vjb25kID0gdGhpcy5waXhlbHNQZXJTZWNvbmQgKiB3aWR0aFJhdGlvO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGR1cmF0aW9uIGRpc3BsYXllZCBieSBgVHJhY2tgIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB2aXNpYmxlRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaWJsZVdpZHRoIC8gdGhpcy5fY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgZHVyYXRpb24gZGlzcGxheWVkIGJ5IHRyYWNrcyBzaG91bGQgYmUgbWFpbnRhaW5lZCB3aGVuXG4gICAqIHRoZWlyIHdpZHRoIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWFpbnRhaW5WaXNpYmxlRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21haW50YWluVmlzaWJsZUR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgaWYgdGhlIGR1cmF0aW9uIGRpc3BsYXllZCBieSB0cmFja3Mgc2hvdWxkIGJlIG1haW50YWluZWQgd2hlblxuICAgKiB0aGVpciB3aWR0aCBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHNldCBtYWludGFpblZpc2libGVEdXJhdGlvbihib29sKSB7XG4gICAgdGhpcy5fbWFpbnRhaW5WaXNpYmxlRHVyYXRpb24gPSBib29sO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRpbWUgdG8gcGl4ZWwgdHJhc2ZlcnQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIGdldCB0aW1lVG9QaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZVRvUGl4ZWw7XG4gIH1cblxuICBfdXBkYXRlVGltZVRvUGl4ZWxSYW5nZSgpIHtcbiAgICB0aGlzLnRpbWVUb1BpeGVsLnJhbmdlKFswLCB0aGlzLl9jb21wdXRlZFBpeGVsc1BlclNlY29uZF0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lVGltZUNvbnRleHQ7XG4iLCJpbXBvcnQgbnMgZnJvbSAnLi9uYW1lc3BhY2UnO1xuXG5cbi8qKlxuICogQWN0cyBhcyBhIHBsYWNlaG9sZGVyIHRvIG9yZ2FuaXplIHRoZSB2ZXJ0aWNhbCBsYXlvdXQgb2YgdGhlIHZpc3VhbGl6YXRpb25cbiAqIGFuZCB0aGUgaG9yaXpvbnRhbCBhbGlnbmVtZW50IHRvIGFuIGFic2Npc3NhIHRoYXQgY29ycmVzcG9uZCB0byBhIGNvbW1vblxuICogdGltZSByZWZlcmVuY2UuIEl0IGJhc2ljYWxseSBvZmZlciBhIHZpZXcgb24gdGhlIG92ZXJhbGwgdGltZWxpbmUuXG4gKlxuICogVHJhY2tzIGFyZSBpbnNlcnRlZCBpbnRvIGEgZ2l2ZW4gRE9NIGVsZW1lbnQsIGFsbG93aW5nIHRvIGNyZWF0ZSBEQVcgbGlrZVxuICogcmVwcmVzZW50YXRpb25zLiBFYWNoIGBUcmFja2AgaW5zdGFuY2UgY2FuIGhvc3QgbXVsdGlwbGUgYExheWVyYCBpbnN0YW5jZXMuXG4gKiBBIHRyYWNrIG11c3QgYmUgYWRkZWQgdG8gYSB0aW1lbGluZSBiZWZvcmUgYmVpbmcgdXBkYXRlZC5cbiAqXG4gKiAjIyMgQSB0aW1lbGluZSB3aXRoIDMgdHJhY2tzOlxuICpcbiAqIGBgYFxuICogMCAgICAgICAgICAgICAgICAgNiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNlxuICogKy0gLSAtIC0gLSAtIC0gLSAtKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLSAtIC0gLSAtIC0gLVxuICogfCAgICAgICAgICAgICAgICAgfHggdHJhY2sgMSB4eHh4eHh4eHh4eHh4eHh4eHh4eHh8XG4gKiArLSAtIC0gLSAtIC0gLSAtIC0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstIC0gLSAtIC0gLSAtXG4gKiB8ICAgICAgICAgICAgICAgICB8eCB0cmFjayAyIHh4eHh4eHh4eHh4eHh4eHh4eHh4eHxcbiAqICstIC0gLSAtIC0gLSAtIC0gLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0gLSAtIC0gLSAtIC1cbiAqIHwgICAgICAgICAgICAgICAgIHx4IHRyYWNrIDMgeHh4eHh4eHh4eHh4eHh4eHh4eHh4fFxuICogKy0gLSAtIC0gLSAtIC0gLSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLSAtIC0gLSAtIC0gLVxuICogKy0tLS0tLS0tLS0tLS0tLS0tPlxuICogdGltZWxpbmUudGltZUNvbnRleHQudGltZVRvUGl4ZWwodGltZWxpbmUudGltZUNvbnRleHQub2Zmc2V0KVxuICpcbiAqICAgICAgICAgICAgICAgICAgIDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPlxuICogICAgICAgICAgICAgICAgICAgdGltZWxpbmUncyB0cmFja3MgZGVmYXVsdHMgdG8gMTAwMHB4XG4gKiAgICAgICAgICAgICAgICAgICB3aXRoIGEgZGVmYXVsdCBwaXhlbHNQZXJTZWNvbmQgb2YgMTAwcHgvcy5cbiAqICAgICAgICAgICAgICAgICAgIGFuZCBhIGRlZmF1bHQgYHN0cmV0Y2hSYXRpbyA9IDFgXG4gKiAgICAgICAgICAgICAgICAgICB0cmFjazEgc2hvd3MgMTAgc2Vjb25kcyBvZiB0aGUgdGltZWxpbmVcbiAqIGBgYFxuICpcbiAqICMjIyBUcmFjayBET00gc3RydWN0dXJlXG4gKlxuICogYGBgaHRtbFxuICogPHN2ZyB3aWR0aD1cIiR7dmlzaWJsZVdpZHRofVwiPlxuICogICA8IS0tIGJhY2tncm91bmQgLS0+XG4gKiAgIDxyZWN0PjxyZWN0PlxuICogICA8IS0tIG1haW4gdmlldyAtLT5cbiAqICAgPGcgY2xhc3M9XCJvZmZzZXRcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoJHtvZmZzZXR9LCAwKVwiPlxuICogICAgIDxnIGNsYXNzPVwibGF5b3V0XCI+XG4gKiAgICAgICA8IS0tIGxheWVycyAtLT5cbiAqICAgICA8L2c+XG4gKiAgIDwvZz5cbiAqICAgPGcgY2xhc3M9XCJpbnRlcmFjdGlvbnNcIj48IS0tIGZvciBmZWVkYmFjayAtLT48L2c+XG4gKiA8L3N2Zz5cbiAqIGBgYFxuICovXG5jbGFzcyBUcmFjayB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9ICRlbFxuICAgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodCA9IDEwMF1cbiAgICovXG4gIGNvbnN0cnVjdG9yKCRlbCwgaGVpZ2h0ID0gMTAwKSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIERPTSBlbGVtZW50IGluIHdoaWNoIHRoZSB0cmFjayBpcyBjcmVhdGVkLlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuJGVsID0gJGVsO1xuICAgIC8qKlxuICAgICAqIEEgcGxhY2Vob2xkZXIgdG8gYWRkIHNoYXBlcyBmb3IgaW50ZXJhY3Rpb25zIGZlZWRiYWNrLlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuJGludGVyYWN0aW9ucyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgIHRoaXMuJGxheW91dCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgIHRoaXMuJG9mZnNldCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgIHRoaXMuJHN2ZyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgIHRoaXMuJGJhY2tncm91bmQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYmVsb25naW5nIHRvIHRoZSB0cmFjay5cbiAgICAgKiBAdHlwZSB7QXJyYXk8TGF5ZXI+fVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRleHQgdXNlZCB0byBtYWludGFpbiB0aGUgRE9NIHN0cnVjdHVyZSBvZiB0aGUgdHJhY2suXG4gICAgICogQHR5cGUge1RpbWVsaW5lVGltZUNvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJpbmdDb250ZXh0ID0gbnVsbDtcblxuICAgIHRoaXMuX2NyZWF0ZUNvbnRhaW5lcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgdHJhY2suXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSB0cmFjay5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICBjb25zdCBwcmV2SGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuXG4gICAgdGhpcy5sYXllcnMuZm9yRWFjaChsYXllciA9PiBsYXllci51cGRhdGVIZWlnaHQocHJldkhlaWdodCwgdGhpcy5faGVpZ2h0KSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYWNrIGlzIGFkZGVkIHRvIHRoZSB0aW1lbGluZS4gVGhlXG4gICAqIHRyYWNrIGNhbm5vdCBiZSB1cGRhdGVkIHdpdGhvdXQgYmVpbmcgYWRkZWQgdG8gYSB0aW1lbGluZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUaW1lbGluZVRpbWVDb250ZXh0fSByZW5kZXJpbmdDb250ZXh0XG4gICAqL1xuICBjb25maWd1cmUocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIHRoaXMucmVuZGVyaW5nQ29udGV4dCA9IHJlbmRlcmluZ0NvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgdHJhY2suIFRoZSBsYXllcnMgZnJvbSB0aGlzIHRyYWNrIGNhbiBzdGlsbCBiZSByZXVzZWQgZWxzZXdoZXJlLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBEZXRhY2ggZXZlcnl0aGluZyBmcm9tIHRoZSBET01cbiAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZCh0aGlzLiRzdmcpO1xuICAgIHRoaXMubGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4gdGhpcy4kbGF5b3V0LnJlbW92ZUNoaWxkKGxheWVyLiRlbCkpO1xuICAgIC8vIGNsZWFuIHJlZmVyZW5jZXNcbiAgICB0aGlzLiRlbCA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJpbmdDb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmxheWVycy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIERPTSBzdHJ1Y3R1cmUgb2YgdGhlIHRyYWNrLlxuICAgKi9cbiAgX2NyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICBjb25zdCAkc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnc3ZnJyk7XG4gICAgJHN2Zy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc2hhcGUtcmVuZGVyaW5nJywgJ29wdGltaXplU3BlZWQnKTtcbiAgICAkc3ZnLnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCB0aGlzLmhlaWdodCk7XG4gICAgJHN2Zy5zZXRBdHRyaWJ1dGUoJ3htbG5zOnhodG1sJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnKTtcbiAgICAkc3ZnLmNsYXNzTGlzdC5hZGQoJ3RyYWNrJyk7XG5cbiAgICBjb25zdCAkYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ3JlY3QnKTtcbiAgICAkYmFja2dyb3VuZC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgJzEwMCUnKTtcbiAgICAkYmFja2dyb3VuZC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCAnMTAwJScpO1xuICAgICRiYWNrZ3JvdW5kLnN0eWxlLmZpbGxPcGFjaXR5ID0gMDtcbiAgICAvLyAkYmFja2dyb3VuZC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXG4gICAgY29uc3QgJGRlZnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdkZWZzJyk7XG5cbiAgICBjb25zdCAkb2Zmc2V0R3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdnJyk7XG4gICAgJG9mZnNldEdyb3VwLmNsYXNzTGlzdC5hZGQoJ29mZnNldCcpO1xuXG4gICAgY29uc3QgJGxheW91dEdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnZycpO1xuICAgICRsYXlvdXRHcm91cC5jbGFzc0xpc3QuYWRkKCdsYXlvdXQnKTtcblxuICAgIGNvbnN0ICRpbnRlcmFjdGlvbnNHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ2cnKTtcbiAgICAkaW50ZXJhY3Rpb25zR3JvdXAuY2xhc3NMaXN0LmFkZCgnaW50ZXJhY3Rpb25zJyk7XG5cbiAgICAkb2Zmc2V0R3JvdXAuYXBwZW5kQ2hpbGQoJGxheW91dEdyb3VwKTtcbiAgICAkc3ZnLmFwcGVuZENoaWxkKCRkZWZzKTtcbiAgICAkc3ZnLmFwcGVuZENoaWxkKCRiYWNrZ3JvdW5kKTtcbiAgICAkc3ZnLmFwcGVuZENoaWxkKCRvZmZzZXRHcm91cCk7XG4gICAgJHN2Zy5hcHBlbmRDaGlsZCgkaW50ZXJhY3Rpb25zR3JvdXApO1xuICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKCRzdmcpO1xuICAgIC8vIHJlbW92ZXMgYWRkaXRpb25uYWwgaGVpZ2h0IGFkZGVkIHdobyBrbm93cyB3aHkuLi5cbiAgICB0aGlzLiRlbC5zdHlsZS5mb250U2l6ZSA9IDA7XG4gICAgLy8gZml4ZXMgb25lIG9mIHRoZSAobWFueSA/KSB3ZWlyZCBjYW52YXMgcmVuZGVyaW5nIGJ1Z3MgaW4gQ2hyb21lXG4gICAgdGhpcy4kZWwuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuXG4gICAgdGhpcy4kbGF5b3V0ID0gJGxheW91dEdyb3VwO1xuICAgIHRoaXMuJG9mZnNldCA9ICRvZmZzZXRHcm91cDtcbiAgICB0aGlzLiRpbnRlcmFjdGlvbnMgPSAkaW50ZXJhY3Rpb25zR3JvdXA7XG4gICAgdGhpcy4kc3ZnID0gJHN2ZztcbiAgICB0aGlzLiRiYWNrZ3JvdW5kID0gJGJhY2tncm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGxheWVyIHRvIHRoZSB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSB0aGUgbGF5ZXIgdG8gYWRkIHRvIHRoZSB0cmFjay5cbiAgICovXG4gIGFkZChsYXllcikge1xuICAgIGxldCBpbnNlcnRJbmRleCA9IG51bGw7XG5cbiAgICBpZiAobGF5ZXIucGFyYW1zLnpJbmRleCA8IDApXG4gICAgICBsYXllci5wYXJhbXMuekluZGV4ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsYXllci5wYXJhbXMuekluZGV4IDwgdGhpcy5sYXllcnNbaV0ucGFyYW1zLnpJbmRleCkge1xuICAgICAgICBpbnNlcnRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbnNlcnRJbmRleCA9PT0gbnVsbClcbiAgICAgIGluc2VydEluZGV4ID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgdGhpcy5sYXllcnMuc3BsaWNlKGluc2VydEluZGV4LCAwLCBsYXllcik7XG4gICAgLy8gYXBwZW5kIGF0IHRoZSB6SW5kZXggcGxhY2VcbiAgICB0aGlzLiRsYXlvdXQuaW5zZXJ0QmVmb3JlKGxheWVyLiRlbCwgdGhpcy4kbGF5b3V0LmNoaWxkcmVuW2luc2VydEluZGV4XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGxheWVyIGZyb20gdGhlIHRyYWNrLiBUaGUgbGF5ZXIgY2FuIGJlIHJldXNlZCBlbHNld2hlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gdGhlIGxheWVyIHRvIHJlbW92ZSBmcm9tIHRoZSB0cmFjay5cbiAgICovXG4gIHJlbW92ZShsYXllcikge1xuICAgIHRoaXMubGF5ZXJzLnNwbGljZSh0aGlzLmxheWVycy5pbmRleE9mKGxheWVyKSwgMSk7XG4gICAgLy8gUmVtb3ZlcyBsYXllciBmcm9tIGl0cyBjb250YWluZXJcbiAgICB0aGlzLiRsYXlvdXQucmVtb3ZlQ2hpbGQobGF5ZXIuJGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiBhIGdpdmVuIGVsZW1lbnQgYmVsb25ncyB0byB0aGUgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gJGVsXG4gICAqIEByZXR1cm4ge2Jvb2x9XG4gICAqL1xuICBoYXNFbGVtZW50KCRlbCkge1xuICAgIGRvIHtcbiAgICAgIGlmICgkZWwgPT09IHRoaXMuJGVsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAkZWwgPSAkZWwucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlICgkZWwgIT09IG51bGwpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgdHJhY2suXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgZm9yIChsZXQgbGF5ZXIgb2YgdGhpcykgeyBsYXllci5yZW5kZXIoKTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHRyYWNrIERPTSBzdHJ1Y3R1cmUgYW5kIHVwZGF0ZXMgdGhlIGxheWVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxMYXllcj59IFtsYXllcnM9bnVsbF0gLSBpZiBub3QgbnVsbCwgYSBzdWJzZXQgb2YgdGhlIGxheWVycyB0byB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGUobGF5ZXJzID0gbnVsbCkge1xuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyKCk7XG4gICAgdGhpcy51cGRhdGVMYXllcnMobGF5ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0cmFjayBET00gc3RydWN0dXJlLlxuICAgKi9cbiAgdXBkYXRlQ29udGFpbmVyKCkge1xuICAgIGNvbnN0ICRzdmcgPSB0aGlzLiRzdmc7XG4gICAgY29uc3QgJG9mZnNldCA9IHRoaXMuJG9mZnNldDtcbiAgICAvLyBTaG91bGQgYmUgaW4gc29tZSB1cGRhdGUgbGF5b3V0XG4gICAgY29uc3QgcmVuZGVyaW5nQ29udGV4dCA9IHRoaXMucmVuZGVyaW5nQ29udGV4dDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQocmVuZGVyaW5nQ29udGV4dC52aXNpYmxlV2lkdGgpO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLnJvdW5kKHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwocmVuZGVyaW5nQ29udGV4dC5vZmZzZXQpKTtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBgdHJhbnNsYXRlKCR7b2Zmc2V0WH0sIDApYDtcblxuICAgICRzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgJHN2Zy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCB3aWR0aCk7XG4gICAgJHN2Zy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndmlld2JveCcsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG5cbiAgICAkb2Zmc2V0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd0cmFuc2Zvcm0nLCB0cmFuc2xhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGxheWVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxMYXllcj59IFtsYXllcnM9bnVsbF0gLSBpZiBub3QgbnVsbCwgYSBzdWJzZXQgb2YgdGhlIGxheWVycyB0byB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGVMYXllcnMobGF5ZXJzID0gbnVsbCkge1xuICAgIGxheWVycyA9IChsYXllcnMgPT09IG51bGwpID8gdGhpcy5sYXllcnMgOiBsYXllcnM7XG5cbiAgICBsYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgIGlmICh0aGlzLmxheWVycy5pbmRleE9mKGxheWVyKSA9PT0gLTEpIHsgcmV0dXJuOyB9XG4gICAgICBsYXllci51cGRhdGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBhZGRlZCBsYXllcnMuXG4gICAqL1xuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgeWllbGQqIHRoaXMubGF5ZXJzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUcmFjaztcbiIsImltcG9ydCBMYXllciBmcm9tICcuL0xheWVyJztcblxuXG4vKipcbiAqIENvbGxlY3Rpb24gaG9zdGluZyBhbGwgdGhlIGBUcmFja2AgaW5zdGFuY2VzIHJlZ2lzdGVyZWQgaW50byB0aGUgdGltZWxpbmUuXG4gKiBJdCBwcm92aWRlcyBzaG9yY3V0cyB0byB0cmlnZ2VyIGByZW5kZXJgIC8gYHVwZGF0ZWAgbWV0aG9kcyBvbiB0cmFja3Mgb3JcbiAqIGxheWVycy4gRXh0ZW5kIGJ1aWx0LWluIEFycmF5XG4gKi9cbmNsYXNzIFRyYWNrQ29sbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHRpbWVsaW5lKSB7XG4gICAgdGhpcy5fdGltZWxpbmUgPSB0aW1lbGluZTtcbiAgICB0aGlzLl90cmFja3MgPSBuZXcgU2V0KCk7XG4gIH1cblxuICAvLyBAbm90ZSAtIHNob3VsZCBiZSBpbiB0aGUgdGltZWxpbmUgP1xuICAvLyBAdG9kbyAtIGFsbG93IHRvIHBhc3MgYW4gYXJyYXkgb2YgbGF5ZXJzXG4gIF9nZXRMYXllcnNPckdyb3VwcyhsYXllck9yR3JvdXAgPSBudWxsKSB7XG4gICAgbGV0IGxheWVycyA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIGxheWVyT3JHcm91cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxheWVycyA9IHRoaXMuX3RpbWVsaW5lLmdyb3VwZWRMYXllcnNbbGF5ZXJPckdyb3VwXTtcbiAgICB9IGVsc2UgaWYgKGxheWVyT3JHcm91cCBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgICBsYXllcnMgPSBbbGF5ZXJPckdyb3VwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfSAtIFVwZGF0ZXMgdGhlIGhlaWdodCBvZiBhbGwgdHJhY2tzIGF0IG9uY2UuXG4gICAqIEB0b2RvIC0gUHJvcGFnYXRlIHRvIGxheWVycywgbm90IHVzZWZ1bGwgZm9yIG5vdy5cbiAgICovXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl90cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLmhlaWdodCA9IHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBhbGwgcmVnaXN0ZXJlZCBsYXllcnMuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxMYXllcj59XG4gICAqL1xuICBnZXQgbGF5ZXJzKCkge1xuICAgIGxldCBsYXllcnMgPSBbXTtcbiAgICB0aGlzLl90cmFja3MuZm9yRWFjaCh0cmFjayA9PiBsYXllcnMgPSBsYXllcnMuY29uY2F0KHRyYWNrLmxheWVycykpO1xuXG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGdpdmVuIHRyYWNrIGJlbG9uZ3MgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrIC0gVHJhY2sgdG8gYmUgdGVzdGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaGFzKHRyYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrcy5oYXModHJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHRyYWNrIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYWNrfSB0cmFjayAtIFRyYWNrIHRvIGFkZCB0byB0aGUgY29sbGVjdGlvblxuICAgKi9cbiAgYWRkKHRyYWNrKSB7XG4gICAgdGhpcy5fdHJhY2tzLmFkZCh0cmFjayk7XG4gIH1cblxuICAvLyBAdG9kb1xuICByZW1vdmUodHJhY2spIHt9XG5cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIHRoaXMuX3RyYWNrcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYWxsIHRyYWNrcyBhbmQgbGF5ZXJzLiBXaGVuIGRvbmUsIHRoZSB0aW1lbGluZSB0cmlnZ2VycyBhIGByZW5kZXJgIGV2ZW50LlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuX3RyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnJlbmRlcigpKTtcbiAgICB0aGlzLl90aW1lbGluZS5lbWl0KCdyZW5kZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFsbCB0cmFja3MgYW5kIGxheWVycy4gV2hlbiBkb25lLCB0aGUgdGltZWxpbmUgdHJpZ2dlcnMgYVxuICAgKiBgdXBkYXRlYCBldmVudC5cbiAgICpcbiAgICogQHRvZG8gLSBmaWx0ZXJpbmcgaXMgcHJvYmFibHkgYnJva2VuLi4uXG4gICAqIEBwYXJhbSB7TGF5ZXJ8U3RyaW5nfSBsYXllck9yR3JvdXAgLSBGaWx0ZXIgdGhlIGxheWVycyB0byB1cGRhdGUgYnlcbiAgICogICAgcGFzc2luZyB0aGUgYExheWVyYCBpbnN0YW5jZSB0byB1cGRhdGUgb3IgYSBgZ3JvdXBJZGBcbiAgICovXG4gIHVwZGF0ZShsYXllck9yR3JvdXApIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9nZXRMYXllcnNPckdyb3VwcyhsYXllck9yR3JvdXApO1xuICAgIHRoaXMuX3RyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnVwZGF0ZShsYXllcnMpKTtcbiAgICB0aGlzLl90aW1lbGluZS5lbWl0KCd1cGRhdGUnLCBsYXllcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYWxsIGBUcmFja2AgY29udGFpbmVycywgbGF5ZXJzIGFyZSBub3QgdXBkYXRlZCB3aXRoIHRoaXMgbWV0aG9kLlxuICAgKiBXaGVuIGRvbmUsIHRoZSB0aW1lbGluZSB0cmlnZ2VycyBhIGB1cGRhdGU6Y29udGFpbmVyc2AgZXZlbnQuXG4gICAqL1xuICB1cGRhdGVDb250YWluZXIoLyogdHJhY2tPclRyYWNrSWRzICovKSB7XG4gICAgdGhpcy5fdHJhY2tzLmZvckVhY2godHJhY2sgPT4gdHJhY2sudXBkYXRlQ29udGFpbmVyKCkpO1xuICAgIHRoaXMuX3RpbWVsaW5lLmVtaXQoJ3VwZGF0ZTpjb250YWluZXJzJyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhbGwgbGF5ZXJzLiBXaGVuIGRvbmUsIHRoZSB0aW1lbGluZSB0cmlnZ2VycyBhIGB1cGRhdGU6bGF5ZXJzYCBldmVudC5cbiAgICpcbiAgICogQHRvZG8gLSBmaWx0ZXJpbmcgaXMgcHJvYmFibHkgYnJva2VuLi4uXG4gICAqIEBwYXJhbSB7TGF5ZXJ8U3RyaW5nfSBsYXllck9yR3JvdXAgLSBGaWx0ZXIgdGhlIGxheWVycyB0byB1cGRhdGUgYnlcbiAgICogICAgcGFzc2luZyB0aGUgYExheWVyYCBpbnN0YW5jZSB0byB1cGRhdGUgb3IgYSBgZ3JvdXBJZGBcbiAgICovXG4gIHVwZGF0ZUxheWVycyhsYXllck9yR3JvdXApIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9nZXRMYXllcnNPckdyb3VwcyhsYXllck9yR3JvdXApO1xuICAgIHRoaXMuX3RyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnVwZGF0ZUxheWVycyhsYXllcnMpKTtcbiAgICB0aGlzLl90aW1lbGluZS5lbWl0KCd1cGRhdGU6bGF5ZXJzJywgbGF5ZXJzKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUcmFja0NvbGxlY3Rpb247XG4iLCJleHBvcnQgZGVmYXVsdCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuIiwiaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuXG5pbXBvcnQgS2V5Ym9hcmQgZnJvbSAnLi4vaW50ZXJhY3Rpb25zL0tleWJvYXJkJztcbmltcG9ydCBMYXllclRpbWVDb250ZXh0IGZyb20gJy4vTGF5ZXJUaW1lQ29udGV4dCc7XG5pbXBvcnQgU3VyZmFjZSBmcm9tICcuLi9pbnRlcmFjdGlvbnMvU3VyZmFjZSc7XG5pbXBvcnQgVGltZWxpbmVUaW1lQ29udGV4dCBmcm9tICcuL1RpbWVsaW5lVGltZUNvbnRleHQnO1xuaW1wb3J0IFRyYWNrIGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IFRyYWNrQ29sbGVjdGlvbiBmcm9tICcuL1RyYWNrQ29sbGVjdGlvbic7XG5cblxuLyoqXG4gKiBJcyB0aGUgbWFpbiBlbnRyeSBwb2ludCB0byBjcmVhdGUgYSB0ZW1wb3JhbCB2aXN1YWxpemF0aW9uLlxuICpcbiAqIEEgYHRpbWVsaW5lYCBpbnN0YW5jZSBtYWlubHkgcHJvdmlkZXMgdGhlIGNvbnRleHQgZm9yIGFueSB2aXN1YWxpemF0aW9uIG9mXG4gKiB0ZW1wb3JhbCBkYXRhIGFuZCBtYWludGFpbnMgdGhlIGhpZXJhcmNoeSBvZiBgVHJhY2tgLCBgTGF5ZXJgIGFuZCBgU2hhcGVgXG4gKiBvdmVyIHRoZSBlbnRpZXJlIHZpc3VhbGlzYXRpb24uXG4gKlxuICogSXRzIG1haW4gcmVzcG9uc2FiaWxpdGVzIGFyZTpcbiAqIC0gbWFpbnRhaW5pbmcgdGhlIHRlbXBvcmFsIGNvbnNpc3RlbmN5IGFjY3Jvc3MgdGhlIHZpc3VhbGlzYXRpb24gdGhyb3VnaFxuICogICBpdHMgYHRpbWVDb250ZXh0YCBwcm9wZXJ0eSAoaW5zdGFuY2Ugb2YgYFRpbWVsaW5lVGltZUNvbnRleHRgKS5cbiAqIC0gaGFuZGxpbmcgaW50ZXJhY3Rpb25zIHRvIGl0cyBjdXJyZW50IHN0YXRlIChhY3RpbmcgaGVyZSBhcyBhIHNpbXBsZVxuICogICBzdGF0ZSBtYWNoaW5lKS5cbiAqXG4gKiBAVE9ETyBpbnNlcnQgZmlndXJlXG4gKlxuICogSXQgYWxzbyBjb250YWlucyBhIHJlZmVyZW5jZSB0byBhbGwgdGhlIHJlZ2lzdGVyIHRyYWNrIGFsbG93aW5nIHRvIGByZW5kZXJgXG4gKiBvciBgdXBkYXRlYCBhbGwgdGhlIGxheWVyIGZyb20gYSBzaW5nbGUgZW50cnkgcG9pbnQuXG4gKlxuICogIyMgRXhhbXBsZSBVc2FnZVxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCB2aXNpYmxlV2lkdGggPSA1MDA7IC8vIGRlZmF1bHQgd2lkdGggaW4gcGl4ZWxzIGZvciBhbGwgY3JlYXRlZCBgVHJhY2tgXG4gKiBjb25zdCBkdXJhdGlvbiA9IDEwOyAvLyB0aGUgdmlzaWJsZSBhcmVhIHJlcHJlc2VudHMgMTAgc2Vjb25kc1xuICogY29uc3QgcGl4ZWxzUGVyU2Vjb25kcyA9IHZpc2libGVXaWR0aCAvIGR1cmF0aW9uO1xuICogY29uc3QgdGltZWxpbmUgPSBuZXcgdWkuY29yZS5UaW1lbGluZShwaXhlbHNQZXJTZWNvbmQsIHdpZHRoKTtcbiAqIGBgYFxuICovXG5jbGFzcyBUaW1lbGluZSBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwaXhlbHNQZXJTZWNvbmQ9MTAwXSAtIHRoZSBkZWZhdWx0IHNjYWxpbmcgYmV0d2VlbiB0aW1lIGFuZCBwaXhlbHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdmlzaWJsZVdpZHRoPTEwMDBdIC0gdGhlIGRlZmF1bHQgdmlzaWJsZSBhcmVhIGZvciBhbGwgcmVnaXN0ZXJlZCB0cmFja3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwaXhlbHNQZXJTZWNvbmQgPSAxMDAsIHZpc2libGVXaWR0aCA9IDEwMDAsIHtcbiAgICByZWdpc3RlcktleWJvYXJkID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fdHJhY2tzID0gbmV3IFRyYWNrQ29sbGVjdGlvbih0aGlzKTtcbiAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0IGludGVyYWN0aW9uc1xuICAgIHRoaXMuX3N1cmZhY2VDdG9yID0gU3VyZmFjZTtcblxuICAgIC8vIHN0b3Jlc1xuICAgIHRoaXMuX3RyYWNrQnlJZCA9IHt9O1xuICAgIHRoaXMuX2dyb3VwZWRMYXllcnMgPSB7fTtcbiAgICB0aGlzLl8kZWxJbnRlcmFjdGlvbnNNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICAvKiogQHR5cGUge1RpbWVsaW5lVGltZUNvbnRleHR9IC0gbWFzdGVyIHRpbWUgY29udGV4dCBmb3IgdGhlIHZpc3VhbGl6YXRpb24uICovXG4gICAgdGhpcy50aW1lQ29udGV4dCA9IG5ldyBUaW1lbGluZVRpbWVDb250ZXh0KHBpeGVsc1BlclNlY29uZCwgdmlzaWJsZVdpZHRoKTtcblxuICAgIGlmIChyZWdpc3RlcktleWJvYXJkKVxuICAgICAgdGhpcy5jcmVhdGVJbnRlcmFjdGlvbihLZXlib2FyZCwgZG9jdW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYG9mZnNldGAgdGltZSBkb21haW4gdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZUNvbnRleHQub2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYG9mZnNldGAgdGltZSBkb21haW4gdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICovXG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLnRpbWVDb250ZXh0Lm9mZnNldCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGB6b29tYCB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn0gW29mZnNldD0wXVxuICAgKi9cbiAgZ2V0IHpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZUNvbnRleHQuem9vbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgem9vbWAgdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICovXG4gIHNldCB6b29tKHZhbHVlKSB7XG4gICAgdGhpcy50aW1lQ29udGV4dC56b29tID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYHBpeGVsc1BlclNlY29uZGAgcmF0aW8uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICovXG4gIGdldCBwaXhlbHNQZXJTZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZUNvbnRleHQucGl4ZWxzUGVyU2Vjb25kO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGBwaXhlbHNQZXJTZWNvbmRgIHJhdGlvLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfSBbb2Zmc2V0PTBdXG4gICAqL1xuICBzZXQgcGl4ZWxzUGVyU2Vjb25kKHZhbHVlKSB7XG4gICAgdGhpcy50aW1lQ29udGV4dC5waXhlbHNQZXJTZWNvbmQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgdmlzaWJsZVdpZHRoYCBwaXhlbCBkb21haW4gdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICovXG4gIGdldCB2aXNpYmxlV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZUNvbnRleHQudmlzaWJsZVdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGB2aXNpYmxlV2lkdGhgIHBpeGVsIGRvbWFpbiB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn0gW29mZnNldD0wXVxuICAgKi9cbiAgc2V0IHZpc2libGVXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMudGltZUNvbnRleHQudmlzaWJsZVdpZHRoID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgdGltZVRvUGl4ZWxgIHRyYW5zZmVydCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgZ2V0IHRpbWVUb1BpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYHZpc2libGVEdXJhdGlvbmAgaGVscGVyIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHZpc2libGVEdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC52aXNpYmxlRHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYG1haW50YWluVmlzaWJsZUR1cmF0aW9uYCB2YWx1ZS5cbiAgICogRGVmaW5lcyBpZiB0aGUgZHVyYXRpb24gb2YgdGhlIHZpc2libGUgYXJlYSBzaG91bGQgYmUgbWFpbnRhaW4gd2hlblxuICAgKiB0aGUgYHZpc2libGVXaWR0aGAgYXR0cmlidXRlIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc2V0IG1haW50YWluVmlzaWJsZUR1cmF0aW9uKGJvb2wpIHtcbiAgICB0aGlzLnRpbWVDb250ZXh0Lm1haW50YWluVmlzaWJsZUR1cmF0aW9uID0gYm9vbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGBtYWludGFpblZpc2libGVEdXJhdGlvbmAgY3VycmVudCB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgbWFpbnRhaW5WaXNpYmxlRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZUNvbnRleHQubWFpbnRhaW5WaXNpYmxlRHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogT2JqZWN0IG1haW50YWluaW5nIGFycmF5cyBvZiBgTGF5ZXJgIGluc3RhbmNlcyBvcmRlcmVkIGJ5IHRoZWlyIGBncm91cElkYC5cbiAgICogSXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBgVHJhY2tDb2xsZWN0aW9uYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldCBncm91cGVkTGF5ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9ncm91cGVkTGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgU3VyZmFjZWAgdGhhdCBpcyBpbnN0YW5jaWF0ZWQgb24gZWFjaCBgVHJhY2tgXG4gICAqIGluc3RhbmNlLiBUaGlzIG1ldGhvcyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgYW55IGBUcmFja2AgaW5zdGFuY2VcbiAgICogdG8gdGhlIGN1cnJlbnQgYHRpbWVsaW5lYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFNvdXJjZX0gY3RvciAtIFRoZSBjb25zdHJ1Y3RvciB0byB1c2UgaW4gb3JkZXIgdG8gY2F0Y2ggbW91c2VcbiAgICogICAgZXZlbnRzIG9uIGVhY2ggYFRyYWNrYCBpbnN0YW5jZXMuXG4gICAqL1xuICBjb25maWd1cmVTdXJmYWNlKGN0b3IpIHtcbiAgICB0aGlzLl9zdXJmYWNlQ3RvciA9IGN0b3I7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdG8gYWRkIGludGVyYWN0aW9uIG1vZHVsZXMgdGhlIHRpbWVsaW5lIHNob3VsZCBsaXN0ZW4gdG8uXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSB0aW1lbGluZSBpbnN0YW5jaWF0ZSBhIGdsb2JhbCBgS2V5Ym9hcmRgIGluc3RhbmNlIGFuZCBhXG4gICAqIGBTdXJmYWNlYCBpbnN0YW5jZSBvbiBlYWNoIGNvbnRhaW5lci5cbiAgICogU2hvdWxkIGJlIHVzZWQgdG8gaW5zdGFsbCBuZXcgaW50ZXJhY3Rpb25zIGltcGxlbWVudGluZyB0aGUgYEV2ZW50U291cmNlYCBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRTb3VyY2V9IGN0b3IgLSBUaGUgY29udHJ1Y3RvciBvZiB0aGUgaW50ZXJhY3Rpb24gbW9kdWxlIHRvIGluc3RhbmNpYXRlLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICRlbCAtIFRoZSBET00gZWxlbWVudCB3aGljaCB3aWxsIGJlIGJpbmRlZCB0byB0aGUgYEV2ZW50U291cmNlYCBtb2R1bGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGBjdG9yYC5cbiAgICovXG4gIGNyZWF0ZUludGVyYWN0aW9uKGN0b3IsICRlbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaW50ZXJhY3Rpb24gPSBuZXcgY3RvcigkZWwsIG9wdGlvbnMpO1xuICAgIGludGVyYWN0aW9uLm9uKCdldmVudCcsIChlKSA9PiB0aGlzLl9oYW5kbGVFdmVudChlKSk7XG5cbiAgICAvLyBzdG9yZSBpbnRlcmFjdGlvbiBhc3NvY2lhdGVkIHRvIHRoZSBET00gZWxlbWVudFxuICAgIGlmICghdGhpcy5fJGVsSW50ZXJhY3Rpb25zTWFwLmhhcygkZWwpKVxuICAgICAgdGhpcy5fJGVsSW50ZXJhY3Rpb25zTWFwLnNldCgkZWwsIG5ldyBTZXQoKSk7XG5cbiAgICBjb25zdCBpbnRlcmFjdGlvblNldCA9IHRoaXMuXyRlbEludGVyYWN0aW9uc01hcC5nZXQoJGVsKTtcbiAgICBpbnRlcmFjdGlvblNldC5hZGQoaW50ZXJhY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBsYXllcnMgc2l0dWF0ZWQgdW5kZXIgdGhlIHBvc2l0aW9uIG9mIGEgYFdhdmVFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7V2F2ZXNFdmVudH0gZSAtIEFuIGV2ZW50IHRyaWdnZXJlZCBieSBhIGBXYXZlRXZlbnRgXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIE1hdGNoZWQgbGF5ZXJzXG4gICAqL1xuICBnZXRIaXRMYXllcnMoZSkge1xuICAgIGNvbnN0IGNsaWVudFggPSBlLm9yaWdpbmFsRXZlbnQuY2xpZW50WDtcbiAgICBjb25zdCBjbGllbnRZID0gZS5vcmlnaW5hbEV2ZW50LmNsaWVudFk7XG4gICAgbGV0IGxheWVycyA9IFtdO1xuXG4gICAgdGhpcy5sYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgIGlmICghbGF5ZXIucGFyYW1zLmhpdHRhYmxlKSB7IHJldHVybjsgfVxuICAgICAgY29uc3QgYm91bmRpbmdSZWN0ID0gbGF5ZXIuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGNsaWVudFggPiBib3VuZGluZ1JlY3QubGVmdCAmJiBjbGllbnRYIDwgYm91bmRpbmdSZWN0LnJpZ2h0ICYmXG4gICAgICAgIGNsaWVudFkgPiBib3VuZGluZ1JlY3QudG9wICYmIGNsaWVudFkgPCBib3VuZGluZ1JlY3QuYm90dG9tXG4gICAgICApIHtcbiAgICAgICAgbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2FsbGJhY2sgdGhhdCBpcyB1c2VkIHRvIGxpc3RlbiB0byBpbnRlcmFjdGlvbnMgbW9kdWxlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXYXZlRXZlbnR9IGUgLSBBbiBldmVudCBnZW5lcmF0ZWQgYnkgYW4gaW50ZXJhY3Rpb24gbW9kdWxlcyAoYEV2ZW50U291cmNlYCkuXG4gICAqL1xuICBfaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IGhpdExheWVycyA9IChlLnNvdXJjZSA9PT0gJ3N1cmZhY2UnKSA/IHRoaXMuZ2V0SGl0TGF5ZXJzKGUpIDogbnVsbDtcbiAgICAvLyBlbWl0IGV2ZW50IGFzIGEgbWlkZGxld2FyZVxuICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBlLCBoaXRMYXllcnMpO1xuICAgIC8vIHByb3BhZ2F0ZSB0byB0aGUgc3RhdGVcbiAgICBpZiAodGhpcy5fc3RhdGUpXG4gICAgICB0aGlzLl9zdGF0ZS5oYW5kbGVFdmVudChlLCBoaXRMYXllcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSB0aW1lbGluZS5cbiAgICpcbiAgICogQHR5cGUge0Jhc2VTdGF0ZX1cbiAgICovXG4gIHNldCBzdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9zdGF0ZSlcbiAgICAgIHRoaXMuX3N0YXRlLmV4aXQoKTtcblxuICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUpXG4gICAgICB0aGlzLl9zdGF0ZS5lbnRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHRpbWVsaW5lLlxuICAgKlxuICAgKiBAdHlwZSB7QmFzZVN0YXRlfVxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgVHJhY2tDb2xsZWN0aW9uYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHR5cGUge1RyYWNrQ29sbGVjdGlvbn1cbiAgICovXG4gIGdldCB0cmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCByZWdpc3RlcmVkIGxheWVycy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgZ2V0IGxheWVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tzLmxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IHRyYWNrIHRvIHRoZSB0aW1lbGluZS5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gdHJhY2sgLSBUaGUgbmV3IHRyYWNrIHRvIGJlIHJlZ2lzdGVyZWQgaW4gdGhlIHRpbWVsaW5lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3RyYWNrSWQ9bnVsbF0gLSBPcHRpb25uYWwgdW5pcXVlIGlkIHRvIGFzc29jaWF0ZSB3aXRoXG4gICAqICAgIHRoZSB0cmFjaywgdGhpcyBpZCBvbmx5IGV4aXN0cyBpbiB0aW1lbGluZSdzIGNvbnRleHQgYW5kIHNob3VsZCBiZSB1c2VkXG4gICAqICAgIGluIGNvbmpvbmN0aW9uIHdpdGggYGFkZExheWVyYCBtZXRob2QuXG4gICAqL1xuICBhZGQodHJhY2ssIHRyYWNrSWQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMudHJhY2tzLmhhcyh0cmFjaykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYWNrIGFscmVhZHkgYWRkZWQgdG8gdGhlIHRpbWVsaW5lJyk7XG5cbiAgICB0aGlzLl9yZWdpc3RlclRyYWNrSWQodHJhY2ssIHRyYWNrSWQpO1xuICAgIHRyYWNrLmNvbmZpZ3VyZSh0aGlzLnRpbWVDb250ZXh0KTtcblxuICAgIHRoaXMudHJhY2tzLmFkZCh0cmFjayk7XG4gICAgdGhpcy5jcmVhdGVJbnRlcmFjdGlvbih0aGlzLl9zdXJmYWNlQ3RvciwgdHJhY2suJGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgdHJhY2sgZnJvbSB0aGUgdGltZWxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrIC0gdGhlIHRyYWNrIHRvIHJlbW92ZSBmcm9tIHRoZSB0aW1lbGluZS5cbiAgICogQHRvZG8gbm90IGltcGxlbWVudGVkLlxuICAgKi9cbiAgcmVtb3ZlKHRyYWNrKSB7XG4gICAgLy8gc2hvdWxkIGRlc3Ryb3kgYWxsIGludGVyYWN0aW9ucyB0b28sIGF2b2lkIGdob3N0IGV2ZW50TGlzdGVuZXJzXG4gICAgY29uc3QgJGVsID0gdHJhY2suJGVsO1xuICAgIGNvbnN0IGludGVyYWN0aW9ucyA9IHRoaXMuXyRlbEludGVyYWN0aW9uc01hcC5nZXQoJGVsKTtcblxuICAgIGlmIChpbnRlcmFjdGlvbnMpXG4gICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChpbnRlcmFjdGlvbiA9PiBpbnRlcmFjdGlvbi5kZXN0cm95KCkpO1xuXG4gICAgdHJhY2suZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBjcmVhdGUgYSBuZXcgYFRyYWNrYCBpbnN0YW5jZS4gVGhlIGB0cmFja2AgaXMgYWRkZWQsXG4gICAqIHJlbmRlcmVkIGFuZCB1cGRhdGVkIGJlZm9yZSBiZWluZyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSAkZWwgLSBUaGUgRE9NIGVsZW1lbnQgd2hlcmUgdGhlIHRyYWNrIHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRyYWNrSGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgbmV3bHkgY3JlYXRlZCB0cmFjay5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0cmFja0lkPW51bGxdIC0gT3B0aW9ubmFsIHVuaXF1ZSBpZCB0byBhc3NvY2lhdGUgd2l0aFxuICAgKiAgICB0aGUgdHJhY2ssIHRoaXMgaWQgb25seSBleGlzdHMgaW4gdGltZWxpbmUncyBjb250ZXh0IGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgKiAgICBjb25qb25jdGlvbiB3aXRoIGBhZGRMYXllcmAgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICovXG4gIGNyZWF0ZVRyYWNrKCRlbCwgdHJhY2tIZWlnaHQgPSAxMDAsIHRyYWNrSWQgPSBudWxsKSB7XG4gICAgY29uc3QgdHJhY2sgPSBuZXcgVHJhY2soJGVsLCB0cmFja0hlaWdodCk7XG4gICAgLy8gQWRkIHRyYWNrIHRvIHRoZSB0aW1lbGluZVxuICAgIHRoaXMuYWRkKHRyYWNrLCB0cmFja0lkKTtcbiAgICB0cmFjay5yZW5kZXIoKTtcbiAgICB0cmFjay51cGRhdGUoKTtcblxuICAgIHJldHVybiB0cmFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0cmFjayBpZCBpcyBkZWZpbmVkLCBhc3NvY2lhdGUgYSB0cmFjayB3aXRoIGEgdW5pcXVlIGlkLlxuICAgKi9cbiAgX3JlZ2lzdGVyVHJhY2tJZCh0cmFjaywgdHJhY2tJZCkge1xuICAgIGlmICh0cmFja0lkICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5fdHJhY2tCeUlkW3RyYWNrSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFja0lkOiBcIiR7dHJhY2tJZH1cIiBpcyBhbHJlYWR5IHVzZWRgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdHJhY2tCeUlkW3RyYWNrSWRdID0gdHJhY2s7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBhZGQgYSBgTGF5ZXJgIGluc3RhbmNlIGludG8gYSBnaXZlbiBgVHJhY2tgLiBJcyBkZXNpZ25lZCB0byBiZVxuICAgKiB1c2VkIGluIGNvbmpvbmN0aW9uIHdpdGggdGhlIGBUaW1lbGluZX5nZXRMYXllcnNCeUdyb3VwYCBtZXRob2QuIFRoZVxuICAgKiBsYXllciBpcyBpbnRlcm5hbGx5IHJlbmRlcmVkIGFuZCB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBgTGF5ZXJgIGluc3RhbmNlIHRvIGFkZCBpbnRvIHRoZSB2aXN1YWxpemF0aW9uLlxuICAgKiBAcGFyYW0geyhUcmFja3xTdHJpbmcpfSB0cmFja09yVHJhY2tJZCAtIFRoZSBgVHJhY2tgIGluc3RhbmNlIChvciBpdHMgYGlkYFxuICAgKiAgICBhcyBkZWZpbmVkIGluIHRoZSBgY3JlYXRlVHJhY2tgIG1ldGhvZCkgd2hlcmUgdGhlIGBMYXllcmAgaW5zdGFuY2Ugc2hvdWxkIGJlIGluc2VydGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2dyb3VwSWQ9J2RlZmF1bHQnXSAtIEFuIG9wdGlvbm5hbCBncm91cCBpZCBpbiB3aGljaCB0aGVcbiAgICogICAgYExheWVyYCBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQXhpc10gLSBTZXQgdG8gYHRydWVgIGlmIHRoZSBhZGRlZCBgbGF5ZXJgIGlzIGFuXG4gICAqICAgIGluc3RhbmNlIG9mIGBBeGlzTGF5ZXJgICh0aGVzZSBsYXllcnMgc2hhcmVzIHRoZSBgVGltbGluZVRpbWVDb250ZXh0YCBpbnN0YW5jZVxuICAgKiAgICBvZiB0aGUgdGltZWxpbmUpLlxuICAgKi9cbiAgYWRkTGF5ZXIobGF5ZXIsIHRyYWNrT3JUcmFja0lkLCBncm91cElkID0gJ2RlZmF1bHQnLCBpc0F4aXMgPSBmYWxzZSkge1xuICAgIGxldCB0cmFjayA9IHRyYWNrT3JUcmFja0lkO1xuXG4gICAgaWYgKHR5cGVvZiB0cmFja09yVHJhY2tJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyYWNrID0gdGhpcy5nZXRUcmFja0J5SWQodHJhY2tPclRyYWNrSWQpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZXMgdGhlIGBMYXllclRpbWVDb250ZXh0YCBpZiBub3QgcHJlc2VudFxuICAgIGlmICghbGF5ZXIudGltZUNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHRpbWVDb250ZXh0ID0gaXNBeGlzID9cbiAgICAgICAgdGhpcy50aW1lQ29udGV4dCA6IG5ldyBMYXllclRpbWVDb250ZXh0KHRoaXMudGltZUNvbnRleHQpO1xuXG4gICAgICBsYXllci5zZXRUaW1lQ29udGV4dCh0aW1lQ29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gd2Ugc2hvdWxkIGhhdmUgYSBUcmFjayBpbnN0YW5jZSBhdCB0aGlzIHBvaW50XG4gICAgdHJhY2suYWRkKGxheWVyKTtcblxuICAgIGlmICghdGhpcy5fZ3JvdXBlZExheWVyc1tncm91cElkXSkge1xuICAgICAgdGhpcy5fZ3JvdXBlZExheWVyc1tncm91cElkXSA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuX2dyb3VwZWRMYXllcnNbZ3JvdXBJZF0ucHVzaChsYXllcik7XG5cbiAgICBsYXllci5yZW5kZXIoKTtcbiAgICBsYXllci51cGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgbGF5ZXIgZnJvbSBpdHMgdHJhY2suIFRoZSBsYXllciBpcyBkZXRhdGNoZWQgZnJvbSB0aGUgRE9NIGJ1dFxuICAgKiBjYW4gc3RpbGwgYmUgcmV1c2VkIGxhdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVMYXllcihsYXllcikge1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdHJhY2subGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkgeyB0cmFjay5yZW1vdmUobGF5ZXIpOyB9XG4gICAgfSk7XG5cbiAgICAvLyBjbGVhbiByZWZlcmVuY2VzIGluIGhlbHBlcnNcbiAgICBmb3IgKGxldCBncm91cElkIGluIHRoaXMuX2dyb3VwZWRMYXllcnMpIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5fZ3JvdXBlZExheWVyc1tncm91cElkXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ3JvdXAuaW5kZXhPZihsYXllcik7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHsgZ3JvdXAuc3BsaWNlKGxheWVyLCAxKTsgfVxuXG4gICAgICBpZiAoIWdyb3VwLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fZ3JvdXBlZExheWVyc1tncm91cElkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGBUcmFja2AgaW5zdGFuY2UgZnJvbSBpdCdzIGdpdmVuIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhY2tJZFxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICovXG4gIGdldFRyYWNrQnlJZCh0cmFja0lkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrQnlJZFt0cmFja0lkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0cmFjayBjb250YWluaW5nIGEgZ2l2ZW4gRE9NIEVsZW1lbnQsIHJldHVybnMgbnVsbCBpZiBubyBtYXRjaCBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSAkZWwgLSBUaGUgRE9NIEVsZW1lbnQgdG8gYmUgdGVzdGVkLlxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICovXG4gIGdldFRyYWNrRnJvbURPTUVsZW1lbnQoJGVsKSB7XG4gICAgbGV0ICRzdmcgPSBudWxsO1xuICAgIGxldCB0cmFjayA9IG51bGw7XG4gICAgLy8gZmluZCB0aGUgY2xvc2VzdCBgLnRyYWNrYCBlbGVtZW50XG4gICAgZG8ge1xuICAgICAgaWYgKCRlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3RyYWNrJykpIHtcbiAgICAgICAgJHN2ZyA9ICRlbDtcbiAgICAgIH1cbiAgICAgICRlbCA9ICRlbC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKCRzdmcgPT09IG51bGwpO1xuICAgIC8vIGZpbmQgdGhlIHJlbGF0ZWQgYFRyYWNrYFxuICAgIHRoaXMudHJhY2tzLmZvckVhY2goZnVuY3Rpb24oX3RyYWNrKSB7XG4gICAgICBpZiAoX3RyYWNrLiRzdmcgPT09ICRzdmcpIHsgdHJhY2sgPSBfdHJhY2s7IH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0cmFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxheWVycyBmcm9tIHRoZWlyIGdpdmVuIGdyb3VwIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBJZCAtIFRoZSBpZCBvZiB0aGUgZ3JvdXAgYXMgZGVmaW5lZCBpbiBgYWRkTGF5ZXJgLlxuICAgKiBAcmV0dXJuIHsoQXJyYXl8dW5kZWZpbmVkKX1cbiAgICovXG4gIGdldExheWVyc0J5R3JvdXAoZ3JvdXBJZCkge1xuICAgIHJldHVybiB0aGlzLl9ncm91cGVkTGF5ZXJzW2dyb3VwSWRdO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVsaW5lO1xuIiwiaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvTGF5ZXInO1xuaW1wb3J0IERvdCBmcm9tICcuLi9zaGFwZXMvRG90JztcbmltcG9ydCBMaW5lIGZyb20gJy4uL3NoYXBlcy9MaW5lJztcbmltcG9ydCBCcmVha3BvaW50QmVoYXZpb3IgZnJvbSAnLi4vYmVoYXZpb3JzL0JyZWFrcG9pbnRCZWhhdmlvcic7XG5cblxuLyoqXG4gKiBIZWxwZXIgdG8gY3JlYXRlIGEgYnJlYWtwb2ludCBmdW5jdGlvbiBsYXllci5cbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci1icmVha3BvaW50Lmh0bWwpXG4gKi9cbmNsYXNzIEJyZWFrcG9pbnRMYXllciBleHRlbmRzIExheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2Nlc3NvcnMgLSBUaGUgYWNjZXNzb3JzIHRvIGNvbmZpZ3VyZSB0aGUgbWFwcGluZ1xuICAgKiAgICBiZXR3ZWVuIHNoYXBlcyBhbmQgZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSwgYWNjZXNzb3JzID0ge30pIHtcbiAgICBzdXBlcignY29sbGVjdGlvbicsIGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuICAgIGxldCBjb21tb25TaGFwZU9wdGlvbnMgPSB7fTtcblxuICAgIGlmIChjb2xvcikge1xuICAgICAgYWNjZXNzb3JzLmNvbG9yID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb2xvcjsgfTtcbiAgICAgIGNvbW1vblNoYXBlT3B0aW9ucy5jb2xvciA9IGNvbG9yO1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlndXJlQ29tbW9uU2hhcGUoTGluZSwgYWNjZXNzb3JzLCBjb21tb25TaGFwZU9wdGlvbnMpO1xuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoRG90LCBhY2Nlc3NvcnMsIHt9KTtcbiAgICB0aGlzLnNldEJlaGF2aW9yKG5ldyBCcmVha3BvaW50QmVoYXZpb3IoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJlYWtwb2ludExheWVyO1xuIiwiaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvTGF5ZXInO1xuaW1wb3J0IEN1cnNvciBmcm9tICcuLi9zaGFwZXMvQ3Vyc29yJztcblxuXG4vKipcbiAqIEhlbHBlciB0byBjcmVhdGUgYSBjdXJzb3IgbGF5ZXIuXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvbGF5ZXItY3Vyc29yLmh0bWwpXG4gKi9cbmNsYXNzIEN1cnNvckxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBbiBvYmplY3QgdG8gY29uZmlndXJlIHRoZSBsYXllci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgaGl0dGFibGU6IGZhbHNlLCAvLyBraW5kIG9mIHBhc3MgdGhyb3VnaCBsYXllclxuICAgIH07XG5cbiAgICBjb25zdCBkYXRhID0geyBjdXJyZW50UG9zaXRpb246IDAgfTtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICBzdXBlcignZW50aXR5JywgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKEN1cnNvciwgeyB4OiAoZCkgPT4gZC5jdXJyZW50UG9zaXRpb24gfSwge1xuICAgICAgY29sb3I6IG9wdGlvbnMuY29sb3JcbiAgICB9KTtcbiAgfVxuXG4gIHNldCBjdXJyZW50UG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmRhdGFbMF0uY3VycmVudFBvc2l0aW9uID0gdmFsdWU7XG4gIH1cblxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbMF0uY3VycmVudFBvc2l0aW9uO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEN1cnNvckxheWVyO1xuIiwiaW1wb3J0IEF4aXNMYXllciBmcm9tICcuLi9heGlzL0F4aXNMYXllcic7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vc2hhcGVzL1RpY2tzJztcbmltcG9ydCBncmlkQXhpc0dlbmVyYXRvciBmcm9tICcuLi9heGlzL2dyaWRBeGlzR2VuZXJhdG9yJztcblxuXG4vKipcbiAqIEhlbHBlciB0byBjcmVhdGUgYSBncmlkIGxheWVyXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvbGF5ZXItYXhpcy5odG1sKVxuICovXG5jbGFzcyBHcmlkQXhpc0xheWVyIGV4dGVuZHMgQXhpc0xheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUgbGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgY29sb3I6ICdzdGVlbGJsdWUnLFxuICAgICAgYnBtOiA2MCxcbiAgICAgIHNpZ25hdHVyZTogJzQvNCdcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHN1cGVyKGdyaWRBeGlzR2VuZXJhdG9yKG9wdGlvbnMuYnBtLCBvcHRpb25zLnNpZ25hdHVyZSksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jb25maWd1cmVTaGFwZShUaWNrcywge30sIHtcbiAgICAgIGNvbG9yOiBvcHRpb25zLmNvbG9yXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR3JpZEF4aXNMYXllcjtcbiIsImltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL0xheWVyJztcbmltcG9ydCBNYXJrZXIgZnJvbSAnLi4vc2hhcGVzL01hcmtlcic7XG5pbXBvcnQgTWFya2VyQmVoYXZpb3IgZnJvbSAnLi4vYmVoYXZpb3JzL01hcmtlckJlaGF2aW9yJztcblxuXG4vKipcbiAqIEhlbHBlciB0byBjcmVhdGUgYSBtYXJrZXIgbGF5ZXIuXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvbGF5ZXItYnJlYWtwb2ludC5odG1sKVxuICovXG5jbGFzcyBNYXJrZXJMYXllciBleHRlbmRzIExheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2Nlc3NvcnMgLSBUaGUgYWNjZXNzb3JzIHRvIGNvbmZpZ3VyZSB0aGUgbWFwcGluZ1xuICAgKiAgICBiZXR3ZWVuIHNoYXBlcyBhbmQgZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSwgYWNjZXNzb3JzID0ge30pIHtcbiAgICBzdXBlcignY29sbGVjdGlvbicsIGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZGlzcGxheUhhbmRsZXJzOiB0cnVlLFxuICAgICAgZGlzcGxheUxhYmVsczogZmFsc2UsXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBjb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cbiAgICBpZiAoY29sb3IpXG4gICAgICBhY2Nlc3NvcnMuY29sb3IgPSAoKSA9PiBjb2xvcjtcblxuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoTWFya2VyLCBhY2Nlc3NvcnMsIHtcbiAgICAgIGRpc3BsYXlIYW5kbGVyczogb3B0aW9ucy5kaXNwbGF5SGFuZGxlcnMsXG4gICAgICBvcGFjaXR5OiBvcHRpb25zLm9wYWNpdHksXG4gICAgfSk7XG5cbiAgICB0aGlzLnNldEJlaGF2aW9yKG5ldyBNYXJrZXJCZWhhdmlvcigpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXJrZXJMYXllcjtcbiIsImltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL0xheWVyJztcbmltcG9ydCBTZWdtZW50IGZyb20gJy4uL3NoYXBlcy9TZWdtZW50JztcbmltcG9ydCBTZWdtZW50QmVoYXZpb3IgZnJvbSAnLi4vYmVoYXZpb3JzL1NlZ21lbnRCZWhhdmlvcic7XG5cblxuLyoqXG4gKiBIZWxwZXIgdG8gY3JlYXRlIGEgc2VnbWVudCBsYXllci5cbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci1zZWdtZW50Lmh0bWwpXG4gKi9cbmNsYXNzIFNlZ21lbnRMYXllciBleHRlbmRzIExheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2Nlc3NvcnMgLSBUaGUgYWNjZXNzb3JzIHRvIGNvbmZpZ3VyZSB0aGUgbWFwcGluZ1xuICAgKiAgICBiZXR3ZWVuIHNoYXBlcyBhbmQgZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSwgYWNjZXNzb3JzID0ge30pIHtcbiAgICBzdXBlcignY29sbGVjdGlvbicsIGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZGlzcGxheUhhbmRsZXJzOiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC42XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKFNlZ21lbnQsIGFjY2Vzc29ycywge1xuICAgICAgZGlzcGxheUhhbmRsZXJzOiBvcHRpb25zLmRpc3BsYXlIYW5kbGVycyxcbiAgICAgIG9wYWNpdHk6IG9wdGlvbnMub3BhY2l0eSxcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0QmVoYXZpb3IobmV3IFNlZ21lbnRCZWhhdmlvcigpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWdtZW50TGF5ZXI7XG4iLCJpbXBvcnQgTGF5ZXIgZnJvbSAnLi4vY29yZS9MYXllcic7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vc2hhcGVzL1RpY2tzJztcblxuXG4vKipcbiAqIEhlbHBlciB0byBjcmVhdGUgYSB0aWNrIGxheWVyLiBDYW4gYmUgc2VlbiBhcyBhIGdyaWQgYXhpcyB3aXRoIHVzZXIgZGVmaW5lZCBkYXRhXG4gKiBvciBhcyBhIG1hcmtlciBsYXllciB3aXRoIGVudGl0eSBiYXNlZCBkYXRhLlxuICovXG5jbGFzcyBUaWNrTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFuIG9iamVjdCB0byBjb25maWd1cmUgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjZXNzb3JzIC0gVGhlIGFjY2Vzc29ycyB0byBjb25maWd1cmUgdGhlIG1hcHBpbmdcbiAgICogICAgYmV0d2VlbiBzaGFwZXMgYW5kIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zLCBhY2Nlc3NvcnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHN1cGVyKCdlbnRpdHknLCBkYXRhLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGNvbmZpZyA9IG9wdGlvbnMuY29sb3IgPyB7IGNvbG9yOiBvcHRpb25zLmNvbG9yIH0gOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb25maWd1cmVTaGFwZShUaWNrcywgYWNjZXNzb3JzLCBjb25maWcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpY2tMYXllcjtcbiIsImltcG9ydCBBeGlzTGF5ZXIgZnJvbSAnLi4vYXhpcy9BeGlzTGF5ZXInO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL3NoYXBlcy9UaWNrcyc7XG5pbXBvcnQgdGltZUF4aXNHZW5lcmF0b3IgZnJvbSAnLi4vYXhpcy90aW1lQXhpc0dlbmVyYXRvcic7XG5cblxuLyoqXG4gKiBIZWxwZXIgdG8gY3JlYXRlIGEgdGltZSBheGlzIGxheWVyXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvbGF5ZXItYXhpcy5odG1sKVxuICovXG5jbGFzcyBUaW1lQXhpc0xheWVyIGV4dGVuZHMgQXhpc0xheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUgbGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBjb2xvcjogJ3N0ZWVsYmx1ZScgfSwgb3B0aW9ucyk7XG4gICAgc3VwZXIodGltZUF4aXNHZW5lcmF0b3IoKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKFRpY2tzLCB7fSwge1xuICAgICAgY29sb3I6IG9wdGlvbnMuY29sb3JcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lQXhpc0xheWVyO1xuIiwiaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvTGF5ZXInO1xuaW1wb3J0IFRyYWNlUGF0aCBmcm9tICcuLi9zaGFwZXMvVHJhY2VQYXRoJztcbmltcG9ydCBUcmFjZURvdHMgZnJvbSAnLi4vc2hhcGVzL1RyYWNlRG90cyc7XG5pbXBvcnQgVHJhY2VCZWhhdmlvciBmcm9tICcuLi9iZWhhdmlvcnMvVHJhY2VCZWhhdmlvcic7XG5cblxuLyoqXG4gKiBIZWxwZXIgdG8gY3JlYXRlIGEgdHJhY2UgbGF5ZXIuXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvbGF5ZXItdHJhY2UuaHRtbClcbiAqL1xuY2xhc3MgVHJhY2VMYXllciBleHRlbmRzIExheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUgbGF5ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2Nlc3NvcnMgLSBUaGUgYWNjZXNzb3JzIHRvIGNvbmZpZ3VyZSB0aGUgbWFwcGluZ1xuICAgKiAgICBiZXR3ZWVuIHNoYXBlcyBhbmQgZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSwgYWNjZXNzb3JzID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGRpc3BsYXlEb3RzOiB0cnVlIH0sIG9wdGlvbnMpO1xuICAgIHN1cGVyKG9wdGlvbnMuZGlzcGxheURvdHMgPyAnY29sbGVjdGlvbicgOiAnZW50aXR5JywgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBzaGFwZU9wdGlvbnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5tZWFuQ29sb3IgIT09IHVuZGVmaW5lZCkgeyBzaGFwZU9wdGlvbnMubWVhbkNvbG9yID0gb3B0aW9ucy5tZWFuQ29sb3I7IH1cbiAgICBpZiAob3B0aW9ucy5yYW5nZUNvbG9yICE9PSB1bmRlZmluZWQpIHsgc2hhcGVPcHRpb25zLnJhbmdlQ29sb3IgPSBvcHRpb25zLnJhbmdlQ29sb3I7IH1cbiAgICBpZiAob3B0aW9ucy5kaXNwbGF5TWVhbiAhPT0gdW5kZWZpbmVkKSB7IHNoYXBlT3B0aW9ucy5kaXNwbGF5TWVhbiA9IG9wdGlvbnMuZGlzcGxheU1lYW47IH1cblxuICAgIGlmIChvcHRpb25zLmRpc3BsYXlEb3RzKSB7XG4gICAgICB0aGlzLmNvbmZpZ3VyZUNvbW1vblNoYXBlKFRyYWNlUGF0aCwgYWNjZXNzb3JzLCBzaGFwZU9wdGlvbnMpO1xuICAgICAgdGhpcy5jb25maWd1cmVTaGFwZShUcmFjZURvdHMsIGFjY2Vzc29ycywgc2hhcGVPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25maWd1cmVTaGFwZShUcmFjZVBhdGgsIGFjY2Vzc29ycywgc2hhcGVPcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEJlaGF2aW9yKG5ldyBUcmFjZUJlaGF2aW9yKCkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyYWNlTGF5ZXI7XG4iLCJpbXBvcnQgTGF5ZXIgZnJvbSAnLi4vY29yZS9MYXllcic7XG5pbXBvcnQgV2F2ZWZvcm0gZnJvbSAnLi4vc2hhcGVzL1dhdmVmb3JtJztcblxuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgeURvbWFpbjogWy0xLCAxXSxcbiAgY2hhbm5lbDogMCxcbiAgY29sb3I6ICdzdGVlbGJsdWUnLFxuICByZW5kZXJpbmdTdHJhdGVneTogJ3N2Zydcbn07XG5cbi8qKlxuICogSGVscGVyIHRvIGNyZWF0ZSBhIHdhdmVmb3JtIGxheWVyLlxuICpcbiAqIFtleGFtcGxlIHVzYWdlXSguL2V4YW1wbGVzL2xheWVyLXdhdmVmb3JtLmh0bWwpXG4gKi9cbmNsYXNzIFdhdmVmb3JtTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBidWZmZXIgLSBUaGUgYXVkaW8gYnVmZmVyIHRvIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUgbGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihidWZmZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgc3VwZXIoJ2VudGl0eScsIGJ1ZmZlci5nZXRDaGFubmVsRGF0YShvcHRpb25zLmNoYW5uZWwpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoV2F2ZWZvcm0sIHt9LCB7XG4gICAgICBzYW1wbGVSYXRlOiBidWZmZXIuc2FtcGxlUmF0ZSxcbiAgICAgIGNvbG9yOiBvcHRpb25zLmNvbG9yLFxuICAgICAgcmVuZGVyaW5nU3RyYXRlZ3k6IG9wdGlvbnMucmVuZGVyaW5nU3RyYXRlZ3lcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXYXZlZm9ybUxheWVyO1xuIiwiLy8gY29yZVxuaW1wb3J0IExheWVyVGltZUNvbnRleHQgZnJvbSAnLi9jb3JlL0xheWVyVGltZUNvbnRleHQnO1xuaW1wb3J0IExheWVyIGZyb20gJy4vY29yZS9MYXllcic7XG5pbXBvcnQgbmFtZXNwYWNlIGZyb20gJy4vY29yZS9uYW1lc3BhY2UnO1xuaW1wb3J0IFRpbWVsaW5lVGltZUNvbnRleHQgZnJvbSAnLi9jb3JlL1RpbWVsaW5lVGltZUNvbnRleHQnO1xuaW1wb3J0IFRpbWVsaW5lIGZyb20gJy4vY29yZS90aW1lbGluZSc7XG5pbXBvcnQgVHJhY2tDb2xsZWN0aW9uIGZyb20gJy4vY29yZS9UcmFja0NvbGxlY3Rpb24nO1xuaW1wb3J0IFRyYWNrIGZyb20gJy4vY29yZS9UcmFjayc7XG5cbi8vIHNoYXBlc1xuaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL3NoYXBlcy9CYXNlU2hhcGUnO1xuaW1wb3J0IEN1cnNvciBmcm9tICcuL3NoYXBlcy9DdXJzb3InO1xuaW1wb3J0IERvdCBmcm9tICcuL3NoYXBlcy9Eb3QnO1xuaW1wb3J0IExpbmUgZnJvbSAnLi9zaGFwZXMvTGluZSc7XG5pbXBvcnQgTWFya2VyIGZyb20gJy4vc2hhcGVzL01hcmtlcic7XG5pbXBvcnQgU2VnbWVudCBmcm9tICcuL3NoYXBlcy9TZWdtZW50JztcbmltcG9ydCBUaWNrcyBmcm9tICcuL3NoYXBlcy9UaWNrcyc7XG5pbXBvcnQgVHJhY2VEb3RzIGZyb20gJy4vc2hhcGVzL1RyYWNlRG90cyc7XG5pbXBvcnQgVHJhY2VQYXRoIGZyb20gJy4vc2hhcGVzL1RyYWNlUGF0aCc7XG5pbXBvcnQgV2F2ZWZvcm0gZnJvbSAnLi9zaGFwZXMvV2F2ZWZvcm0nO1xuXG4vLyBiZWhhdmlvcnNcbmltcG9ydCBCYXNlQmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvQmFzZUJlaGF2aW9yJztcbmltcG9ydCBCcmVha3BvaW50QmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvQnJlYWtwb2ludEJlaGF2aW9yJztcbmltcG9ydCBNYXJrZXJCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9NYXJrZXJCZWhhdmlvcic7XG5pbXBvcnQgU2VnbWVudEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL1NlZ21lbnRCZWhhdmlvcic7XG5pbXBvcnQgVGltZUNvbnRleHRCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9UaW1lQ29udGV4dEJlaGF2aW9yJztcbmltcG9ydCBUcmFjZUJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL1RyYWNlQmVoYXZpb3InO1xuXG4vLyBpbnRlcmFjdGlvbnNcbmltcG9ydCBFdmVudFNvdXJjZSBmcm9tICcuL2ludGVyYWN0aW9ucy9FdmVudFNvdXJjZSc7XG5pbXBvcnQgS2V5Ym9hcmQgZnJvbSAnLi9pbnRlcmFjdGlvbnMvS2V5Ym9hcmQnO1xuaW1wb3J0IFN1cmZhY2UgZnJvbSAnLi9pbnRlcmFjdGlvbnMvU3VyZmFjZSc7XG5pbXBvcnQgV2F2ZUV2ZW50IGZyb20gJy4vaW50ZXJhY3Rpb25zL1dhdmVFdmVudCc7XG5cbi8vIHN0YXRlc1xuaW1wb3J0IEJhc2VTdGF0ZSBmcm9tICcuL3N0YXRlcy9CYXNlU3RhdGUnO1xuaW1wb3J0IEJyZWFrcG9pbnRTdGF0ZSBmcm9tICcuL3N0YXRlcy9CcmVha3BvaW50U3RhdGUnO1xuaW1wb3J0IEJydXNoWm9vbVN0YXRlIGZyb20gJy4vc3RhdGVzL0JydXNoWm9vbVN0YXRlJztcbmltcG9ydCBDZW50ZXJlZFpvb21TdGF0ZSBmcm9tICcuL3N0YXRlcy9DZW50ZXJlZFpvb21TdGF0ZSc7XG5pbXBvcnQgQ29udGV4dEVkaXRpb25TdGF0ZSBmcm9tICcuL3N0YXRlcy9Db250ZXh0RWRpdGlvblN0YXRlJztcbmltcG9ydCBFZGl0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZXMvRWRpdGlvblN0YXRlJztcbmltcG9ydCBTZWxlY3Rpb25TdGF0ZSBmcm9tICcuL3N0YXRlcy9TZWxlY3Rpb25TdGF0ZSc7XG5pbXBvcnQgU2ltcGxlRWRpdGlvblN0YXRlIGZyb20gJy4vc3RhdGVzL1NpbXBsZUVkaXRpb25TdGF0ZSc7XG5cbi8vIGhlbHBlcnNcbmltcG9ydCBCcmVha3BvaW50TGF5ZXIgZnJvbSAnLi9oZWxwZXJzL0JyZWFrcG9pbnRMYXllcic7XG5pbXBvcnQgQ3Vyc29yTGF5ZXIgZnJvbSAnLi9oZWxwZXJzL0N1cnNvckxheWVyJztcbmltcG9ydCBHcmlkQXhpc0xheWVyIGZyb20gJy4vaGVscGVycy9HcmlkQXhpc0xheWVyJztcbmltcG9ydCBNYXJrZXJMYXllciBmcm9tICcuL2hlbHBlcnMvTWFya2VyTGF5ZXInO1xuaW1wb3J0IFNlZ21lbnRMYXllciBmcm9tICcuL2hlbHBlcnMvU2VnbWVudExheWVyJztcbmltcG9ydCBUaWNrTGF5ZXIgZnJvbSAnLi9oZWxwZXJzL1RpY2tMYXllcic7XG5pbXBvcnQgVGltZUF4aXNMYXllciBmcm9tICcuL2hlbHBlcnMvVGltZUF4aXNMYXllcic7XG5pbXBvcnQgVHJhY2VMYXllciBmcm9tICcuL2hlbHBlcnMvVHJhY2VMYXllcic7XG5pbXBvcnQgV2F2ZWZvcm1MYXllciBmcm9tICcuL2hlbHBlcnMvV2F2ZWZvcm1MYXllcic7XG5cbi8vIGF4aXNcbmltcG9ydCBBeGlzTGF5ZXIgZnJvbSAnLi9heGlzL0F4aXNMYXllcic7XG5pbXBvcnQgZ3JpZEF4aXNHZW5lcmF0b3IgZnJvbSAnLi9heGlzL2dyaWRBeGlzR2VuZXJhdG9yJztcbmltcG9ydCB0aW1lQXhpc0dlbmVyYXRvciBmcm9tICcuL2F4aXMvdGltZUF4aXNHZW5lcmF0b3InO1xuXG4vLyB1dGlsc1xuaW1wb3J0IGZvcm1hdCBmcm9tICcuL3V0aWxzL2Zvcm1hdCc7XG5pbXBvcnQgT3J0aG9nb25hbERhdGEgZnJvbSAnLi91dGlscy9PcnRob2dvbmFsRGF0YSc7XG5pbXBvcnQgc2NhbGVzIGZyb20gJy4vdXRpbHMvc2NhbGVzJztcblxuZXhwb3J0IGNvbnN0IGNvcmUgPSB7XG4gIExheWVyVGltZUNvbnRleHQsIExheWVyLCBuYW1lc3BhY2UsXG4gIFRpbWVsaW5lVGltZUNvbnRleHQsIFRpbWVsaW5lLCBUcmFja0NvbGxlY3Rpb24sIFRyYWNrXG59O1xuXG5leHBvcnQgY29uc3Qgc2hhcGVzID0ge1xuICBCYXNlU2hhcGUsIEN1cnNvciwgRG90LCBMaW5lLCBNYXJrZXIsIFNlZ21lbnQsXG4gIFRpY2tzLCBUcmFjZVBhdGgsIFRyYWNlRG90cywgV2F2ZWZvcm1cbn07XG5cbmV4cG9ydCBjb25zdCBiZWhhdmlvcnMgPSB7XG4gIEJhc2VCZWhhdmlvciwgQnJlYWtwb2ludEJlaGF2aW9yLCBNYXJrZXJCZWhhdmlvciwgU2VnbWVudEJlaGF2aW9yLFxuICBUaW1lQ29udGV4dEJlaGF2aW9yLCBUcmFjZUJlaGF2aW9yXG59O1xuXG5leHBvcnQgY29uc3QgaW50ZXJhY3Rpb25zID0geyBFdmVudFNvdXJjZSwgS2V5Ym9hcmQsIFN1cmZhY2UsIFdhdmVFdmVudCB9O1xuXG5leHBvcnQgY29uc3Qgc3RhdGVzID0ge1xuICBCYXNlU3RhdGUsIEJyZWFrcG9pbnRTdGF0ZSwgQnJ1c2hab29tU3RhdGUsIENlbnRlcmVkWm9vbVN0YXRlLFxuICBDb250ZXh0RWRpdGlvblN0YXRlLCBFZGl0aW9uU3RhdGUsIFNlbGVjdGlvblN0YXRlLCBTaW1wbGVFZGl0aW9uU3RhdGVcbn07XG5cbmV4cG9ydCBjb25zdCBoZWxwZXJzID0ge1xuICBCcmVha3BvaW50TGF5ZXIsIEN1cnNvckxheWVyLCBHcmlkQXhpc0xheWVyLCBNYXJrZXJMYXllciwgU2VnbWVudExheWVyLFxuICBUaWNrTGF5ZXIsIFRpbWVBeGlzTGF5ZXIsIFRyYWNlTGF5ZXIsIFdhdmVmb3JtTGF5ZXJcbn07XG5cbmV4cG9ydCBjb25zdCBheGlzID0ge1xuICBBeGlzTGF5ZXIsIHRpbWVBeGlzR2VuZXJhdG9yLCBncmlkQXhpc0dlbmVyYXRvclxufTtcblxuZXhwb3J0IGNvbnN0IHV0aWxzID0ge1xuICBmb3JtYXQsIE9ydGhvZ29uYWxEYXRhLCBzY2FsZXNcbn07XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuXG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdG8gZXh0ZW5kIHRvIGNyZWF0ZSBuZXcgc291cmNlcyBvZiBpbnRlcmFjdGlvbnMuXG4gKiBBIGBTdXJmYWNlYCBhbmQgYEtleWJvYXJkYCBldmVudCBzb3VyY2VzIGFyZSBwcm92aWRlZC5cbiAqL1xuY2xhc3MgRXZlbnRTb3VyY2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigkZWwpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuJGVsID0gJGVsO1xuICB9XG5cbiAgZGVzdHJveSgpwqB7XG4gICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgfVxuXG4gIGNyZWF0ZUV2ZW50KHR5cGUsIGUpIHt9XG5cbiAgYmluZEV2ZW50cygpIHt9XG5cbiAgdW5iaW5kRXZlbnRzKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRTb3VyY2U7XG4iLCJpbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnLi9FdmVudFNvdXJjZSc7XG5pbXBvcnQgV2F2ZUV2ZW50IGZyb20gJy4vV2F2ZUV2ZW50JztcblxuXG4vKipcbiAqIEEgZ2xvYmFsIGV2ZW50IHNvdXJ2ZSBmb3IgdGhlIGtleWJvYXJkLiBPbmx5IG9uZSBpbnN0YW5jZSBvZiB0aGlzIHNvdXJjZVxuICogY2FuIGJlIGNyZWF0ZWQuIFRoZSBmaXJzdCBjcmVhdGVkIHRpbWVsaW5lIGluc3RhbmNpYXRlIHRoZSBzaW5nbGV0b24sIGVhY2hcbiAqIHN1YnNlcXVlbnQgaW5zdGFuY2lhdGlvbiByZXR1cm5zIHRoZSBmaXJzdCBjcmVhdGVkIGluc3RhbmNlLlxuICovXG5jbGFzcyBLZXlib2FyZCBleHRlbmRzIEV2ZW50U291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gJGVsIC0gVGhlIGVsZW1lbnQgb24gd2hpY2ggdG8gaW5zdGFsbCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigkZWwpIHtcbiAgICBzdXBlcigkZWwpO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBzb3VyY2VcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlTmFtZSA9ICdrZXlib2FyZCc7XG5cbiAgICB0aGlzLl9vbktleURvd24gPSB0aGlzLl9vbktleURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbktleVVwID0gdGhpcy5fb25LZXlVcC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBjcmVhdGVFdmVudCh0eXBlLCBlKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgV2F2ZUV2ZW50KHRoaXMuc291cmNlTmFtZSwgdHlwZSwgZSk7XG5cbiAgICBldmVudC5zaGlmdEtleSA9IGUuc2hpZnRLZXk7XG4gICAgZXZlbnQuY3RybEtleSA9IGUuY3RybEtleTtcbiAgICBldmVudC5hbHRLZXkgPSBlLmFsdEtleTtcbiAgICBldmVudC5tZXRhS2V5ID0gZS5tZXRhS2V5O1xuICAgIGV2ZW50LndoaWNoID0gZS53aGljaDtcbiAgICBldmVudC5jaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLndoaWNoKTtcblxuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fb25LZXlVcCwgZmFsc2UpO1xuICB9XG5cbiAgdW5iaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uS2V5VXAsIGZhbHNlKTtcbiAgfVxuXG4gIF9vbktleURvd24oZSkge1xuICAgIGxldCBldmVudCA9IHRoaXMuY3JlYXRlRXZlbnQoJ2tleWRvd24nLCBlKTtcbiAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICB9XG5cbiAgX29uS2V5VXAoZSkge1xuICAgIGxldCBldmVudCA9IHRoaXMuY3JlYXRlRXZlbnQoJ2tleXVwJywgZSk7XG4gICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZDtcbiIsImltcG9ydCBFdmVudFNvdXJjZSBmcm9tICcuL0V2ZW50U291cmNlJztcbmltcG9ydCBXYXZlRXZlbnQgZnJvbSAnLi9XYXZlRXZlbnQnO1xuXG5cbi8qKlxuICogTm9ybWFsaXplcyBtb3VzZSB1c2VyIGludGVyYWN0aW9ucyB3aXRoIHRoZSB0aW1lbGluZSB1cG9uIHRoZSBET01cbiAqIGNvbnRhaW5lciBlbGVtZW50IG9mIGBUcmFja2AgaW5zdGFuY2VzLiBBcyBzb29uIGFzIGEgYHRyYWNrYCBpcyBhZGRlZCB0byBhXG4gKiBgdGltZWxpbmVgLCBpdHMgYXR0YWNoZWQgYFN1cmZhY2VgIGluc3RhbmNlIHdpbGwgZW1pdCB0aGUgbW91c2UgZXZlbnRzLlxuICovXG5jbGFzcyBTdXJmYWNlIGV4dGVuZHMgRXZlbnRTb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbCAtIFRoZSBET00gZWxlbWVudCB0byBsaXN0ZW4uXG4gICAqIEB0b2RvIC0gQWRkIHNvbWUgcGFkZGluZyB0byB0aGUgc3VyZmFjZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCRlbCkge1xuICAgIHN1cGVyKCRlbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgc291cmNlLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VOYW1lID0gJ3N1cmZhY2UnO1xuICAgIHRoaXMuX21vdXNlRG93bkV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gICAgdGhpcy5fb25Nb3VzZURvd24gPSB0aGlzLl9vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRGJsQ2xpY2sgPSB0aGlzLl9vbkRibENsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Nb3VzZU92ZXIgPSB0aGlzLl9vbk1vdXNlT3Zlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uTW91c2VPdXQgPSB0aGlzLl9vbk1vdXNlT3V0LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgYEV2ZW50YCBjbGFzc1xuICAgKi9cbiAgY3JlYXRlRXZlbnQodHlwZSwgZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IFdhdmVFdmVudCh0aGlzLnNvdXJjZU5hbWUsIHR5cGUsIGUpO1xuXG4gICAgY29uc3QgcG9zID0gdGhpcy5fZ2V0UmVsYXRpdmVQb3NpdGlvbihlKTtcbiAgICBldmVudC54ID0gcG9zLng7XG4gICAgZXZlbnQueSA9IHBvcy55O1xuXG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEtlZXAgdGhpcyBwcml2YXRlIHRvIGF2b2lkIGRvdWJsZSBldmVudCBiaW5kaW5nLiBNYWluIGxvZ2ljIG9mIHRoZSBzdXJmYWNlXG4gICAqIGlzIGhlcmUuIFNob3VsZCBiZSBleHRlbmRlZCB3aXRoIG5lZWRlZCBldmVudHMgKG1vdXNlZW50ZXIsIG1vdXNlbGVhdmUsXG4gICAqIHdoZWVsIC4uLikuXG4gICAqXG4gICAqIEB0b2RvIC0gdGhyb3R0bGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgLy8gQmluZCBjYWxsYmFja3NcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgZmFsc2UpO1xuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljaywgZmFsc2UpO1xuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5fb25EYmxDbGljaywgZmFsc2UpO1xuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMuX29uTW91c2VPdmVyLCBmYWxzZSk7XG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vbk1vdXNlT3V0LCBmYWxzZSk7XG4gIH1cblxuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgLy8gQmluZCBjYWxsYmFja3NcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgZmFsc2UpO1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljaywgZmFsc2UpO1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5fb25EYmxDbGljaywgZmFsc2UpO1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMuX29uTW91c2VPdmVyLCBmYWxzZSk7XG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vbk1vdXNlT3V0LCBmYWxzZSk7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB4LCB5IGNvb3JkaW5hdGVzIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSBzdXJmYWNlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgLSBSYXcgZXZlbnQgZnJvbSBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAdG9kbyAtIGhhbmRsZSBwYWRkaW5nLlxuICAgKi9cbiAgX2dldFJlbGF0aXZlUG9zaXRpb24oZSkge1xuICAgIC8vIEBUT0RPOiBzaG91bGQgYmUgYWJsZSB0byBpZ25vcmUgcGFkZGluZ1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgY29uc3QgY2xpZW50UmVjdCA9IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHNjcm9sbExlZnQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBjb25zdCBzY3JvbGxUb3AgID0gZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgLy8gQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbCNwb3NpdGlvblxuICAgIGlmIChlLnBhZ2VYIHx8IGUucGFnZVkpIHtcbiAgICAgIHggPSBlLnBhZ2VYO1xuICAgICAgeSA9IGUucGFnZVk7XG4gICAgfSBlbHNlIGlmIChlLmNsaWVudFggfHwgZS5jbGllbnRZKSB7XG4gICAgICAvLyBOb3JtYWxpemUgdG8gcGFnZVgsIHBhZ2VZXG4gICAgICB4ID0gZS5jbGllbnRYICsgc2Nyb2xsTGVmdDtcbiAgICAgIHkgPSBlLmNsaWVudFkgKyBzY3JvbGxUb3A7XG4gICAgfVxuXG4gICAgLy8gY2xpZW50UmVjdCByZWZlcnMgdG8gdGhlIGNsaWVudCwgbm90IHRvIHRoZSBwYWdlXG4gICAgeCA9IHggLSAoY2xpZW50UmVjdC5sZWZ0ICsgc2Nyb2xsTGVmdCk7XG4gICAgeSA9IHkgLSAoY2xpZW50UmVjdC50b3AgICsgc2Nyb2xsVG9wICk7XG5cbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH1cblxuICBfZGVmaW5lQXJlYShlLCBtb3VzZURvd25FdmVudCwgbGFzdEV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZURvd25FdmVudCB8fMKgIWxhc3RFdmVudCkgeyByZXR1cm47IH1cbiAgICBlLmR4ID0gZS54IC0gbGFzdEV2ZW50Lng7XG4gICAgZS5keSA9IGUueSAtIGxhc3RFdmVudC55O1xuXG4gICAgY29uc3QgbGVmdCA9IG1vdXNlRG93bkV2ZW50LnggPCBlLnggPyBtb3VzZURvd25FdmVudC54IDogZS54O1xuICAgIGNvbnN0IHRvcCAgPSBtb3VzZURvd25FdmVudC55IDwgZS55ID8gbW91c2VEb3duRXZlbnQueSA6IGUueTtcbiAgICBjb25zdCB3aWR0aCAgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGUueCAtIG1vdXNlRG93bkV2ZW50LngpKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGUueSAtIG1vdXNlRG93bkV2ZW50LnkpKTtcblxuICAgIGUuYXJlYSA9IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH07XG4gIH1cblxuICBfb25Nb3VzZURvd24oZSkge1xuICAgIC8vIGJ5IHJlbW92aW5nIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gd2UgcHJldmVudCBieXBhc3NpbmcgdGhlIG1vdXNlbW92ZSBldmVudHMgY29taW5nIGZyb20gU1ZHIGluIEZpcmVmb3guXG4gICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5jcmVhdGVFdmVudCgnbW91c2Vkb3duJywgZSk7XG5cblxuICAgIHRoaXMuX21vdXNlRG93bkV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZlbnQ7XG4gICAgLy8gUmVnaXN0ZXIgbW91c2Vtb3ZlIGFuZCBtb3VzZXVwIGxpc3RlbmVycyBvbiB3aW5kb3dcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuXG4gICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgfVxuXG4gIF9vbk1vdXNlTW92ZShlKSB7XG4gICAgbGV0IGV2ZW50ID0gdGhpcy5jcmVhdGVFdmVudCgnbW91c2Vtb3ZlJywgZSk7XG4gICAgdGhpcy5fZGVmaW5lQXJlYShldmVudCwgdGhpcy5fbW91c2VEb3duRXZlbnQsIHRoaXMuX2xhc3RFdmVudCk7XG4gICAgLy8gVXBkYXRlIGBsYXN0RXZlbnRgIGZvciBuZXh0IGNhbGxcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldmVudDtcblxuICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gIH1cblxuICBfb25Nb3VzZVVwKGUpIHtcbiAgICBsZXQgZXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50KCdtb3VzZXVwJywgZSk7XG4gICAgdGhpcy5fZGVmaW5lQXJlYShldmVudCwgdGhpcy5fbW91c2VEb3duRXZlbnQsIHRoaXMuX2xhc3RFdmVudCk7XG5cblxuICAgIHRoaXMuX21vdXNlRG93bkV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgIC8vIFJlbW92ZSBtb3VzZW1vdmUgYW5kIG1vdXNldXAgbGlzdGVuZXJzIG9uIHdpbmRvd1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuXG4gICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgfVxuXG4gIF9vbkNsaWNrKGUpIHtcbiAgICBsZXQgZXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50KCdjbGljaycsIGUpO1xuICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gIH1cblxuICBfb25EYmxDbGljayhlKSB7XG4gICAgbGV0IGV2ZW50ID0gdGhpcy5jcmVhdGVFdmVudCgnZGJsY2xpY2snLCBlKTtcbiAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICB9XG5cbiAgX29uTW91c2VPdmVyKGUpIHtcbiAgICBsZXQgZXZlbnQgPSB0aGlzLmNyZWF0ZUV2ZW50KCdtb3VzZW92ZXInLCBlKTtcbiAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICB9XG5cbiAgX29uTW91c2VPdXQoZSkge1xuICAgIGxldCBldmVudCA9IHRoaXMuY3JlYXRlRXZlbnQoJ21vdXNlb3V0JywgZSk7XG4gICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdXJmYWNlO1xuIiwiLyoqXG4gKiBPYmplY3QgdGVtcGxhdGUgZm9yIGFsbCBldmVudHMuIEV2ZW50IHNvdXJjZXMgc2hvdWxkIHVzZSB0aGlzIGV2ZW50IHRlbXBsYXRlXG4gKiBpbiBvcmRlciB0byBrZWVwIGNvbnNpc3RlbmN5IHdpdGggZXhpc3Rpbmcgc291cmNlcy5cbiAqL1xuY2xhc3MgV2F2ZUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgLSBUaGUgbmFtZSBvZiB0aGUgc291cmNlIChga2V5Ym9hcmRgLCBgc3VyZmFjZWAsIC4uLikuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHNvdXJjZSAoYG1vdXNlZG93bmAsIGBrZXl1cGAsIC4uLikuXG4gICAqIEBwYXJhbSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgZXZlbnQgYXMgZW1pdHRlZCBieSB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdHlwZSwgb3JpZ2luYWxFdmVudCkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcblxuICAgIHRoaXMudGFyZ2V0ID0gb3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gb3JpZ2luYWxFdmVudC5jdXJyZW50VGFyZ2V0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdhdmVFdmVudDtcbiIsImltcG9ydCBucyBmcm9tICcuLi9jb3JlL25hbWVzcGFjZSc7XG5cblxuLyoqXG4gKiBJcyBhbiBhYnN0cmFjdCBjbGFzcyBvciBpbnRlcmZhY2UgdG8gYmUgb3ZlcnJpZGVuIGluIG9yZGVyIHRvIGRlZmluZSBuZXdcbiAqIHNoYXBlcy4gU2hhcGVzIGRlZmluZSB0aGUgd2F5IGEgZ2l2ZW4gZGF0dW0gc2hvdWxkIGJlIHJlbmRlcmVkLCB0aGV5IGFyZVxuICogdGhlIHNtYWxsZXN0IHVuaXQgb2YgcmVuZGVyaW5nIGludG8gYSB0aW1lbGluZS5cbiAqXG4gKiBBbGwgdGhlIGxpZmUgY3ljbGUgb2YgYFNoYXBlYCBpbnN0YW5jZXMgaXMgaGFuZGxlZCBpbnRvIHRoZSBgTGF5ZXJgIGluc3RhbmNlXG4gKiB0aGV5IGFyZSBhdHRhY2ggdG8uIEFzIGEgY29uc2VxdWVuY2UsIHRoZXkgc2hvdWxkIGJlIG1haW5seSBjb25zaWRlcmVkIGFzXG4gKiBwcml2YXRlIG9iamVjdHMuIFRoZSBvbmx5IHBsYWNlIHRoZXkgc2hvdWxkIGJlIGludGVyYWN0ZWQgd2l0aCBpcyBpbiBgQmVoYXZpb3JgXG4gKiBkZWZpbml0aW9ucywgdG8gdGVzdCB3aGljaCBlbGVtZW50IG9mIHRoZSBzaGFwZSBpcyB0aGUgdGFyZ2V0IG9mIHRoZVxuICogaW50ZXJhY3Rpb24gYW5kIGRlZmluZSB0aGUgaW50ZXJhY3Rpb24gYWNjb3JkaW5nIHRvIHRoYXQgdGVzdC5cbiAqXG4gKiBEZXBlbmRpbmcgb2YgaXRzIGltcGxlbWVudGF0aW9uIGEgYFNoYXBlYCBjYW4gYmUgdXNlZCBhbG9uZyB3aXRoIGBlbnRpdHlgIG9yXG4gKiBgY29sbGVjdGlvbmAgZGF0YSB0eXBlLiBTb21lIHNoYXBlcyBhcmUgdGhlbiBjcmVhdGVkIHRvIHVzZSBkYXRhIGNvbnNpZGVyZWRcbiAqIGFzIGEgc2luZ2xlIGVudGl0eSAoV2F2ZWZvcm0sIFRyYWNlUGF0aCwgTGluZSksIHdoaWxlIG90aGVycyBhcmUgZGVmaW5lZCB0b1xuICogYmUgdXNlZCB3aXRoIGRhdGEgc2VlbiBhcyBhIGNvbGxlY3Rpb24sIGVhY2ggc2hhcGUgcmVuZGVyaW5nIGEgc2luZ2xlIGVudHJ5XG4gKiBvZiB0aGUgY29sbGVjdGlvbi4gVGhlIHNoYXBlcyB3b3JraW5nIHdpdGggZW50aXR5IHR5cGUgZGF0YSBzaG91bGQgdGhlcmVmb3JlXG4gKiBiZSB1c2VkIGluIGFuIGBlbnRpdHlgIGNvbmZpZ3VyZWQgYExheWVyYC4gTm90ZSB0aGF0IGlmIHRoZXkgYXJlIHJlZ2lzdGVyZWRcbiAqIGFzIFwiY29tbW9uU2hhcGVcIiBpbiBhIGBjb2xsZWN0aW9uYCB0eXBlIGBMYXllcmAsIHRoZXkgd2lsbCBiZWhhdmUgdGhlIGV4YWN0XG4gKiBzYW1lIHdheS4gVGhlc2Uga2luZCBvZiBzaGFwZXMgYXJlIG5vdGVkOiBcImVudGl0eSBzaGFwZVwiLlxuICpcbiAqICMjIyBBdmFpbGFibGUgYGNvbGxlY3Rpb25gIHNoYXBlczpcbiAqIC0gTWFya2VyIC8gQW5ub3RhdGVkIE1hcmtlclxuICogLSBTZWdtZW50IC8gQW5ub3RhdGVkIFNlZ21lbnRcbiAqIC0gRG90XG4gKiAtIFRyYWNlRG90c1xuICpcbiAqICMjIyBBdmFpbGFibGUgYGVudGl0eWAgc2hhcGVzOlxuICogLSBMaW5lXG4gKiAtIFRpY2sgKGZvciBheGlzKVxuICogLSBXYXZlZm9ybVxuICogLSBUcmFjZVBhdGhcbiAqL1xuY2xhc3MgQmFzZVNoYXBlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3ZlcnJpZGUgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAvKiogQHR5cGUge0VsZW1lbnR9IC0gU3ZnIGVsZW1lbnQgdG8gYmUgcmV0dXJuZWQgYnkgdGhlIGByZW5kZXJgIG1ldGhvZC4gKi9cbiAgICB0aGlzLiRlbCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtTdHJpbmd9IC0gU3ZnIG5hbWVzcGFjZS4gKi9cbiAgICB0aGlzLm5zID0gbnM7XG4gICAgLyoqIEB0eXBlIHtPYmplY3R9IC0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGdsb2JhbCBwYXJhbWV0ZXJzIG9mIHRoZSBzaGFwZSAqL1xuICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fZ2V0RGVmYXVsdHMoKSwgb3B0aW9ucyk7XG4gICAgLy8gY3JlYXRlIGFjY2Vzc29ycyBtZXRob2RzIGFuZCBzZXQgZGVmYXVsdCBhY2Nlc3NvciBmdW5jdGlvbnNcbiAgICBjb25zdCBhY2Nlc3NvcnMgPSB0aGlzLl9nZXRBY2Nlc3Nvckxpc3QoKTtcbiAgICB0aGlzLl9jcmVhdGVBY2Nlc3NvcnMoYWNjZXNzb3JzKTtcbiAgICB0aGlzLl9zZXREZWZhdWx0QWNjZXNzb3JzKGFjY2Vzc29ycyk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgc2hhcGUgYW5kIGNsZWFuIHJlZmVyZW5jZXMuIEludGVyZmFjZSBtZXRob2QgY2FsbGVkIGZyb20gdGhlIGBsYXllcmAuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIC8vIHRoaXMuZ3JvdXAgPSBudWxsO1xuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgbWV0aG9kIHRvIG92ZXJyaWRlIHdoZW4gZXh0ZW5kaW5nIHRoaXMgYmFzZSBjbGFzcy4gVGhlIG1ldGhvZFxuICAgKiBpcyBjYWxsZWQgYnkgdGhlIGBMYXllcn5yZW5kZXJgIG1ldGhvZC4gUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgc2hhcGUsXG4gICAqIHVzZWQgYXMgYSBjbGFzcyBpbiB0aGUgZWxlbWVudCBncm91cCAoZGVmYXVsdHMgdG8gYCdzaGFwZSdgKS5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ3NoYXBlJzsgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyBub3QgaW1wbGVtZW50ZWRcbiAgICogYWxsb3cgdG8gaW5zdGFsbCBkZWZzIGluIHRoZSB0cmFjayBzdmcgZWxlbWVudC4gU2hvdWxkIGJlIGNhbGxlZCB3aGVuXG4gICAqIGFkZGluZyB0aGUgYExheWVyYCB0byB0aGUgYFRyYWNrYC5cbiAgICovXG4gIC8vIHNldFN2Z0RlZmluaXRpb24oZGVmcykge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVmYXVsdHMgZm9yIGdsb2JhbCBjb25maWd1cmF0aW9uIG9mIHRoZSBzaGFwZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGtleXMgYXJlIHRoZSBhY2Nlc3NvcnMgbWV0aG9kcyBuYW1lcyB0byBjcmVhdGVcbiAgICogYW5kIHZhbHVlcyBhcmUgdGhlIGRlZmF1bHQgdmFsdWVzIGZvciBlYWNoIGdpdmVuIGFjY2Vzc29yLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0b2RvIHJlbmFtZSA/XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIF9nZXRBY2Nlc3Nvckxpc3QoKSB7IHJldHVybiB7fTsgfVxuXG5cbiAgLyoqXG4gICAqIEludGVyZmFjZSBtZXRob2QgY2FsbGVkIGJ5IExheWVyIHdoZW4gY3JlYXRpbmcgYSBzaGFwZS4gSW5zdGFsbCB0aGVcbiAgICogZ2l2ZW4gYWNjZXNzb3JzIG9uIHRoZSBzaGFwZSwgb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBhY2Nlc3NvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PFN0cmluZywgZnVuY3Rpb24+fSBhY2Nlc3NvcnNcbiAgICovXG4gIGluc3RhbGwoYWNjZXNzb3JzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGFjY2Vzc29ycykgeyB0aGlzW2tleV0gPSBhY2Nlc3NvcnNba2V5XTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgbWV0aG9kIHRvIGNyZWF0ZSBhY2Nlc3NvcnMuIEFkZHMgZ2V0dGVycyBlbiBzZXR0ZXJzIHRvIHRoZVxuICAgKiBwcm90b3R5cGUgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAgICovXG4gIF9jcmVhdGVBY2Nlc3NvcnMoYWNjZXNzb3JzKSB7XG4gICAgdGhpcy5fYWNjZXNzb3JzID0ge307XG4gICAgLy8gYWRkIGl0IHRvIHRoZSBwcm90b3R5cGVcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAvLyBjcmVhdGUgYSBnZXR0ZXIgLyBzZXR0ZXIgZm9yIGVhY2ggYWNjZXNzb3JzXG4gICAgLy8gc2V0dGVyIDogYHRoaXMueCA9IGNhbGxiYWNrYFxuICAgIC8vIGdldHRlciA6IGB0aGlzLngoZGF0dW0pYFxuICAgIE9iamVjdC5rZXlzKGFjY2Vzc29ycykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpKSB7IHJldHVybjsgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2FjY2Vzc29yc1tuYW1lXTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgdGhpcy5fYWNjZXNzb3JzW25hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBhcyBhIGRlZmF1bHQgYWNjZXNzb3IgZm9yIGVhY2ggYWNjZXNvcnNcbiAgICovXG4gIF9zZXREZWZhdWx0QWNjZXNzb3JzKGFjY2Vzc29ycykge1xuICAgIE9iamVjdC5rZXlzKGFjY2Vzc29ycykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gYWNjZXNzb3JzW25hbWVdO1xuICAgICAgbGV0IGFjY2Vzc29yID0gZnVuY3Rpb24oZCwgdiA9IG51bGwpIHtcbiAgICAgICAgaWYgKHYgPT09IG51bGwpIHsgcmV0dXJuIGRbbmFtZV0gfHwgZGVmYXVsdFZhbHVlOyB9XG4gICAgICAgIGRbbmFtZV0gPSB2O1xuICAgICAgfTtcbiAgICAgIC8vIHNldCBhY2Nlc3NvciBhcyB0aGUgZGVmYXVsdCBvbmVcbiAgICAgIHRoaXNbbmFtZV0gPSBhY2Nlc3NvcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgbWV0aG9kIGNhbGxlZCBieSBgTGF5ZXJ+cmVuZGVyYC4gQ3JlYXRlcyB0aGUgRE9NIHN0cnVjdHVyZSBvZlxuICAgKiB0aGUgc2hhcGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJpbmdDb250ZXh0IC0gdGhlIHJlbmRlcmluZ0NvbnRleHQgb2YgdGhlIGxheWVyXG4gICAqICAgIHdoaWNoIG93bnMgdGhpcyBzaGFwZS5cbiAgICogQHJldHVybiB7RWxlbWVudH0gLSB0aGUgRE9NIGVsZW1lbnQgdG8gaW5zZXJ0IGluIHRoZSBpdGVtJ3MgZ3JvdXAuXG4gICAqL1xuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge31cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCBjYWxsZWQgYnkgYExheWVyfnVwZGF0ZWAuIFVwZGF0ZXMgdGhlIERPTSBzdHJ1Y3R1cmUgb2YgdGhlIHNoYXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVuZGVyaW5nQ29udGV4dCAtIFRoZSBgcmVuZGVyaW5nQ29udGV4dGAgb2YgdGhlIGxheWVyXG4gICAqICAgIHdoaWNoIG93bnMgdGhpcyBzaGFwZS5cbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdHVtIC0gVGhlIGRhdHVtIGFzc29jaWF0ZWQgdG8gdGhlIHNoYXBlLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtKSB7fVxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgbWV0aG9kIHRvIG92ZXJyaWRlIGNhbGxlZCBieSBgTGF5ZXJ+Z2V0SXRlbXNJbkFyZWFgLiBEZWZpbmVzIGlmXG4gICAqIHRoZSBzaGFwZSBpcyBjb25zaWRlcmVkIHRvIGJlIHRoZSBnaXZlbiBhcmVhLiBBcmd1bWVudHMgYXJlIHBhc3NlZCBpbiBwaXhlbCBkb21haW4uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJpbmdDb250ZXh0IC0gdGhlIHJlbmRlcmluZ0NvbnRleHQgb2YgdGhlIGxheWVyIHdoaWNoXG4gICAqICAgIG93bnMgdGhpcyBzaGFwZS5cbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdHVtIC0gVGhlIGRhdHVtIGFzc29jaWF0ZWQgdG8gdGhlIHNoYXBlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgYXJlYSB0byB0ZXN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0geTEgLSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgYXJlYSB0byB0ZXN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0geDIgLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIGJvdHRvbS1yaWdodCBjb3JuZXIgb2YgdGhlIGFyZWEgdG8gdGVzdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSBib3R0b20tcmlnaHQgY29ybmVyIG9mIHRoZSBhcmVhIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlzIGNvbnNpZGVyZWQgdG8gYmUgaW4gdGhlIGdpdmVuIGFyZWEsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgaW5BcmVhKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtLCB4MSwgeTEsIHgyLCB5Mikge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVNoYXBlO1xuIiwiaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL0Jhc2VTaGFwZSc7XG5pbXBvcnQgbnMgZnJvbSAnLi4vY29yZS9uYW1lc3BhY2UnO1xuXG5cbi8qKlxuICogQSBzaGFwZSB0byBkaXNwbGF5IGEgY3Vyc29yLlxuICpcbiAqIFtleGFtcGxlIHVzYWdlXSguL2V4YW1wbGVzL2xheWVyLWN1cnNvci5odG1sKVxuICovXG5jbGFzcyBDdXJzb3IgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICBnZXRDbGFzc05hbWUoKSB7IHJldHVybiAnY3Vyc29yJzsgfVxuXG4gIF9nZXRBY2Nlc3Nvckxpc3QoKSB7XG4gICAgcmV0dXJuIHsgeDogMCB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgb3BhY2l0eTogMVxuICAgIH07XG4gIH1cblxuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIHRoaXMuJGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnbGluZScpO1xuICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JywgMCk7XG4gICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3kxJywgMCk7XG4gICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3NoYXBlLXJlbmRlcmluZycsICdjcmlzcEVkZ2VzJyk7XG4gICAgdGhpcy4kZWwuc3R5bGUuc3Ryb2tlID0gdGhpcy5wYXJhbXMuY29sb3I7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICB1cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pIHtcbiAgICBjb25zdCBmbG9hdFggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkYXR1bSkpO1xuICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKGZsb2F0WCk7XG5cbiAgICB0aGlzLiRlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCAwKWApO1xuICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5MicsIHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3Vyc29yIGNhbm5vdCBiZSBzZWxlY3RlZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZmFsc2VcbiAgICovXG4gIGluQXJlYSgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEN1cnNvcjtcbiIsImltcG9ydCBCYXNlU2hhcGUgZnJvbSAnLi9CYXNlU2hhcGUnO1xuXG5cbi8qKlxuICogQSBzaGFwZSB0byBkaXNwbGF5IGEgZG90LlxuICpcbiAqIFtleGFtcGxlIHVzYWdlXSguL2V4YW1wbGVzL2xheWVyLWJyZWFrcG9pbnQuaHRtbClcbiAqL1xuY2xhc3MgRG90IGV4dGVuZHMgQmFzZVNoYXBlIHtcbiAgZ2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ2RvdCc7IH1cblxuICAvLyBAVE9ETyByZW5hbWUgOiBjb25mdXNpb24gYmV0d2VlbiBhY2Nlc3NvcnMgYW5kIG1ldGEtYWNjZXNzb3JzXG4gIF9nZXRBY2Nlc3Nvckxpc3QoKSB7XG4gICAgcmV0dXJuIHsgY3g6IDAsIGN5OiAwLCByOiAzLCBjb2xvcjogJyMwMDAwMDAnwqB9O1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cblxuICAgIHRoaXMuJGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsICdjaXJjbGUnKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSkge1xuICAgIGNvbnN0IGN4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLmN4KGRhdHVtKSk7XG4gICAgY29uc3QgY3kgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLmN5KGRhdHVtKSk7XG4gICAgY29uc3QgciAgPSB0aGlzLnIoZGF0dW0pO1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5jb2xvcihkYXR1bSk7XG5cbiAgICB0aGlzLiRlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke2N4fSwgJHtjeX0pYCk7XG4gICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCByKTtcbiAgICB0aGlzLiRlbC5zdHlsZS5maWxsID0gY29sb3I7XG4gIH1cblxuICAvLyB4MSwgeDIsIHkxLCB5MiA9PiBpbiBwaXhlbCBkb21haW5cbiAgaW5BcmVhKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGNvbnN0IGN4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLmN4KGRhdHVtKSk7XG4gICAgY29uc3QgY3kgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLmN5KGRhdHVtKSk7XG5cbiAgICBpZiAoKGN4ID4geDEgJiYgY3ggPCB4MikgJiYgKGN5ID4geTEgJiYgY3kgPCB5MikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEb3Q7XG4iLCJpbXBvcnQgQmFzZVNoYXBlIGZyb20gJy4vQmFzZVNoYXBlJztcblxuXG4vKipcbiAqIEEgc2hhcGUgdG8gZGlzcGxheSBhIGxpbmUuIEl0cyBtYWluIHVzZSBpcyBhcyBjb21tb24gc2hhcGUgdG8gY3JlYXRlIGFcbiAqIGJyZWFrcG9pbnQgdmlzdWFsaXphdGlvbi4gKGVudGl0eSBzaGFwZSlcbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci1icmVha3BvaW50Lmh0bWwpXG4gKi9cbmNsYXNzIExpbmUgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICBnZXRDbGFzc05hbWUoKSB7IHJldHVybiAnbGluZSc7IH1cblxuICBfZ2V0QWNjZXNzb3JMaXN0KCkge1xuICAgIHJldHVybiB7IGN4OiAwLCBjeTogMCB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7IGNvbG9yOiAnIzAwMDAwMCcgfTtcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7IHJldHVybiB0aGlzLiRlbDsgfVxuXG4gICAgdGhpcy4kZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5ucywgJ3BhdGgnKTtcbiAgICAvLyB0aGlzLmVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpO1xuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEuc2xpY2UoMCk7XG4gICAgZGF0YS5zb3J0KChhLCBiKSA9PiB0aGlzLmN4KGEpIDwgdGhpcy5jeChiKSA/IC0xIDogMSk7XG5cbiAgICBsZXQgcGF0aCA9ICdNJztcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdHVtID0gZGF0YVtpXTtcbiAgICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMuY3goZGF0dW0pKTtcbiAgICAgIGNvbnN0IHkgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLmN5KGRhdHVtKSkgLSAwLjU7XG4gICAgICBwYXRoICs9IGAke3h9LCR7eX1gO1xuXG4gICAgICBpZiAoaSA8IGxlbmd0aCAtIDEpXG4gICAgICAgIHBhdGggKz0gJ0wnO1xuICAgIH1cblxuICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcGF0aCk7XG4gICAgdGhpcy4kZWwuc3R5bGUuc3Ryb2tlID0gdGhpcy5wYXJhbXMuY29sb3I7XG4gICAgdGhpcy4kZWwuc3R5bGUuZmlsbCA9ICdub25lJztcblxuICAgIGRhdGEgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmU7XG4iLCJpbXBvcnQgQmFzZVNoYXBlIGZyb20gJy4vQmFzZVNoYXBlJztcblxuXG4vKipcbiAqIEEgc2hhcGUgdG8gZGlzcGxheSBhIG1hcmtlci5cbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci1tYXJrZXIuaHRtbClcbiAqL1xuY2xhc3MgTWFya2VyIGV4dGVuZHMgQmFzZVNoYXBlIHtcbiAgZ2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ21hcmtlcic7IH1cblxuICBfZ2V0QWNjZXNzb3JMaXN0KCkge1xuICAgIHJldHVybiB7IHg6IDAsIGNvbG9yOiAnI2ZmMDAwMCcsIGxhYmVsOiAnJyB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyV2lkdGg6IDcsXG4gICAgICBoYW5kbGVySGVpZ2h0OiAxMCxcbiAgICAgIGRpc3BsYXlIYW5kbGVyczogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBjb2xvcjogJ3JlZCcsXG4gICAgICBkaXNwbGF5TGFiZWxzOiBmYWxzZSxcbiAgICAgIGxhYmVsV2lkdGg6IDYwLFxuICAgIH07XG4gIH1cblxuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIGlmICh0aGlzLiRlbClcbiAgICAgIHJldHVybiB0aGlzLiRlbDtcblxuICAgIGNvbnN0IGhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0O1xuXG4gICAgdGhpcy4kZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5ucywgJ2cnKTtcbiAgICB0aGlzLiRsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsICdsaW5lJyk7XG5cbiAgICAvLyBkcmF3IGxpbmVcbiAgICB0aGlzLiRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JywgMCk7XG4gICAgdGhpcy4kbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneTEnLCAwKTtcbiAgICB0aGlzLiRsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpO1xuXG4gICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQodGhpcy4kbGluZSk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuZGlzcGxheUhhbmRsZXJzKSB7XG4gICAgICB0aGlzLiRoYW5kbGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsICdyZWN0Jyk7XG5cbiAgICAgIHRoaXMuJGhhbmRsZXIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLCAtIHRoaXMucGFyYW1zLmhhbmRsZXJXaWR0aCAvIDIpO1xuICAgICAgdGhpcy4kaGFuZGxlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCB0aGlzLnBhcmFtcy5oYW5kbGVyV2lkdGgpO1xuICAgICAgdGhpcy4kaGFuZGxlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgdGhpcy5wYXJhbXMuaGFuZGxlckhlaWdodCk7XG4gICAgICB0aGlzLiRoYW5kbGVyLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpO1xuXG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZCh0aGlzLiRoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuZGlzcGxheUxhYmVscykge1xuICAgICAgLy8gcHJlZmVyIGh0bWwgYGRpdmAgb3ZlciBzdmcgYHRleHRgIHRhZyBiZWNhdXNlIHdlIHRoZW4gdXNlIHRoZSBgY29udGVudGVkaXRhYmxlYCBwcm9wZXJ0eVxuICAgICAgdGhpcy4kZm9yZWlnbk9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCAnZm9yZWlnbk9iamVjdCcpO1xuXG4gICAgICB0aGlzLiRsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy4kbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLiRsYWJlbC5zdHlsZS53aWR0aCA9IGAke3RoaXMucGFyYW1zLmxhYmVsV2lkdGh9cHhgO1xuICAgICAgdGhpcy4kbGFiZWwuc3R5bGUuZm9udFNpemUgPSAnMTJweCc7XG4gICAgICB0aGlzLiRsYWJlbC5zdHlsZS5mb250RmFtaWx5ID0gJ2FyaWFsJztcbiAgICAgIHRoaXMuJGxhYmVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRsYWJlbC5zdHlsZS5vdXRsaW5lV2lkdGggPSAnMXB4JztcblxuICAgICAgdGhpcy4kZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZCh0aGlzLiRsYWJlbCk7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZCh0aGlzLiRmb3JlaWduT2JqZWN0KTtcbiAgICB9XG5cbiAgICB0aGlzLiRlbC5zdHlsZS5vcGFjaXR5ID0gdGhpcy5wYXJhbXMub3BhY2l0eTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSkge1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkYXR1bSkpO1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5jb2xvcihkYXR1bSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG5cbiAgICB0aGlzLiRlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCAwKWApO1xuXG4gICAgdGhpcy4kbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneTInLCBoZWlnaHQpO1xuICAgIHRoaXMuJGxpbmUuc3R5bGUuc3Ryb2tlID0gY29sb3I7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuZGlzcGxheUhhbmRsZXJzKSB7XG4gICAgICB0aGlzLiRoYW5kbGVyLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgaGVpZ2h0IC0gdGhpcy5wYXJhbXMuaGFuZGxlckhlaWdodCk7XG4gICAgICB0aGlzLiRoYW5kbGVyLnN0eWxlLmZpbGwgPSBjb2xvcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuZGlzcGxheUxhYmVscykge1xuICAgICAgY29uc3QgbWF0cml4ID0gYG1hdHJpeCgxLCAwLCAwLCAtMSwgJHt0aGlzLnBhcmFtcy5oYW5kbGVyV2lkdGh9LCAke2hlaWdodCAtIDJ9KWA7XG4gICAgICB0aGlzLiRmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd0cmFuc2Zvcm0nLCBtYXRyaXgpO1xuICAgICAgdGhpcy4kbGFiZWwuaW5uZXJIVE1MID0gdGhpcy5sYWJlbChkYXR1bSk7XG4gICAgfVxuICB9XG5cbiAgaW5BcmVhKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIC8vIGhhbmRsZXJzIG9ubHkgYXJlIHNlbGVjdGFibGVcbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZGF0dW0pKTtcbiAgICBjb25zdCBzaGFwZVgxID0geCAtICh0aGlzLnBhcmFtcy5oYW5kbGVyV2lkdGggLSAxKSAvIDI7XG4gICAgY29uc3Qgc2hhcGVYMiA9IHNoYXBlWDEgKyB0aGlzLnBhcmFtcy5oYW5kbGVyV2lkdGg7XG4gICAgY29uc3Qgc2hhcGVZMSA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0IC0gdGhpcy5wYXJhbXMuaGFuZGxlckhlaWdodDtcbiAgICBjb25zdCBzaGFwZVkyID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG5cbiAgICBjb25zdCB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHgyLCBzaGFwZVgyKSAtIE1hdGgubWF4KHgxLCBzaGFwZVgxKSk7XG4gICAgY29uc3QgeU92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih5Miwgc2hhcGVZMikgLSBNYXRoLm1heCh5MSwgc2hhcGVZMSkpO1xuICAgIGNvbnN0IGFyZWEgPSB4T3ZlcmxhcCAqIHlPdmVybGFwO1xuXG4gICAgcmV0dXJuIGFyZWEgPiAwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcmtlcjtcbiIsImltcG9ydCBCYXNlU2hhcGUgZnJvbSAnLi9CYXNlU2hhcGUnO1xuXG5cbi8qKlxuICogQSBzaGFwZSB0byBkaXNwbGF5IGEgc2VnbWVudC5cbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci1zZWdtZW50Lmh0bWwpXG4gKi9cbmNsYXNzIFNlZ21lbnQgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICBnZXRDbGFzc05hbWUoKSB7IHJldHVybiAnc2VnbWVudCc7IH1cblxuICBfZ2V0QWNjZXNzb3JMaXN0KCkge1xuICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDEsIGNvbG9yOiAnIzAwMDAwMCcsIG9wYWNpdHk6IDEsIGxhYmVsOiAnJyB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5SGFuZGxlcnM6IHRydWUsXG4gICAgICBoYW5kbGVyV2lkdGg6IDIsXG4gICAgICBoYW5kbGVyT3BhY2l0eTogMC44LFxuICAgICAgb3BhY2l0eTogMC42LFxuICAgICAgZGlzcGxheUxhYmVsczogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7IHJldHVybiB0aGlzLiRlbDsgfVxuXG4gICAgdGhpcy4kZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5ucywgJ2cnKTtcblxuICAgIHRoaXMuJHNlZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5ucywgJ3JlY3QnKTtcbiAgICB0aGlzLiRzZWdtZW50LmNsYXNzTGlzdC5hZGQoJ3NlZ21lbnQnKTtcbiAgICB0aGlzLiRzZWdtZW50LnN0eWxlLm9wYWNpdHkgPSB0aGlzLnBhcmFtcy5vcGFjaXR5O1xuICAgIHRoaXMuJHNlZ21lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3NoYXBlLXJlbmRlcmluZycsICdjcmlzcEVkZ2VzJyk7XG5cbiAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZCh0aGlzLiRzZWdtZW50KTtcblxuICAgIGlmICh0aGlzLnBhcmFtcy5kaXNwbGF5SGFuZGxlcnMpIHtcbiAgICAgIHRoaXMuJGxlZnRIYW5kbGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsICdyZWN0Jyk7XG4gICAgICB0aGlzLiRsZWZ0SGFuZGxlci5jbGFzc0xpc3QuYWRkKCdsZWZ0JywgJ2hhbmRsZXInKTtcbiAgICAgIHRoaXMuJGxlZnRIYW5kbGVyLnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIHRoaXMucGFyYW1zLmhhbmRsZXJXaWR0aCk7XG4gICAgICB0aGlzLiRsZWZ0SGFuZGxlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKTtcbiAgICAgIHRoaXMuJGxlZnRIYW5kbGVyLnN0eWxlLm9wYWNpdHkgPSB0aGlzLnBhcmFtcy5oYW5kbGVyT3BhY2l0eTtcbiAgICAgIHRoaXMuJGxlZnRIYW5kbGVyLnN0eWxlLmN1cnNvciA9ICdldy1yZXNpemUnO1xuXG4gICAgICB0aGlzLiRyaWdodEhhbmRsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5ucywgJ3JlY3QnKTtcbiAgICAgIHRoaXMuJHJpZ2h0SGFuZGxlci5jbGFzc0xpc3QuYWRkKCdyaWdodCcsICdoYW5kbGVyJyk7XG4gICAgICB0aGlzLiRyaWdodEhhbmRsZXIuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgdGhpcy5wYXJhbXMuaGFuZGxlcldpZHRoKTtcbiAgICAgIHRoaXMuJHJpZ2h0SGFuZGxlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKTtcbiAgICAgIHRoaXMuJHJpZ2h0SGFuZGxlci5zdHlsZS5vcGFjaXR5ID0gdGhpcy5wYXJhbXMuaGFuZGxlck9wYWNpdHk7XG4gICAgICB0aGlzLiRyaWdodEhhbmRsZXIuc3R5bGUuY3Vyc29yID0gJ2V3LXJlc2l6ZSc7XG5cbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKHRoaXMuJGxlZnRIYW5kbGVyKTtcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKHRoaXMuJHJpZ2h0SGFuZGxlcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1zLmRpc3BsYXlMYWJlbHMpIHtcbiAgICAgIC8vIHByZWZlciBodG1sIGBkaXZgIG92ZXIgc3ZnIGB0ZXh0YCB0YWcgYmVjYXVzZSB3ZSB0aGVuIHVzZSB0aGUgYGNvbnRlbnRlZGl0YWJsZWAgcHJvcGVydHlcbiAgICAgIHRoaXMuJGZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5ucywgJ2ZvcmVpZ25PYmplY3QnKTtcblxuICAgICAgdGhpcy4kbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuJGxhYmVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdGhpcy4kbGFiZWwuc3R5bGUud2lkdGggPSAnNTBweCc7XG4gICAgICB0aGlzLiRsYWJlbC5zdHlsZS5mb250U2l6ZSA9ICcxMnB4JztcbiAgICAgIHRoaXMuJGxhYmVsLnN0eWxlLmZvbnRGYW1pbHkgPSAnYXJpYWwnO1xuICAgICAgdGhpcy4kbGFiZWwuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgIHRoaXMuJGxhYmVsLnN0eWxlLm91dGxpbmVXaWR0aCA9ICcxcHgnO1xuXG4gICAgICB0aGlzLiRmb3JlaWduT2JqZWN0LmFwcGVuZENoaWxkKHRoaXMuJGxhYmVsKTtcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKHRoaXMuJGZvcmVpZ25PYmplY3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSkge1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkYXR1bSkpO1xuICAgIGNvbnN0IHkgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLnkoZGF0dW0pKTtcblxuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLndpZHRoKGRhdHVtKSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy5oZWlnaHQoZGF0dW0pKTtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuY29sb3IoZGF0dW0pO1xuICAgIGNvbnN0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHkoZGF0dW0pO1xuXG4gICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgKTtcbiAgICB0aGlzLiRlbC5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcblxuICAgIHRoaXMuJHNlZ21lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgTWF0aC5tYXgod2lkdGgsIDApKTtcbiAgICB0aGlzLiRzZWdtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCBoZWlnaHQpO1xuICAgIHRoaXMuJHNlZ21lbnQuc3R5bGUuZmlsbCA9IGNvbG9yO1xuXG5cbiAgICBpZiAodGhpcy5wYXJhbXMuZGlzcGxheUhhbmRsZXJzKSB7XG4gICAgICAvLyBkaXNwbGF5IGhhbmRsZXJzXG4gICAgICB0aGlzLiRsZWZ0SGFuZGxlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgIHRoaXMuJGxlZnRIYW5kbGVyLnNldEF0dHJpYnV0ZU5TKG51bGwsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIDApJyk7XG4gICAgICB0aGlzLiRsZWZ0SGFuZGxlci5zdHlsZS5maWxsID0gY29sb3I7XG5cbiAgICAgIGNvbnN0IHJpZ2h0SGFuZGxlclRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHt3aWR0aCAtIHRoaXMucGFyYW1zLmhhbmRsZXJXaWR0aH0sIDApYDtcbiAgICAgIHRoaXMuJHJpZ2h0SGFuZGxlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgIHRoaXMuJHJpZ2h0SGFuZGxlci5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgcmlnaHRIYW5kbGVyVHJhbnNsYXRlKTtcbiAgICAgIHRoaXMuJHJpZ2h0SGFuZGxlci5zdHlsZS5maWxsID0gY29sb3I7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1zLmRpc3BsYXlMYWJlbHMpIHtcbiAgICAgIGNvbnN0IG1hdHJpeCA9IGBtYXRyaXgoMSwgMCwgMCwgLTEsIDQsICR7aGVpZ2h0IC0gMn0pYFxuICAgICAgdGhpcy4kZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICAgIHRoaXMuJGxhYmVsLmlubmVySFRNTCA9IHRoaXMubGFiZWwoZGF0dW0pO1xuICAgIH1cbiAgfVxuXG4gIGluQXJlYShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjb25zdCBzaGFwZVgxID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZGF0dW0pKTtcbiAgICBjb25zdCBzaGFwZVgyID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZGF0dW0pICsgdGhpcy53aWR0aChkYXR1bSkpO1xuICAgIGNvbnN0IHNoYXBlWTEgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLnkoZGF0dW0pKTtcbiAgICBjb25zdCBzaGFwZVkyID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGRhdHVtKSArIHRoaXMuaGVpZ2h0KGRhdHVtKSk7XG5cbiAgICAvLyBodHRwOi8vanNmaWRkbGUubmV0L3V0aHlaLyAtIGNoZWNrIG92ZXJsYXBpbmcgYXJlYVxuICAgIGNvbnN0IHhPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeDIsIHNoYXBlWDIpIC0gTWF0aC5tYXgoeDEsIHNoYXBlWDEpKTtcbiAgICBjb25zdCB5T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHkyLCBzaGFwZVkyKSAtIE1hdGgubWF4KHkxLCBzaGFwZVkxKSk7XG4gICAgY29uc3QgYXJlYSA9IHhPdmVybGFwICogeU92ZXJsYXA7XG5cbiAgICByZXR1cm4gYXJlYSA+IDA7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VnbWVudDtcbiIsImltcG9ydCBCYXNlU2hhcGUgZnJvbSAnLi9CYXNlU2hhcGUnO1xuXG4vKipcbiAqIEtpbmQgb2YgTWFya2VyIGZvciBlbnRpdHkgb3JpZW50ZWQgZGF0YS4gVXNlZnVsbCB0byBkaXNwbGF5IGEgZ3JpZC5cbiAqL1xuY2xhc3MgVGlja3MgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICBfZ2V0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAndGljayc7XG4gIH1cblxuICBfZ2V0QWNjZXNzb3JMaXN0KCkge1xuICAgIHJldHVybiB7IHRpbWU6IDAsIGZvY3VzZWQ6IHRydWUsIGxhYmVsOiAnJyB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJ3N0ZWVsYmx1ZScsXG4gICAgICBmb2N1c2VkT3BhY2l0eTogMC44LFxuICAgICAgZGVmYXVsdE9wYWNpdHk6IDAuM1xuICAgIH07XG4gIH1cblxuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIHRoaXMuJGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsICdnJyk7XG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgdXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdGEpIHtcbiAgICB3aGlsZSAodGhpcy4kZWwuZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQodGhpcy4kZWwuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDsgLy8gdmFsdWVUb1BpeGVsKDEpO1xuXG4gICAgZGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy50aW1lKGRhdHVtKSk7XG4gICAgICBjb25zdCBvcGFjaXR5ID0gdGhpcy5mb2N1c2VkKGRhdHVtKSA/XG4gICAgICAgIHRoaXMucGFyYW1zLmZvY3VzZWRPcGFjaXR5IDogdGhpcy5wYXJhbXMuZGVmYXVsdE9wYWNpdHk7XG5cbiAgICAgIGNvbnN0IGhlaWdodCA9IGxheWVySGVpZ2h0O1xuXG4gICAgICBjb25zdCB0aWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsICdsaW5lJyk7XG4gICAgICB0aWNrLmNsYXNzTGlzdC5hZGQoJ3RpY2snKTtcblxuICAgICAgdGljay5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneDEnLCAwKTtcbiAgICAgIHRpY2suc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gyJywgMCk7XG4gICAgICB0aWNrLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5MScsIDApO1xuICAgICAgdGljay5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneTInLCBoZWlnaHQpO1xuXG4gICAgICB0aWNrLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJ25vbmUnKTtcbiAgICAgIHRpY2suc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZScsIHRoaXMucGFyYW1zLmNvbG9yKTtcbiAgICAgIHRpY2suc2V0QXR0cmlidXRlTlMobnVsbCwgJ3NoYXBlLXJlbmRlcmluZycsICdjcmlzcEVkZ2VzJyk7XG4gICAgICB0aWNrLnNldEF0dHJpYnV0ZU5TKG51bGwsICd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7eH0sIDApYCk7XG4gICAgICB0aWNrLnNldEF0dHJpYnV0ZU5TKG51bGwsICdvcGFjaXR5Jywgb3BhY2l0eSk7XG5cbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKHRpY2spO1xuXG4gICAgICBjb25zdCBsYWJlbCA9IHRoaXMubGFiZWwoZGF0dW0pO1xuXG4gICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgY29uc3QgJGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsICd0ZXh0Jyk7XG4gICAgICAgICRsYWJlbC5jbGFzc0xpc3QuYWRkKCdsYWJlbCcpO1xuICAgICAgICBjb25zdCAkdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsKTtcbiAgICAgICAgJGxhYmVsLmFwcGVuZENoaWxkKCR0ZXh0KTtcbiAgICAgICAgJGxhYmVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICd0cmFuc2Zvcm0nLCBgbWF0cml4KDEsIDAsIDAsIC0xLCAke3ggKyAyfSwgJHtoZWlnaHQgKyAyfSlgKTtcbiAgICAgICAgLy8gZmlyZWZveCBwcm9ibGVtIGhlcmVcbiAgICAgICAgLy8gJGxhYmVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAndGV4dC1iZWZvcmUtZWRnZScpO1xuICAgICAgICAkbGFiZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCAnMTAnKTtcblxuICAgICAgICAkbGFiZWwuc3R5bGUuZm9udFNpemUgPSAnMTBweCc7XG4gICAgICAgICRsYWJlbC5zdHlsZS5saW5lSGVpZ2h0ID0gJzEwcHgnO1xuICAgICAgICAkbGFiZWwuc3R5bGUuZm9udEZhbWlseSA9ICdtb25vc3BhY2UnO1xuICAgICAgICAkbGFiZWwuc3R5bGUuY29sb3IgPSAnIzY3Njc2Nyc7XG4gICAgICAgICRsYWJlbC5zdHlsZS5vcGFjaXR5ID0gMC45O1xuICAgICAgICAkbGFiZWwuc3R5bGUubW96VXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgJGxhYmVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgICRsYWJlbC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuXG4gICAgICAgIC8vIGNvbnN0IGJnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsICdyZWN0Jyk7XG4gICAgICAgIC8vIGJnLnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsICcxMDAlJyk7XG4gICAgICAgIC8vIGJnLnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCAnMTAwJScpO1xuICAgICAgICAvLyBiZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjZmZmZmZmJyk7XG4gICAgICAgIC8vIGxhYmVsLmFwcGVuZENoaWxkKGJnKTtcblxuICAgICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZCgkbGFiZWwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpY2tzO1xuIiwiaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL0Jhc2VTaGFwZSc7XG5cblxuLyoqXG4gKiBBIHNoYXBlIHRvIGRpc3BsYXkgZG90cyBpbiBhIHRyYWNlIHZpc3VhbGl6YXRpb24gKG1lYW4gLyByYW5nZSkuXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvbGF5ZXItdHJhY2UuaHRtbClcbiAqL1xuY2xhc3MgVHJhY2VEb3RzIGV4dGVuZHMgQmFzZVNoYXBlIHtcbiAgZ2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ3RyYWNlLWRvdHMnOyB9XG5cbiAgX2dldEFjY2Vzc29yTGlzdCgpIHtcbiAgICByZXR1cm4geyB4OiAwLCBtZWFuOiAwLCByYW5nZTogMCB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZWFuUmFkaXVzOiAzLFxuICAgICAgcmFuZ2VSYWRpdXM6IDMsXG4gICAgICBtZWFuQ29sb3I6ICcjMjMyMzIzJyxcbiAgICAgIHJhbmdlQ29sb3I6ICdzdGVlbGJsdWUnXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7IHJldHVybiB0aGlzLiRlbDsgfVxuICAgIC8vIGNvbnRhaW5lclxuICAgIHRoaXMuJGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsICdnJyk7XG4gICAgLy8gZHJhdyBtZWFuIGRvdFxuICAgIHRoaXMuJG1lYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5ucywgJ2NpcmNsZScpO1xuICAgIHRoaXMuJG1lYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCB0aGlzLnBhcmFtcy5tZWFuUmFkaXVzKTtcbiAgICB0aGlzLiRtZWFuLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCB0aGlzLnBhcmFtcy5tZWFuQ29sb3IpO1xuICAgIHRoaXMuJG1lYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAndHJhbnNwYXJlbnQnKTtcbiAgICB0aGlzLiRtZWFuLmNsYXNzTGlzdC5hZGQoJ21lYW4nKTtcbiAgICAvLyByYW5nZSBkb3RzICgwID0+IHRvcCwgMSA9PiBib3R0b20pXG4gICAgdGhpcy4kbWF4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubnMsICdjaXJjbGUnKTtcbiAgICB0aGlzLiRtYXguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCB0aGlzLnBhcmFtcy5tZWFuUmFkaXVzKTtcbiAgICB0aGlzLiRtYXguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZScsIHRoaXMucGFyYW1zLnJhbmdlQ29sb3IpO1xuICAgIHRoaXMuJG1heC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICd0cmFuc3BhcmVudCcpO1xuICAgIHRoaXMuJG1heC5jbGFzc0xpc3QuYWRkKCdtYXgnKTtcblxuICAgIHRoaXMuJG1pbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCAnY2lyY2xlJyk7XG4gICAgdGhpcy4kbWluLnNldEF0dHJpYnV0ZU5TKG51bGwsICdyJywgdGhpcy5wYXJhbXMubWVhblJhZGl1cyk7XG4gICAgdGhpcy4kbWluLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCB0aGlzLnBhcmFtcy5yYW5nZUNvbG9yKTtcbiAgICB0aGlzLiRtaW4uc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAndHJhbnNwYXJlbnQnKTtcbiAgICB0aGlzLiRtaW4uY2xhc3NMaXN0LmFkZCgnbWluJyk7XG5cbiAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZCh0aGlzLiRtZWFuKTtcbiAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZCh0aGlzLiRtYXgpO1xuICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKHRoaXMuJG1pbik7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICAvLyBAVE9ETyB1c2UgYWNjZXNzb3JzXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSkge1xuICAgIGNvbnN0IG1lYW4gPSB0aGlzLm1lYW4oZGF0dW0pO1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5yYW5nZShkYXR1bSk7XG4gICAgY29uc3QgeCA9IHRoaXMueChkYXR1bSk7XG4gICAgLy8geSBwb3NpdGlvbnNcbiAgICBjb25zdCBtZWFuUG9zID0gYCR7cmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwobWVhbil9YDtcbiAgICB0aGlzLiRtZWFuLnNldEF0dHJpYnV0ZU5TKG51bGwsICd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7bWVhblBvc30pYCk7XG5cbiAgICBjb25zdCBoYWxmUmFuZ2UgPSByYW5nZSAvIDI7XG4gICAgY29uc3QgbWF4ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwobWVhbiArIGhhbGZSYW5nZSk7XG4gICAgY29uc3QgbWluID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwobWVhbiAtIGhhbGZSYW5nZSk7XG4gICAgY29uc3QgeFBvcyA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoeCk7XG5cbiAgICB0aGlzLiRtYXguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHttYXh9KWApO1xuICAgIHRoaXMuJG1pbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke21pbn0pYCk7XG4gICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4UG9zfSwgMClgKTtcbiAgfVxuXG4gIGluQXJlYShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZGF0dW0pKTtcbiAgICBjb25zdCBtZWFuID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy5tZWFuKGRhdHVtKSk7XG4gICAgY29uc3QgcmFuZ2UgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLnJhbmdlKGRhdHVtKSk7XG4gICAgY29uc3QgbWluID0gbWVhbiAtIChyYW5nZSAvIDIpO1xuICAgIGNvbnN0IG1heCA9IG1lYW4gKyAocmFuZ2UgLyAyKTtcblxuICAgIGlmICh4ID4geDEgJiYgeCA8IHgyICYmIChtaW4gPiB5MSB8fCBtYXggPCB5MikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUcmFjZURvdHM7XG4iLCJpbXBvcnQgQmFzZVNoYXBlIGZyb20gJy4vQmFzZVNoYXBlJztcblxuXG4vKipcbiAqIEEgc2hhcGUgdG8gZGlzcGxheSBwYXRocyBpbiBhIHRyYWNlIHZpc3VhbGl6YXRpb24gKG1lYW4gLyByYW5nZSkuIChlbnRpdHkgc2hhcGUpXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvbGF5ZXItdHJhY2UuaHRtbClcbiAqL1xuY2xhc3MgVHJhY2VQYXRoIGV4dGVuZHMgQmFzZVNoYXBlIHtcbiAgZ2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ3RyYWNlLWNvbW1vbic7IH1cblxuICBfZ2V0QWNjZXNzb3JMaXN0KCkge1xuICAgIHJldHVybiB7IHg6IDAsIG1lYW46IDAsIHJhbmdlOiAwIH07XG4gIH1cblxuICBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbmdlQ29sb3I6ICdzdGVlbGJsdWUnLFxuICAgICAgbWVhbkNvbG9yOiAnIzIzMjMyMycsXG4gICAgICBkaXNwbGF5TWVhbjogdHJ1ZVxuICAgIH07XG4gIH1cblxuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cbiAgICB0aGlzLiRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCAnZycpO1xuICAgIC8vIHJhbmdlIHBhdGhcbiAgICB0aGlzLiRyYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCAncGF0aCcpO1xuICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKHRoaXMuJHJhbmdlKTtcblxuICAgIC8vIG1lYW4gbGluZVxuICAgIGlmICh0aGlzLnBhcmFtcy5kaXNwbGF5TWVhbikge1xuICAgICAgdGhpcy4kbWVhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCAncGF0aCcpO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQodGhpcy4kbWVhbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgdXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdGEpIHtcbiAgICAvLyBvcmRlciBkYXRhIGJ5IHggcG9zaXRpb25cbiAgICBkYXRhID0gZGF0YS5zbGljZSgwKTtcbiAgICBkYXRhLnNvcnQoKGEsIGIpID0+IHRoaXMueChhKSA8IHRoaXMueChiKSA/IC0xIDogMSk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuZGlzcGxheU1lYW4pIHtcbiAgICAgIHRoaXMuJG1lYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCB0aGlzLl9idWlsZE1lYW5MaW5lKHJlbmRlcmluZ0NvbnRleHQsIGRhdGEpKTtcbiAgICAgIHRoaXMuJG1lYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZScsIHRoaXMucGFyYW1zLm1lYW5Db2xvcik7XG4gICAgICB0aGlzLiRtZWFuLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJ25vbmUnKTtcbiAgICB9XG5cbiAgICB0aGlzLiRyYW5nZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIHRoaXMuX2J1aWxkUmFuZ2Vab25lKHJlbmRlcmluZ0NvbnRleHQsIGRhdGEpKTtcbiAgICB0aGlzLiRyYW5nZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3Ryb2tlJywgJ25vbmUnKTtcbiAgICB0aGlzLiRyYW5nZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIHRoaXMucGFyYW1zLnJhbmdlQ29sb3IpO1xuICAgIHRoaXMuJHJhbmdlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdvcGFjaXR5JywgJzAuNCcpO1xuXG4gICAgZGF0YSA9IG51bGw7XG4gIH1cblxuICBfYnVpbGRNZWFuTGluZShyZW5kZXJpbmdDb250ZXh0LCBkYXRhKSB7XG4gICAgbGV0IGluc3RydWN0aW9ucyA9IGRhdGEubWFwKChkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkYXR1bSkpO1xuICAgICAgY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMubWVhbihkYXR1bSkpO1xuICAgICAgcmV0dXJuIGAke3h9LCR7eX1gO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICdNJyArIGluc3RydWN0aW9ucy5qb2luKCdMJyk7XG4gIH1cblxuICBfYnVpbGRSYW5nZVpvbmUocmVuZGVyaW5nQ29udGV4dCwgZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIC8vIGNvbnN0IGxhc3RJbmRleCA9IGRhdGFcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zU3RhcnQgPSAnJztcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zRW5kID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXR1bSA9IGRhdGFbaV07XG4gICAgICBjb25zdCBtZWFuID0gdGhpcy5tZWFuKGRhdHVtKTtcbiAgICAgIGNvbnN0IGhhbGZSYW5nZSA9IHRoaXMucmFuZ2UoZGF0dW0pIC8gMjtcblxuICAgICAgY29uc3QgeCAgPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkYXR1bSkpO1xuICAgICAgY29uc3QgeTAgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChtZWFuICsgaGFsZlJhbmdlKTtcbiAgICAgIGNvbnN0IHkxID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwobWVhbiAtIGhhbGZSYW5nZSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gYCR7eH0sJHt5MH1gO1xuICAgICAgY29uc3QgZW5kICAgPSBgJHt4fSwke3kxfWA7XG5cbiAgICAgIGluc3RydWN0aW9uc1N0YXJ0ID0gaW5zdHJ1Y3Rpb25zU3RhcnQgPT09ICcnID9cbiAgICAgICAgc3RhcnQgOiBgJHtpbnN0cnVjdGlvbnNTdGFydH1MJHtzdGFydH1gO1xuXG4gICAgICBpbnN0cnVjdGlvbnNFbmQgPSBpbnN0cnVjdGlvbnNFbmQgPT09ICcnID9cbiAgICAgICAgZW5kIDogYCR7ZW5kfUwke2luc3RydWN0aW9uc0VuZH1gO1xuICAgIH1cblxuICAgIGxldCBpbnN0cnVjdGlvbnMgPSBgTSR7aW5zdHJ1Y3Rpb25zU3RhcnR9TCR7aW5zdHJ1Y3Rpb25zRW5kfVpgO1xuICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJhY2VQYXRoO1xuIiwiaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL0Jhc2VTaGFwZSc7XG5cblxuY29uc3QgeGh0bWxOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcblxuLyoqXG4gKiBBIHNoYXBlIHRvIGRpc3BsYXkgYSB3YXZlZm9ybS4gKGZvciBlbnRpdHkgZGF0YSlcbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci13YXZlZm9ybS5odG1sKVxuICpcbiAqIEB0b2RvIC0gZml4IHByb2JsZW1zIHdpdGggY2FudmFzIHN0cmF0ZWd5LlxuICovXG5jbGFzcyBXYXZlZm9ybSBleHRlbmRzIEJhc2VTaGFwZSB7XG4gIGdldENsYXNzTmFtZSgpIHsgcmV0dXJuICd3YXZlZm9ybSc7IH1cblxuICBfZ2V0QWNjZXNzb3JMaXN0KCkge1xuICAgIC8vIHJldHVybiB7IHk6IDAgfTtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZVJhdGU6IDQ0MTAwLFxuICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAvLyByZW5kZXJpbmdTdHJhdGVneTogJ3N2ZycgLy8gY2FudmFzIGlzIGJ1Z2dlZCAodHJhbnNsYXRpb24sIGV0Yy4uLilcbiAgICB9O1xuICB9XG5cbiAgcmVuZGVyKHJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICBpZiAodGhpcy4kZWwpXG4gICAgICByZXR1cm4gdGhpcy4kZWw7XG5cbiAgICAvLyBpZiAodGhpcy5wYXJhbXMucmVuZGVyaW5nU3RyYXRlZ3kgPT09ICdzdmcnKSB7XG5cbiAgICB0aGlzLiRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCAncGF0aCcpO1xuICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJ25vbmUnKTtcbiAgICB0aGlzLiRlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKTtcbiAgICB0aGlzLiRlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3Ryb2tlJywgdGhpcy5wYXJhbXMuY29sb3IpO1xuICAgIHRoaXMuJGVsLnN0eWxlLm9wYWNpdHkgPSB0aGlzLnBhcmFtcy5vcGFjaXR5O1xuXG4gICAgLy8gfSBlbHNlIGlmICh0aGlzLnBhcmFtcy5yZW5kZXJpbmdTdHJhdGVneSA9PT0gJ2NhbnZhcycpIHtcblxuICAgIC8vICAgdGhpcy4kZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5ucywgJ2ZvcmVpZ25PYmplY3QnKTtcbiAgICAvLyAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIHJlbmRlcmluZ0NvbnRleHQud2lkdGgpO1xuICAgIC8vICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0KTtcblxuICAgIC8vICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhodG1sTlMsICd4aHRtbDpjYW52YXMnKTtcblxuICAgIC8vICAgdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgLy8gICB0aGlzLl9jdHguY2FudmFzLndpZHRoID0gcmVuZGVyaW5nQ29udGV4dC53aWR0aDtcbiAgICAvLyAgIHRoaXMuX2N0eC5jYW52YXMuaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG5cbiAgICAvLyAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgLy8gfVxuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgdXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtKSB7XG4gICAgLy8gZGVmaW5lIG5iciBvZiBzYW1wbGVzIHBlciBwaXhlbHNcbiAgICBjb25zdCBzbGljZU1ldGhvZCA9IGRhdHVtIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID8gJ3N1YmFycmF5JyA6ICdzbGljZSc7XG4gICAgY29uc3QgbmJyU2FtcGxlcyA9IGRhdHVtLmxlbmd0aDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IG5iclNhbXBsZXMgLyB0aGlzLnBhcmFtcy5zYW1wbGVSYXRlO1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChkdXJhdGlvbik7XG4gICAgY29uc3Qgc2FtcGxlc1BlclBpeGVsID0gbmJyU2FtcGxlcyAvIHdpZHRoO1xuXG4gICAgaWYgKCFzYW1wbGVzUGVyUGl4ZWwgfHwgZGF0dW0ubGVuZ3RoIDwgc2FtcGxlc1BlclBpeGVsKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3QgeyBtaW5YLCBtYXhYIH0gPSByZW5kZXJpbmdDb250ZXh0O1xuXG4gICAgLy8gZ2V0IG1pbi9tYXggcGVyIHBpeGVscywgY2xhbXBlZCB0byB0aGUgdmlzaWJsZSBhcmVhXG4gICAgY29uc3QgaW52ZXJ0ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQ7XG4gICAgY29uc3Qgc2FtcGxlUmF0ZSA9IHRoaXMucGFyYW1zLnNhbXBsZVJhdGU7XG4gICAgY29uc3QgbWluTWF4ID0gW107XG5cbiAgICBmb3IgKGxldCBweCA9IG1pblg7IHB4IDwgbWF4WDsgcHgrKykge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gaW52ZXJ0KHB4KTtcbiAgICAgIGNvbnN0IHN0YXJ0U2FtcGxlID0gc3RhcnRUaW1lICogc2FtcGxlUmF0ZTtcbiAgICAgIGNvbnN0IGV4dHJhY3QgPSBkYXR1bVtzbGljZU1ldGhvZF0oc3RhcnRTYW1wbGUsIHN0YXJ0U2FtcGxlICsgc2FtcGxlc1BlclBpeGVsKTtcblxuICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgICAgbGV0IG1heCA9IC1JbmZpbml0eTtcblxuICAgICAgZm9yIChsZXQgaiA9IDAsIGwgPSBleHRyYWN0Lmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICBsZXQgc2FtcGxlID0gZXh0cmFjdFtqXTtcbiAgICAgICAgaWYgKHNhbXBsZSA8IG1pbikgbWluID0gc2FtcGxlO1xuICAgICAgICBpZiAoc2FtcGxlID4gbWF4KSBtYXggPSBzYW1wbGU7XG4gICAgICB9XG4gICAgICAvLyBkaXNhbGxvdyBJbmZpbml0eVxuICAgICAgbWluID0gIWlzRmluaXRlKG1pbikgPyAwIDogbWluO1xuICAgICAgbWF4ID0gIWlzRmluaXRlKG1heCkgPyAwIDogbWF4O1xuXG4gICAgICBtaW5NYXgucHVzaChbcHgsIG1pbiwgbWF4XSk7XG4gICAgfVxuXG4gICAgaWYgKG1pbk1heC5sZW5ndGgpIHtcblxuICAgICAgY29uc3QgUElYRUwgPSAwO1xuICAgICAgY29uc3QgTUlOICAgPSAxO1xuICAgICAgY29uc3QgTUFYICAgPSAyO1xuXG4gICAgICAvLyByZW5kZXJpbmcgc3RyYXRlZ2llc1xuICAgICAgLy8gaWYgKHRoaXMucGFyYW1zLnJlbmRlcmluZ1N0cmF0ZWd5ID09PSAnc3ZnJykge1xuXG4gICAgICBsZXQgZCA9ICdNJztcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBtaW5NYXgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdHVtID0gbWluTWF4W2ldO1xuICAgICAgICBjb25zdCB4ICA9IGRhdHVtW1BJWEVMXTtcbiAgICAgICAgbGV0IHkxID0gTWF0aC5yb3VuZChyZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChkYXR1bVtNSU5dKSk7XG4gICAgICAgIGxldCB5MiA9IE1hdGgucm91bmQocmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoZGF0dW1bTUFYXSkpO1xuXG4gICAgICAgIGQgKz0gYCR7eH0sJHt5MX1MJHt4fSwke3kyfWA7XG5cbiAgICAgICAgaWYgKGkgPCBsIC0gMSlcbiAgICAgICAgICBkICs9ICdMJztcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBkKTtcblxuICAgICAgLy8gfSBlbHNlIGlmICh0aGlzLnBhcmFtcy5yZW5kZXJpbmdTdHJhdGVneSA9PT0gJ2NhbnZhcycpIHtcblxuICAgICAgLy8gICB0aGlzLl9jdHguY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAvLyAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCk7XG4gICAgICAvLyAgIC8vIGZpeCBjaHJvbWUgYnVnIHdpdGggdHJhbnNsYXRlXG4gICAgICAvLyAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSkge1xuICAgICAgLy8gICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZSgneCcsIHJlbmRlcmluZ0NvbnRleHQub2Zmc2V0WCk7XG4gICAgICAvLyAgIH1cblxuICAgICAgLy8gICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnBhcmFtcy5jb2xvcjtcbiAgICAgIC8vICAgdGhpcy5fY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5wYXJhbXMub3BhY2l0eTtcbiAgICAgIC8vICAgdGhpcy5fY3R4Lm1vdmVUbyhyZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKDApLCByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCgwKSk7XG5cbiAgICAgIC8vICAgbWluTWF4LmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAvLyAgICAgY29uc3QgeCAgPSBkYXR1bVtQSVhFTF07XG4gICAgICAvLyAgICAgbGV0IHkxID0gTWF0aC5yb3VuZChyZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChkYXR1bVtNSU5dKSk7XG4gICAgICAvLyAgICAgbGV0IHkyID0gTWF0aC5yb3VuZChyZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChkYXR1bVtNQVhdKSk7XG5cbiAgICAgIC8vICAgICB0aGlzLl9jdHgubW92ZVRvKHgsIHkxKTtcbiAgICAgIC8vICAgICB0aGlzLl9jdHgubGluZVRvKHgsIHkyKTtcbiAgICAgIC8vICAgfSk7XG5cbiAgICAgIC8vICAgdGhpcy5fY3R4LnN0cm9rZSgpO1xuICAgICAgLy8gfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXYXZlZm9ybTtcbiIsIi8qKlxuICogYFN0YXRlYCBpbnN0YW5jZXMgYXJlIHVzZWQgdG8gZGVmaW5lIHRoZSBhcHBsaWNhdGlvbiBsb2dpYyBieSBwcmVjaXNpbmdcbiAqIHNwZWNpZmljIHVzZXIgaW50ZXJhY3Rpb24gY2FzZXMsIGFuZCBob3cgdGhleSBpbXBhY3QgdGhlIG92ZXJhbCB0ZW1wb3JhbFxuICogcmVwcmVzZW50YXRpb24uIFRoZSBhYnN0cmFjdGlvbnMgZXh0ZW5kaW5nIHRoaXMgYmFzZSBjbGFzcyBzaG91bGQgYmVcbiAqIGNvbnNpZGVyZWQgYXMgdGhlIG1haW4gaW50ZXJmYWNlIGJldHdlZW4gdGhlIHZpc3VhbGl6YXRpb24gYW5kIHRoZVxuICogYXBwbGljYXRpb24gbG9naWMuIEFsbCBwcm92aWRlZCBzdGF0ZXMgc2hvdWxkIGJlIHNlZW4gYXMgc2ltcGxlIGV4YW1wbGVzIGZvclxuICogcmFwaWQgcHJvdG90eXBpbmcsXG4gKlxuICogU3RhdGVzIG1hbmFnZSBpbnRlcmFjdGlvbnMgbGlrZSB6b29taW5nLCBicm93c2luZywgb3IgZWRpdGluZyB0aGUgdGltZWxpbmUuXG4gKiBDdXN0b21pemVkIHN0YXRlcyBzaG91bGQgZXh0ZW5kIHRoaXMgQmFzZVN0YXRlLlxuICovXG5jbGFzcyBCYXNlU3RhdGUge1xuICAvKipcbiAgICogUmV0dXJucyB0aW1lbGluZSB0cmFja3MgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHR5cGUge1RyYWNrQ29sbGVjdGlvbn1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRpbWVsaW5lKSB7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHRpbWVsaW5lIG9uIHdoaWNoIHRoZSBzdGF0ZSBzaG91bGQgYmUgaW5zdGFsbGVkLlxuICAgICAqIEB0eXBlIHtUaW1lbGluZX1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVsaW5lID0gdGltZWxpbmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aW1lbGluZSB0cmFja3MgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHR5cGUge1RyYWNrQ29sbGVjdGlvbjxUcmFjaz59XG4gICAqL1xuICBnZXQgdHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVsaW5lLnRyYWNrcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIGxheWVycy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PExheWVyPn1cbiAgICovXG4gIGdldCBsYXllcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZWxpbmUudHJhY2tzLmxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdGltZWxpbmUgaXMgZW50ZXJpbmcgdGhlIHN0YXRlLlxuICAgKi9cbiAgZW50ZXIoKSB7fVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdGltZWxpbmUgaXMgbGVhdmluZyB0aGUgc3RhdGUuXG4gICAqL1xuICBleGl0KCkge31cblxuICAvKipcbiAgICogTWFpbiBpbnRlcmZhY2UgbWV0aG9kIHRvIG92ZXJyaWRlIHdoZW4gY3JlYXRpbmcgYSBuZXcgYFN0YXRlYC4gSGFuZGxlIGV2ZW50XG4gICAqIGZyb20gbW91c2Ugb3Iga2V5Ym9hcmQsIHNob3VsZCBkZWZpbmUgYmVoYXZpb3IgYWNjb3JkaW5nIHRvIHRoZSBldmVudFxuICAgKiAoYWthLiBtb3VzZWRvd24sIG1vdXNldXAsIC4uLikuXG4gICAqXG4gICAqIEBwYXJhbSB7V2F2ZUV2ZW50fSBlIC0gdGhlIGV2ZW50IHRvIHByb2Nlc3MuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGhpdExheWVycyAtIHRoZSBsYXllcnMgaGl0IGJ5IHRoZSBtb3VzZSBldmVudCAoaWYgc3VyZmFjZVxuICAgKiBldmVudCkuXG4gICAqL1xuICBoYW5kbGVFdmVudChlLCBoaXRMYXllcnMpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VTdGF0ZTtcbiIsImltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9CYXNlU3RhdGUnO1xuXG5cbi8qKlxuICogQSBzdGF0ZSB0byBpbnRlcmFjdCB3aXRoIGEgYnJlYWtwb2ludCBmdW5jdGlvbiwgbWltaWNpbmcgTWF4L01TUCdzXG4gKiBicmVha3BvaW50IGZ1bmN0aW9uIGludGVyYWN0aW9ucy5cbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci1icmVha3BpbnQuaHRtbClcbiAqL1xuY2xhc3MgQnJlYWtwb2ludFN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmUsIGRhdHVtR2VuZXJhdG9yKSB7XG4gICAgc3VwZXIodGltZWxpbmUpO1xuXG4gICAgdGhpcy5kYXR1bUdlbmVyYXRvciA9IGRhdHVtR2VuZXJhdG9yO1xuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICB9XG5cbiAgZW50ZXIoKSB7fVxuICBleGl0KCkge31cblxuICBoYW5kbGVFdmVudChlLCBoaXRMYXllcnMpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlLCBoaXRMYXllcnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZSwgaGl0TGF5ZXJzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAoZSwgaGl0TGF5ZXJzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZURvd24oZSwgaGl0TGF5ZXJzKSB7XG4gICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICAgIC8vIGtlZXAgdGFyZ2V0IGNvbnNpc3RlbnQgd2l0aCBtb3VzZSBkb3duXG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgbGV0IHVwZGF0ZWRMYXllciA9IG51bGw7XG5cbiAgICBjb25zdCBsYXllcnMgPSBoaXRMYXllcnM7XG5cbiAgICBsYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgIGxheWVyLnVuc2VsZWN0KCk7XG4gICAgICBjb25zdCBpdGVtID0gbGF5ZXIuZ2V0SXRlbUZyb21ET01FbGVtZW50KGUudGFyZ2V0KTtcblxuICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgLy8gY3JlYXRlIGFuIGl0ZW1cbiAgICAgICAgY29uc3QgdGltZSA9IGxheWVyLnRpbWVUb1BpeGVsLmludmVydChlLngpIC0gdGhpcy50aW1lbGluZS5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGF5ZXIudmFsdWVUb1BpeGVsLmludmVydChsYXllci5wYXJhbXMuaGVpZ2h0IC0gZS55KTtcbiAgICAgICAgY29uc3QgZGF0dW0gPSB0aGlzLmRhdHVtR2VuZXJhdG9yKHRpbWUsIHZhbHVlKTtcblxuICAgICAgICBsYXllci5kYXRhLnB1c2goZGF0dW0pO1xuICAgICAgICB1cGRhdGVkTGF5ZXIgPSBsYXllcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHNoaWZ0IGlzIHByZXNzZWQsIHJlbW92ZSB0aGUgaXRlbVxuICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGxheWVyLmRhdGE7XG4gICAgICAgICAgY29uc3QgZGF0dW0gPSBsYXllci5nZXREYXR1bUZyb21JdGVtKGl0ZW0pO1xuICAgICAgICAgIGRhdGEuc3BsaWNlKGRhdGEuaW5kZXhPZihkYXR1bSksIDEpO1xuXG4gICAgICAgICAgdXBkYXRlZExheWVyID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICBsYXllci5zZWxlY3QoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh1cGRhdGVkTGF5ZXIpIHtcbiAgICAgIHRoaXMudGltZWxpbmUudHJhY2tzLnJlbmRlcih1cGRhdGVkTGF5ZXIpO1xuICAgICAgdGhpcy50aW1lbGluZS50cmFja3MudXBkYXRlKHVwZGF0ZWRMYXllcik7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZU1vdmUoZSkge1xuICAgIGlmICghdGhpcy5tb3VzZURvd24gfHzCoCF0aGlzLmN1cnJlbnRFZGl0ZWRMYXllcikgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXI7XG4gICAgY29uc3QgaXRlbXMgPSBsYXllci5zZWxlY3RlZEl0ZW1zO1xuICAgIC8vIHRoZSBsb29wIHNob3VsZCBiZSBpbiBsYXllciB0byBtYXRjaCBzZWxlY3QgLyB1bnNlbGVjdCBBUElcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBsYXllci5lZGl0KGl0ZW0sIGUuZHgsIGUuZHksIHRoaXMuY3VycmVudFRhcmdldCk7XG4gICAgfSk7XG5cbiAgICBsYXllci51cGRhdGUoaXRlbXMpO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllciA9IG51bGw7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCcmVha3BvaW50U3RhdGU7XG4iLCJpbXBvcnQgbnMgZnJvbSAnLi4vY29yZS9uYW1lc3BhY2UnO1xuaW1wb3J0IEJhc2VTdGF0ZSBmcm9tICcuL0Jhc2VTdGF0ZSc7XG5cblxuLyoqXG4gKiBQcm90b29scyBsaWtlIHpvb20gd2l0aCB6b25lIHNlbGVjdGlvbi4gUHJlc3Mgc3BhY2UgYmFyIHRvIHJlc2V0IHpvb20uXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvc3RhdGVzLXpvb20uaHRtbClcbiAqXG4gKiBAdG9kbyAtIGNvdWxkIGFsc28gaGFuZGxlIGBnYCBhbmQgYGhgIGtleXMgdG8gem9vbS1pbiwgem9vbS1vdXQuXG4gKi9cbmNsYXNzIEJydXNoWm9vbVN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmUpIHtcbiAgICBzdXBlcih0aW1lbGluZSk7XG4gIH1cblxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgc3dpdGNoKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLm9uTW91c2VVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgICAgdGhpcy5vbktleURvd24oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEb3duKGUpIHtcbiAgICB0aGlzLmJydXNoZXMgPSBbXTtcbiAgICB0aGlzLnN0YXJ0WCA9IGUueDtcbiAgICAvLyBjcmVhdGUgYnJ1c2ggaW4gZWFjaCBjb250YWluZXJzXG4gICAgdGhpcy50cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgIGNvbnN0IGludGVyYWN0aW9ucyA9IHRyYWNrLiRpbnRlcmFjdGlvbnM7XG5cbiAgICAgIGNvbnN0IGJydXNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAncmVjdCcpO1xuICAgICAgYnJ1c2guc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIHRyYWNrLmhlaWdodCk7XG4gICAgICBicnVzaC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsIDApO1xuICAgICAgYnJ1c2guc3R5bGUuZmlsbCA9ICcjNzg3ODc4JztcbiAgICAgIGJydXNoLnN0eWxlLm9wYWNpdHkgPSAwLjI7XG5cbiAgICAgIGludGVyYWN0aW9ucy5hcHBlbmRDaGlsZChicnVzaCk7XG5cbiAgICAgIHRoaXMuYnJ1c2hlcy5wdXNoKGJydXNoKTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAvLyB1cGRhdGUgYnJ1c2hcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguYWJzKGUueCAtIHRoaXMuc3RhcnRYKTtcbiAgICBjb25zdCB4ID0gTWF0aC5taW4oZS54LCB0aGlzLnN0YXJ0WCk7XG5cbiAgICB0aGlzLmJydXNoZXMuZm9yRWFjaCgoYnJ1c2gpID0+IHtcbiAgICAgIGJydXNoLnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgIGJydXNoLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JywgeCk7XG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlVXAoZSkge1xuICAgIC8vIHJlbW92ZSBicnVzaFxuICAgIHRoaXMuYnJ1c2hlcy5mb3JFYWNoKChicnVzaCkgPT4ge1xuICAgICAgYnJ1c2gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChicnVzaCk7XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgdGltZUNvbnRleHRcbiAgICBjb25zdCBzdGFydFggPSB0aGlzLnN0YXJ0WDtcbiAgICBjb25zdCBlbmRYID0gZS54O1xuICAgIC8vIHJldHVybiBpZiBubyBkcmFnXG4gICAgaWYgKE1hdGguYWJzKHN0YXJ0WCAtIGVuZFgpIDwgMSkgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IGxlZnRYID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnRYLCBlbmRYKSk7XG4gICAgY29uc3QgcmlnaHRYID0gTWF0aC5tYXgoc3RhcnRYLCBlbmRYKTtcblxuICAgIGxldCBtaW5UaW1lID0gdGhpcy50aW1lbGluZS50aW1lVG9QaXhlbC5pbnZlcnQobGVmdFgpO1xuICAgIGxldCBtYXhUaW1lID0gdGhpcy50aW1lbGluZS50aW1lVG9QaXhlbC5pbnZlcnQocmlnaHRYKTtcblxuICAgIGNvbnN0IGRlbHRhRHVyYXRpb24gPSBtYXhUaW1lIC0gbWluVGltZTtcbiAgICBjb25zdCB6b29tID0gdGhpcy50aW1lbGluZS52aXNpYmxlRHVyYXRpb24gLyBkZWx0YUR1cmF0aW9uO1xuXG4gICAgdGhpcy50aW1lbGluZS5vZmZzZXQgLT0gbWluVGltZTtcbiAgICB0aGlzLnRpbWVsaW5lLnpvb20gKj0gem9vbTtcblxuICAgIHRoaXMudHJhY2tzLnVwZGF0ZSgpO1xuICB9XG5cbiAgb25LZXlEb3duKGUpIHtcbiAgICAvLyByZXNldCBvbiBzcGFjZSBiYXJcbiAgICBpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDMyKSB7XG4gICAgICB0aGlzLnRpbWVsaW5lLm9mZnNldCA9IDA7XG4gICAgICB0aGlzLnRpbWVsaW5lLnpvb20gPSAxO1xuICAgICAgdGhpcy50cmFja3MudXBkYXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJydXNoWm9vbVN0YXRlO1xuIiwiaW1wb3J0IHNjYWxlcyBmcm9tICcuLi91dGlscy9zY2FsZXMnO1xuaW1wb3J0IEJhc2VTdGF0ZSBmcm9tICcuL0Jhc2VTdGF0ZSc7XG5cblxuLyoqXG4gKiBgQ2VudGVyZWRab29tU3RhdGVgIGlzIGEgdGltZWxpbmUgc3RhdGUgbWltaWNpbmcgdGhlIGBMaXZlYCB6b29tIGludGVyYWN0aW9uLiBJdCBhbGxvd3MgdGhlIHVzZXIgdG8gYnJvd3NlIHRoZSB0aW1lbGluZSBieSBjbGlja2luZyBvbiBhIHRyYWNrLCBhbmQgdGhlblxuICogLSBtb3ZpbmcgZG93biB0byB6b29tIGluXG4gKiAtIG1vdmluZyB1cCB0byB6b29tIG91dFxuICogLSBtb3ZpbmcgbGVmdCB0byBtb3ZlIGluIHRpbWUsIGFmdGVyXG4gKiAtIG1vdmluZyByaWdodCB0byBtb3ZlIGluIHRpbWUsIGJlZm9yZVxuICpcbiAqIFtleGFtcGxlIHVzYWdlXSguL2V4YW1wbGVzL3N0YXRlcy16b29tLmh0bWwpXG4gKi9cbmNsYXNzIENlbnRlcmVkWm9vbVN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmUpIHtcbiAgICBzdXBlcih0aW1lbGluZSk7XG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSBudWxsO1xuICAgIC8vIFNldCBtYXgvbWluIHpvb21cbiAgICAvLyBtYXhab29tOiAxcHggcGVyIHNhbXBsZVxuICAgIC8vIG1pblpvb206IDEwIDAwMCBweCBwZXIgMSBob3VyXG4gICAgLy8gd2l0aCBhIGRlZmF1bHQgdG8gNDQuMWtIeiBzYW1wbGUgcmF0ZVxuICAgIHRoaXMubWF4Wm9vbSA9IDQ0MTAwICogMSAvIHRoaXMudGltZWxpbmUudGltZUNvbnRleHQucGl4ZWxzUGVyU2Vjb25kO1xuICAgIHRoaXMubWluWm9vbSA9IDEwMDAwIC8gMzYwMCAvIHRoaXMudGltZWxpbmUudGltZUNvbnRleHQucGl4ZWxzUGVyU2Vjb25kO1xuICB9XG5cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaChlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgIHRoaXMub25Nb3VzZURvd24oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEb3duKGUpIHtcbiAgICB0aGlzLmluaXRpYWxab29tID0gdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC56b29tO1xuICAgIHRoaXMuaW5pdGlhbFkgPSBlLnk7XG5cbiAgICB0aGlzLl9waXhlbFRvRXhwb25lbnQgPSBzY2FsZXMubGluZWFyKClcbiAgICAgIC5kb21haW4oWzAsIDEwMF0pIC8vIDEwMHB4ID0+IGZhY3RvciAyXG4gICAgICAucmFuZ2UoWzAsIDFdKTtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAvLyBwcmV2ZW50IGFubm95aW5nIHRleHQgc2VsZWN0aW9uIHdoZW4gZHJhZ2dpbmdcbiAgICBlLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHRpbWVDb250ZXh0ID0gdGhpcy50aW1lbGluZS50aW1lQ29udGV4dDtcbiAgICBjb25zdCBsYXN0Q2VudGVyVGltZSA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChlLngpO1xuICAgIGNvbnN0IGV4cG9uZW50ID0gdGhpcy5fcGl4ZWxUb0V4cG9uZW50KGUueSAtIHRoaXMuaW5pdGlhbFkpO1xuICAgIGNvbnN0IHRhcmdldFpvb20gPSB0aGlzLmluaXRpYWxab29tICogTWF0aC5wb3coMiwgZXhwb25lbnQpOyAvLyAtMS4uLjEgLT4gMS8yLi4uMlxuXG4gICAgdGltZUNvbnRleHQuem9vbSA9IE1hdGgubWluKE1hdGgubWF4KHRhcmdldFpvb20sIHRoaXMubWluWm9vbSksIHRoaXMubWF4Wm9vbSk7XG5cbiAgICBjb25zdCBuZXdDZW50ZXJUaW1lID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KGUueCk7XG4gICAgY29uc3QgZGVsdGEgPSBuZXdDZW50ZXJUaW1lIC0gbGFzdENlbnRlclRpbWU7XG5cbiAgICAvLyBBcHBseSBuZXcgb2Zmc2V0IHRvIGtlZXAgaXQgY2VudGVyZWQgdG8gdGhlIG1vdXNlXG4gICAgdGltZUNvbnRleHQub2Zmc2V0ICs9IChkZWx0YSArIHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChlLmR4KSk7XG5cbiAgICAvLyBPdGhlciBwb3NzaWJsZSBleHBlcmltZW50cyB3aXRoIGNlbnRlcmVkLXpvb20tc3RhdGVcbiAgICAvL1xuICAgIC8vIEV4YW1wbGUgMTogUHJldmVudCB0aW1lbGluZS5vZmZzZXQgdG8gYmUgbmVnYXRpdmVcbiAgICAvLyB0aW1lQ29udGV4dC5vZmZzZXQgPSBNYXRoLm1pbih0aW1lQ29udGV4dC5vZmZzZXQsIDApO1xuICAgIC8vXG4gICAgLy8gRXhhbXBsZSAyOiBLZWVwIGluIGNvbnRhaW5lciB3aGVuIHpvb21lZCBvdXRcbiAgICAvLyBpZiAodGltZUNvbnRleHQuc3RyZXRjaFJhdGlvIDwgMSnCoHtcbiAgICAvLyAgIGNvbnN0IG1pbk9mZnNldCA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCgwKTtcbiAgICAvLyAgIGNvbnN0IG1heE9mZnNldCA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh2aWV3LndpZHRoIC0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwodGltZUNvbnRleHQuZHVyYXRpb24pKTtcbiAgICAvLyAgIHRpbWVDb250ZXh0Lm9mZnNldCA9IE1hdGgubWF4KHRpbWVDb250ZXh0Lm9mZnNldCwgbWluT2Zmc2V0KTtcbiAgICAvLyAgIHRpbWVDb250ZXh0Lm9mZnNldCA9IE1hdGgubWluKHRpbWVDb250ZXh0Lm9mZnNldCwgbWF4T2Zmc2V0KTtcbiAgICAvLyB9XG5cbiAgICB0aGlzLnRpbWVsaW5lLnRyYWNrcy51cGRhdGUoKTtcbiAgfVxuXG4gIG9uTW91c2VVcChlKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBDZW50ZXJlZFpvb21TdGF0ZTtcbiIsImltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9CYXNlU3RhdGUnO1xuaW1wb3J0IFRpbWVDb250ZXh0QmVoYXZpb3IgZnJvbSAnLi4vYmVoYXZpb3JzL1RpbWVDb250ZXh0QmVoYXZpb3InO1xuXG5cbi8qKlxuICogQSBzdGF0ZSB0byBpbnRlcmFjdCBkaXJlY3RseSB3aXRoIGxheWVycyB0aW1lIGNvbnRleHRzLlxuICpcbiAqIFtleGFtcGxlIHVzYWdlLCBzZWUuIGFkdmFuY2VkIHVzYWdlXSguL2V4YW1wbGVzL2xheWVyLXdhdmVmb3JtLmh0bWwpXG4gKi9cbmNsYXNzIENvbnRleHRFZGl0aW9uU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSkge1xuICAgIHN1cGVyKHRpbWVsaW5lKTtcbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2goZS50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICB0aGlzLm9uTW91c2VEb3duKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgIHRoaXMub25Nb3VzZVVwKGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBvbk1vdXNlRG93bihlKSB7XG4gICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNbaV07XG4gICAgICBpZiAobGF5ZXIuaGFzRWxlbWVudChlLnRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TGF5ZXIgPSBsYXllcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZU1vdmUoZSkge1xuICAgIGlmICghdGhpcy5tb3VzZURvd24gfHzCoCF0aGlzLmN1cnJlbnRMYXllcikgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50TGF5ZXI7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0O1xuXG4gICAgLy8gaW4gdGhpcyBleGFtcGxlIHRoZSBjb250ZXh0IGlzIHN0cmV0Y2hlZCB3aGVuIHNoaWZ0IGlzIHByZXNzZWRcbiAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgbGF5ZXIuZWRpdENvbnRleHQoZS5keCwgZS5keSwgdGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIuc3RyZXRjaENvbnRleHQoZS5keCwgZS5keSwgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICB0aGlzLnRpbWVsaW5lLnRyYWNrcy51cGRhdGUobGF5ZXIpO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRleHRFZGl0aW9uU3RhdGU7XG4iLCJpbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vQmFzZVN0YXRlJztcblxuXG4vKipcbiAqIEEgc3RhdGUgdG8gZWRpdCBzaGFwZXMgaW4gdGhlIG1vcmUgZ2VuZXJhbCB3YXkuIEludGVyYWN0IG9ubHkgd2l0aCBzZWxlY3RlZCBzaGFwZXMuXG4gKi9cbmNsYXNzIEVkaXRpb25TdGF0ZSBleHRlbmRzIEJhc2VTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKHRpbWVsaW5lKSB7XG4gICAgc3VwZXIodGltZWxpbmUpO1xuXG4gICAgdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXIgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIH1cblxuICBlbnRlcigpIHt9XG4gIGV4aXQoKSB7fVxuXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLm9uTW91c2VVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZURvd24oZSkge1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZSkge1xuICAgIHRoaXMubGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IGxheWVyLnNlbGVjdGVkSXRlbXM7XG5cbiAgICAgIGxheWVyLmVkaXQoaXRlbXMsIGUuZHgsIGUuZHksIHRoaXMuY3VycmVudFRhcmdldCk7XG4gICAgICBsYXllci51cGRhdGUoaXRlbXMpO1xuICAgIH0pO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllciA9IG51bGw7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFZGl0aW9uU3RhdGU7XG4iLCJpbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vQmFzZVN0YXRlJztcbmltcG9ydCBucyBmcm9tICcuLi9jb3JlL25hbWVzcGFjZSc7XG5cblxuLyoqXG4gKiBBIHN0YXRlIHRvIHNlbGVjdCBzaGFwZXMuXG4gKi9cbmNsYXNzIFNlbGVjdGlvblN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmUgLyosIG9wdGlvbnMgPSB7fSAqLykge1xuICAgIHN1cGVyKHRpbWVsaW5lIC8qLCBvcHRpb25zICovKTtcblxuICAgIHRoaXMuY3VycmVudExheWVyID0gbnVsbDtcbiAgICAvLyBuZWVkIGEgY2FjaGVkXG4gICAgdGhpcy5zZWxlY3RlZEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgIHRoaXMuc2hpZnRLZXkgPSBmYWxzZTtcblxuICAgIHRoaXMuX2xheWVyU2VsZWN0ZWRJdGVtc01hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGVudGVyKCkge1xuXG4gIH1cblxuICBleGl0KCkge1xuICAgIGNvbnN0IGNvbnRhaW5lcnMgPSB0aGlzLnRpbWVsaW5lLmNvbnRhaW5lcnM7XG5cbiAgICBmb3IgKGxldCBpZCBpbiBjb250YWluZXJzKSB7XG4gICAgICB0aGlzLl9yZW1vdmVCcnVzaChjb250YWluZXJzW2lkXSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICB0aGlzLm9uTW91c2VEb3duKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgIHRoaXMub25Nb3VzZVVwKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgdGhpcy5vbkNsaWNrKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICB0aGlzLm9uS2V5KGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgICAgdGhpcy5vbktleShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX2FkZEJydXNoKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLiRicnVzaCkgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IGJydXNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAncmVjdCcpO1xuICAgIGJydXNoLnN0eWxlLmZpbGwgPSAnIzY4Njg2OCc7XG4gICAgYnJ1c2guc3R5bGUub3BhY2l0eSA9IDAuMjtcblxuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnMuYXBwZW5kQ2hpbGQoYnJ1c2gpO1xuICAgIHRyYWNrLiRicnVzaCA9IGJydXNoO1xuICB9XG5cbiAgX3JlbW92ZUJydXNoKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLiRicnVzaCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblxuICAgIHRoaXMuX3Jlc2V0QnJ1c2godHJhY2spO1xuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnMucmVtb3ZlQ2hpbGQodHJhY2suJGJydXNoKTtcbiAgICBkZWxldGUgdHJhY2suJGJydXNoO1xuICB9XG5cbiAgX3Jlc2V0QnJ1c2godHJhY2spIHtcbiAgICBjb25zdCAkYnJ1c2ggPSB0cmFjay4kYnJ1c2g7XG4gICAgLy8gcmVzZXQgYnJ1c2ggZWxlbWVudFxuICAgICRicnVzaC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAwKScpO1xuICAgICRicnVzaC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCAwKTtcbiAgICAkYnJ1c2guc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIDApO1xuICB9XG5cbiAgX3VwZGF0ZUJydXNoKGUsIHRyYWNrKSB7XG4gICAgY29uc3QgJGJydXNoID0gdHJhY2suJGJydXNoO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHtlLmFyZWEubGVmdH0sICR7ZS5hcmVhLnRvcH0pYDtcblxuICAgICRicnVzaC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJywgdHJhbnNsYXRlKTtcbiAgICAkYnJ1c2guc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgZS5hcmVhLndpZHRoKTtcbiAgICAkYnJ1c2guc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIGUuYXJlYS5oZWlnaHQpO1xuICB9XG5cbiAgb25LZXkoZSkge1xuICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICB9XG5cbiAgb25Nb3VzZURvd24oZSkge1xuICAgIHRoaXMuX2N1cnJlbnRUcmFjayA9IHRoaXMudGltZWxpbmUuZ2V0VHJhY2tGcm9tRE9NRWxlbWVudChlLnRhcmdldCk7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50VHJhY2spIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLl9hZGRCcnVzaCh0aGlzLl9jdXJyZW50VHJhY2spO1xuXG4gICAgLy8gcmVjcmVhdGUgdGhlIG1hcFxuICAgIHRoaXMuX2xheWVyU2VsZWN0ZWRJdGVtc01hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9jdXJyZW50VHJhY2subGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAuc2V0KGxheWVyLCBsYXllci5zZWxlY3RlZEl0ZW1zLnNsaWNlKDApKTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGUpIHtcbiAgICB0aGlzLl91cGRhdGVCcnVzaChlLCB0aGlzLl9jdXJyZW50VHJhY2spO1xuXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGxheWVyLnNlbGVjdGVkSXRlbXM7XG4gICAgICBjb25zdCBjdXJyZW50SXRlbXMgPSBsYXllci5nZXRJdGVtc0luQXJlYShlLmFyZWEpO1xuXG4gICAgICAvLyBpZiBpcyBub3QgcHJlc3NlZFxuICAgICAgaWYgKCFlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgbGF5ZXIudW5zZWxlY3QoY3VycmVudFNlbGVjdGlvbik7XG4gICAgICAgIGxheWVyLnNlbGVjdChjdXJyZW50SXRlbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdG9TZWxlY3QgPSBbXTtcbiAgICAgICAgY29uc3QgdG9VbnNlbGVjdCA9IFtdO1xuICAgICAgICAvLyB1c2UgdGhlIHNlbGVjdGlvbiBmcm9tIHRoZSBwcmV2aW91cyBkcmFnXG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0aW9uID0gdGhpcy5fbGF5ZXJTZWxlY3RlZEl0ZW1zTWFwLmdldChsYXllcik7XG4gICAgICAgIC8vIHRvVW5zZWxlY3QgPSB0b1Vuc2VsZWN0LmNvbmNhdChwcmV2aW91c1NlbGVjdGVkSXRlbXMpO1xuXG4gICAgICAgIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKHByZXZpb3VzU2VsZWN0aW9uLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0b1NlbGVjdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b1Vuc2VsZWN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjdXJyZW50U2VsZWN0aW9uLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjdXJyZW50SXRlbXMuaW5kZXhPZihpdGVtKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIHByZXZpb3VzU2VsZWN0aW9uLmluZGV4T2YoaXRlbSkgPT09IC0xXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0b1Vuc2VsZWN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsYXllci51bnNlbGVjdCh0b1Vuc2VsZWN0KTtcbiAgICAgICAgbGF5ZXIuc2VsZWN0KHRvU2VsZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG9uTW91c2VVcChlKSB7XG4gICAgdGhpcy5fcmVtb3ZlQnJ1c2godGhpcy5fY3VycmVudFRyYWNrKTtcbiAgfVxuXG4gIG9uQ2xpY2soZSkge1xuICAgIGlmICghdGhpcy5fY3VycmVudFRyYWNrKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgbGV0IGl0ZW0gPSBsYXllci5nZXRJdGVtRnJvbURPTUVsZW1lbnQoZS50YXJnZXQpO1xuXG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgICBsYXllci51bnNlbGVjdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBsYXllci50b2dnbGVTZWxlY3Rpb24oaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uU3RhdGU7XG4iLCJpbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vQmFzZVN0YXRlJztcblxuXG4vKipcbiAqIEEgc3RhdGUgdG8gc2VsZWN0IGFuZCBlZGl0IHNoYXBlcyBpbiBhIHNpbXBsZSB3YXkuIChraW5kIG9mIHBsdWcgbiBwbGF5IHN0YXRlKVxuICovXG5jbGFzcyBTaW1wbGVFZGl0aW9uU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSkge1xuICAgIHN1cGVyKHRpbWVsaW5lKTtcblxuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICB9XG5cbiAgZW50ZXIoKSB7fVxuICBleGl0KCkge31cblxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgIHRoaXMub25Nb3VzZURvd24oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEb3duKGUpIHtcbiAgICAvLyBrZWVwIHRhcmdldCBjb25zaXN0ZW50IHdpdGggbW91c2UgZG93blxuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgdGhpcy5sYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgIGlmICghbGF5ZXIuaGFzRWxlbWVudCh0aGlzLmN1cnJlbnRUYXJnZXQpKSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgICBsYXllci51bnNlbGVjdCgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpdGVtID0gbGF5ZXIuZ2V0SXRlbUZyb21ET01FbGVtZW50KHRoaXMuY3VycmVudFRhcmdldCk7XG5cbiAgICAgIGlmIChpdGVtID09PSBudWxsKSB7IHJldHVybjsgfVxuXG4gICAgICB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllciA9IGxheWVyO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkgeyBsYXllci5zZWxlY3QoaXRlbSk7IH0pO1xuICAgIH0pO1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZSkge1xuICAgIGlmICghdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXIpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBsYXllciA9IHRoaXMuY3VycmVudEVkaXRlZExheWVyO1xuICAgIGNvbnN0IGl0ZW1zID0gbGF5ZXIuc2VsZWN0ZWRJdGVtcztcblxuICAgIGxheWVyLmVkaXQoaXRlbXMsIGUuZHgsIGUuZHksIHRoaXMuY3VycmVudFRhcmdldCk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkgeyBsYXllci51cGRhdGUoaXRlbXMpOyB9KTtcbiAgfVxuXG4gIG9uTW91c2VVcChlKSB7XG4gICAgdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXIgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpbXBsZUVkaXRpb25TdGF0ZTtcbiIsIi8qKlxuICogT3J0aG9nb25hbERhdGEgdHJhbnNmb3JtcyBhbiBvYmplY3Qgb2YgYXJyYXlzIGB7Zm9vOiBbMSwgMl0sIGJhcjogWzMsIDRdfWBcbiAqIHRvIG9yIGZyb20gYW4gYXJyYXkgb2Ygb2JqZWN0cyBgW3tmb286IDEsIGJhcjogM30sIHtmb286IDIsIGJhcjogNH1dYFxuICovXG5jbGFzcyBPcnRob2dvbmFsRGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2NvbHMgPSBudWxsOyAvLyBPYmplY3Qgb2YgYXJyYXlzXG4gICAgdGhpcy5fcm93cyA9IG51bGw7IC8vIEFycmF5IG9mIG9iamVjdHNcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgY29uc2lzdGVuY3kgb2YgdGhlIGRhdGEuXG4gICAqL1xuICBfY2hlY2tDb25zaXN0ZW5jeSgpIHtcbiAgICBsZXQgc2l6ZSA9IG51bGw7XG5cbiAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fY29scykge1xuICAgICAgY29uc3QgY29sID0gdGhpcy5fY29sc1trZXldO1xuICAgICAgY29uc3QgY29sTGVuZ3RoID0gY29sLmxlbmd0aDtcblxuICAgICAgaWYgKHNpemUgIT09IG51bGwgJiYgc2l6ZSAhPT0gY29sTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lfTogaW5jb25zaXN0ZW50IGRhdGFgKTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICBzaXplID0gY29sTGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFycmF5IG9mIG9iamVjdHMgZnJvbSBvYmplY3Qgb2YgYXJyYXlzLlxuICAgKi9cbiAgdXBkYXRlRnJvbUNvbHMoKSB7XG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9jb2xzKTtcblxuICAgIGtleXMuZm9yRWFjaCgoa2V5LCBpKSA9PiB7XG4gICAgICBjb25zdCBjb2wgPSB0aGlzLl9jb2xzW2tleV07XG5cbiAgICAgIGNvbC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvd3NbaW5kZXhdID09PSB1bmRlZmluZWQpIHRoaXMuX3Jvd3NbaW5kZXhdID0ge307XG4gICAgICAgIHRoaXMuX3Jvd3NbaW5kZXhdW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY2hlY2tDb25zaXN0ZW5jeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgb2JqZWN0IG9mIGFycmF5cyBmcm9tIGFycmF5IG9mIG9iamVjdHMuXG4gICAqL1xuICB1cGRhdGVGcm9tUm93cygpIHtcbiAgICB0aGlzLl9yb3dzLmZvckVhY2goKG9iaiwgaW5kZXgpID0+IHtcbiAgICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB0aGlzLl9jb2xzW2tleV0gPSBbXTtcbiAgICAgICAgdGhpcy5fY29sc1trZXldLnB1c2gob2JqW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fY2hlY2tDb25zaXN0ZW5jeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gb2JqZWN0IG9mIGFycmF5cy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdDxTdHJpbmcsIEFycmF5Pn1cbiAgICovXG4gIHNldCBjb2xzKG9iaikge1xuICAgIHRoaXMuX2NvbHMgPSBvYmo7XG4gICAgdGhpcy5fcm93cyA9IFtdO1xuXG4gICAgdGhpcy51cGRhdGVGcm9tQ29scygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGFycmF5cy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdDxTdHJpbmcsIEFycmF5Pn1cbiAgICovXG4gIGdldCBjb2xzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PE9iamVjdD59XG4gICAqL1xuICBzZXQgcm93cyhhcnIpIHtcbiAgICB0aGlzLl9yb3dzID0gYXJyO1xuICAgIHRoaXMuX2NvbHMgPSB7fTtcblxuICAgIHRoaXMudXBkYXRlRnJvbVJvd3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuICAgKi9cbiAgZ2V0IHJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvd3M7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT3J0aG9nb25hbERhdGE7XG4iLCJcbi8qKlxuICogQWRkIGBzaWduYCB0byB0aGUgbGVmdCBvZiBhIGdpdmVuIGBpbnB1dGAgdW50aWwgaXQgbWF0Y2hlcyBtYXRjaCBgbGVuZ3RoYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCAtIFN0cmluZyB0byBmb3JtYXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduIC0gQ2hhcmFjdGVyIHRvIGFkZCB0byB0aGUgbGVmdFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIExlbmd0aCBvZiB0aGUgb3V0cHV0IHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgcGFkTGVmdCA9IChpbnB1dCwgc2lnbiwgbGVuZ3RoKSA9PiB7XG4gIGlucHV0ICs9ICcnOyAvLyBtYWtlIHN1cmUgd2UgZGVhbCB3aXRoIGEgc3RyaW5nXG5cbiAgd2hpbGUgKGlucHV0Lmxlbmd0aCA8IGxlbmd0aClcbiAgICBpbnB1dCA9IHNpZ24gKyBpbnB1dDtcblxuICByZXR1cm4gaW5wdXQ7XG59XG4iLCIvKipcbiAqIExpZ2h0d2VpZ2h0IHNjYWxlcyBtaW1pY2luZyB0aGUgYGQzLmpzYCBmdW5jdGlvbm5hbCBBUEkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEEgbGluZWFyIHNjYWxlIGludGVycG9sYXRpbmcgdmFsdWVzIGJldHdlZW4gYSBgZG9tYWluYCBhbmQgYSBgcmFuZ2VgLlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIGxpbmVhcigpIHtcbiAgICBsZXQgX2RvbWFpbiA9IFswLCAxXTtcbiAgICBsZXQgX3JhbmdlID0gWzAsIDFdO1xuXG4gICAgbGV0IF9zbG9wZSA9IDE7XG4gICAgbGV0IF9pbnRlcmNlcHQgPSAwO1xuXG4gICAgZnVuY3Rpb24gX3VwZGF0ZUNvZWZzKCkge1xuICAgICAgX3Nsb3BlID0gKF9yYW5nZVsxXSAtIF9yYW5nZVswXSkgLyAoX2RvbWFpblsxXSAtIF9kb21haW5bMF0pO1xuICAgICAgX2ludGVyY2VwdCA9IF9yYW5nZVswXSAtIChfc2xvcGUgKiBfZG9tYWluWzBdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZSAodmFsdWUpIHtcbiAgICAgIHJldHVybiAoX3Nsb3BlICogdmFsdWUpICsgX2ludGVyY2VwdDtcbiAgICB9XG5cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSAtIF9pbnRlcmNlcHQpIC8gX3Nsb3BlO1xuICAgIH07XG5cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihhcnIgPSBudWxsKSB7XG4gICAgICBpZiAoYXJyID09PSBudWxsKSB7IHJldHVybiBfZG9tYWluOyB9XG5cbiAgICAgIF9kb21haW4gPSBhcnI7XG4gICAgICBfdXBkYXRlQ29lZnMoKTtcblxuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG5cbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKGFyciA9IG51bGwpIHtcbiAgICAgIGlmIChhcnIgPT09IG51bGwpIHsgcmV0dXJuIF9yYW5nZTsgfVxuXG4gICAgICBfcmFuZ2UgPSBhcnI7XG4gICAgICBfdXBkYXRlQ29lZnMoKTtcblxuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZyb207IiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZScpOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5NYXA7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKXtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHJldHVybiAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbn07IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRQcm90b3R5cGVPZjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmtleXM7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuU2V0OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSl7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXIsIElURVJBVE9SKXtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTsiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhc2MgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUsICRjcmVhdGUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYXG4gICAgLCBjcmVhdGUgICAgICAgID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpc0FycmF5ICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwpe1xuICB2YXIgQztcbiAgaWYoaXNBcnJheShvcmlnaW5hbCkpe1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSlDID0gdW5kZWZpbmVkO1xuICAgIGlmKGlzT2JqZWN0KEMpKXtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYoQyA9PT0gbnVsbClDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTsiLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBsZW5ndGgpe1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTsiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgc2V0U3BlY2llcyAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgZmFzdEtleSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleVxuICAsIFNJWkUgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsICdmb3JFYWNoJyk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZil7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihERVNDUklQVE9SUylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWV0YSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lQWxsICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgYW5JbnN0YW5jZSAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGVhY2ggICAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gZ2xvYmFsW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICBpZighREVTQ1JJUFRPUlMgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUsICdfYycpO1xuICAgICAgdGFyZ2V0Ll9jID0gbmV3IEJhc2U7XG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBlYWNoKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04nLnNwbGl0KCcsJyksZnVuY3Rpb24oS0VZKXtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZihLRVkgaW4gcHJvdG8gJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSloaWRlKEMucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsIEtFWSk7XG4gICAgICAgIGlmKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSlyZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKCdzaXplJyBpbiBwcm90bylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XG4gIGlmKGluZGV4IGluIG9iamVjdCkkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTsiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07IiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7IiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSBwSUUuZlxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCJ2YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICwgQlJFQUsgICAgICAgPSB7fVxuICAsIFJFVFVSTiAgICAgID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUil7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSlcbiAgICAsIGYgICAgICA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxuICAgICwgaW5kZXggID0gMFxuICAgICwgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyApe1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07IiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTsiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07IiwidmFyIElURVJBVE9SICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyByZXR1cm4ge2RvbmU6IHNhZmUgPSB0cnVlfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge307IiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTsiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTsiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCAkYXNzaWduICA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgYUxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmZcbiAgICAsIGlzRW51bSAgICAgPSBwSUUuZjtcbiAgd2hpbGUoYUxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduOyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTsiLCJ2YXIgcElFICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCBnT1BEICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07IiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sczsiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59OyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTsiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTsiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTsiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTsiLCJ2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMsIHNhZmUpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpe1xuICAgIGlmKHNhZmUgJiYgdGFyZ2V0W2tleV0pdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIGhpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTsiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSB0eXBlb2YgY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBjb3JlW0tFWV0gOiBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07IiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59OyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07IiwidmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcbn07IiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7IiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7IiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07IiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXQgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59OyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgfHwgSXRlcmF0b3JzLmhhc093blByb3BlcnR5KGNsYXNzb2YoTykpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5JylcbiAgLCBnZXRJdGVyRm4gICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7IiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpfSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKX0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pOyIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRrZXlzICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKX0pOyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpOyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpOyIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZihwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn0iLCIvLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPVxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXM7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbC5wcm9jZXNzID09PSBcIm9iamVjdFwiICYmIGdsb2JhbC5wcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gZ2xvYmFsLnByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcbiJdfQ==
